{
  "slug": "tools/intercom",
  "title": "Intercom for Permissioned Agents | Claw EA",
  "category": "tools",
  "html": "<h2>Direct Answer</h2>\n<p>Intercom is a high-impact surface for agents because a single misfire can message customers, change ticket state, or leak conversation history. For enterprise use, treat Intercom actions as permissioned execution: policy-as-code enforced by a WPC, authenticated with a CST, and evidenced by gateway receipts and a proof bundle.</p>\n<p>Claw EA runs agents on OpenClaw as the baseline runtime, then adds machine-checkable authorization and audit artifacts around every model-assisted run. This keeps “what the agent is allowed to do” out of prompts and inside signed policy, scoped credentials, and verifiable receipts.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the Intercom blast radius you will permit: read-only triage, draft-only replies, or limited write actions such as tagging and assignment. Write it down as a WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols), including explicit tool/action lists and data handling rules.</p>\n  </li>\n  <li>\n    <p>Stand up authentication for Intercom via official API with an enterprise buildout that supports least-privilege scopes and separation between environments. Keep “admin” capabilities out of the agent path; route them through an approval gate described by the WPC.</p>\n  </li>\n  <li>\n    <p>Issue a CST = scoped token (issued by clawscope) for each job or queue drain, and bind it to the WPC hash (policy hash pinning) so the token cannot be replayed under a looser policy. Use job-scoped CST binding to reduce replay risk across runs.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw with a minimal tool profile and sandboxing aligned to your environment. OpenClaw tool policy and sandboxing reduce local blast radius, but your Intercom authorization should still be enforced at the execution layer, not in chat text.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy so you receive gateway receipts for each model call, then package the run into a proof bundle. Store the bundle and, when needed, publish it as a Trust Pulse for review.</p>\n  </li>\n  <li>\n    <p>Perform rollout in stages: start with “suggest-only” outputs to a human queue, then allow constrained writes such as tagging, assignment, and internal notes. Expand to customer-visible messages only after you have stable proof bundles and a reliable rollback plan.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Intercom failures are rarely subtle. The common risk is an agent that was allowed to act, received untrusted content, and then used its tools too broadly.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection from customer message</td>\n      <td>The agent treats a customer instruction as operator intent and performs actions like changing ticket state or sending sensitive info.</td>\n      <td>WPC restricts allowed actions and fields; CST is minted only for the constrained policy; OpenClaw tool allow/deny keeps local tools narrow.</td>\n    </tr>\n    <tr>\n      <td>Over-privileged Intercom auth</td>\n      <td>A triage agent can escalate into admin-like writes, bulk edits, exports, or inbox-wide access.</td>\n      <td>Enterprise buildout enforces least-privilege scopes; write and admin actions require WPC approval gates and explicit scoping in the CST.</td>\n    </tr>\n    <tr>\n      <td>Misconfigured “write” defaults</td>\n      <td>The agent sends customer-facing messages when you intended drafts or internal notes only.</td>\n      <td>WPC defines message modes (draft vs send) as separate actions; require human approval for customer-visible send until proven safe.</td>\n    </tr>\n    <tr>\n      <td>Replay of a prior run</td>\n      <td>A captured credential or token is reused to re-run a previously valid action sequence.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding; require a new CST for each run and pin it to the WPC hash.</td>\n    </tr>\n    <tr>\n      <td>Audit gaps after an incident</td>\n      <td>You cannot prove which model call produced which action, or whether policy was in effect at the time.</td>\n      <td>Gateway receipts from clawproxy for model calls, packaged into a proof bundle with run metadata for verification and review.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a JSON-like sketch of how teams typically express Intercom constraints in a WPC. The goal is to make “can read” and “can write” separate capabilities, and make customer-visible actions harder to reach than internal triage.</p>\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"tool\": \"intercom_via_official_api\",\n  \"allowed_actions\": [\n    \"conversations.read\",\n    \"conversations.search\",\n    \"conversations.add_internal_note\",\n    \"conversations.assign\",\n    \"conversations.tag\"\n  ],\n  \"denied_actions\": [\n    \"conversations.send_message\",\n    \"contacts.export\",\n    \"admin.*\"\n  ],\n  \"data_handling\": {\n    \"log_redaction\": \"on\",\n    \"store_customer_content\": \"no\",\n    \"allowed_fields\": [\"conversation_id\", \"subject\", \"body_redacted\", \"tags\", \"assignee_id\"]\n  },\n  \"approvals\": [\n    { \"action\": \"conversations.send_message\", \"mode\": \"manual_gate\" }\n  ],\n  \"auth\": {\n    \"cst_required\": true,\n    \"cst_policy_hash_pinning\": true\n  }\n}\n</pre>\n<p>In practice, this WPC is signed and hash-addressed, then fetched and verified by the execution path before Intercom writes are attempted. Prompts can describe intent, but they do not grant capability.</p>\n\n<h2>What proof do you get?</h2>\n<p>For each model call routed through clawproxy, you get gateway receipts that can be checked later to confirm which model was called, when, and under which run context. Those receipts are not a substitute for application logs, but they let you tie agent outputs to specific model interactions.</p>\n<p>Claw EA bundles receipts and run metadata into a proof bundle suitable for audit and verification. When you need to share evidence with internal reviewers or external auditors, you can store and view the artifact as a Trust Pulse.</p>\n<p>Operationally, this is what makes “permissioned agents” enforceable. You can show the WPC hash that governed the run, the CST that was scoped to it, and the receipts that demonstrate the model traffic that led to actions.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback for Intercom agents should assume you may need to stop writes immediately, then recover state with a bounded set of compensating actions. The safest approach is to design your WPC so rollback is mostly “disable capability” plus “human clean-up,” not “agent fixes agent.”</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop all Intercom writes</td>\n      <td>Mint new CSTs that are read-only and pinned to a stricter WPC; revoke or expire existing CSTs per your operations practice.</td>\n      <td>WPC hash change, CST scope hash, and proof bundles showing when the policy changed.</td>\n    </tr>\n    <tr>\n      <td>Rollback incorrect tagging or assignment</td>\n      <td>Use a human-run batch process via official API to revert specific fields, based on a list of affected conversation IDs.</td>\n      <td>Proof bundle run metadata to enumerate impacted items; Intercom-side audit and change history as applicable.</td>\n    </tr>\n    <tr>\n      <td>Rollback an incorrect customer message</td>\n      <td>Do not attempt automated deletion unless your governance allows it; send a corrected follow-up message with human approval.</td>\n      <td>Gateway receipts for the model call that drafted content, plus a record of the approved corrective action.</td>\n    </tr>\n    <tr>\n      <td>Suspected prompt injection campaign</td>\n      <td>Quarantine the queue: read-only triage, stricter content handling, and temporary manual review for any customer-visible action.</td>\n      <td>Proof bundles for the impacted runs and the pinned WPC version that was active during the event window.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why is prompt-only safety not enough for Intercom agents?</h3>\n<p>Prompts can be overwritten by untrusted customer text, tool outputs, or a malicious plugin. A WPC makes the allowed actions machine-enforced, and a CST ensures the agent cannot exceed that policy even if the prompt tries.</p>\n\n<h3>Is Intercom a native Claw EA connector today?</h3>\n<p>No. Intercom can be connected via official API with enterprise buildout controls, and the run can still produce gateway receipts and proof bundles for audit and replay checks.</p>\n\n<h3>What Intercom actions should be allowed first?</h3>\n<p>Start with read-only triage plus non-customer-visible writes like internal notes, tagging, and assignment. Make customer-visible sends an approval-gated action in the WPC until you have stable operating evidence.</p>\n\n<h3>Can we use MCP with Intercom?</h3>\n<p>Intercom publishes MCP documentation, but you should treat MCP as an integration transport, not an authorization system. If you adopt it, do so via an MCP server and still enforce WPC and CST rules at the execution layer.</p>\n\n<h3>How do we prove what the model saw and did during an incident?</h3>\n<p>Gateway receipts from clawproxy provide verifiable records of model calls, and the proof bundle ties those receipts to the job context and policy hash. This gives you a concrete chain to review alongside Intercom-side logs and your own operational telemetry.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://developers.intercom.com/docs/guides/mcp\">Intercom Developer Guides: Model Context Protocol (MCP)</a></li>\n  <li><a href=\"https://www.intercom.com/blog/data-privacy-security-ai-chatbots/\">Intercom: How Intercom ensures data privacy and safety in the age of AI</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Intercom is a high-impact surface for agents because a single misfire can message customers, change ticket state, or leak conversation history. For enterprise use, treat Intercom actions as permissioned execution: policy",
  "faqs": [
    {
      "q": "Why is prompt-only safety not enough for Intercom agents?",
      "a": "Prompts can be overwritten by untrusted customer text, tool outputs, or a malicious plugin. A WPC makes the allowed actions machine-enforced, and a CST ensures the agent cannot exceed that policy even if the prompt tries."
    },
    {
      "q": "Is Intercom a native Claw EA connector today?",
      "a": "No. Intercom can be connected via official API with enterprise buildout controls, and the run can still produce gateway receipts and proof bundles for audit and replay checks."
    },
    {
      "q": "What Intercom actions should be allowed first?",
      "a": "Start with read-only triage plus non-customer-visible writes like internal notes, tagging, and assignment. Make customer-visible sends an approval-gated action in the WPC until you have stable operating evidence."
    },
    {
      "q": "Can we use MCP with Intercom?",
      "a": "Intercom publishes MCP documentation, but you should treat MCP as an integration transport, not an authorization system. If you adopt it, do so via an MCP server and still enforce WPC and CST rules at the execution layer."
    },
    {
      "q": "How do we prove what the model saw and did during an incident?",
      "a": "Gateway receipts from clawproxy provide verifiable records of model calls, and the proof bundle ties those receipts to the job context and policy hash. This gives you a concrete chain to review alongside Intercom-side logs and your own operational telemetry."
    }
  ],
  "sources": [
    {
      "title": "MCP Demo Day: How 10 leading AI companies built MCP servers ...",
      "uri": "https://blog.cloudflare.com/mcp-demo-day/"
    },
    {
      "title": "Connect Amazon Quick Suite to enterprise apps and agents with MCP",
      "uri": "https://aws.amazon.com/blogs/machine-learning/connect-amazon-quick-suite-to-enterprise-apps-and-agents-with-mcp/"
    },
    {
      "title": "Model Context Protocol (MCP)",
      "uri": "https://developers.intercom.com/docs/guides/mcp"
    },
    {
      "title": "Intercom achieves AIUC-1 certification: A new standard for trust in AI Agents",
      "uri": "https://www.intercom.com/blog/intercom-achieves-aiuc-1-certification/"
    },
    {
      "title": "How Intercom ensures data privacy and safety in the age of AI",
      "uri": "https://www.intercom.com/blog/data-privacy-security-ai-chatbots/"
    },
    {
      "title": "A Testing Framework for AI Agents | Intercom",
      "uri": "https://www.intercom.com/campaigns/ai-agent-testing-framework"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:26:42.800Z",
  "indexable": true
}