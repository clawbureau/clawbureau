{
  "slug": "tools/azure-event-grid",
  "title": "Azure Event Grid for Permissioned Agents | Claw EA",
  "category": "tools",
  "html": "<p>Azure Event Grid is a push-based changefeed that delivers events to HTTPS webhooks, and it will retry deliveries, so duplicates and replays are normal operating conditions. For permissioned agents running in OpenClaw, you should treat every Event Grid delivery as untrusted input and require policy-as-code gates before the agent can write back to Azure or mutate downstream systems.</p>\n<p>Claw EA can connect to Azure Event Grid via official API with enterprise buildout controls, using Work Policy Contracts (WPC), CST (scoped token) issuance, and model traffic routed through clawproxy for gateway receipts. The goal is operational: idempotent event processing, least-privilege auth scopes, and auditable runs with proof bundles.</p>\n\n<h2>Step-by-step runbook</h2>\n<p><strong>1) Define your event contract and idempotency rule.</strong> Pick the unique key you will dedupe on (for example, CloudEvents <code>id</code> or Event Grid <code>id</code> plus <code>eventType</code> plus <code>subject</code>). Write down the retention window for dedupe state (hours or days) and what “exactly once” means for your system.</p>\n<p><strong>2) Secure inbound delivery to the agent-facing webhook.</strong> Prefer Microsoft Entra ID protected endpoints for Event Grid webhook delivery, and validate tokens (issuer, audience, signature, and expected app identity). Keep the endpoint HTTPS-only and implement the Event Grid endpoint validation handshake.</p>\n<p><strong>3) Add a permissioned execution layer, not prompt-only controls.</strong> Prompts can be overwritten by injected content inside event payloads, so the runtime needs machine-enforced constraints. Put the agent behind a WPC that explicitly defines allowed tools, allowed write actions, required human approvals (if any), and required policy hash pinning for CST.</p>\n<p><strong>4) Scope Azure access to the smallest surface that works.</strong> Use Entra ID app registrations and restrict permissions (and where applicable, Microsoft Graph permissions/scopes) to only what the event handler needs. For privileged operations, use Conditional Access and Privileged Identity Management (PIM) patterns in your organization, and avoid long-lived secrets.</p>\n<p><strong>5) Build an idempotent handler with a two-phase flow.</strong> Phase A validates and records the event key as “in progress” before any side effects; Phase B performs the allowed action and then marks “done” with a result hash. If Phase B fails, return an error so Event Grid can retry, but your handler must detect duplicates and safely short-circuit.</p>\n<p><strong>6) Run the agent with receipts and an audit trail.</strong> Route model calls through clawproxy so every model interaction emits gateway receipts, then package the run into a proof bundle. Store the proof bundle and the run summary where your auditors can retrieve it, and optionally publish a Trust Pulse for viewing.</p>\n\n<h2>Threat model</h2>\n<p>Event Grid is a changefeed, not a trusted command channel. Your agent must assume event bodies can be malformed, duplicated, reordered, or crafted to trigger unsafe tool use.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Duplicate delivery and replay</td>\n      <td>Event Grid retries on timeouts and failures; the same event can be delivered multiple times, causing repeated side effects (double ticket creation, repeated configuration changes).</td>\n      <td>Idempotency key store keyed by CloudEvents <code>id</code> or Event Grid <code>id</code>; job-scoped CST binding to reduce replay across jobs; require WPC-defined “no side effects before dedupe commit”.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection inside event payload</td>\n      <td>An event includes text that attempts to override the agent’s instructions, leading to unintended tool calls or credential exfiltration.</td>\n      <td>Permissioned execution via WPC tool allowlists and explicit action schemas; sandbox tool execution in OpenClaw where applicable; treat event fields as data, not instructions.</td>\n    </tr>\n    <tr>\n      <td>Webhook endpoint spoofing or weak auth</td>\n      <td>An attacker posts synthetic events to your webhook and triggers agent workflows without going through Event Grid.</td>\n      <td>Microsoft Entra ID protected webhook delivery and strict token validation; reject requests that fail validation; log request metadata and event ids for incident response.</td>\n    </tr>\n    <tr>\n      <td>Over-broad Azure permissions</td>\n      <td>The agent’s credential can perform admin writes (topic management, subscription updates, broad resource writes) if compromised or misused.</td>\n      <td>Least-privilege Entra ID app scopes; split roles for read vs write; WPC approval gates for admin actions; short TTL CST and explicit policy hash pinning.</td>\n    </tr>\n    <tr>\n      <td>Poisoned changefeed causes cascading writes</td>\n      <td>A misconfigured rule forwards high-volume events; the agent performs expensive or destructive work, saturating queues and producing inconsistent state.</td>\n      <td>WPC-defined rate and concurrency limits at the worker layer; fail closed on schema mismatches; optional cost budget enforcement can be implemented, but do not rely on it as shipped behavior.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the shape of a WPC that makes Event Grid handling safe: it pins what the agent can do, and forces idempotency and explicit approval for write paths. Treat it as a starting point and adjust the action list to your Azure footprint.</p>\n<pre>{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"azure-event-grid-permissioned-handler\",\n  \"inputs\": {\n    \"event_grid\": {\n      \"require_azure_entra_protected_webhook\": true,\n      \"required_event_types\": [\"Microsoft.Storage.BlobCreated\", \"Custom.ChangefeedItem\"],\n      \"idempotency_key\": \"cloudevents.id\",\n      \"dedupe_ttl_seconds\": 86400\n    }\n  },\n  \"auth\": {\n    \"cst\": {\n      \"require_scope_hash\": true,\n      \"pin_wpc_hash\": true,\n      \"max_ttl_seconds\": 1800,\n      \"job_scoped_binding\": true\n    }\n  },\n  \"execution\": {\n    \"runtime\": \"OpenClaw\",\n    \"sandbox\": { \"mode\": \"all\", \"workspace_access\": \"ro\" },\n    \"tools\": {\n      \"allow\": [\n        \"http.fetch\",\n        \"json.parse\",\n        \"azure.eventgrid.publish.via_official_api\"\n      ],\n      \"deny\": [\"shell.exec\", \"filesystem.write\", \"browser.remote_control\"]\n    }\n  },\n  \"approvals\": [\n    {\n      \"action\": \"azure.eventgrid.admin_write\",\n      \"required\": true,\n      \"reason\": \"subscription/topic changes require explicit approval\"\n    }\n  ],\n  \"logging\": {\n    \"record_event_id\": true,\n    \"redact_secrets\": true\n  }\n}</pre>\n\n<h2>What proof do you get?</h2>\n<p>When the agent uses an LLM during event handling, you can route those model calls through clawproxy and receive gateway receipts for each call. Those receipts are designed for verification: they tie a specific model interaction to a specific run context, rather than relying on application logs.</p>\n<p>Claw EA then packages receipts and related run metadata into a proof bundle. In an enterprise buildout, you typically include the Event Grid delivery identifiers you processed (event id, subject, eventType, timestamp) and the dedupe decision (first-seen vs duplicate) so auditors can verify idempotency behavior alongside the model receipts.</p>\n<p>If you need a marketplace-visible artifact, you can store the proof bundle and expose it via Trust Pulse for audit viewing. Separately, CST job-scoped binding helps reduce cross-job replay, so the same token cannot be reused to “legitimize” an unrelated run.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback for Event Grid handlers is mostly about stopping writes, draining retries safely, and proving what happened. Plan for duplicates and partial failures, and make rollbacks a policy change, not a prompt edit.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Disable side effects while still acknowledging events</td>\n      <td>Update WPC to deny write tools and allow only classification and logging; keep idempotency store active so retries do not accumulate work.</td>\n      <td>WPC hash used for the run; proof bundle shows denied tool attempts (if any) and the model gateway receipts for the decision path.</td>\n    </tr>\n    <tr>\n      <td>Quarantine a suspicious event type</td>\n      <td>Update WPC required_event_types allowlist to remove the eventType, and fail closed on unexpected schemas.</td>\n      <td>Run metadata shows rejected eventType and event id; proof bundle ties the rejection behavior to the pinned WPC.</td>\n    </tr>\n    <tr>\n      <td>Reprocess with a corrected handler</td>\n      <td>Replay from your own stored event log, not from Event Grid retries; reset dedupe entries only for a targeted subset of keys.</td>\n      <td>New proof bundles reference the reprocess job context; gateway receipts show the model inputs used for the corrected decision.</td>\n    </tr>\n    <tr>\n      <td>Credential compromise response</td>\n      <td>Revoke CST issuance for the scope, rotate Entra ID credentials, and tighten app permissions; require approvals for any admin writes.</td>\n      <td>Token issuance and revocation events from clawscope; proof bundles identify which job-scoped CST was used for each run.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>How do I make Azure Event Grid deliveries idempotent for an agent?</h3>\n<p>Assume duplicates and implement a dedupe store keyed by the CloudEvents <code>id</code> or Event Grid <code>id</code>, recorded before any side effects. Treat “already processed” as a successful no-op, and store a result hash so you can prove consistent outcomes.</p>\n\n<h3>Why is policy-as-code required instead of a carefully written prompt?</h3>\n<p>Because event payloads are untrusted and can contain instructions that conflict with your intent. A WPC enforces the allowed tools and write paths even if the model output is manipulated, which a prompt alone cannot guarantee.</p>\n\n<h3>Is this a native Claw EA connector for Azure Event Grid?</h3>\n<p>No. Azure Event Grid can be connected via official API with enterprise buildout controls, and the integration should be treated as implementable rather than shipped as a native connector.</p>\n\n<h3>What should I use for authentication on the webhook endpoint?</h3>\n<p>Use Microsoft Entra ID protected webhook delivery where possible and validate the token on every request. Also implement the Event Grid endpoint validation flow and reject any request that does not match expected issuer, audience, and client identity.</p>\n\n<h3>What do I get that helps with audit and replay checks?</h3>\n<p>Model-assisted runs can produce gateway receipts (from clawproxy) and proof bundles that package those receipts with run metadata, including event ids and dedupe decisions. This makes it practical to verify what the model saw and what policy was in force for the run.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/event-grid/secure-webhook-delivery\">Secure WebHook delivery with Microsoft Entra ID - Azure Event Grid</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/event-grid/handler-webhooks\">Webhooks as event handlers for Azure Event Grid events - Azure Event Grid</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/event-grid/webhook-event-delivery\">WebHook event delivery - Azure Event Grid</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Azure Event Grid is a push-based changefeed that delivers events to HTTPS webhooks, and it will retry deliveries, so duplicates and replays are normal operating conditions. For permissioned agents running in OpenClaw, yo",
  "faqs": [
    {
      "q": "How do I make Azure Event Grid deliveries idempotent for an agent?",
      "a": "Assume duplicates and implement a dedupe store keyed by the CloudEvents id or Event Grid id , recorded before any side effects. Treat “already processed” as a successful no-op, and store a result hash so you can prove consistent outcomes."
    },
    {
      "q": "Why is policy-as-code required instead of a carefully written prompt?",
      "a": "Because event payloads are untrusted and can contain instructions that conflict with your intent. A WPC enforces the allowed tools and write paths even if the model output is manipulated, which a prompt alone cannot guarantee."
    },
    {
      "q": "Is this a native Claw EA connector for Azure Event Grid?",
      "a": "No. Azure Event Grid can be connected via official API with enterprise buildout controls, and the integration should be treated as implementable rather than shipped as a native connector."
    },
    {
      "q": "What should I use for authentication on the webhook endpoint?",
      "a": "Use Microsoft Entra ID protected webhook delivery where possible and validate the token on every request. Also implement the Event Grid endpoint validation flow and reject any request that does not match expected issuer, audience, and client identity."
    },
    {
      "q": "What do I get that helps with audit and replay checks?",
      "a": "Model-assisted runs can produce gateway receipts (from clawproxy) and proof bundles that package those receipts with run metadata, including event ids and dedupe decisions. This makes it practical to verify what the model saw and what policy was in force for the run."
    }
  ],
  "sources": [
    {
      "title": "Secure WebHook delivery with Microsoft Entra ID - Azure Event Grid",
      "uri": "https://learn.microsoft.com/en-us/azure/event-grid/secure-webhook-delivery"
    },
    {
      "title": "Authenticate with namespaces using webhook auth - Azure Event Grid",
      "uri": "https://learn.microsoft.com/en-us/azure/event-grid/authenticate-with-namespaces-using-webhook-authentication"
    },
    {
      "title": "Webhooks as event handlers for Azure Event Grid events - Azure Event Grid",
      "uri": "https://learn.microsoft.com/en-us/azure/event-grid/handler-webhooks"
    },
    {
      "title": "Authenticate Event Grid publishing clients using Microsoft Entra ID - Azure Event Grid",
      "uri": "https://learn.microsoft.com/en-us/azure/event-grid/authenticate-with-microsoft-entra-id"
    },
    {
      "title": "Secure WebHook delivery with Microsoft Entra ID in Azure Event Grid - Azure Event Grid",
      "uri": "https://learn.microsoft.com/en-sg/azure/event-grid/secure-webhook-delivery"
    },
    {
      "title": "WebHook event delivery - Azure Event Grid",
      "uri": "https://learn.microsoft.com/en-us/azure/event-grid/webhook-event-delivery"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:09:20.589Z",
  "indexable": true
}