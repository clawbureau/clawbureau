{
  "slug": "tools/github-actions",
  "title": "GitHub Actions for Permissioned Agents | Claw EA",
  "category": "tools",
  "html": "<p>GitHub Actions is a high-leverage place to let agents propose changes, run tests, and open pull requests, but it is also a privileged execution surface where a mis-scoped token or unsafe workflow can turn into repo write access, secret exposure, or supply-chain drift. For enterprise agent security, you want permissioned execution: policy-as-code that constrains what an agent may do in Actions, independent of what it says in a prompt.</p>\n<p>Claw EA runs OpenClaw as the baseline agent runtime and uses Claw Bureau primitives to make Actions runs auditable and bounded: a WPC that defines allowed operations, a CST that carries the intended scope and can be policy-hash pinned, plus gateway receipts and a proof bundle so you can verify what model calls happened and under what constraints. GitHub Actions connectivity is implementable via official API with enterprise buildout controls, not a native connector.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>This runbook assumes you want an agent to interact with GitHub Actions without giving it a standing “repo admin” capability. The goal is to keep authorization machine-enforced, then make every run reviewable after the fact.</p>\n<ol>\n  <li>\n    <p><strong>Define the Work Policy Contract.</strong> Create a WPC that enumerates allowed repositories, allowed workflow files (or workflow names), and what “write” means (for example, only open PRs, never push directly to default branch). Store the signed, hash-addressed WPC in the WPC registry, then plan to fetch and verify it at execution time.</p>\n  </li>\n  <li>\n    <p><strong>Choose the minimal GitHub auth footprint.</strong> Decide whether your enterprise buildout will use a GitHub App, OAuth, or a service account pattern, and map it to least-privilege repository permissions. If your agent can trigger workflows, keep write and admin actions behind WPC approval gates and explicit least-privilege auth scopes.</p>\n  </li>\n  <li>\n    <p><strong>Issue a job-scoped CST.</strong> At the start of an agent job, request a CST from clawscope with a short TTL and a scope hash that matches the WPC intent. If you need stronger coupling, enable optional policy hash pinning so the CST is only valid for the specific WPC hash your workflow expects.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy.</strong> For any model-assisted step (triage, code review, test failure summarization), route the model traffic through clawproxy so gateway receipts are emitted. This makes model usage verifiable and prevents “invisible” model calls outside the approved execution path.</p>\n  </li>\n  <li>\n    <p><strong>Execute Actions operations via official API.</strong> Use the GitHub REST API to dispatch workflows, check run status, and fetch logs and artifacts, but only for targets allowed by the WPC. Treat every “write” operation (dispatch, approve, rerun, cancel, or create PR) as a policy decision, not a prompt decision.</p>\n  </li>\n  <li>\n    <p><strong>Generate a proof bundle.</strong> At the end of the job, emit a proof bundle that binds together the CST scope hash, the WPC hash, gateway receipts, and job metadata (repo, workflow, commit, runner identity as observed). Store the proof bundle for audit, and optionally publish a Trust Pulse for easy viewing.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>GitHub Actions is powerful because it can run arbitrary steps in a runner and it often has access to secrets and repo permissions. When an agent is involved, you should assume it will eventually encounter prompt injection, malicious PR content, or ambiguous instructions that cause overreach unless the execution layer is permissioned.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Workflow modification to gain privileges</td>\n      <td>An agent edits a workflow to add extra permissions, exfiltrate secrets, or run unreviewed scripts, then triggers it.</td>\n      <td>WPC restricts which workflow files may be changed and forbids direct pushes; “write” paths require WPC approval gates. Use short-lived CST and pin it to the WPC hash so a different policy cannot be swapped in mid-run.</td>\n    </tr>\n    <tr>\n      <td>Secret leakage through logs or artifacts</td>\n      <td>Actions logs or uploaded artifacts capture tokens, environment variables, or private code, then get copied into issues or external systems.</td>\n      <td>Keep Actions permissions minimal and avoid giving the agent raw secrets when possible; treat logs as sensitive and restrict who can read them. Use proof bundles for audit rather than copying full logs into chat transcripts.</td>\n    </tr>\n    <tr>\n      <td>Token overreach (repo-wide write when only PR is needed)</td>\n      <td>A single token can write to many repos or bypass review by pushing directly to protected branches.</td>\n      <td>Use least-privilege GitHub permissions and restrict targets in WPC to a repo allowlist; bind the CST to the job and WPC so replay across repos is blocked by marketplace anti-replay binding (job-scoped CST binding).</td>\n    </tr>\n    <tr>\n      <td>Supply-chain compromise through unpinned actions</td>\n      <td>A workflow uses a third-party action by a moving tag, and a compromised update runs under your permissions.</td>\n      <td>Enforce an internal policy that actions are pinned to commit SHAs and reviewed; have the WPC require pinned references for any workflow the agent may trigger or modify.</td>\n    </tr>\n    <tr>\n      <td>Prompt-only controls get bypassed</td>\n      <td>The agent “agrees” to constraints but still takes a dangerous path when it encounters a tricky failure mode or conflicting instruction.</td>\n      <td>Permission the execution layer with WPC and CST so the system rejects disallowed API calls even if the prompt tries to override. Use OpenClaw tool policy and sandboxing to reduce local blast radius for any auxiliary tooling.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the shape of a WPC you might use to constrain GitHub Actions usage for an agent that is allowed to run CI and open PRs, but not push to default branches or manage secrets. Treat it as a compact “deny by default” artifact that your enterprise buildout enforces around GitHub API calls.</p>\n<pre>{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"github-actions-permissioned-agent-ci\",\n  \"targets\": {\n    \"github\": {\n      \"org_allowlist\": [\"acme\"],\n      \"repo_allowlist\": [\"acme/payment-api\", \"acme/webapp\"],\n      \"workflow_allowlist\": [\".github/workflows/ci.yml\", \".github/workflows/test.yml\"]\n    }\n  },\n  \"actions\": {\n    \"workflow_dispatch\": { \"allowed\": true },\n    \"rerun_failed_jobs\": { \"allowed\": true },\n    \"cancel_run\": { \"allowed\": true },\n    \"create_pull_request\": { \"allowed\": true },\n    \"push_to_default_branch\": { \"allowed\": false },\n    \"edit_workflow_files\": {\n      \"allowed\": true,\n      \"requires_review\": true,\n      \"require_pinned_actions\": true\n    },\n    \"secrets_read_or_write\": { \"allowed\": false }\n  },\n  \"auth\": {\n    \"require_least_privilege_scopes\": true,\n    \"max_token_ttl_seconds\": 900\n  },\n  \"attestation\": {\n    \"require_gateway_receipts_for_model_calls\": true,\n    \"emit_proof_bundle\": true\n  }\n}</pre>\n<p>Operationally: your GitHub Actions integration code checks this WPC before calling the GitHub API, and the job CST is minted to match the intent. If the agent tries to dispatch an unlisted workflow or touch a disallowed repo, the call is denied even if the prompt is persuasive.</p>\n\n<h2>What proof do you get?</h2>\n<p>For model-assisted CI runs, clawproxy emits gateway receipts for model calls, including what was requested and the signed receipt metadata needed for verification. Those receipts are bundled with job context into a proof bundle, which you can keep with the run artifacts or hand to an audit pipeline.</p>\n<p>The proof bundle is designed to answer concrete questions: which WPC hash governed the run, which CST scope hash was used, and which model calls occurred under clawproxy. If you publish it, a Trust Pulse can store the artifact for later viewing and comparison across runs.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollbacks should assume two things: agents will sometimes make undesirable changes, and long-lived credentials are a liability. Your response plan should be able to stop new actions quickly, then produce evidence for what happened without relying on a human remembering the timeline.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Suspected agent overreach in GitHub</td>\n      <td>Disable the enterprise buildout path that issues CST for GitHub Actions jobs, then revoke or expire job CST quickly via clawscope. Freeze agent write capabilities by updating the WPC to deny write operations and requiring review.</td>\n      <td>Proof bundle showing WPC hash, CST scope hash, and gateway receipts for model calls involved in the run.</td>\n    </tr>\n    <tr>\n      <td>Bad workflow change merged</td>\n      <td>Revert the workflow file change in a PR, and temporarily block any agent from editing workflows by updating WPC. Review GitHub Actions permission settings and pin third-party actions to SHAs.</td>\n      <td>Git history plus proof bundle linking the agent job to the commit and the policy used at the time.</td>\n    </tr>\n    <tr>\n      <td>Secret suspected exposed in logs</td>\n      <td>Rotate the secret, invalidate any derived tokens, and restrict log access while you investigate. Update WPC to block steps that output environment dumps and require redaction discipline in the workflow.</td>\n      <td>Proof bundle for the job, plus GitHub run logs retained under your normal controls (do not copy them into chat).</td>\n    </tr>\n    <tr>\n      <td>Need to validate what the model saw</td>\n      <td>Reconstruct the model call sequence from gateway receipts rather than relying on the agent transcript. If necessary, rerun the job with a stricter WPC and compare outputs.</td>\n      <td>Gateway receipts (from clawproxy) and the proof bundle integrity checks.</td>\n    </tr>\n  </tbody>\n</table>\n<p>If you need network egress allowlists or automatic cost budget enforcement, those are optional or can be implemented, but you should not depend on them as your primary guardrail. Start with permissioned execution via WPC plus short-lived CST, then add infrastructure controls as your deployment matures.</p>\n\n<h2>FAQ</h2>\n<h3>Is this a native GitHub Actions connector in Claw EA today?</h3>\n<p>No. GitHub Actions can be connected via official API with enterprise buildout controls, and you should treat it as an integration project with explicit security review rather than a toggle.</p>\n\n<h3>Why is prompt-only safety not enough for GitHub Actions?</h3>\n<p>Prompts can be ignored, misunderstood, or overridden by content in PRs, logs, or issues. Policy-as-code makes the execution layer reject disallowed API calls even if the agent attempts them.</p>\n\n<h3>What is the minimum set of Claw Bureau primitives I should use?</h3>\n<p>Use a WPC to define allowed Actions operations and targets, a CST to enforce job-scoped access with a scope hash (optionally pinned to the WPC hash), and clawproxy gateway receipts so model calls are provable. Wrap the whole run into a proof bundle for audit and verification.</p>\n\n<h3>How does anti-replay work for an Actions-triggering agent?</h3>\n<p>Use marketplace anti-replay binding (job-scoped CST binding) so a CST minted for one job cannot be reused for another job or target. Pair that with WPC allowlists so even a valid token cannot be used outside the intended repo or workflow set.</p>\n\n<h3>Can I run the agent locally and still do this securely?</h3>\n<p>You can, but assume local shell and filesystem access increase risk. Use OpenClaw sandboxing and tool policy to constrain local tools, and keep GitHub permissions and CST TTLs tight so local compromise does not become persistent repo compromise.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions\">Secure use reference (Security hardening for GitHub Actions) - GitHub Docs</a></li>\n  <li><a href=\"https://docs.github.com/en/copilot/tutorials/roll-out-at-scale/enable-developers/integrate-ai-agents\">Integrating agentic AI into your enterprise&#x27;s software development lifecycle - GitHub Docs</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "GitHub Actions is a high-leverage place to let agents propose changes, run tests, and open pull requests, but it is also a privileged execution surface where a mis-scoped token or unsafe workflow can turn into repo write",
  "faqs": [
    {
      "q": "Is this a native GitHub Actions connector in Claw EA today?",
      "a": "No. GitHub Actions can be connected via official API with enterprise buildout controls, and you should treat it as an integration project with explicit security review rather than a toggle."
    },
    {
      "q": "Why is prompt-only safety not enough for GitHub Actions?",
      "a": "Prompts can be ignored, misunderstood, or overridden by content in PRs, logs, or issues. Policy-as-code makes the execution layer reject disallowed API calls even if the agent attempts them."
    },
    {
      "q": "What is the minimum set of Claw Bureau primitives I should use?",
      "a": "Use a WPC to define allowed Actions operations and targets, a CST to enforce job-scoped access with a scope hash (optionally pinned to the WPC hash), and clawproxy gateway receipts so model calls are provable. Wrap the whole run into a proof bundle for audit and verification."
    },
    {
      "q": "How does anti-replay work for an Actions-triggering agent?",
      "a": "Use marketplace anti-replay binding (job-scoped CST binding) so a CST minted for one job cannot be reused for another job or target. Pair that with WPC allowlists so even a valid token cannot be used outside the intended repo or workflow set."
    },
    {
      "q": "Can I run the agent locally and still do this securely?",
      "a": "You can, but assume local shell and filesystem access increase risk. Use OpenClaw sandboxing and tool policy to constrain local tools, and keep GitHub permissions and CST TTLs tight so local compromise does not become persistent repo compromise."
    }
  ],
  "sources": [
    {
      "title": "Managing agents in your enterprise - GitHub Docs",
      "uri": "https://docs.github.com/en/copilot/how-tos/administer-copilot/manage-for-enterprise/manage-agents"
    },
    {
      "title": "Secure use reference - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions"
    },
    {
      "title": "Deploy AI agents on Amazon Bedrock AgentCore using GitHub ...",
      "uri": "https://aws.amazon.com/blogs/machine-learning/deploy-ai-agents-on-amazon-bedrock-agentcore-using-github-actions/"
    },
    {
      "title": "Security hardening for GitHub Actions - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions?learn=getting_started&learnProduct=actions"
    },
    {
      "title": "Integrating agentic AI into your enterprise's software development ...",
      "uri": "https://docs.github.com/en/copilot/tutorials/roll-out-at-scale/enable-developers/integrate-ai-agents"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:19:31.078Z",
  "indexable": true
}