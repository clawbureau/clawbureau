{
  "slug": "tools/github",
  "title": "GitHub for Permissioned Agents | Claw EA",
  "category": "tools",
  "html": "<h2>Direct Answer</h2>\n<p>Use GitHub with permissioned agents by forcing every repo-changing action through policy-as-code and verifiable execution, not prompt instructions. In Claw EA, the baseline runtime is OpenClaw, and GitHub access is implemented via official API or an official MCP server with enterprise buildout controls, then constrained by a WPC and CST.</p>\n<p>This matters because GitHub is a change control surface: a single mis-scoped token or a single “helpful” model decision can create branches, open pull requests, alter workflows, or leak code. Prompt-only “rules” are not enforcement, so you need machine-checked gates for write and admin actions.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>1) Decide the GitHub connection path: official API or an official MCP server, and define which identity will be used (GitHub App, OAuth token, or other enterprise-approved method). Start with read-only scopes and only add write scopes when you have a hard approval gate.</p>\n<p>2) Create a WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols) that enumerates allowed repos, allowed operations, and escalation rules. Treat “merge”, “push”, “workflow changes”, and “secrets” as separate operations, even if they are all “write” in GitHub terms.</p>\n<p>3) Issue a CST = scoped token (issued by clawscope) for the job, and pin it to the policy by hash when you can. Use job-scoped CST binding to reduce replay across jobs and to make “this token only existed for that run” a verifiable claim.</p>\n<p>4) Run the agent in OpenClaw with strict tool policy and sandbox defaults. Put GitHub operations behind an explicit tool name so you can deny-by-default and only allow the minimal calls needed for the run.</p>\n<p>5) Route model calls through clawproxy so you get Gateway receipts for each model call, then bundle them into a proof bundle for the run. Store the resulting artifact as a Trust Pulse when you need centralized viewing and audit workflows.</p>\n<p>6) Operationally, set a two-phase flow: phase A is read and plan (list issues, read files, propose diff), phase B is apply (create branch, push commit, open PR), and phase B requires WPC approval gates. If phase B is denied, the agent should still produce a patch artifact and a PR-ready plan without touching GitHub.</p>\n\n<h2>Threat model</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection via issue text or PR comments</td>\n      <td>The agent is tricked into running “helpful” actions like pushing code, changing CI, or exfiltrating file contents into a comment.</td>\n      <td>Separate read from write in the WPC, default to read-only, and require explicit approval for write/admin actions. Constrain OpenClaw tool policy so GitHub write tools are not available in the same session as broad file or shell tools unless required.</td>\n    </tr>\n    <tr>\n      <td>Over-scoped GitHub credentials</td>\n      <td>A token with broad repo access is reused to modify unrelated repositories or sensitive org settings.</td>\n      <td>Issue CST per job and bind it to a narrow WPC policy hash; the job cannot “grow” permissions mid-run. Use least-privilege GitHub auth scopes and restrict to specific repos and orgs in your enterprise buildout.</td>\n    </tr>\n    <tr>\n      <td>Malicious or compromised tool/plugin</td>\n      <td>The GitHub tool silently performs extra API calls (extra repo reads, unexpected writes) beyond the user intent.</td>\n      <td>Require WPC approval gates for any write or admin capability. Keep GitHub operations auditable as discrete tool calls, and review the proof bundle post-run when the action touches protected repos.</td>\n    </tr>\n    <tr>\n      <td>Supply chain edits via workflow manipulation</td>\n      <td>The agent changes GitHub Actions workflows to run untrusted code or to publish artifacts, creating a CI-to-prod path.</td>\n      <td>In the WPC, treat “.github/workflows/*” edits as a higher-risk category requiring additional approval. Deny workflow file changes by default unless the job is explicitly a CI maintenance task.</td>\n    </tr>\n    <tr>\n      <td>Replay of an earlier “approved” run</td>\n      <td>An attacker replays an old token or re-submits an old plan to get the same write action executed again.</td>\n      <td>Use marketplace anti-replay binding with job-scoped CST binding so a token is tied to a single job context. Verify that the policy hash and scope hash match what was approved for that job.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact, JSON-like WPC sketch showing how teams typically gate GitHub. The key point is that “allowed” is enforced by the execution layer, not requested in a prompt.</p>\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"tool\": \"github\",\n  \"connection_mode\": [\"official_api\", \"mcp_server\"],\n  \"repos\": [\n    \"acme/payments-service\",\n    \"acme/shared-libraries\"\n  ],\n  \"permissions\": {\n    \"read\": [\"issues:read\", \"pull_requests:read\", \"contents:read\"],\n    \"write_requires_approval\": [\n      \"contents:write\",\n      \"pull_requests:write\",\n      \"workflows:write\",\n      \"actions:write\",\n      \"administration:*\"\n    ]\n  },\n  \"path_rules\": [\n    { \"glob\": \".github/workflows/**\", \"default\": \"deny\", \"override\": \"approval_required\" },\n    { \"glob\": \"**/secrets/**\", \"default\": \"deny\" }\n  ],\n  \"change_controls\": {\n    \"require_plan_before_write\": true,\n    \"require_human_approval_for_write\": true\n  },\n  \"token_binding\": {\n    \"require_cst\": true,\n    \"pin_policy_hash\": true\n  }\n}</pre>\n<p>In practice, the WPC is signed and hash-addressed in clawcontrols, then fetched and verified before the job runs. The CST from clawscope can be pinned to the WPC hash so the job cannot swap policies without failing closed.</p>\n\n<h2>What proof do you get?</h2>\n<p>For model traffic, clawproxy emits Gateway receipts for each model call, and Claw EA can package those receipts into a proof bundle for the run. This lets you answer “which model calls led to the plan” without trusting a mutable log stream.</p>\n<p>For authorization, you can show which WPC was used (by policy hash) and which CST was presented (with scope hash and optional policy hash pinning). Combined with job-scoped CST binding, this gives an auditable link from an approved policy to a specific run, instead of “someone said it was approved”.</p>\n<p>When you need centralized viewing, store the resulting artifact as a Trust Pulse for audit and review. If a repo write occurred, the proof bundle is the object you hand to security or compliance to validate what was permitted and what actually executed.</p>\n\n<h2>Rollback posture</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Branch created and commits pushed</td>\n      <td>Delete the branch or force-protect the default branch so only reviewed PRs can merge.</td>\n      <td>Proof bundle links the run to the WPC and CST used; Git history shows the commit set that must be reverted.</td>\n    </tr>\n    <tr>\n      <td>Pull request opened</td>\n      <td>Close the PR and block auto-merge; require CODEOWNERS review on protected paths.</td>\n      <td>Run artifacts show the intended diff and the policy category (read vs write) that was approved.</td>\n    </tr>\n    <tr>\n      <td>Workflow files modified</td>\n      <td>Revert the workflow commit immediately, then rotate any exposed secrets and re-run CI from a known-good commit.</td>\n      <td>WPC path rules show whether workflows were allowed; the proof bundle identifies the run that produced the change.</td>\n    </tr>\n    <tr>\n      <td>Unexpected API calls (extra reads or writes)</td>\n      <td>Revoke the GitHub credential, revoke the CST, and quarantine the agent configuration until reviewed.</td>\n      <td>CST issuance and revocation records, plus the policy hash used, support a tight incident timeline.</td>\n    </tr>\n  </tbody>\n</table>\n<p>OpenClaw sandboxing and tool policy reduce local blast radius if a task also involves running tests or generating artifacts. Keep “elevated” host execution off unless you have a clear need, and treat it as a separate approval path.</p>\n\n<h2>FAQ</h2>\n<h3>Is this a native GitHub connector in Claw EA today?</h3>\n<p>No. GitHub can be connected via official API and MCP-compatible tooling with enterprise buildout controls, but it should be treated as an implementable integration rather than an out-of-the-box connector.</p>\n\n<h3>Why is prompt-only control not enough for GitHub actions?</h3>\n<p>Prompts are advisory and can be overridden by injected text from issues, PRs, or repo files. A permissioned execution layer enforces WPC rules and CST scope constraints even when the agent is pressured to do more.</p>\n\n<h3>What GitHub permissions should an agent start with?</h3>\n<p>Start with read-only capabilities needed to plan work: repo contents read, issues read, and pull request read. Add write permissions only behind WPC approval gates, and separate workflow edits from normal code edits.</p>\n\n<h3>What does “approval gate” mean operationally?</h3>\n<p>It means the run must present a WPC that explicitly allows the write category, and your workflow requires an explicit approval decision before those tool calls are enabled. If approval is not granted, the agent can still produce a patch and plan without touching GitHub.</p>\n\n<h3>What evidence is available after a run changes a repository?</h3>\n<p>You can retain the WPC policy hash, CST scope hash (and optional policy hash pinning), plus Gateway receipts and a proof bundle covering model calls. When stored as a Trust Pulse, reviewers have a single artifact to inspect for what was permitted and what executed.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://docs.github.com/en/copilot/concepts/agents/coding-agent/access-management\">Managing access to GitHub Copilot coding agent - GitHub Docs</a></li>\n  <li><a href=\"https://docs.github.com/en/copilot/how-tos/administer-copilot/manage-for-enterprise/manage-copilot-coding-agent\">Managing GitHub Copilot coding agent in your enterprise - GitHub Docs</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Use GitHub with permissioned agents by forcing every repo-changing action through policy-as-code and verifiable execution, not prompt instructions. In Claw EA, the baseline runtime is OpenClaw, and GitHub access is imple",
  "faqs": [
    {
      "q": "Is this a native GitHub connector in Claw EA today?",
      "a": "No. GitHub can be connected via official API and MCP-compatible tooling with enterprise buildout controls, but it should be treated as an implementable integration rather than an out-of-the-box connector."
    },
    {
      "q": "Why is prompt-only control not enough for GitHub actions?",
      "a": "Prompts are advisory and can be overridden by injected text from issues, PRs, or repo files. A permissioned execution layer enforces WPC rules and CST scope constraints even when the agent is pressured to do more."
    },
    {
      "q": "What GitHub permissions should an agent start with?",
      "a": "Start with read-only capabilities needed to plan work: repo contents read, issues read, and pull request read. Add write permissions only behind WPC approval gates, and separate workflow edits from normal code edits."
    },
    {
      "q": "What does “approval gate” mean operationally?",
      "a": "It means the run must present a WPC that explicitly allows the write category, and your workflow requires an explicit approval decision before those tool calls are enabled. If approval is not granted, the agent can still produce a patch and plan without touching GitHub."
    },
    {
      "q": "What evidence is available after a run changes a repository?",
      "a": "You can retain the WPC policy hash, CST scope hash (and optional policy hash pinning), plus Gateway receipts and a proof bundle covering model calls. When stored as a Trust Pulse, reviewers have a single artifact to inspect for what was permitted and what executed."
    }
  ],
  "sources": [
    {
      "title": "Managing access to GitHub Copilot coding agent - GitHub Docs",
      "uri": "https://docs.github.com/en/copilot/concepts/agents/coding-agent/access-management"
    },
    {
      "title": "Managing access to GitHub Copilot coding agent - GitHub Docs",
      "uri": "https://docs.github.com/en/copilot/concepts/agents/coding-agent/managing-access"
    },
    {
      "title": "Integrating agentic AI into your enterprise's software development lifecycle - GitHub Docs",
      "uri": "https://docs.github.com/en/copilot/tutorials/roll-out-at-scale/enable-developers/integrate-ai-agents"
    },
    {
      "title": "Managing GitHub Copilot coding agent in your enterprise - GitHub Docs",
      "uri": "https://docs.github.com/en/copilot/how-tos/administer-copilot/manage-for-enterprise/manage-copilot-coding-agent"
    },
    {
      "title": "About GitHub Copilot coding agent for business and enterprise - GitHub Docs",
      "uri": "https://docs.github.com/en/copilot/concepts/agents/coding-agent/coding-agent-for-business-and-enterprise"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:18:24.126Z",
  "indexable": true
}