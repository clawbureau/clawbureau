{
  "slug": "tools/microsoft-calendar",
  "title": "Microsoft Calendar for Permissioned Agents | Claw EA",
  "category": "tools",
  "html": "<p>Microsoft Calendar can be connected to permissioned agents via the official API (Microsoft Graph) with enterprise buildout controls, but it should not be treated as a “simple tool” you hand to a model. Calendar write access is an operational control surface: it can move meetings, leak attendee lists, and create social-engineering leverage.</p>\n<p>In Claw EA, run the agent in OpenClaw as the baseline runtime, and make calendar actions pass through policy-as-code gates: a WPC, CST issuance, and verified logging via gateway receipts and proof bundles. Prompt-only constraints are not sufficient because prompts are editable, bypassable, and do not bind to identity, scopes, or an audit trail.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Define the calendar blast radius.</strong> Decide which mailboxes/calendars are in scope (service mailbox vs human mailbox), what time horizon is allowed (for example, “next 30 days”), and what actions are permitted (read-only, create tentative holds, invite-only, or full edits).</p>\n    <p>Write this down as operational rules first, then encode it as policy so enforcement does not depend on model compliance.</p>\n  </li>\n  <li>\n    <p><strong>Choose an identity pattern in Entra ID.</strong> Prefer a dedicated non-human identity, and plan how consent and Microsoft Graph permissions/scopes will be granted and reviewed. Use Conditional Access and PIM where applicable so privileged approvals are time-bound and visible.</p>\n    <p>This step is where most deployments fail: excessive scopes or ambiguous ownership turns calendar access into “tenant-wide scheduling powers.”</p>\n  </li>\n  <li>\n    <p><strong>Attach a WPC to the job.</strong> Publish a WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols) that defines allowed tool actions (calendar read vs write), required approvals, and logging requirements. The agent run should pin the policy hash so the job cannot silently drift to a different policy version.</p>\n    <p>This is the core difference from prompt-only: the WPC is enforced outside the model, and is stable under adversarial prompts.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for this run.</strong> Get a CST = scoped token (issued by clawscope) that is job-scoped and includes a scope hash that matches the WPC constraints. If you use policy hash pinning, bind the CST to the exact WPC hash used by the job.</p>\n    <p>This prevents “token reuse” across jobs and reduces the value of any leaked credential material.</p>\n  </li>\n  <li>\n    <p><strong>Execute calendar calls via official API with explicit scope checks.</strong> Implement the Microsoft Graph calls in your enterprise buildout, and force the agent to request actions in structured form (for example: create event, list free/busy). Before executing, validate that the request matches the WPC and that the Graph permission being used is least-privilege for that action.</p>\n    <p>When in doubt, start with read-only and only allow create events with “tentative” status and limited attendee domains.</p>\n  </li>\n  <li>\n    <p><strong>Route model traffic through clawproxy for receipts.</strong> Send the model calls through clawproxy so you get gateway receipts = signed receipts emitted by clawproxy for model calls. Store a proof bundle = harness artifact bundling receipts and related metadata for audit/verification for each run.</p>\n    <p>This creates an after-action record you can verify later, instead of relying on application logs that can be incomplete or altered.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Calendar tools are attractive targets because they combine identity, presence, and influence. A malicious or misconfigured skill/plugin can do real damage without touching code repos or production infrastructure.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Over-broad Microsoft Graph permissions</td>\n      <td>Agent can read or modify calendars beyond the intended mailbox, or enumerate users/attendees at scale.</td>\n      <td>Least-privilege Graph permissions/scopes, Entra admin consent reviews, and a WPC that denies actions outside a mailbox allowlist.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection via meeting content</td>\n      <td>Meeting descriptions or attendee emails instruct the agent to reschedule, cancel, or exfiltrate details.</td>\n      <td>WPC gates for write actions, structured tool requests, and separation between “read context” and “execute change.”</td>\n    </tr>\n    <tr>\n      <td>Social engineering amplification</td>\n      <td>Agent invites external attendees, adds phishing links, or creates meetings that appear legitimate.</td>\n      <td>WPC rules on attendee domains, link handling, and a required human approval step for external invites (implemented in enterprise buildout).</td>\n    </tr>\n    <tr>\n      <td>Replay and cross-job token reuse</td>\n      <td>A captured token or job artifact is reused to perform calendar writes later.</td>\n      <td>Job-scoped CST binding (anti-replay) and short TTL issuance; deny long-lived tokens for agent runs.</td>\n    </tr>\n    <tr>\n      <td>Undetected tool drift</td>\n      <td>Agent behavior changes because the “policy in the prompt” changed, or the tool implementation changed, but no one notices.</td>\n      <td>Pin the policy hash in the CST and require WPC fetch/verify before execution; store proof bundles per run for audit diffs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the shape of a policy you would package into a WPC and pin for a job. It is intentionally narrow: read availability, create tentative holds, and forbid cancel/reschedule without approval.</p>\n\n<pre>{\n  \"policy_name\": \"m365_calendar_permissioned_agent_v1\",\n  \"tool\": \"microsoft_calendar_via_graph_api\",\n  \"allowed_mailboxes\": [\"scheduling-bot@corp.example\"],\n  \"allowed_actions\": [\n    { \"action\": \"calendar.read.freebusy\", \"constraints\": { \"horizon_days\": 30 } },\n    { \"action\": \"calendar.event.create\", \"constraints\": { \"show_as\": [\"tentative\"], \"max_duration_minutes\": 60 } }\n  ],\n  \"denied_actions\": [\n    \"calendar.event.cancel\",\n    \"calendar.event.update.attendees\",\n    \"calendar.event.update.time\"\n  ],\n  \"approval_gates\": [\n    { \"action_prefix\": \"calendar.event.\", \"require\": \"human_approval_for_external_attendees\" }\n  ],\n  \"auth\": {\n    \"entra_id\": {\n      \"token_type\": \"app_or_delegated\",\n      \"graph_permissions_scopes\": [\"least_privilege_required\"]\n    }\n  },\n  \"run_controls\": {\n    \"require_cst\": true,\n    \"cst_scope_hash_required\": true,\n    \"optional_policy_hash_pinning\": true\n  },\n  \"audit\": {\n    \"require_gateway_receipts_for_model_calls\": true,\n    \"emit_proof_bundle\": true\n  }\n}</pre>\n\n<h2>What proof do you get?</h2>\n<p>For the model side, clawproxy emits gateway receipts for each model call routed through it. Those receipts let you later verify what the model was asked, what it returned, and which run the call belonged to.</p>\n<p>Claw EA packages receipts into a proof bundle, along with run metadata needed for audit and verification. If you store the resulting artifact in Trust Pulse, you get a stable place to view and review the evidence across runs, including job-scoped anti-replay binding via the CST.</p>\n<p>For Microsoft Calendar actions, you should also retain your enterprise buildout logs (Graph request metadata, mailbox targeted, and resulting event IDs). The key operational point is correlation: the proof bundle anchors the model decisions, while Graph logs anchor the external side effects.</p>\n\n<h2>Rollback posture</h2>\n<p>Calendar changes are partially reversible, but the safest posture is to design actions that create minimal harm by default. Use tentative holds, avoid cancellations, and keep all writes attributable to a dedicated mailbox so you can quarantine and review quickly.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Agent created a tentative hold</td>\n      <td>Delete the event from the service mailbox; notify internal attendees if any were invited.</td>\n      <td>Proof bundle for the run; Graph event ID and timestamps from enterprise logs.</td>\n    </tr>\n    <tr>\n      <td>Agent invited external attendees (should be gated)</td>\n      <td>Cancel the event, rotate the CST issuance rules for the next runs, and require approval for external domains.</td>\n      <td>WPC that should have denied it (or proof of missing gate); proof bundle showing the model request path.</td>\n    </tr>\n    <tr>\n      <td>Agent rescheduled or canceled a real meeting</td>\n      <td>Restore from mailbox audit data where possible and re-issue corrected invites; temporarily disable calendar writes.</td>\n      <td>Run-level CST binding, proof bundle to trace why it happened, and Entra sign-in/audit trails.</td>\n    </tr>\n    <tr>\n      <td>Suspected token misuse</td>\n      <td>Revoke the CST, rotate underlying app credentials if applicable, and reduce Graph permissions/scopes.</td>\n      <td>CST issuance and revocation records; proof bundle showing which job the CST was bound to.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Is Microsoft Calendar support a native Claw EA connector today?</h3>\n<p>No. Microsoft Calendar can be connected via official API with enterprise buildout controls, and the run can still be permissioned and audited with WPC, CST, gateway receipts, and proof bundles.</p>\n\n<h3>Why is prompt-only control not enough for calendar agents?</h3>\n<p>Prompt rules are not an enforcement layer: they can be overridden by injection, model error, or tool drift. A WPC and CST make permissions machine-checked, job-scoped, and verifiable even when the model output is adversarial.</p>\n\n<h3>What Microsoft security controls matter most for calendar agents?</h3>\n<p>Use Entra ID as the identity boundary, and be strict about Microsoft Graph permissions/scopes and consent. Conditional Access and PIM help reduce standing privilege and make elevated access visible when you need it.</p>\n\n<h3>Can you prove what the model did during scheduling?</h3>\n<p>You can prove the model-call side when routed through clawproxy because you get gateway receipts and a proof bundle per run. For the external calendar side effects, you should correlate with Graph request logs from your enterprise buildout.</p>\n\n<h3>How do you prevent replay of a previous “approved” run?</h3>\n<p>Use job-scoped CST binding (anti-replay) and keep token TTL short. Pin the policy hash so an old token cannot be reused under a different WPC.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/entra/identity-platform/permissions-consent-overview\">Overview of permissions and consent - Microsoft identity platform</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/entra/agent-id/identity-platform/agent-identities\">Overview of agent identities in Microsoft Entra</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Microsoft Calendar can be connected to permissioned agents via the official API (Microsoft Graph) with enterprise buildout controls, but it should not be treated as a “simple tool” you hand to a model. Calendar write acc",
  "faqs": [
    {
      "q": "Is Microsoft Calendar support a native Claw EA connector today?",
      "a": "No. Microsoft Calendar can be connected via official API with enterprise buildout controls, and the run can still be permissioned and audited with WPC, CST, gateway receipts, and proof bundles."
    },
    {
      "q": "Why is prompt-only control not enough for calendar agents?",
      "a": "Prompt rules are not an enforcement layer: they can be overridden by injection, model error, or tool drift. A WPC and CST make permissions machine-checked, job-scoped, and verifiable even when the model output is adversarial."
    },
    {
      "q": "What Microsoft security controls matter most for calendar agents?",
      "a": "Use Entra ID as the identity boundary, and be strict about Microsoft Graph permissions/scopes and consent. Conditional Access and PIM help reduce standing privilege and make elevated access visible when you need it."
    },
    {
      "q": "Can you prove what the model did during scheduling?",
      "a": "You can prove the model-call side when routed through clawproxy because you get gateway receipts and a proof bundle per run. For the external calendar side effects, you should correlate with Graph request logs from your enterprise buildout."
    },
    {
      "q": "How do you prevent replay of a previous “approved” run?",
      "a": "Use job-scoped CST binding (anti-replay) and keep token TTL short. Pin the policy hash so an old token cannot be reused under a different WPC."
    }
  ],
  "sources": [
    {
      "title": "Security for AI agents with Microsoft Entra Agent ID",
      "uri": "https://learn.microsoft.com/en-us/entra/agent-id/identity-professional/security-for-ai"
    },
    {
      "title": "Agent 365 tooling servers overview",
      "uri": "https://learn.microsoft.com/en-us/microsoft-agent-365/tooling-servers-overview"
    },
    {
      "title": "Secure AI agents at scale using Microsoft Agent 365",
      "uri": "https://learn.microsoft.com/en-us/security/security-for-ai/agent-365-security"
    },
    {
      "title": "Microsoft Agent 365 documentation",
      "uri": "https://learn.microsoft.com/en-us/microsoft-agent-365/"
    },
    {
      "title": "Overview of agent identities in Microsoft Entra",
      "uri": "https://learn.microsoft.com/en-us/entra/agent-id/identity-platform/agent-identities"
    },
    {
      "title": "Overview of permissions and consent - Microsoft identity platform",
      "uri": "https://learn.microsoft.com/en-us/entra/identity-platform/permissions-consent-overview"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:29:27.274Z",
  "indexable": true
}