{
  "slug": "tools/kubernetes",
  "title": "Kubernetes for Permissioned Agents | Claw EA",
  "category": "tools",
  "html": "<p>Kubernetes is a good control plane for running enterprise agents, but it is a high-impact tool: a single mis-scoped credential can turn a “helpful” agent into a cluster admin. For permissioned agents, treat Kubernetes actions as governed operations that require policy-as-code gates, not prompt-only instructions.</p>\n<p>Claw EA runs OpenClaw as the baseline agent runtime, then wraps Kubernetes access in Work Policy Contracts (WPC) and CST so each run is constrained, attributable, and reviewable. When the agent uses models through clawproxy, you also get gateway receipts and a proof bundle for audit.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>These steps assume Kubernetes access is connected via official API with enterprise buildout controls. The goal is to allow safe read operations by default and force explicit approvals for write and admin actions.</p>\n<ol>\n  <li>\n    <p>Define the Kubernetes “shape” you will allow: namespaces, resource types, and verbs (get/list/watch first). Decide which actions are always forbidden (for example: creating ClusterRoleBindings, reading Secrets, exec into pods).</p>\n  </li>\n  <li>\n    <p>Create a WPC that encodes those constraints, including allowed namespaces and a strict verb allowlist. Store it as a signed, hash-addressed artifact in the WPC registry (served by clawcontrols), and record the policy hash you intend to pin.</p>\n  </li>\n  <li>\n    <p>Issue a CST from clawscope for the job. Use CST scope hash and optional policy hash pinning so the run can only operate under the intended WPC, and so the token is not reusable outside the job.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw with sandboxing enabled for tool execution, and with a tight tool allowlist. Keep “elevated” host execution off unless you have a specific, documented need.</p>\n  </li>\n  <li>\n    <p>Implement Kubernetes calls via official API and require an approval gate for write and admin actions. The approval gate should check the WPC, validate the CST, and enforce least-privilege auth scopes on the Kubernetes credential you supply.</p>\n  </li>\n  <li>\n    <p>Route model traffic through clawproxy so each model call emits gateway receipts. On completion, package receipts plus run metadata into a proof bundle, then store the audit artifact in Trust Pulse for later review.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Kubernetes is not “just another tool” for agents. It is an authorization hub: if an agent can create workloads, it can often create new network paths, mount data, and establish persistence.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection turns into kubectl write</td>\n      <td>An attacker convinces the agent to apply YAML that creates a privileged pod or a backdoored deployment.</td>\n      <td>WPC verb allowlist with explicit approval gates for write/admin actions; CST policy hash pinning so “write” cannot be unlocked mid-run without a new policy.</td>\n    </tr>\n    <tr>\n      <td>Over-permissioned service account</td>\n      <td>The agent can list secrets, bind roles, or escalate to cluster-admin via RBAC changes.</td>\n      <td>Least-privilege Kubernetes RBAC; WPC forbids Secrets reads and RBAC mutation; require separate, time-bounded credentials for rare admin actions.</td>\n    </tr>\n    <tr>\n      <td>Namespace boundary confusion</td>\n      <td>The agent is intended to operate in a single namespace but queries or mutates other namespaces.</td>\n      <td>WPC namespace allowlist; deny cluster-scoped resources; enforce namespace scoping in the tool wrapper before issuing the API call.</td>\n    </tr>\n    <tr>\n      <td>Stealth persistence through workloads</td>\n      <td>The agent creates CronJobs, webhooks, or controllers that reintroduce malicious pods after cleanup.</td>\n      <td>WPC denies creation of workload controllers by default; require change-ticket style approvals for controller creation; keep a rollback plan that can enumerate and delete created resources.</td>\n    </tr>\n    <tr>\n      <td>Data exfiltration via logs or sidecars</td>\n      <td>The agent deploys a pod that scrapes internal services and exports data over allowed egress paths.</td>\n      <td>WPC forbids creating new Services/Ingress by default; egress allowlists enforced outside clawproxy can be implemented as an added control (optional).</td>\n    </tr>\n    <tr>\n      <td>Audit gaps</td>\n      <td>You cannot later prove what the model was asked, which model was used, or whether a run replayed a token.</td>\n      <td>Use clawproxy for gateway receipts; bundle into a proof bundle; use marketplace anti-replay binding (job-scoped CST binding) and store the artifact in Trust Pulse.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the intent of a Kubernetes WPC: allow safe reads in one namespace, forbid secrets and RBAC mutations, and require explicit approval for any write path. The WPC is a Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols), so the hash becomes the stable reference you pin in the CST.</p>\n<pre>{\n  \"tool\": \"kubernetes\",\n  \"mode\": \"via_official_api\",\n  \"k8s\": {\n    \"allowedNamespaces\": [\"apps-prod\"],\n    \"allowedVerbs\": [\"get\", \"list\", \"watch\"],\n    \"allowedResources\": [\n      \"pods\",\n      \"deployments\",\n      \"replicasets\",\n      \"services\",\n      \"events\"\n    ],\n    \"deny\": {\n      \"resources\": [\"secrets\", \"clusterrolebindings\", \"clusterroles\"],\n      \"verbs\": [\"create\", \"patch\", \"update\", \"delete\", \"exec\"]\n    },\n    \"approvalGates\": [\n      {\n        \"when\": { \"verbIn\": [\"create\", \"patch\", \"update\", \"delete\"] },\n        \"required\": true,\n        \"reason\": \"All writes require review against WPC and change ticket\"\n      }\n    ]\n  },\n  \"modelTraffic\": {\n    \"mustUseClawproxy\": true\n  }\n}</pre>\n\n<h2>What proof do you get?</h2>\n<p>For model traffic, clawproxy emits gateway receipts for each call, including the binding metadata needed for verification. Those receipts are collected with run context into a proof bundle so you can audit what was asked and what was answered, without relying on an operator’s logs alone.</p>\n<p>For authorization, the CST from clawscope can be pinned to a policy hash so the run is cryptographically tied to the intended WPC. For replay resistance across jobs, marketplace anti-replay binding (job-scoped CST binding) reduces the risk that a token captured from one run can be reused in another.</p>\n<p>For review and sharing, you can store the result in Trust Pulse as the place your audit team can retrieve and view the artifact. If you need independent verification, the proof bundle is the unit you hand to verification tooling and incident response.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback for agents touching Kubernetes must assume partial failure: some resources were created, others were updated, and the agent may have been interrupted. Plan rollback as a sequence of safe, deterministic actions, and require the agent to label everything it creates so cleanup is feasible.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Read-only investigation (events, pod logs metadata)</td>\n      <td>No rollback needed; ensure the agent did not elevate into exec or secret reads.</td>\n      <td>WPC shows read-only verbs; CST pinned to the WPC; proof bundle shows model decisions and tool intent.</td>\n    </tr>\n    <tr>\n      <td>Applied manifests (deployments/services)</td>\n      <td>Delete only labeled resources created by the run; then redeploy the last known good release from your CI system.</td>\n      <td>Approval record plus WPC gate; proof bundle correlates the change request to the run; cluster audit logs remain your source of truth for API actions.</td>\n    </tr>\n    <tr>\n      <td>RBAC or cluster-scoped changes (should be rare)</td>\n      <td>Revert RBAC bindings to a baseline, then rotate affected credentials and review for persistence (webhooks, controllers).</td>\n      <td>WPC should normally deny this; if permitted, it must be an explicit approval with a dedicated CST and short TTL.</td>\n    </tr>\n    <tr>\n      <td>Suspected compromise mid-run</td>\n      <td>Revoke the CST, stop the job, and quarantine the namespace; then enumerate and delete labeled workloads created during the run.</td>\n      <td>CST revocation event; job-scoped binding reduces replay; gateway receipts and proof bundle provide the investigative timeline for model activity.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is prompt-only control not enough for Kubernetes agents?</h3>\n<p>Prompts can be overridden by injection, tool output, or misaligned instructions, and Kubernetes consequences are durable. Policy-as-code in a WPC provides a machine-enforced boundary that the agent cannot “talk itself out of” during a run.</p>\n\n<h3>Is Kubernetes support a native Claw EA connector today?</h3>\n<p>No. Kubernetes can be connected via official API with enterprise buildout controls, and write and admin actions should require WPC approval gates, CST, and explicit least-privilege auth scopes.</p>\n\n<h3>What should be allowed by default for a new cluster integration?</h3>\n<p>Start with get/list/watch in a single namespace for non-sensitive resources, and deny Secrets and exec. Add narrowly-scoped write paths only when you have an approval workflow and a rollback plan you have tested.</p>\n\n<h3>How do gateway receipts help if the real risk is Kubernetes API access?</h3>\n<p>Receipts prove the model call history that led to an action, which helps determine whether the agent was instructed, injected, or malfunctioned. Kubernetes API auditing is still required for the authoritative record of cluster actions, but receipts close the gap on “why did the agent decide this.”</p>\n\n<h3>Where does OpenClaw fit in this stack?</h3>\n<p>OpenClaw is the agent runtime that executes tools and skills and can be sandboxed to limit local blast radius. Claw EA layers permissioning and verification around that runtime using WPC, CST, gateway receipts, and proof bundles.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://docs.cloud.google.com/kubernetes-engine/docs/how-to/agent-sandbox\">Isolate AI code execution with Agent Sandbox</a></li>\n  <li><a href=\"https://docs.cloud.google.com/kubernetes-engine/docs/tutorials/agentic-adk-vertex\">Deploy an agentic AI application on GKE with the Agent Development Kit (ADK) and Vertex AI</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Kubernetes is a good control plane for running enterprise agents, but it is a high-impact tool: a single mis-scoped credential can turn a “helpful” agent into a cluster admin. For permissioned agents, treat Kubernetes ac",
  "faqs": [
    {
      "q": "Why is prompt-only control not enough for Kubernetes agents?",
      "a": "Prompts can be overridden by injection, tool output, or misaligned instructions, and Kubernetes consequences are durable. Policy-as-code in a WPC provides a machine-enforced boundary that the agent cannot “talk itself out of” during a run."
    },
    {
      "q": "Is Kubernetes support a native Claw EA connector today?",
      "a": "No. Kubernetes can be connected via official API with enterprise buildout controls, and write and admin actions should require WPC approval gates, CST, and explicit least-privilege auth scopes."
    },
    {
      "q": "What should be allowed by default for a new cluster integration?",
      "a": "Start with get/list/watch in a single namespace for non-sensitive resources, and deny Secrets and exec. Add narrowly-scoped write paths only when you have an approval workflow and a rollback plan you have tested."
    },
    {
      "q": "How do gateway receipts help if the real risk is Kubernetes API access?",
      "a": "Receipts prove the model call history that led to an action, which helps determine whether the agent was instructed, injected, or malfunctioned. Kubernetes API auditing is still required for the authoritative record of cluster actions, but receipts close the gap on “why did the agent decide this.”"
    },
    {
      "q": "Where does OpenClaw fit in this stack?",
      "a": "OpenClaw is the agent runtime that executes tools and skills and can be sandboxed to limit local blast radius. Claw EA layers permissioning and verification around that runtime using WPC, CST, gateway receipts, and proof bundles."
    }
  ],
  "sources": [
    {
      "title": "Deploy an agentic AI application on GKE with the Agent ...",
      "uri": "https://docs.cloud.google.com/kubernetes-engine/docs/tutorials/agentic-adk-vllm"
    },
    {
      "title": "Deploy an agentic AI application on GKE with the Agent Development Kit (ADK) and Vertex AI",
      "uri": "https://docs.cloud.google.com/kubernetes-engine/docs/tutorials/agentic-adk-vertex"
    },
    {
      "title": "Deploy ADK agents to Google Kubernetes Engine (GKE)  |  Google Codelabs",
      "uri": "https://codelabs.developers.google.com/codelabs/production-ready-ai-with-gc/5-deploying-agents/deploy-adk-agents-to-gke"
    },
    {
      "title": "Isolate AI code execution with Agent Sandbox",
      "uri": "https://docs.cloud.google.com/kubernetes-engine/docs/how-to/agent-sandbox"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:28:34.241Z",
  "indexable": true
}