{
  "slug": "tools/azure-devops",
  "title": "Azure DevOps for Permissioned Agents | Claw EA",
  "category": "tools",
  "html": "<p>Azure DevOps is a high-impact surface for agents because it can change code, pipelines, and release settings in ways that ship to production. If you let an agent operate on prompt-only instructions, a single prompt injection or mis-scoped token can turn “help me triage” into “change a pipeline to exfiltrate secrets.”</p>\n<p>Claw EA runs OpenClaw as the baseline agent runtime and adds a permissioned execution layer: every Azure DevOps write or admin action must be authorized by policy-as-code using a WPC, carried by a CST, and auditable with gateway receipts and a proof bundle.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Azure DevOps is connectable via official API with enterprise buildout controls. Do not treat it as a “tool the model can call freely.” Treat it as a controlled capability with explicit scopes, approvals, and a bounded blast radius.</p>\n<ol>\n  <li>\n    <p>Define the minimum Azure DevOps duties for the agent, split into read-only and write paths. Start with “read work items and pull requests” and postpone “edit pipelines” until you have approval gates.</p>\n  </li>\n  <li>\n    <p>Provision identity in Microsoft Entra ID for the integration (service principal or delegated flow), and restrict sign-in using Conditional Access where your org policy supports it. Use PIM for any role elevation that a human operator may need during setup or incident response.</p>\n  </li>\n  <li>\n    <p>Build an Azure DevOps access model using Azure DevOps security groups, permissions inheritance, and access levels. Ensure the identity can only see the specific organization and project(s) the agent is supposed to touch.</p>\n  </li>\n  <li>\n    <p>Write a WPC that enumerates allowed Azure DevOps operations, projects, and repositories, and that requires explicit approval for write and admin actions. Pin the policy hash where you need stable behavior across runs.</p>\n  </li>\n  <li>\n    <p>Issue a CST from clawscope for the job, with scope hash and optional policy hash pinning to the WPC. Bind the CST to the job to reduce replay, so a token from one run is not accepted for a different run.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw with sandboxing and tool policy enabled, and route model traffic through clawproxy. Collect gateway receipts and emit a proof bundle for the run, then store or attach it to your internal ticketing or audit workflow.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Azure DevOps failures are rarely “the agent made a bad summary.” The meaningful failures are permission mistakes, tool misuse, and changes that silently widen access or change what gets deployed.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection turns triage into a destructive change</td>\n      <td>The agent edits pipeline YAML, service connections, or branch policies after reading untrusted text from a work item, PR description, or log.</td>\n      <td>WPC denies write/admin calls by default; write paths require WPC approval gates and a separate CST scope. Keep OpenClaw tool policy tight so the agent cannot add new tools to “work around” the denial.</td>\n    </tr>\n    <tr>\n      <td>Overbroad OAuth scopes or project-wide permissions</td>\n      <td>The integration identity can read or modify unrelated projects, repos, or release pipelines, increasing blast radius for any mistake.</td>\n      <td>Least-privilege Azure DevOps permissions and access levels, combined with WPC constraints that whitelist org, project, and repo identifiers. In Claw EA, only issue CSTs whose scope hash corresponds to that WPC.</td>\n    </tr>\n    <tr>\n      <td>Malicious or misconfigured plugin/skill</td>\n      <td>A tool implementation makes extra calls not described in prompts, or a skill encourages unsafe “temporary” elevation like granting admin to unblock a job.</td>\n      <td>Permissioned execution over prompt-only: the WPC is enforced regardless of what the model requests. Use OpenClaw sandboxing and tool allow/deny so the runtime cannot execute arbitrary host actions if a plugin is compromised.</td>\n    </tr>\n    <tr>\n      <td>Token replay across runs</td>\n      <td>A captured token is reused later to perform the same Azure DevOps operation outside the intended change window.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding. Require short TTL and rotate credentials using your Entra ID and Azure DevOps practices.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable model behavior during an incident</td>\n      <td>You cannot prove which model calls and tool decisions led to a pipeline change, so you cannot scope impact quickly.</td>\n      <td>Route model calls through clawproxy to emit gateway receipts, and package them into a proof bundle. Use the bundle to reconstruct what the agent was asked and what it did, without relying on ad hoc logs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>The goal is to make “what the agent is allowed to do” machine-checkable, stable, and reviewable. A prompt can be negotiated; a WPC is an enforceable contract served by clawcontrols and referenced by hash.</p>\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"tool\": \"azure_devops\",\n  \"connection\": { \"mode\": \"official_api\", \"auth\": \"oauth\" },\n\n  \"allow\": {\n    \"orgs\": [\"contoso\"],\n    \"projects\": [\"PaymentsPlatform\"],\n    \"repos\": [\"payments-api\", \"payments-infra\"],\n    \"operations\": [\n      \"work_items.read\",\n      \"pull_requests.read\",\n      \"pipelines.read\",\n      \"repos.read\"\n    ]\n  },\n\n  \"deny\": {\n    \"operations\": [\n      \"pipelines.write\",\n      \"service_connections.write\",\n      \"permissions.admin\",\n      \"branch_policies.write\"\n    ]\n  },\n\n  \"approval_gates\": [\n    {\n      \"when_operation_in\": [\"pipelines.write\", \"permissions.admin\"],\n      \"require\": [\"human_approval\", \"change_ticket_id\"]\n    }\n  ],\n\n  \"token_requirements\": {\n    \"cst\": { \"scope_hash_required\": true, \"policy_hash_pinning\": \"optional\" }\n  },\n\n  \"logging\": { \"receipt_required\": true, \"proof_bundle_required\": true }\n}\n</pre>\n<p>This pattern keeps “read for triage” always-on while forcing “write to production path” through explicit review. In an enterprise buildout, you map the allowed operations to Azure DevOps REST API calls and the minimum OAuth permissions your security team approves.</p>\n\n<h2>What proof do you get?</h2>\n<p>For model calls routed through clawproxy, you get gateway receipts that can be checked later to confirm what was called and under which constraints. Those receipts are not a screenshot of Azure DevOps, but they are a verifiable record of the model call path used by the run.</p>\n<p>Claw EA packages receipts plus related metadata into a proof bundle. If you publish it for audit viewing, you can store it as a Trust Pulse artifact so reviewers can fetch the same run evidence without asking the operator for local files.</p>\n<p>When you combine the WPC hash, CST scope hash, and the proof bundle, you can answer operational questions quickly: which policy was in force, whether the token was job-bound, and which model calls were made during the run.</p>\n\n<h2>Rollback posture</h2>\n<p>For Azure DevOps, rollback needs to be planned before you grant write access. The safest posture is to require pull-request based changes for anything that affects builds and releases, so a revert is a normal Git operation.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Agent edited pipeline YAML in a repo</td>\n      <td>Revert the commit, then rerun the last known-good pipeline. Prefer branch protections so the agent cannot push directly to main.</td>\n      <td>Repo commit history plus the proof bundle showing the model call sequence and the WPC that allowed the edit.</td>\n    </tr>\n    <tr>\n      <td>Agent changed pipeline variables or library values</td>\n      <td>Restore from a recorded baseline or redeploy configuration from code. If values include secrets, rotate secrets immediately and invalidate the integration credentials.</td>\n      <td>Azure DevOps audit trail where available, plus CST issuance/revocation records and the run’s proof bundle.</td>\n    </tr>\n    <tr>\n      <td>Agent modified permissions or added a broad group</td>\n      <td>Remove the permission grant, review group membership, and require PIM for any future elevation. Re-run access reviews for the affected project.</td>\n      <td>WPC deny or approval records (if a gate was bypassed, that is the incident), and receipts indicating what the agent attempted.</td>\n    </tr>\n    <tr>\n      <td>Agent triggered an unintended deployment</td>\n      <td>Stop the release, roll forward with a corrective release, or roll back using your environment’s standard procedure. Treat this as a release management incident, not an “agent glitch.”</td>\n      <td>Release logs and pipeline run IDs correlated to the agent job metadata and proof bundle timestamp window.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Is Azure DevOps support a native Claw EA connector today?</h3>\n<p>No. Azure DevOps can be connected via official API with enterprise buildout controls, and you should expect a scoped, reviewed integration rather than a one-click connector.</p>\n\n<h3>Why is policy-as-code required instead of just careful prompting?</h3>\n<p>Prompts do not constrain execution; they only influence behavior. A WPC is enforced even when the model is coerced, confused, or reading untrusted content from a work item or pull request.</p>\n\n<h3>What Azure DevOps permissions should an agent start with?</h3>\n<p>Start with read-only access to a single project and a small set of repos. Add write permissions only after you have WPC approval gates and a rollback plan that your release owner accepts.</p>\n\n<h3>How do CSTs relate to Entra ID tokens?</h3>\n<p>Entra ID handles authentication to Microsoft services; a CST is used to authenticate and scope the agent job within Claw Bureau services. You use the CST scope hash and optional policy hash pinning to bind the run to the approved WPC.</p>\n\n<h3>What do gateway receipts prove in practice?</h3>\n<p>They prove which model calls were made through clawproxy and provide signed evidence for later verification. They do not replace Azure DevOps audit logs, but they close a common gap when agent behavior is otherwise only “logged” in text.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/devops/organizations/security/about-permissions?view=azure-devops\">About permissions and security groups - Azure DevOps</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/devops/organizations/security/permissions?view=azure-devops\">Security groups, service accounts, and permissions reference</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/considerations/security-considerations-tools\">Role-based access control for DevOps tools - Cloud Adoption Framework</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Azure DevOps is a high-impact surface for agents because it can change code, pipelines, and release settings in ways that ship to production. If you let an agent operate on prompt-only instructions, a single prompt injec",
  "faqs": [
    {
      "q": "Is Azure DevOps support a native Claw EA connector today?",
      "a": "No. Azure DevOps can be connected via official API with enterprise buildout controls, and you should expect a scoped, reviewed integration rather than a one-click connector."
    },
    {
      "q": "Why is policy-as-code required instead of just careful prompting?",
      "a": "Prompts do not constrain execution; they only influence behavior. A WPC is enforced even when the model is coerced, confused, or reading untrusted content from a work item or pull request."
    },
    {
      "q": "What Azure DevOps permissions should an agent start with?",
      "a": "Start with read-only access to a single project and a small set of repos. Add write permissions only after you have WPC approval gates and a rollback plan that your release owner accepts."
    },
    {
      "q": "How do CSTs relate to Entra ID tokens?",
      "a": "Entra ID handles authentication to Microsoft services; a CST is used to authenticate and scope the agent job within Claw Bureau services. You use the CST scope hash and optional policy hash pinning to bind the run to the approved WPC."
    },
    {
      "q": "What do gateway receipts prove in practice?",
      "a": "They prove which model calls were made through clawproxy and provide signed evidence for later verification. They do not replace Azure DevOps audit logs, but they close a common gap when agent behavior is otherwise only “logged” in text."
    }
  ],
  "sources": [
    {
      "title": "About permissions and security groups - Azure DevOps",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/organizations/security/about-permissions?view=azure-devops"
    },
    {
      "title": "Security groups, service accounts, and permissions reference",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/organizations/security/permissions?view=azure-devops"
    },
    {
      "title": "Permissions and role lookup guide - Azure DevOps | Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/organizations/security/permissions-lookup-guide?view=azure-devops"
    },
    {
      "title": "About access levels - Azure DevOps | Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/organizations/security/access-levels?view=azure-devops"
    },
    {
      "title": "DevOps security considerations overview - Cloud Adoption Framework",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/considerations/security-considerations-overview"
    },
    {
      "title": "Role-based access control for DevOps tools - Cloud Adoption Framework",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/considerations/security-considerations-tools"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:08:20.129Z",
  "indexable": true
}