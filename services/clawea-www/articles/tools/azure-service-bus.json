{
  "slug": "tools/azure-service-bus",
  "title": "Azure Service Bus for Permissioned Agents | Claw EA",
  "category": "tools",
  "html": "<h2>Direct Answer</h2>\n<p>Azure Service Bus is a durable queue and pub/sub backbone, so it is a natural place to connect enterprise agents to real workflows. It is also a high impact surface: a single mis-scoped sender or receiver can leak data, trigger downstream execution, or wedge production consumers.</p>\n<p>Claw EA runs OpenClaw as the baseline agent runtime and treats Service Bus access as permissioned execution. Instead of relying on prompt instructions, you put a Work Policy Contract (WPC) in front of “send”, “receive”, and “admin” actions, issue a CST = scoped token (issued by clawscope) bound to that policy, and capture proof artifacts (gateway receipts and proof bundles) for audit.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>These steps assume an enterprise buildout that connects to Azure Service Bus via official API. This is not a native connector, so treat the “tool” as a controlled wrapper around the SDK operations you approve.</p>\n<ol>\n  <li>\n    <p><strong>Decide the minimum Service Bus actions the agent needs.</strong> Split “send”, “receive”, and “manage” into separate roles, and separate namespaces and entities (queue/topic/subscription) by environment. Prefer Microsoft Entra ID with Azure RBAC over broad Shared Access Signatures (SAS) when feasible.</p>\n  </li>\n  <li>\n    <p><strong>Define the WPC for the Service Bus tool.</strong> The WPC should name exact entities, allowed operations, message size limits, and whether dead-letter operations are permitted. Keep “admin” actions as a separate WPC that requires explicit approval gates.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for a single job and pin it to the WPC.</strong> The CST should be short lived and job scoped, and should carry a scope hash with optional policy hash pinning so the execution layer can fail closed if the policy changes mid-run. Use marketplace anti-replay binding (job-scoped CST binding) to reduce token replay risk across jobs.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent under OpenClaw tool policy and sandboxing.</strong> Use OpenClaw tool allowlists so only the Service Bus tool (and required utilities) are callable, and prefer Docker sandboxing for tool execution. Avoid elevated host execution except for tightly reviewed break-glass tasks.</p>\n  </li>\n  <li>\n    <p><strong>Route model traffic through clawproxy to get Gateway receipts.</strong> The goal is verifiable evidence of what the model was asked and what it returned when it decided to send or consume messages. This does not prove Azure accepted a message, but it does prove the model side of the decision and tool call plan under the pinned WPC.</p>\n  </li>\n  <li>\n    <p><strong>Emit a proof bundle per run and store it.</strong> Bundle the Gateway receipts, the CST scope hash, the WPC hash, and run metadata (job id, agent id, tool version hash) into a proof bundle. Store the bundle and optionally publish a Trust Pulse for audit viewing.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Service Bus is a control plane for downstream work. When an agent can send or receive messages, it can indirectly create side effects in other services, even if the agent never gets direct credentials for those services.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Over-broad sender permissions</td>\n      <td>Agent can send to any queue or topic in a namespace, including production entities, triggering unexpected consumers.</td>\n      <td>WPC restricts entity paths and operations; CST pinned to the WPC; Azure RBAC role assignments scoped to the minimum set of entities.</td>\n    </tr>\n    <tr>\n      <td>Receiver drains or poisons the queue</td>\n      <td>Agent receives and completes messages it should not touch, or repeatedly abandons to force retries and load.</td>\n      <td>Separate WPC for receive; require explicit “peek-lock vs receive-and-delete” choice; rate limits and message count caps in policy; isolate subscriptions for agent consumption.</td>\n    </tr>\n    <tr>\n      <td>Dead-letter abuse</td>\n      <td>Agent moves messages to dead-letter to hide work, or drains dead-letter and leaks sensitive payloads.</td>\n      <td>Default deny dead-letter operations in WPC; only allow with an approved WPC for incident workflows; short lived CST per incident job.</td>\n    </tr>\n    <tr>\n      <td>SAS key exfiltration</td>\n      <td>If SAS is used, a leaked key grants broad access until rotated, and can be used outside Claw EA.</td>\n      <td>Prefer Microsoft Entra ID with Azure RBAC; if SAS is unavoidable, treat it as a high risk secret and scope it to an entity, not the namespace, and keep rotation tight.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection causes covert messaging</td>\n      <td>Agent is convinced to encode sensitive data into messages, turning Service Bus into an exfil channel.</td>\n      <td>WPC constrains destinations and message schema; OpenClaw tool policy limits what tools can read sensitive sources; separate “read secrets” tools from “send message” tools.</td>\n    </tr>\n    <tr>\n      <td>Misconfiguration of the agent execution boundary</td>\n      <td>Tool runs on host with broad filesystem and network access, so a malicious plugin can harvest credentials and then use Service Bus.</td>\n      <td>OpenClaw sandboxing on by default for non-main or all sessions; deny elevated tools except reviewed break-glass; run OpenClaw security audit regularly.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a simplified, JSON-like sketch of a WPC that gates an “azure_service_bus” tool. In practice the WPC is a signed, hash-addressed policy artifact served by clawcontrols and fetched and verified by the proxy.</p>\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"asb-send-orders-staging\",\n  \"tools\": {\n    \"azure_service_bus\": {\n      \"allow\": [\n        { \"op\": \"send\", \"entity\": \"sb://&lt;namespace&gt;.servicebus.windows.net/orders-staging\" }\n      ],\n      \"deny\": [\n        { \"op\": \"manage\", \"entity\": \"*\" },\n        { \"op\": \"send\", \"entity\": \"sb://&lt;namespace&gt;.servicebus.windows.net/orders-prod\" }\n      ],\n      \"constraints\": {\n        \"max_message_bytes\": 131072,\n        \"max_messages_per_job\": 200,\n        \"require_application_properties\": [\"schema_version\", \"correlation_id\"],\n        \"forbid_properties\": [\"authorization\", \"cookie\", \"set-cookie\"]\n      }\n    }\n  },\n  \"auth\": {\n    \"token\": \"CST\",\n    \"pin_policy_hash\": true,\n    \"job_scoped_binding\": true\n  },\n  \"approvals\": {\n    \"required_for_ops\": [\"manage\", \"deadletter_read\", \"deadletter_purge\"]\n  }\n}\n</pre>\n<p>The key difference from “prompt-only safety” is enforcement. A prompt can be ignored; a WPC gate denies the tool call even when the model insists, because execution is permissioned by policy.</p>\n\n<h2>What proof do you get?</h2>\n<p>For model calls, clawproxy emits Gateway receipts that record the request/response envelope for the routed model traffic. This gives you a verifiable trail for what the model was asked, what it returned, and when it decided to attempt a Service Bus action under a specific WPC and CST.</p>\n<p>For each job, Claw EA packages receipts and run metadata into a proof bundle. The proof bundle can include the WPC hash reference, the CST scope hash (and optional policy hash pinning), job identifiers, and tool invocation summaries suitable for audit and replay checks.</p>\n<p>If you publish externally for auditors or internal review, you can store and view the run’s artifact as a Trust Pulse. Treat this as an audit viewer and storage surface, not as a replacement for your SIEM or Azure-native logs.</p>\n\n<h2>Rollback posture</h2>\n<p>A safe rollback plan assumes the agent or the tool wrapper can be wrong. You want fast ways to stop sends, stop receives, and invalidate credentials without needing to redeploy every agent.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop all agent messaging</td>\n      <td>Revoke or expire the CST for the job; deny the Service Bus tool in OpenClaw tool policy for affected agents.</td>\n      <td>Token revocation events and the last proof bundle showing when the agent attempted the blocked action.</td>\n    </tr>\n    <tr>\n      <td>Block a single queue or topic</td>\n      <td>Update the WPC to remove the entity allowance and require policy hash pinning so old policies fail closed on the next tool call.</td>\n      <td>WPC hash change record plus proof bundles showing which jobs ran under which WPC hash.</td>\n    </tr>\n    <tr>\n      <td>Reduce blast radius after a near miss</td>\n      <td>Split “send” and “receive” into different principals and policies; move the agent to a dedicated subscription or queue.</td>\n      <td>New WPC and CST scope hash, plus receipts demonstrating the changed tool availability and model routing.</td>\n    </tr>\n    <tr>\n      <td>Credential containment</td>\n      <td>Prefer Entra ID and rotate or disable the service principal or managed identity; if SAS is used, rotate keys and reduce scope.</td>\n      <td>Azure audit logs on identity changes, plus internal proof bundles correlating job ids to the window of exposure.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Is Azure Service Bus integration available as a native Claw EA connector?</h3>\n<p>No. Azure Service Bus can be connected via official API with enterprise buildout controls, and the tool wrapper must be gated by WPC approval and CST issuance.</p>\n\n<h3>Why is prompt-only control not sufficient for Service Bus access?</h3>\n<p>Prompts do not enforce anything at execution time, and a model can be manipulated or can drift. With permissioned execution, the WPC defines what the tool can do, and the runtime denies calls that are out of policy even if the agent requests them.</p>\n\n<h3>Should we use Microsoft Entra ID or SAS for agents?</h3>\n<p>Microsoft documentation describes both, but Entra ID with Azure RBAC is usually easier to scope and rotate safely for applications and managed identities. If you must use SAS, keep it narrowly scoped and treat it as a high risk secret.</p>\n\n<h3>What do gateway receipts prove in a Service Bus workflow?</h3>\n<p>Gateway receipts prove the model-call side: the exact model request and response that led to a tool action, routed through clawproxy. They do not replace Azure-side delivery confirmation; pair them with Azure logs if you need end-to-end delivery evidence.</p>\n\n<h3>How do we prevent an agent from sending to production queues?</h3>\n<p>Use separate namespaces or entity naming per environment, enforce WPC entity allowlists, and keep distinct Entra ID principals for staging vs production. If a job does not have the WPC allowance and CST pinned to it, the send should be denied by policy.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-authentication-and-authorization\">Azure Service Bus authentication and authorization (Microsoft Learn)</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/service-bus-messaging/authenticate-application\">Authenticate and authorize an application with Microsoft Entra ID to access Azure Service Bus entities (Microsoft Learn)</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/security/benchmark/azure/baselines/service-bus-security-baseline\">Azure security baseline for Service Bus (Microsoft Learn)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security audit guidance (OpenClaw)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated (OpenClaw)</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Azure Service Bus is a durable queue and pub/sub backbone, so it is a natural place to connect enterprise agents to real workflows. It is also a high impact surface: a single mis-scoped sender or receiver can leak data, ",
  "faqs": [
    {
      "q": "Is Azure Service Bus integration available as a native Claw EA connector?",
      "a": "No. Azure Service Bus can be connected via official API with enterprise buildout controls, and the tool wrapper must be gated by WPC approval and CST issuance."
    },
    {
      "q": "Why is prompt-only control not sufficient for Service Bus access?",
      "a": "Prompts do not enforce anything at execution time, and a model can be manipulated or can drift. With permissioned execution, the WPC defines what the tool can do, and the runtime denies calls that are out of policy even if the agent requests them."
    },
    {
      "q": "Should we use Microsoft Entra ID or SAS for agents?",
      "a": "Microsoft documentation describes both, but Entra ID with Azure RBAC is usually easier to scope and rotate safely for applications and managed identities. If you must use SAS, keep it narrowly scoped and treat it as a high risk secret."
    },
    {
      "q": "What do gateway receipts prove in a Service Bus workflow?",
      "a": "Gateway receipts prove the model-call side: the exact model request and response that led to a tool action, routed through clawproxy. They do not replace Azure-side delivery confirmation; pair them with Azure logs if you need end-to-end delivery evidence."
    },
    {
      "q": "How do we prevent an agent from sending to production queues?",
      "a": "Use separate namespaces or entity naming per environment, enforce WPC entity allowlists, and keep distinct Entra ID principals for staging vs production. If a job does not have the WPC allowance and CST pinned to it, the send should be denied by policy."
    }
  ],
  "sources": [
    {
      "title": "Building your Agent on Azure | Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/microsoft-for-startups/build/build-agent"
    },
    {
      "title": "Authenticate an application to access Azure Service Bus entities - Azure Service Bus",
      "uri": "https://learn.microsoft.com/en-us/azure/service-bus-messaging/authenticate-application"
    },
    {
      "title": "Service Bus authentication and authorization",
      "uri": "https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-authentication-and-authorization"
    },
    {
      "title": "How to Send Messages to Azure Service Bus",
      "uri": "https://learn.microsoft.com/en-us/azure/api-management/api-management-howto-send-service-bus"
    },
    {
      "title": "Governance and security for AI agents across the organization",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization"
    },
    {
      "title": "Azure security baseline for Service Bus",
      "uri": "https://learn.microsoft.com/en-us/security/benchmark/azure/baselines/service-bus-security-baseline"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:12:17.857Z",
  "indexable": true
}