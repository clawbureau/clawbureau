{
  "slug": "event-native-agents",
  "title": "Event-native Agents (Webhooks, Changefeeds, Queues) | Claw EA",
  "category": "pillars",
  "html": "<p>Event-native agents replace cron jobs with webhooks, changefeeds, and queue consumers, but they only stay safe at scale if execution is permissioned and repeatable. In Claw EA, OpenClaw is the baseline agent runtime, and each event-triggered run is bound to a WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols) plus a CST = scoped token (issued by clawscope) so the agent cannot “decide” its own permissions.</p>\n<p>For verification, model traffic can be routed through clawproxy to generate gateway receipts, and each run can emit a proof bundle that you can retain internally or publish to Trust Pulse for audit/viewing. This is how you keep idempotency, authorization, and incident response concrete when events arrive out of order, duplicate, or maliciously crafted.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the event contract per source: required headers, signature scheme, idempotency key, and maximum payload size. Decide whether the agent consumes webhooks directly, or via a queue that provides retries and dead-letter handling.</p>\n    <p>For changefeeds, decide the cursor semantics (time-based, token-based, or per-partition) and how you will re-seed after a deployment.</p>\n  </li>\n  <li>\n    <p>Write a WPC that encodes what the agent is allowed to do in response to each event type, including tool allow/deny boundaries and which data domains it can touch. Treat prompts and skills as documentation and guidance, not as authorization.</p>\n    <p>This matters because prompt-only controls fail open under injection, and event payloads are attacker-controlled inputs.</p>\n  </li>\n  <li>\n    <p>Issue a CST for the specific job context and bind it to the event source and run identity. Use CST scope hash and, when you need strict change control, enable optional policy hash pinning so the CST only works with the intended WPC.</p>\n    <p>If you run jobs through a marketplace workflow, use marketplace anti-replay binding (job-scoped CST binding) so a token captured from one run cannot be replayed for another.</p>\n  </li>\n  <li>\n    <p>Implement idempotency at the execution layer, not in the prompt. Store a dedupe record keyed by (event_source, idempotency_key) with a status machine (received, running, committed, failed) and an immutable pointer to the run’s proof bundle.</p>\n    <p>For webhooks, return success only after you have safely enqueued or persisted the dedupe record. For queues, ack only after the “committed” transition.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw with sandboxing and tool policy configured to match the WPC. Keep “elevated” tool execution off unless you have a narrowly scoped operational need and a rollback plan.</p>\n    <p>OpenClaw includes a security audit flow to flag common footguns like overly open inbound policies and unsafe filesystem permissions.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy when you need verification artifacts, and prefer stable provider routing. If you use OpenRouter via fal, run it through clawproxy so you get gateway receipts for each model call.</p>\n    <p>At the end of each run, emit a proof bundle that references the WPC hash, CST scope hash, gateway receipts, and the run metadata used for dedupe.</p>\n  </li>\n  <li>\n    <p>Operationalize failure handling: per-source rate limits, retry caps, and dead-letter queues or quarantine tables. Reprocessing should always be “replay with the same WPC hash” unless you explicitly approve a new policy.</p>\n    <p>For audit, store proof bundles and optionally publish a Trust Pulse artifact so reviewers can inspect what happened without re-running the job.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Event-native agents fail differently than chat-triggered agents. The attack surface is dominated by replay, payload manipulation, and permission creep across retries and backfills.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Webhook replay and duplicate deliveries</td>\n      <td>An attacker or misconfigured sender replays the same event, causing repeated side effects (double refunds, duplicate tickets, repeated emails).</td>\n      <td>Execution-layer idempotency keyed by a required idempotency_key, plus marketplace anti-replay binding (job-scoped CST binding) when runs are brokered through the marketplace.</td>\n    </tr>\n    <tr>\n      <td>Changefeed cursor confusion</td>\n      <td>A deployment resets the cursor and the agent reprocesses old changes, or skips forward and misses required actions.</td>\n      <td>Persist cursor state separately from prompts, and require a WPC-approved backfill mode that limits tools and side effects while rehydrating state.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection via event payload</td>\n      <td>Event data contains instructions that push the agent to call tools outside your intended workflow.</td>\n      <td>Permissioned execution using WPC-enforced tool policy and sandboxing. Skills can explain how to interpret payloads, but they do not grant permissions.</td>\n    </tr>\n    <tr>\n      <td>Over-broad tokens across many consumers</td>\n      <td>A single leaked credential can be reused by multiple workers or environments to perform high-impact actions.</td>\n      <td>Issue a CST per job or per worker identity with narrow scope hash, short TTL, and optional policy hash pinning to the WPC.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable model-dependent decisions</td>\n      <td>You cannot prove what the model saw and produced when investigating an incident or dispute.</td>\n      <td>Route model calls through clawproxy to obtain gateway receipts, and include them in a proof bundle attached to the idempotency record.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a JSON-like sketch of a WPC that constrains an event-native agent. It encodes what inputs are accepted, which tools can run, and how runs bind to tokens and receipts.</p>\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"event-native-agent:payments-webhooks\",\n  \"policy_hash\": \"b64u:... (hash-addressed WPC)\",\n  \"inputs\": {\n    \"sources\": [\n      {\n        \"type\": \"webhook\",\n        \"name\": \"payments_provider\",\n        \"require_signature\": true,\n        \"require_idempotency_key\": true,\n        \"max_payload_bytes\": 131072\n      },\n      {\n        \"type\": \"queue\",\n        \"name\": \"payments_events\",\n        \"require_idempotency_key\": true\n      }\n    ]\n  },\n  \"auth\": {\n    \"cst\": {\n      \"require_scope_hash\": true,\n      \"policy_hash_pinning\": \"optional\"\n    }\n  },\n  \"execution\": {\n    \"runtime\": \"OpenClaw\",\n    \"sandbox\": {\n      \"mode\": \"all\",\n      \"workspace_access\": \"ro\"\n    },\n    \"tools\": {\n      \"allow\": [\n        \"http.request (via official API)\",\n        \"db.read\",\n        \"db.write\"\n      ],\n      \"deny\": [\n        \"shell.exec\",\n        \"filesystem.write خارج workspace\"\n      ]\n    }\n  },\n  \"model_calls\": {\n    \"route_via\": \"clawproxy\",\n    \"receipts\": \"required\",\n    \"provider\": \"OpenRouter via fal (optional)\"\n  },\n  \"idempotency\": {\n    \"dedupe_key\": \"event_source + idempotency_key\",\n    \"commit_rule\": \"only-once side effects after committed\"\n  },\n  \"outputs\": {\n    \"proof_bundle\": \"required\",\n    \"trust_pulse\": \"optional publish\"\n  }\n}</pre>\n<p>The point is not the exact schema. The point is that the execution layer enforces the contract, and the agent cannot talk itself into broader access during a retry storm or a backfill.</p>\n\n<h2>What proof do you get?</h2>\n<p>For each event-triggered run, Claw EA can produce artifacts that make incident response practical. You can answer: which policy was in force, which token scope was used, what model calls occurred, and whether a run is a replay.</p>\n<p>When model traffic is routed through clawproxy, you receive gateway receipts for model calls. These receipts can be bundled with run metadata, WPC hash references, CST scope hash references, and job identifiers into a proof bundle for later verification.</p>\n<p>For teams that need shared review, a proof bundle can be stored and viewed as a Trust Pulse artifact. Retention is your choice, but the operational pattern is to link your idempotency record to the proof bundle so you can prove that “duplicate event X” was deduped or replayed under a specific WPC.</p>\n\n<h2>Rollback posture</h2>\n<p>Event systems require rollback plans that assume duplicates and late arrivals. Your rollback should be a sequence of reversible controls that stop new side effects first, then allow safe replay under a pinned WPC.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop the consumer (webhook handler or queue worker)</td>\n      <td>Disable ingress or pause the worker pool so no new runs start. Keep the dedupe store and cursor store intact.</td>\n      <td>Queue offsets, webhook ingress logs, and the last successful run’s proof bundle pointer in your dedupe table.</td>\n    </tr>\n    <tr>\n      <td>Revoke or rotate CST</td>\n      <td>Invalidate the CST so in-flight retries cannot continue making calls. Re-issue a new CST only after the WPC is reviewed.</td>\n      <td>CST issuance and revocation records from clawscope, plus proof bundles showing which runs used which scope hash.</td>\n    </tr>\n    <tr>\n      <td>Pin to a known-good WPC hash</td>\n      <td>Roll back to a previously approved WPC hash and re-run only the quarantined events. Do not widen tools during remediation.</td>\n      <td>WPC hash references in proof bundles, and verification that the WPC was fetched and verified before execution.</td>\n    </tr>\n    <tr>\n      <td>Replay events safely</td>\n      <td>Replay from the queue or changefeed using the same idempotency keys and a “backfill mode” WPC that limits side effects.</td>\n      <td>Idempotency records that show received vs committed transitions, and proof bundles for the replay runs.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Optional controls like egress allowlists enforced outside clawproxy can be implemented if you need network-level containment. Automatic cost budget enforcement and transparency log inclusion proofs are planned, so treat them as future hardening rather than current rollback dependencies.</p>\n\n<h2>FAQ</h2>\n<h3>Why not just put idempotency instructions in the prompt?</h3>\n<p>Because prompts are not enforcement, and event payloads are adversarial inputs. Idempotency must live in the execution layer where retries, timeouts, and concurrency are handled deterministically.</p>\n\n<h3>How do WPC and OpenClaw tool policy work together?</h3>\n<p>OpenClaw enforces local tool policy and sandboxing as the immediate boundary. A WPC gives you a signed, hash-addressed policy artifact you can fetch and verify consistently across workers, then map into those local controls.</p>\n\n<h3>What stops a replayed token from re-running an old event?</h3>\n<p>Use CSTs with narrow scope and, when appropriate, marketplace anti-replay binding (job-scoped CST binding). Separately, keep a dedupe store keyed by (event_source, idempotency_key) so a replay cannot re-commit side effects.</p>\n\n<h3>Can I use Microsoft event notifications with this?</h3>\n<p>Yes, via official API patterns for Microsoft 365 notifications where applicable, but treat preview features as unstable. Keep the same structure: validate signatures, require an idempotency key, and run the agent under a WPC with a CST that is scoped to the job.</p>\n\n<h3>What do gateway receipts actually cover?</h3>\n<p>Gateway receipts are signed receipts emitted by clawproxy for model calls. They help you prove which model calls were made during a run and tie those calls into a proof bundle for audit and verification.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-agent-365/developer/notification?tabs=python\">Notify agents (Microsoft Learn)</a></li>\n  <li><a href=\"https://developer.salesforce.com/blogs/2022/10/design-considerations-for-change-data-capture-and-platform-events\">Design Considerations for Change Data Capture and Platform Events (Salesforce)</a></li>\n</ul>",
  "description": "Event-native agents replace cron jobs with webhooks, changefeeds, and queue consumers, but they only stay safe at scale if execution is permissioned and repeatable. In Claw EA, OpenClaw is the baseline agent runtime, and",
  "faqs": [
    {
      "q": "Why not just put idempotency instructions in the prompt?",
      "a": "Because prompts are not enforcement, and event payloads are adversarial inputs. Idempotency must live in the execution layer where retries, timeouts, and concurrency are handled deterministically."
    },
    {
      "q": "How do WPC and OpenClaw tool policy work together?",
      "a": "OpenClaw enforces local tool policy and sandboxing as the immediate boundary. A WPC gives you a signed, hash-addressed policy artifact you can fetch and verify consistently across workers, then map into those local controls."
    },
    {
      "q": "What stops a replayed token from re-running an old event?",
      "a": "Use CSTs with narrow scope and, when appropriate, marketplace anti-replay binding (job-scoped CST binding). Separately, keep a dedupe store keyed by (event_source, idempotency_key) so a replay cannot re-commit side effects."
    },
    {
      "q": "Can I use Microsoft event notifications with this?",
      "a": "Yes, via official API patterns for Microsoft 365 notifications where applicable, but treat preview features as unstable. Keep the same structure: validate signatures, require an idempotency key, and run the agent under a WPC with a CST that is scoped to the job."
    },
    {
      "q": "What do gateway receipts actually cover?",
      "a": "Gateway receipts are signed receipts emitted by clawproxy for model calls. They help you prove which model calls were made during a run and tie those calls into a proof bundle for audit and verification."
    }
  ],
  "sources": [
    {
      "title": "Agents API · Cloudflare Agents docs",
      "uri": "https://developers.cloudflare.com/agents/api-reference/agents-api"
    },
    {
      "title": "Notify agents",
      "uri": "https://learn.microsoft.com/en-us/microsoft-agent-365/developer/notification?tabs=python"
    },
    {
      "title": "Design Considerations for Change Data Capture and Platform Events",
      "uri": "https://developer.salesforce.com/blogs/2022/10/design-considerations-for-change-data-capture-and-platform-events"
    },
    {
      "title": "Integrate Agents with Platform Events",
      "uri": "https://developer.salesforce.com/blogs/2025/07/integrate-agents-with-platform-events"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:45:18.695Z",
  "indexable": true
}