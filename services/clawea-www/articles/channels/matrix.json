{
  "slug": "channels/matrix",
  "title": "Matrix AI Agent Control Plane | Claw EA",
  "category": "channels",
  "html": "<p>Matrix can be a solid control plane for enterprise AI agents when you treat chat messages as a request queue, not as authorization. With Claw EA running OpenClaw as the baseline agent runtime, you enforce permissioned execution using policy-as-code and verifiable proof artifacts, rather than trusting prompt text.</p>\n<p>The practical pattern is: Matrix room messages create jobs, a WPC defines what the agent may do, and a CST is issued per job with optional policy hash pinning. Model calls route through clawproxy to produce gateway receipts, then Claw EA packages them into a proof bundle you can file or review later.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Define your Matrix operating boundary.</strong> Pick a small set of rooms for agent work, and decide who can request work versus who can approve execution. Keep “request” and “approval” separate to avoid accidental authorization in busy rooms.</p>\n  </li>\n  <li>\n    <p><strong>Deploy the Matrix channel via official API.</strong> Integrate Matrix using the official Matrix Client-Server API (or via MCP server if your environment standardizes on MCP). Treat the Matrix bot as an inbound channel only, not a place where secrets or long-lived credentials live.</p>\n  </li>\n  <li>\n    <p><strong>Write and register a WPC.</strong> Encode tool access, sandbox expectations, and approval gates as a Work Policy Contract (WPC) and store it in the WPC registry served by clawcontrols. Reference the WPC by its hash in your job configuration so enforcement stays deterministic.</p>\n  </li>\n  <li>\n    <p><strong>Configure OpenClaw tool policy and sandbox defaults.</strong> Keep the tool allowlist tight, prefer Docker sandboxing for tool execution, and avoid elevated host execution unless explicitly required. Run <code>openclaw security audit</code> as part of every config change and before exposing any network surfaces.</p>\n  </li>\n  <li>\n    <p><strong>Implement a two-step approval in the room.</strong> The agent posts a proposed plan and a “pending approval” marker (for example, a job id). An approver replies with an explicit approval command that your control layer recognizes, and only then do you mint a CST scoped to that job.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST with job binding and optional policy hash pinning.</strong> Use clawscope to issue the CST and bind it to the specific job (anti-replay). If you want strict change control, pin the CST to the WPC policy hash so execution fails closed if the policy changes.</p>\n  </li>\n  <li>\n    <p><strong>Route model traffic through clawproxy and archive proof.</strong> Send all model calls through clawproxy, including OpenRouter via fal, so you receive gateway receipts for each model call. At job end, collect receipts and metadata into a proof bundle, then store or share it via Trust Pulse for review.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens in Matrix</th>\n      <th>Control in Claw EA</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection via room content</td>\n      <td>An attacker posts a message that tries to coerce the agent into running tools or exfiltrating data.</td>\n      <td>Execution is permissioned by WPC tool policy, not by prompt text. Even if the model “wants” to act, the tool layer is denied unless the policy allows it and a CST is present.</td>\n    </tr>\n    <tr>\n      <td>Approval spoofing</td>\n      <td>A user mimics an approver (“approved”) or forwards an old approval message.</td>\n      <td>CSTs are issued only after verifying the approver identity and room context, and are job-scoped with marketplace anti-replay binding. Reused approvals do not mint valid job-bound CSTs for new work.</td>\n    </tr>\n    <tr>\n      <td>Model call repudiation</td>\n      <td>After an incident, nobody can prove what the model was asked, what it returned, or which model endpoint was used.</td>\n      <td>clawproxy emits gateway receipts for model calls. The proof bundle ties those receipts to the job metadata so audit and verification are based on artifacts, not screenshots.</td>\n    </tr>\n    <tr>\n      <td>Overbroad tool access</td>\n      <td>A helpful agent in a chat room ends up with shell, file, or network capabilities it does not need.</td>\n      <td>OpenClaw tool policy and sandboxing restrict what can run and where it runs. The WPC gives an additional machine-enforced contract so “just this once” exceptions are explicit and reviewable.</td>\n    </tr>\n    <tr>\n      <td>Long-lived credentials in chat automation</td>\n      <td>A Matrix bot ends up holding durable tokens or secrets and becomes a high-value target.</td>\n      <td>Prefer short-lived CSTs minted per job. Keep Matrix as the control surface and put execution credentials behind scoped issuance and verification.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Matrix is a good fit when you already run Matrix for internal comms and you want an auditable human-in-the-loop workflow. It is not a magic boundary, so you still need allowlists, sandboxing, and token scoping to keep the blast radius predictable.</p>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact, JSON-like sketch of a Matrix job policy encoded as a WPC. The point is that the agent cannot “talk its way” into more permissions; the execution layer checks the WPC and the CST before any sensitive action.</p>\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"channel\": \"matrix\",\n  \"matrix\": {\n    \"rooms_allowlist\": [\n      \"!finance-ops:example.com\",\n      \"!sec-review:example.com\"\n    ],\n    \"approval\": {\n      \"required\": true,\n      \"approver_user_ids_allowlist\": [\n        \"@alice:example.com\",\n        \"@oncall-security:example.com\"\n      ],\n      \"approval_command\": \"!approve\"\n    }\n  },\n  \"execution\": {\n    \"sandbox\": {\n      \"mode\": \"all\",\n      \"workspace_access\": \"ro\"\n    },\n    \"tools\": {\n      \"allow\": [\"read\", \"search\", \"http\", \"write_pr\"],\n      \"deny\": [\"exec\", \"browser_control\", \"secrets_export\"]\n    }\n  },\n  \"tokens\": {\n    \"cst\": {\n      \"job_scoped\": true,\n      \"pin_policy_hash\": true\n    }\n  },\n  \"model_access\": {\n    \"route_via\": \"clawproxy\",\n    \"receipts\": \"required\"\n  }\n}\n</pre>\n<p>In practice you store the signed WPC in the clawcontrols registry and refer to it by hash. The CST minted by clawscope can include the scope hash and optional policy hash pinning so policy drift becomes a hard failure, not a soft expectation.</p>\n\n<h2>What proof do you get?</h2>\n<p>For every model call routed through clawproxy, you get gateway receipts that can be verified later. These receipts are not “logs you hope are accurate”; they are signed artifacts emitted at the gateway where model traffic passes.</p>\n<p>At the end of a Matrix-triggered job, Claw EA produces a proof bundle that packages the receipts plus job metadata such as the WPC hash and the job-scoped CST context. If you want a shareable review artifact, you can store the result as a Trust Pulse so auditors and reviewers can view the same bundle without reconstructing it from scattered systems.</p>\n<p>Operationally, you can have the agent post a final message back into the Matrix room containing: job id, WPC hash, and a Trust Pulse reference. That makes the chat transcript a pointer to evidence, while the evidence itself stays in a verification-friendly format.</p>\n\n<h2>Rollback posture</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence you should retain</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Disable agent execution in Matrix rooms</td>\n      <td>Stop minting CSTs for approvals and keep the bot in “read-only triage” mode.</td>\n      <td>Room event ids for approvals attempted, plus the last known WPC hash used for that channel.</td>\n    </tr>\n    <tr>\n      <td>Revoke access after suspected token misuse</td>\n      <td>Revoke or expire CSTs via clawscope and rotate any downstream credentials used by tools.</td>\n      <td>List of affected job ids, CST identifiers (if tracked internally), and related proof bundles.</td>\n    </tr>\n    <tr>\n      <td>Policy regression or overly permissive tool change</td>\n      <td>Roll back to a prior WPC hash and require policy hash pinning for all new CSTs.</td>\n      <td>Before and after WPC hashes, and proof bundles for jobs executed under the permissive policy.</td>\n    </tr>\n    <tr>\n      <td>Disputed model output or “who authorized this?” incident</td>\n      <td>Freeze further approvals until the proof bundle is verified and reviewed.</td>\n      <td>Gateway receipts for the disputed calls, the job’s proof bundle, and the Matrix message ids that initiated and approved the job.</td>\n    </tr>\n  </tbody>\n</table>\n<p>This rollback posture is designed to fail closed. When approvals stop or tokens are revoked, the agent can still chat, but it cannot execute tools that change state.</p>\n\n<h2>FAQ</h2>\n<h3>Why is policy-as-code required instead of prompt-only controls?</h3>\n<p>Prompt-only controls rely on the model complying, and they fail in exactly the situations you care about: prompt injection, ambiguity, and adversarial content. Policy-as-code moves the decision to the execution layer, where tool calls are allowed or denied based on the WPC and the CST, not on model intent.</p>\n\n<h3>How do approvals show up in the Matrix UI?</h3>\n<p>Keep it explicit: the agent posts a plan and a job id, then an approver replies with a specific approval command you standardize on. The control layer uses that to mint a job-scoped CST, and the agent posts the completion message with a proof bundle reference (optionally via Trust Pulse) back into the room.</p>\n\n<h3>Can Matrix be used for fully autonomous agents?</h3>\n<p>It can, but it is usually a poor default for autonomous execution because chat rooms are noisy and easy to socially engineer. A more reliable approach is to keep Matrix for requests and approvals, and run autonomous schedules in a separate job system with the same WPC and CST mechanics.</p>\n\n<h3>What models can I use with this setup?</h3>\n<p>Any model reachable through your configured providers, with the strongest audit properties when traffic is routed through clawproxy. OpenRouter via fal routed through clawproxy is available when you want provider flexibility while still getting gateway receipts.</p>\n\n<h3>What is the minimum set of artifacts I should retain for audit?</h3>\n<p>Keep the WPC hash used for each job, the job-scoped CST context, and the proof bundle containing gateway receipts. If you need a review surface for non-technical stakeholders, store the bundle as a Trust Pulse and link it from the Matrix transcript.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://aws.amazon.com/ai/security/agentic-ai-scoping-matrix/\">AWS Agentic AI Security Scoping Matrix</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Matrix can be a solid control plane for enterprise AI agents when you treat chat messages as a request queue, not as authorization. With Claw EA running OpenClaw as the baseline agent runtime, you enforce permissioned ex",
  "faqs": [
    {
      "q": "Why is policy-as-code required instead of prompt-only controls?",
      "a": "Prompt-only controls rely on the model complying, and they fail in exactly the situations you care about: prompt injection, ambiguity, and adversarial content. Policy-as-code moves the decision to the execution layer, where tool calls are allowed or denied based on the WPC and the CST, not on model intent."
    },
    {
      "q": "How do approvals show up in the Matrix UI?",
      "a": "Keep it explicit: the agent posts a plan and a job id, then an approver replies with a specific approval command you standardize on. The control layer uses that to mint a job-scoped CST, and the agent posts the completion message with a proof bundle reference (optionally via Trust Pulse) back into the room."
    },
    {
      "q": "Can Matrix be used for fully autonomous agents?",
      "a": "It can, but it is usually a poor default for autonomous execution because chat rooms are noisy and easy to socially engineer. A more reliable approach is to keep Matrix for requests and approvals, and run autonomous schedules in a separate job system with the same WPC and CST mechanics."
    },
    {
      "q": "What models can I use with this setup?",
      "a": "Any model reachable through your configured providers, with the strongest audit properties when traffic is routed through clawproxy. OpenRouter via fal routed through clawproxy is available when you want provider flexibility while still getting gateway receipts."
    },
    {
      "q": "What is the minimum set of artifacts I should retain for audit?",
      "a": "Keep the WPC hash used for each job, the job-scoped CST context, and the proof bundle containing gateway receipts. If you need a review surface for non-technical stakeholders, store the bundle as a Trust Pulse and link it from the Matrix transcript."
    }
  ],
  "sources": [
    {
      "title": "Agent management for enterprises - GitHub Docs",
      "uri": "https://docs.github.com/copilot/concepts/agents/enterprise-management"
    },
    {
      "title": "[PDF] AWS Prescriptive Guidance - Agentic AI frameworks, platforms ...",
      "uri": "https://docs.aws.amazon.com/pdfs/prescriptive-guidance/latest/agentic-ai-frameworks/agentic-ai-frameworks.pdf"
    },
    {
      "title": "Securing Agentic AI: The Agentic AI Security Scoping Matrix",
      "uri": "https://aws.amazon.com/ai/security/agentic-ai-scoping-matrix/"
    },
    {
      "title": "The Agentic AI Security Scoping Matrix: A framework for securing autonomous AI systems",
      "uri": "https://aws.amazon.com/blogs/security/the-agentic-ai-security-scoping-matrix-a-framework-for-securing-autonomous-ai-systems/"
    },
    {
      "title": "Become an Agentic Enterprise:\t\t\t\t\t \n\t\t\t\t\t\t\t\t \n\t\t\t\t\tA Step-By-Step Guide",
      "uri": "https://www.salesforce.com/blog/playbook/agentic-ai/"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:59:15.387Z",
  "indexable": true
}