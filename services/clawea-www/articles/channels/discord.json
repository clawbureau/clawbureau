{
  "slug": "channels/discord",
  "title": "Discord AI Agent Control Plane | Claw EA",
  "category": "channels",
  "html": "<h2>Direct Answer</h2>\n<p>Claw EA turns Discord into a controlled front door for enterprise agents by running OpenClaw as the baseline agent runtime and binding every run to machine-enforced policy. Instead of trusting “the prompt” to behave, you permission the execution layer with a WPC and a CST, so the agent cannot exceed what is explicitly allowed.</p>\n<p>For model calls, route traffic through clawproxy to produce Gateway receipts, then collect a proof bundle per job for audit. Discord is a good control plane for human visibility and lightweight approvals, but it is not a system of record, so you should treat it as an operator UI plus chat ingress, not as the authority for identity or data classification.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Stand up an OpenClaw Gateway with the Discord channel enabled, and start with a strict inbound posture. Configure Discord access so only known guilds and channels can trigger the bot, and require an explicit mention for non-thread traffic to reduce accidental triggers.</p>\n  </li>\n  <li>\n    <p>Define what “work” is allowed from Discord, separate from what the model can say. Put the operational constraints in a WPC and publish it as a signed artifact, then treat the policy hash as a deployable input to your agent runtime.</p>\n  </li>\n  <li>\n    <p>Issue a CST (scoped token) from clawscope for the Discord-run job, with a scope hash appropriate to the tools and providers you will allow. If you want fail-closed behavior when policy changes, pin the policy hash in the CST so the job is tied to an exact WPC version.</p>\n  </li>\n  <li>\n    <p>Route model traffic through clawproxy so every model call emits Gateway receipts. If you use OpenRouter via fal, route that through clawproxy as well so the same receipt pipeline applies.</p>\n  </li>\n  <li>\n    <p>Lock down execution in OpenClaw using sandboxing plus tool policy, not prompt instructions. Put risky tools behind an explicit allowlist, and prefer sandbox mode for Discord sessions so a compromised conversation has less filesystem and process access.</p>\n  </li>\n  <li>\n    <p>Run a “dry run” flow in Discord: the agent posts a plan and the exact tool set it intends to use, then an operator explicitly acknowledges before you issue the CST for the real run. This approval gate is typically implemented as an enterprise buildout that mints a job-scoped CST only after the operator signal is recorded.</p>\n  </li>\n  <li>\n    <p>After completion, export a proof bundle for the job and store it where your audit team can find it. If you use Trust Pulse, you can store the artifact for later viewing and verification workflows.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Discord is high-risk for prompt injection because it mixes untrusted user text, links, and attachments in the same thread where tools may be available. Treat every Discord message as hostile input, and rely on policy and sandboxing rather than “please ignore the attacker” prompt patterns.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection in a public channel</td>\n      <td>Attacker messages the bot and tries to coerce tool use (file reads, network calls, posting secrets).</td>\n      <td>Discord allowlists and mention requirements in OpenClaw, plus WPC-based tool allowlists and sandboxing for Discord sessions.</td>\n    </tr>\n    <tr>\n      <td>Over-broad tools available in chat</td>\n      <td>A legitimate request accidentally triggers a destructive tool or touches sensitive files.</td>\n      <td>Policy-as-code that enumerates allowed tools per channel, plus “deny by default” tool profiles.</td>\n    </tr>\n    <tr>\n      <td>Token replay across jobs</td>\n      <td>A captured token is reused to run additional work later.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding, so a CST is valid only for the intended job context.</td>\n    </tr>\n    <tr>\n      <td>Model-call repudiation</td>\n      <td>You cannot prove what the model saw or which provider was used when investigating an incident.</td>\n      <td>Gateway receipts emitted by clawproxy for model calls, bundled into a proof bundle with job metadata.</td>\n    </tr>\n    <tr>\n      <td>Discord bot token compromise</td>\n      <td>An attacker can impersonate the bot, read channels the bot can access, or send messages.</td>\n      <td>Limit bot permissions in Discord, rotate credentials promptly, and keep the agent execution policy strict so bot compromise does not imply tool compromise.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a JSON-like sketch of a WPC that constrains what Discord-triggered work can do. The point is that the control lives outside the prompt: the runtime enforces it, and the CST can pin the WPC hash so the agent cannot silently “upgrade” permissions mid-run.</p>\n\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"discord-control-plane-prod\",\n  \"channel\": {\n    \"type\": \"discord\",\n    \"guild_allowlist\": [\"123456789012345678\"],\n    \"channel_allowlist\": [\"234567890123456789\", \"345678901234567890\"],\n    \"require_mention\": true,\n    \"threads_only_for_work\": true\n  },\n  \"execution\": {\n    \"runtime\": \"openclaw-gateway\",\n    \"sandbox_mode\": \"all\",\n    \"workspace_access\": \"ro\"\n  },\n  \"tools\": {\n    \"profile\": \"deny-by-default\",\n    \"allow\": [\n      \"http.fetch\",\n      \"browser.navigate\",\n      \"read\",\n      \"write\"\n    ],\n    \"deny\": [\n      \"exec\",\n      \"process\",\n      \"tools.elevated\"\n    ]\n  },\n  \"model_calls\": {\n    \"route_via\": \"clawproxy\",\n    \"allowed_providers\": [\"openrouter-via-fal\"],\n    \"receipt_required\": true\n  },\n  \"auth\": {\n    \"cst\": {\n      \"issuer\": \"clawscope\",\n      \"scope_hash_required\": true,\n      \"policy_hash_pinning\": \"optional\"\n    }\n  }\n}</pre>\n\n<p>Operationally, you publish the WPC as a signed, hash-addressed artifact served by clawcontrols, then configure the runtime to fetch and verify the WPC before a Discord session can start tool execution. That gives you a stable policy surface you can diff, review, and roll forward safely.</p>\n\n<h2>What proof do you get?</h2>\n<p>For each model call routed through clawproxy, you get Gateway receipts that you can later use to show that calls were mediated by your gateway and associated with a specific job context. These receipts are designed to support verification workflows without relying on “trust me” logs from the agent process.</p>\n<p>At the end of a run, Claw EA can emit a proof bundle that packages the relevant receipts and metadata needed for audit. Typical contents include the job identifier, the CST scope hash, any pinned WPC hash, and the set of model-call receipts that occurred during the run.</p>\n<p>If you use Trust Pulse, you can store the resulting artifact for later viewing and review. Treat this as evidence attached to a run, not as a replacement for your internal ticketing or incident system.</p>\n\n<h2>Rollback posture</h2>\n<p>Discord is a chat surface, so rollback should focus on stopping new work quickly and making it obvious which permissions changed. You want rollback actions that are fast, scoped, and leave evidence behind.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Bad behavior from one Discord thread</td>\n      <td>Revoke the job CST and close the thread workflow so no new tool runs can start from that thread.</td>\n      <td>Proof bundle shows the last accepted CST scope hash and the Gateway receipts up to revocation time.</td>\n    </tr>\n    <tr>\n      <td>Policy mistake (too many tools)</td>\n      <td>Publish a new WPC version with tightened tool allowlists and pin the new policy hash for subsequent CST issuance.</td>\n      <td>Old and new WPC hashes are comparable, and new runs show the new pinned policy hash in job metadata.</td>\n    </tr>\n    <tr>\n      <td>Suspected token leak</td>\n      <td>Invalidate affected CSTs and re-issue with narrower scope hashes and shorter lifetimes.</td>\n      <td>Run evidence remains intact via proof bundles; new runs show different CST scope hashes.</td>\n    </tr>\n    <tr>\n      <td>Discord bot compromise</td>\n      <td>Rotate Discord credentials, reduce Discord-side permissions, and temporarily disable channel allowlists until the bot identity is re-established.</td>\n      <td>Discord-side rotation is separate; proof bundles still show what work ran and when via receipts.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why not just put safety instructions in the prompt?</h3>\n<p>Prompt-only controls are not a permission boundary because the model can be coerced, confused, or simply make a mistake. A WPC plus CST-based scoping forces the runtime to deny actions even if the model “decides” to attempt them.</p>\n\n<h3>What does Discord approve, and what stays in policy?</h3>\n<p>Use Discord for operator intent and visibility, like “approve this plan” or “confirm these targets,” typically implemented as an enterprise buildout that mints a job CST after approval. Keep tool permissions, sandbox settings, and provider routing in the WPC so approvals cannot silently expand capability.</p>\n\n<h3>Can I restrict the bot to only respond when mentioned?</h3>\n<p>Yes, OpenClaw supports mention-gating behavior for Discord guild messages, and you can keep it strict outside bot-owned threads. This reduces accidental triggers and makes it clearer which messages are actually work requests.</p>\n\n<h3>How do receipts and proof bundles help during an incident?</h3>\n<p>Gateway receipts let you tie specific model calls to a mediated path through clawproxy, which helps answer “what was called, when, and under which job context.” The proof bundle packages those receipts with the job metadata so an auditor can review a run without scraping ad hoc logs.</p>\n\n<h3>Is Discord a good place to handle secrets?</h3>\n<p>No. Treat Discord as untrusted for secrets by default, and keep secrets out of chat history.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/src/discord/monitor/allow-list.ts#L337-L382\">OpenClaw source: Discord allowlist and mention gating defaults</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Claw EA turns Discord into a controlled front door for enterprise agents by running OpenClaw as the baseline agent runtime and binding every run to machine-enforced policy. Instead of trusting “the prompt” to behave, you",
  "faqs": [
    {
      "q": "Why not just put safety instructions in the prompt?",
      "a": "Prompt-only controls are not a permission boundary because the model can be coerced, confused, or simply make a mistake. A WPC plus CST-based scoping forces the runtime to deny actions even if the model “decides” to attempt them."
    },
    {
      "q": "What does Discord approve, and what stays in policy?",
      "a": "Use Discord for operator intent and visibility, like “approve this plan” or “confirm these targets,” typically implemented as an enterprise buildout that mints a job CST after approval. Keep tool permissions, sandbox settings, and provider routing in the WPC so approvals cannot silently expand capability."
    },
    {
      "q": "Can I restrict the bot to only respond when mentioned?",
      "a": "Yes, OpenClaw supports mention-gating behavior for Discord guild messages, and you can keep it strict outside bot-owned threads. This reduces accidental triggers and makes it clearer which messages are actually work requests."
    },
    {
      "q": "How do receipts and proof bundles help during an incident?",
      "a": "Gateway receipts let you tie specific model calls to a mediated path through clawproxy, which helps answer “what was called, when, and under which job context.” The proof bundle packages those receipts with the job metadata so an auditor can review a run without scraping ad hoc logs."
    },
    {
      "q": "Is Discord a good place to handle secrets?",
      "a": "No. Treat Discord as untrusted for secrets by default, and keep secrets out of chat history."
    }
  ],
  "sources": [],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:56:08.266Z",
  "indexable": true
}