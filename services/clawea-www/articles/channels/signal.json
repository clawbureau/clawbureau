{
  "slug": "channels/signal",
  "title": "Signal AI Agent Control Plane | Claw EA",
  "category": "channels",
  "html": "<h2>Direct Answer</h2>\n<p>Signal can work as a lightweight human control plane for enterprise AI agents when you treat it as an approvals and notification surface, not as the execution boundary. In Claw EA, the execution boundary is permissioned by policy-as-code using a WPC and a CST, with model calls routed through clawproxy to produce gateway receipts and a proof bundle.</p>\n<p>This matters because prompt-only rules are not enforceable under adversarial input. A signed WPC plus scoped runtime authorization is enforceable even when the chat content is malicious or confusing.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Decide what Signal is for.</strong> Use Signal for human approvals, incident pings, and status summaries. Keep system-of-record actions and credentials outside the chat surface.</p>\n  </li>\n  <li>\n    <p><strong>Run agents on OpenClaw.</strong> OpenClaw is the baseline agent runtime, so you start by configuring a channel extension that can read and post messages. For Signal, this is typically an enterprise buildout using a self-hosted bridge or a dedicated MCP server, since there is no guaranteed official enterprise API.</p>\n  </li>\n  <li>\n    <p><strong>Write a WPC that matches the Signal workflow.</strong> Put concrete constraints in the WPC: which tools can run, which model routing is allowed, and what approval phrase is required. Store the WPC in the WPC registry so it is signed and hash-addressed.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST per job.</strong> When an operator asks for work, your orchestrator requests a CST from clawscope that is job-scoped and optionally pinned to the WPC hash. This makes replay harder because the CST is bound to the job context.</p>\n  </li>\n  <li>\n    <p><strong>Route model traffic through clawproxy.</strong> Configure the OpenClaw provider so model calls go through clawproxy (for example OpenRouter via fal routed through clawproxy). clawproxy emits gateway receipts for each model call.</p>\n  </li>\n  <li>\n    <p><strong>Return proof to the chat and to audit storage.</strong> At the end of the run, produce a proof bundle that includes gateway receipts and metadata, then post a short summary in Signal including the WPC hash and the proof bundle identifier. If you need a viewer artifact for audit stakeholders, store it as a Trust Pulse.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Signal is a high-signal operator surface, but it is not an enterprise administrative plane. You should assume screenshots leak, group membership changes without notice, and attackers will attempt prompt injection directly in the chat.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection in chat</td>\n      <td>A message tries to override instructions and trigger unsafe tools or data access.</td>\n      <td>Fail closed at execution: OpenClaw tool allow/deny plus sandboxing, and a WPC that restricts tools and model routing. Do not rely on “do not do X” prompts.</td>\n    </tr>\n    <tr>\n      <td>Unauthorized participant in a group</td>\n      <td>An untrusted user joins and requests actions that look legitimate.</td>\n      <td>Policy-as-code gating: WPC restricts allowed sender identifiers, and the job CST is issued only after a verified approval step. Treat group membership as untrusted input, not authorization.</td>\n    </tr>\n    <tr>\n      <td>Replay of an old approval message</td>\n      <td>Someone copies “approved” text from a prior run to trigger another run.</td>\n      <td>Use job-scoped CST binding and require a per-job nonce in the approval phrase. The CST scope hash and optional policy hash pinning make the authorization specific to that job and WPC.</td>\n    </tr>\n    <tr>\n      <td>Model output disputes after an incident</td>\n      <td>You cannot prove what the model was asked and what it returned during execution.</td>\n      <td>Route calls through clawproxy to generate gateway receipts, then package them into a proof bundle. Use the proof bundle for verification and post-incident review.</td>\n    </tr>\n    <tr>\n      <td>Sandbox escape via tool configuration</td>\n      <td>A tool runs on the host unintentionally, expanding blast radius.</td>\n      <td>Prefer sandboxed tool execution in OpenClaw, minimize bind mounts, and avoid elevated execution except for explicitly approved break-glass runs. Run OpenClaw security audit after config changes.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is an illustrative WPC-style policy for a Signal approvals channel. The key idea is that the runtime is permissioned by a signed WPC (fetched and verified via clawcontrols) and enforced by scoped authorization (CST) rather than chat text.</p>\n<pre>{\n  \"policy_name\": \"signal-approvals-control-plane\",\n  \"channel\": {\n    \"type\": \"signal\",\n    \"allowed_recipients\": [\"+15551234567\", \"+15557654321\"],\n    \"allowed_senders\": [\"+15559876543\"],\n    \"approval\": {\n      \"required\": true,\n      \"format\": \"APPROVE {job_nonce}\",\n      \"deny_format\": \"DENY {job_nonce}\"\n    }\n  },\n  \"runtime\": {\n    \"baseline\": \"OpenClaw\",\n    \"sandbox_mode\": \"all\",\n    \"tools\": {\n      \"allow\": [\"read\", \"write\", \"http\", \"mcp:*\"],\n      \"deny\": [\"exec\", \"elevated:*\"]\n    }\n  },\n  \"model_routing\": {\n    \"via\": \"clawproxy\",\n    \"provider\": \"openrouter_via_fal\"\n  },\n  \"auth\": {\n    \"cst\": {\n      \"job_scoped\": true,\n      \"pin_wpc_hash\": true\n    }\n  }\n}</pre>\n<p>Operationally, the agent posts the job nonce and the WPC hash into Signal before it starts work. The human reply is only a trigger to mint or release the job CST; it is not treated as the authorization itself.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get gateway receipts for model calls emitted by clawproxy. These receipts can be checked later to confirm which model calls were made under which scoped authorization.</p>\n<p>You also get a proof bundle that packages the gateway receipts and related metadata for audit and verification. If you need a durable artifact for reviewers, store the run as a Trust Pulse so audit stakeholders can view what was produced without joining the operator chat.</p>\n<p>In the Signal UI, the practical pattern is a short “control card” message: WPC hash, job nonce, requested tools, and a single approve or deny instruction. After completion, post the proof bundle identifier and a concise outcome summary, and keep detailed logs outside Signal.</p>\n\n<h2>Rollback posture</h2>\n<p>Signal-driven operations need a clear rollback plan because the chat channel can go noisy quickly. Treat rollback as a set of concrete operator actions, each tied to evidence you can later verify.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop new work immediately</td>\n      <td>Stop issuing new CSTs for the job class, and rotate or revoke active CSTs if needed.</td>\n      <td>CST issuance and revocation records, plus the absence of new gateway receipts after the cutoff.</td>\n    </tr>\n    <tr>\n      <td>Freeze a specific workflow</td>\n      <td>Pin agents to a known-good WPC hash and refuse jobs that reference other policies.</td>\n      <td>WPC hash shown in Signal control messages and embedded in the run metadata within the proof bundle.</td>\n    </tr>\n    <tr>\n      <td>Contain tool blast radius</td>\n      <td>Reduce tool allowlists and ensure OpenClaw sandbox mode is set to restrict host access.</td>\n      <td>OpenClaw audit output and effective sandbox and tool policy inspection, plus proof bundles showing tool usage boundaries.</td>\n    </tr>\n    <tr>\n      <td>Dispute a run result</td>\n      <td>Re-verify the proof bundle and compare gateway receipts to the claimed outcome.</td>\n      <td>Proof bundle contents and gateway receipts for the model calls involved.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Is Signal a good enterprise control plane?</h3>\n<p>It is good for small, explicit approvals and incident communication. It is not a replacement for identity governance, admin policy, or enterprise retention, so keep authorization and audit in Claw EA artifacts, not in the chat transcript.</p>\n\n<h3>Why not just put the rules in the system prompt?</h3>\n<p>Prompt rules are advisory and can be bypassed by adversarial input or model error. A WPC plus CST permissioning is enforced by the execution layer, so the agent cannot “talk itself into” extra tools or access.</p>\n\n<h3>How do approvals show up in the Signal chat?</h3>\n<p>Post a structured message that includes the job nonce, the WPC hash, and exactly what is being requested. The operator replies with a single approval phrase that matches the policy, and the job CST is minted or released only after that check passes.</p>\n\n<h3>What do I show auditors after a Signal-approved run?</h3>\n<p>Provide the proof bundle for the run, which includes gateway receipts and metadata suitable for verification. If you need a stable viewing artifact outside the operator chat, store it as a Trust Pulse.</p>\n\n<h3>Can I restrict what the agent can do on the machine running OpenClaw?</h3>\n<p>Yes, using OpenClaw sandboxing and tool policy controls, and by avoiding elevated execution unless you have an explicit break-glass procedure. Re-run the OpenClaw security audit after any config or extension changes.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization\">Governance and security for AI agents across the organization (Microsoft Cloud Adoption Framework)</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-copilot-studio/guidance/architecture/multi-agent-patterns\">Multi-agent patterns (Microsoft Copilot Studio)</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Signal can work as a lightweight human control plane for enterprise AI agents when you treat it as an approvals and notification surface, not as the execution boundary. In Claw EA, the execution boundary is permissioned ",
  "faqs": [
    {
      "q": "Is Signal a good enterprise control plane?",
      "a": "It is good for small, explicit approvals and incident communication. It is not a replacement for identity governance, admin policy, or enterprise retention, so keep authorization and audit in Claw EA artifacts, not in the chat transcript."
    },
    {
      "q": "Why not just put the rules in the system prompt?",
      "a": "Prompt rules are advisory and can be bypassed by adversarial input or model error. A WPC plus CST permissioning is enforced by the execution layer, so the agent cannot “talk itself into” extra tools or access."
    },
    {
      "q": "How do approvals show up in the Signal chat?",
      "a": "Post a structured message that includes the job nonce, the WPC hash, and exactly what is being requested. The operator replies with a single approval phrase that matches the policy, and the job CST is minted or released only after that check passes."
    },
    {
      "q": "What do I show auditors after a Signal-approved run?",
      "a": "Provide the proof bundle for the run, which includes gateway receipts and metadata suitable for verification. If you need a stable viewing artifact outside the operator chat, store it as a Trust Pulse."
    },
    {
      "q": "Can I restrict what the agent can do on the machine running OpenClaw?",
      "a": "Yes, using OpenClaw sandboxing and tool policy controls, and by avoiding elevated execution unless you have an explicit break-glass procedure. Re-run the OpenClaw security audit after any config or extension changes."
    }
  ],
  "sources": [
    {
      "title": "What Is Microsoft Foundry Control Plane?",
      "uri": "https://learn.microsoft.com/en-us/azure/ai-foundry/control-plane/overview?view=foundry"
    },
    {
      "title": "Governance and security for AI agents across the organization",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization"
    },
    {
      "title": "The Agentic Enterprise: IT Architecture for the AI-Powered Future",
      "uri": "https://architect.salesforce.com/fundamentals/agentic-enterprise-it-architecture"
    },
    {
      "title": "Multi-agent patterns - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/guidance/architecture/multi-agent-patterns"
    },
    {
      "title": "Use Microsoft Purview to manage data security & compliance for ...",
      "uri": "https://learn.microsoft.com/en-us/purview/ai-azure-foundry"
    },
    {
      "title": "Observability in Generative AI - Microsoft Foundry",
      "uri": "https://learn.microsoft.com/en-us/azure/ai-foundry/concepts/observability?view=foundry-classic"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:02:36.595Z",
  "indexable": true
}