{
  "slug": "channels/mattermost",
  "title": "Mattermost AI Agent Control Plane | Claw EA",
  "category": "channels",
  "html": "<h2>Direct Answer</h2>\n<p>Mattermost can work as a practical chat control plane for enterprise agents when you treat chat as the place to request work, approve risky actions, and review evidence. Claw EA runs agents on the OpenClaw baseline runtime, then binds each run to a Work Policy Contract (WPC) and a CST (scoped token) so execution is permissioned rather than prompt-only.</p>\n<p>You do not need to trust a long prompt to keep the agent safe. Instead, you pin policy by hash, scope every run, and collect Gateway receipts and a Proof bundle so security teams can verify what was called and under what constraints.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Decide the Mattermost interaction pattern: a dedicated request channel plus a dedicated approvals channel, or a single channel with strict allowlisting. Integration can be implemented via official API or via an MCP server, depending on your Mattermost deployment and bot framework.</p>\n  </li>\n  <li>\n    <p>Write a WPC that defines allowed tools, allowed model routing, and required approval gates for high-impact actions. Store the signed, hash-addressed WPC in the WPC registry (served by clawcontrols) and treat the policy hash as the release artifact you deploy.</p>\n  </li>\n  <li>\n    <p>Configure OpenClaw to run tools in a sandbox where possible and to start from an allowlist tool profile. Run <a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">openclaw security audit</a> as part of the change process, especially after enabling a new channel surface.</p>\n  </li>\n  <li>\n    <p>Issue a per-job CST (scoped token) from clawscope and bind it to the job identity you use in Mattermost (for example: team id + channel id + root post id). Enable optional policy hash pinning so the CST is only valid when the agent presents the exact WPC hash you approved.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy so each model request and response emits Gateway receipts. If you use OpenRouter via fal, keep the provider routing consistent and record it in the job metadata so verification is deterministic.</p>\n  </li>\n  <li>\n    <p>Make approvals explicit in chat: the agent posts a “proposed actions” message with a job id, then waits for a human reply like “APPROVE job:123 step:send_message” from an allowlisted user group. This approval gate is enforced by your agent harness and OpenClaw tool policy, not by prompt text.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection in Mattermost threads</td>\n      <td>An attacker posts instructions that try to override guardrails and trigger tools or data access.</td>\n      <td>Do not rely on “system prompt” rules. Enforce tool allow/deny via OpenClaw tool policy, and bind each run to a WPC hash that constrains what can execute.</td>\n    </tr>\n    <tr>\n      <td>Unauthorized user triggers the agent</td>\n      <td>Someone outside the intended group gets the agent to act in a sensitive channel.</td>\n      <td>Channel allowlisting plus explicit “approval required” flow. Keep the “who can request work” set narrower than “who can read outcomes,” and verify requester identity in your Mattermost integration via official API.</td>\n    </tr>\n    <tr>\n      <td>Credential misuse or token replay</td>\n      <td>A captured token is reused to run actions later, or in a different channel context.</td>\n      <td>Use marketplace anti-replay binding with job-scoped CST binding. Tie the CST claims to the job and optionally pin the WPC hash so the token cannot be replayed under a different policy.</td>\n    </tr>\n    <tr>\n      <td>Model call disputes after an incident</td>\n      <td>Teams cannot prove what the model saw or produced during a run.</td>\n      <td>Route model traffic through clawproxy to generate Gateway receipts. Package receipts into a Proof bundle for verification and audit review.</td>\n    </tr>\n    <tr>\n      <td>Tool blast radius on the host</td>\n      <td>A compromised session reaches the filesystem or executes commands outside expected bounds.</td>\n      <td>Prefer sandboxed tool execution and avoid elevated host execution unless required. Use OpenClaw sandbox settings to reduce filesystem access and keep tool profiles minimal.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Egress allowlists enforced outside clawproxy can be implemented if your environment needs hard network boundaries for tools. Treat that as an infrastructure control layered under OpenClaw, not a prompt rule.</p>\n\n<h2>Policy-as-code example</h2>\n<p>This is an illustrative WPC-style policy artifact for a Mattermost-controlled agent. The important part is that the policy is signed, hash-addressed, and pinned for the run; it is enforced by your harness and by proxy verification rather than by chat text.</p>\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"mattermost-agent-prod\",\n  \"channel_context\": {\n    \"system\": \"mattermost\",\n    \"allowed_team_ids\": [\"team-prod-1\"],\n    \"allowed_channel_ids\": [\"chan-ops-approvals\", \"chan-agent-requests\"]\n  },\n  \"execution\": {\n    \"require_human_approval_for\": [\"send_message\", \"write_file\", \"exec\"],\n    \"approval_rule\": {\n      \"allowed_approver_groups\": [\"ops-oncall\", \"sec-reviewers\"],\n      \"approval_phrase\": \"APPROVE job:{job_id} step:{step}\"\n    }\n  },\n  \"models\": {\n    \"provider\": \"openrouter-via-fal\",\n    \"allowed_models\": [\"openrouter/*\"],\n    \"route_through\": \"clawproxy\",\n    \"require_gateway_receipts\": true\n  },\n  \"tools\": {\n    \"profile\": \"allowlist\",\n    \"allow\": [\"read\", \"search\", \"http_get\"],\n    \"deny\": [\"exec\", \"write_file\", \"browser_control\"]\n  },\n  \"attestation\": {\n    \"require_proof_bundle\": true\n  }\n}\n</pre>\n<p>If you need “exec” or file writes, keep them off by default and introduce them as a controlled change: update the WPC, review the diff, pin the new policy hash, and re-run the security audit.</p>\n\n<h2>What proof do you get?</h2>\n<p>Each model call routed through clawproxy produces Gateway receipts. Receipts are signed artifacts that you can later verify, and they are the backbone for answering “what did the model see” and “what did it return” without relying on a mutable log stream.</p>\n<p>For each job, Claw EA can produce a Proof bundle that includes the relevant receipts plus run metadata needed for audit and verification. In practice this ties together the WPC hash used, the CST scope hash (and any policy hash pinning), job identifiers (including your Mattermost thread or post ids), and the model routing information.</p>\n<p>You can store and view the resulting artifact as a Trust Pulse for later review. This is useful when approvals happen in chat but security teams need a separate evidence object to validate what was enforced.</p>\n\n<h2>Rollback posture</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to collect</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Policy regression</td>\n      <td>Pin back to the last known-good WPC hash and re-issue CSTs that only allow the reverted policy.</td>\n      <td>WPC hashes before and after, plus the Proof bundle for the first run under the reverted policy.</td>\n    </tr>\n    <tr>\n      <td>Suspected token leakage</td>\n      <td>Revoke affected CSTs and re-issue job-scoped CSTs with tighter TTLs and policy hash pinning.</td>\n      <td>CST identifiers, job ids, and the set of Proof bundles produced during the exposure window.</td>\n    </tr>\n    <tr>\n      <td>Channel compromise or noisy inputs</td>\n      <td>Disable the Mattermost trigger path in your integration and move approvals to a known-good channel while you investigate.</td>\n      <td>Export of the triggering thread, and the corresponding Proof bundles for any executed jobs.</td>\n    </tr>\n    <tr>\n      <td>Tool misuse</td>\n      <td>Reduce OpenClaw tool allowlists and re-run OpenClaw security audit before restoring access.</td>\n      <td>OpenClaw configuration diffs, audit output, and proof artifacts from clawproxy for disputed runs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why is Mattermost a good control plane for enterprise agents?</h3>\n<p>It already hosts operational approvals and incident coordination, so teams will actually use it. The key is to keep chat as the request and approval surface, while enforcing execution through WPC and CST instead of trusting the conversation.</p>\n\n<h3>Why not just put the rules in the system prompt?</h3>\n<p>Prompt-only controls are advisory: they can be bypassed by injection, tool confusion, or model error. Policy-as-code lets you pin a WPC hash, scope the CST to that policy, and enforce tools and routing at the execution layer.</p>\n\n<h3>Do you provide a native Mattermost connector?</h3>\n<p>This page does not assume a native connector. Mattermost control can be implemented via official API or via an MCP server, and the operational contract is the same: job identity, approvals, policy pinning, and evidence capture.</p>\n\n<h3>How do approvals show up in chat?</h3>\n<p>The simplest pattern is a two-message flow: the agent posts “Plan + job id,” then waits for an allowlisted approver to reply with a structured approval phrase. Your harness records the approval message id as job metadata so the Proof bundle links execution back to the approval event.</p>\n\n<h3>What do auditors actually verify later?</h3>\n<p>They verify Gateway receipts for model calls and the Proof bundle envelope that binds receipts to the run context. They also verify that the WPC hash and CST scope hash used for the run match the approved change record.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n</ul>\n<p>Note: a Mattermost vendor documentation link is not included because the allowed citation list for this page only contains OpenClaw sources.</p>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Mattermost can work as a practical chat control plane for enterprise agents when you treat chat as the place to request work, approve risky actions, and review evidence. Claw EA runs agents on the OpenClaw baseline runti",
  "faqs": [
    {
      "q": "Why is Mattermost a good control plane for enterprise agents?",
      "a": "It already hosts operational approvals and incident coordination, so teams will actually use it. The key is to keep chat as the request and approval surface, while enforcing execution through WPC and CST instead of trusting the conversation."
    },
    {
      "q": "Why not just put the rules in the system prompt?",
      "a": "Prompt-only controls are advisory: they can be bypassed by injection, tool confusion, or model error. Policy-as-code lets you pin a WPC hash, scope the CST to that policy, and enforce tools and routing at the execution layer."
    },
    {
      "q": "Do you provide a native Mattermost connector?",
      "a": "This page does not assume a native connector. Mattermost control can be implemented via official API or via an MCP server, and the operational contract is the same: job identity, approvals, policy pinning, and evidence capture."
    },
    {
      "q": "How do approvals show up in chat?",
      "a": "The simplest pattern is a two-message flow: the agent posts “Plan + job id,” then waits for an allowlisted approver to reply with a structured approval phrase. Your harness records the approval message id as job metadata so the Proof bundle links execution back to the approval event."
    },
    {
      "q": "What do auditors actually verify later?",
      "a": "They verify Gateway receipts for model calls and the Proof bundle envelope that binds receipts to the run context. They also verify that the WPC hash and CST scope hash used for the run match the approved change record."
    }
  ],
  "sources": [],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:00:30.896Z",
  "indexable": true
}