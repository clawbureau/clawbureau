{
  "slug": "channels/telegram",
  "title": "Telegram AI Agent Control Plane | Claw EA",
  "category": "channels",
  "html": "<h2>Direct Answer</h2>\n<p>Claw EA turns Telegram into a controlled command surface for enterprise agents by running them on OpenClaw as the baseline runtime, then forcing real permissions at execution time instead of relying on prompt text. You use a WPC (Work Policy Contract) to define what the agent is allowed to do, a CST (scoped token) to bind each run to that policy, and clawproxy to emit gateway receipts for every model call.</p>\n<p>In Telegram, approvals show up as explicit “approve or deny” steps in the chat, and the run produces a proof bundle you can verify later. This is a good fit for on-call and field workflows where Telegram is already adopted, but it is not a substitute for a full enterprise collaboration suite’s compliance controls.</p>\n\n<h2>Step-by-step runbook</h2>\n<p><strong>1) Create a Telegram bot and lock down who can talk to it.</strong> Configure the bot via the official API, then restrict usage to known user IDs and specific group chats where possible. Treat the bot token as a production secret and rotate it on any suspicion of exposure.</p>\n<p><strong>2) Stand up the OpenClaw Gateway with the Telegram channel enabled.</strong> Keep the Gateway private and run <code>openclaw security audit</code> regularly to catch common footguns like open group policies or unsafe filesystem permissions. Use Docker sandboxing for tool execution unless you have a documented reason not to.</p>\n<p><strong>3) Write and publish a WPC that matches your Telegram operating model.</strong> Put concrete constraints in the WPC: which Telegram chats are allowed, whether a mention is required, what tools can run, and which actions require an approval message. Publish the signed WPC to the WPC registry (served by clawcontrols), and treat the policy hash as the immutable identifier.</p>\n<p><strong>4) Issue a CST for the agent run, pinned to the policy.</strong> Use clawscope to issue a CST (scoped token) with a scope hash aligned to your tool and channel permissions, optionally pinning to the WPC policy hash. Use short TTLs for Telegram agents, and issue a new CST per job or on-call shift.</p>\n<p><strong>5) Route model calls through clawproxy for receipts.</strong> Configure the OpenClaw provider path so model traffic is proxied via clawproxy, which emits gateway receipts for each model call. If you use OpenRouter via fal, keep it behind clawproxy so the receipts cover the call boundary.</p>\n<p><strong>6) Implement “approval-in-chat” as a hard gate, not a suggestion.</strong> In Telegram, have the agent post a structured approval request (what action, which target, and the policy hash), then wait for an explicit <code>/approve</code> or <code>/deny</code> from an allowlisted approver. The execution layer should refuse to proceed without the approval event bound to the current job context.</p>\n<p><strong>7) Export and store proof for audit.</strong> At the end of a run, collect the proof bundle that includes gateway receipts and metadata needed for verification. Store it internally and optionally publish a Trust Pulse artifact for easier viewing during audits or incident reviews.</p>\n\n<h2>Threat model</h2>\n<p>Telegram is convenient, but it is a high-risk input channel because untrusted text is the primary interface. The control plane has to assume adversarial prompts, forwarded messages, and accidental operator commands.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection via chat content</td>\n      <td>A user pastes “ignore your rules” content and the agent attempts a sensitive tool action.</td>\n      <td>Permissioned execution with a WPC and OpenClaw tool policy. The model can ask, but the runtime denies calls outside the allowlist.</td>\n    </tr>\n    <tr>\n      <td>Impersonation or wrong-chat activation</td>\n      <td>The bot acts on commands from the wrong user, or in an unapproved group chat.</td>\n      <td>WPC chat and user allowlists, plus “require mention” semantics at the channel layer. Separate CST per job to prevent reuse across contexts.</td>\n    </tr>\n    <tr>\n      <td>Credential misuse after token leakage</td>\n      <td>A leaked CST or bot token is reused to run unauthorized actions.</td>\n      <td>CST short TTL and revocation via clawscope. Marketplace anti-replay binding with job-scoped CST binding to reduce token replay across jobs.</td>\n    </tr>\n    <tr>\n      <td>Silent model changes or disputed outputs</td>\n      <td>Teams cannot prove what model was called or what inputs produced an instruction.</td>\n      <td>Gateway receipts from clawproxy for each model call, assembled into a proof bundle for verification and audit.</td>\n    </tr>\n    <tr>\n      <td>Excessive tool blast radius</td>\n      <td>A “helpful” agent starts writing files, running shell commands, or accessing broad network resources.</td>\n      <td>OpenClaw sandboxing for tool execution and minimal tool allowlists. Use “elevated” mode only with explicit gating and a written operational runbook.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a simplified, JSON-like WPC sketch for a Telegram-operated agent. The goal is to make Telegram a request and approval surface, while keeping execution bounded by explicit tool and data permissions.</p>\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"telegram-oncall-agent\",\n  \"channel\": {\n    \"type\": \"telegram\",\n    \"allowed_chat_ids\": [\"-1001234567890\"],\n    \"allowed_user_ids\": [\"11111111\", \"22222222\"],\n    \"require_mention\": true\n  },\n  \"session\": {\n    \"job_scoped\": true,\n    \"max_ttl_seconds\": 3600\n  },\n  \"tools\": {\n    \"allow\": [\"http_get\", \"ticket_create\", \"ticket_comment\", \"runbook_search\"],\n    \"deny\": [\"shell_exec\", \"filesystem_write\", \"secrets_dump\"]\n  },\n  \"approvals\": [\n    {\n      \"action\": \"ticket_create\",\n      \"required_from_user_ids\": [\"22222222\"],\n      \"telegram_command\": \"/approve\"\n    },\n    {\n      \"action\": \"any_external_change\",\n      \"required_from_user_ids\": [\"22222222\"],\n      \"telegram_command\": \"/approve\"\n    }\n  ],\n  \"model_calls\": {\n    \"must_proxy_via\": \"clawproxy\",\n    \"receipts_required\": true\n  }\n}</pre>\n<p>Prompt-only controls fail here because the model can be convinced to “agree” to constraints while still calling tools. A WPC makes the constraint enforceable at the tool boundary, and the CST binds the running agent to that exact policy hash.</p>\n\n<h2>What proof do you get?</h2>\n<p>Every model call routed through clawproxy produces gateway receipts that you can verify later, even if the chat transcript is incomplete. Those receipts are then packaged into a proof bundle along with run metadata so you can answer: what was called, under which policy, and in which job context.</p>\n<p>Because runs can be bound to a job-scoped CST, you get practical anti-replay properties for audits. If you publish to Trust Pulse, you can keep an external, marketplace-stored artifact for viewing and review without re-running the job.</p>\n\n<h2>Rollback posture</h2>\n<p>Telegram agents should be operated like production automation: assume you will need to stop runs quickly and prove what happened. Rollback is a mix of token revocation, channel disablement, and tightening the WPC and tool policy for the next run.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Compromised run or suspicious behavior</td>\n      <td>Revoke the CST in clawscope and stop accepting new jobs for that agent.</td>\n      <td>CST revocation record and the proof bundle for the run in question.</td>\n    </tr>\n    <tr>\n      <td>Wrong-chat activation</td>\n      <td>Disable the Telegram channel entry for the agent and rotate the Telegram bot token.</td>\n      <td>Chat IDs in the WPC, plus Telegram transcript correlation with the run’s proof bundle metadata.</td>\n    </tr>\n    <tr>\n      <td>Tool policy too permissive</td>\n      <td>Update the WPC to remove tools, then issue a new CST pinned to the new policy hash.</td>\n      <td>Policy hash change history, plus receipts showing attempted tool calls being denied in the next run.</td>\n    </tr>\n    <tr>\n      <td>Disputed model output</td>\n      <td>Re-verify the proof bundle and review gateway receipts for the exact model call sequence.</td>\n      <td>Gateway receipts emitted by clawproxy, bundled and verifiable.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why use Telegram as a control plane at all?</h3>\n<p>Telegram is fast for on-call and field teams, and it works well for approvals and status updates. It is weaker for enterprise retention and compliance than dedicated enterprise collaboration platforms, so treat it as an operational surface, not your system of record.</p>\n\n<h3>What makes this permissioned execution instead of “a careful prompt”?</h3>\n<p>A careful prompt is advisory and can be overridden by chat content. A WPC plus CST makes constraints enforceable at execution time, so the runtime can deny tool calls even when the model tries to proceed.</p>\n\n<h3>How do approvals work in the chat UI?</h3>\n<p>The agent posts a structured approval request message that includes the action, target, and the policy hash, then pauses. Only an allowlisted approver can send <code>/approve</code> in the same chat to unlock the next step, and that approval is bound to the current job context.</p>\n\n<h3>Do you provide a native Telegram connector?</h3>\n<p>Claw EA focuses on secure execution, policy, and proof for OpenClaw agents. Telegram integration is typically done via OpenClaw’s channel support and the Telegram official API, and deeper enterprise workflows can be implemented via an MCP server or an enterprise buildout.</p>\n\n<h3>What can auditors verify after the fact?</h3>\n<p>They can verify gateway receipts for model calls and review the proof bundle metadata that ties the run to a specific WPC and CST context. This is designed to reduce “we think the model did X” uncertainty during incident review.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw\">OpenClaw repository (channel support and runtime overview)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit guidance and common footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw Sandboxing (tool execution isolation)</a></li>\n  <li><a href=\"https://github.com/modelcontextprotocol/servers\">Model Context Protocol servers (reference implementations and registry pointers)</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Claw EA turns Telegram into a controlled command surface for enterprise agents by running them on OpenClaw as the baseline runtime, then forcing real permissions at execution time instead of relying on prompt text. You u",
  "faqs": [
    {
      "q": "Why use Telegram as a control plane at all?",
      "a": "Telegram is fast for on-call and field teams, and it works well for approvals and status updates. It is weaker for enterprise retention and compliance than dedicated enterprise collaboration platforms, so treat it as an operational surface, not your system of record."
    },
    {
      "q": "What makes this permissioned execution instead of “a careful prompt”?",
      "a": "A careful prompt is advisory and can be overridden by chat content. A WPC plus CST makes constraints enforceable at execution time, so the runtime can deny tool calls even when the model tries to proceed."
    },
    {
      "q": "How do approvals work in the chat UI?",
      "a": "The agent posts a structured approval request message that includes the action, target, and the policy hash, then pauses. Only an allowlisted approver can send /approve in the same chat to unlock the next step, and that approval is bound to the current job context."
    },
    {
      "q": "Do you provide a native Telegram connector?",
      "a": "Claw EA focuses on secure execution, policy, and proof for OpenClaw agents. Telegram integration is typically done via OpenClaw’s channel support and the Telegram official API, and deeper enterprise workflows can be implemented via an MCP server or an enterprise buildout."
    },
    {
      "q": "What can auditors verify after the fact?",
      "a": "They can verify gateway receipts for model calls and review the proof bundle metadata that ties the run to a specific WPC and CST context. This is designed to reduce “we think the model did X” uncertainty during incident review."
    }
  ],
  "sources": [
    {
      "title": "modelcontextprotocol/servers: Model Context Protocol Servers",
      "uri": "https://github.com/modelcontextprotocol/servers"
    },
    {
      "title": "openclaw/openclaw: Your own personal AI assistant. Any ... - GitHub",
      "uri": "https://github.com/openclaw/openclaw"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:04:20.752Z",
  "indexable": true
}