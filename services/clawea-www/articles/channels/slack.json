{
  "slug": "channels/slack",
  "title": "Slack AI Agent Control Plane | Claw EA",
  "category": "channels",
  "html": "<h2>Direct Answer</h2>\n<p>Slack is a practical control plane for enterprise AI agents because it already has identity, channels, message history, and a place for approvals to happen in the open. Claw EA uses OpenClaw as the baseline agent runtime, then adds permissioned execution so “what the agent can do” is enforced by policy-as-code, not by prompts.</p>\n<p>Prompt-only guardrails fail when a message includes a malicious instruction or when a tool call is available by accident. With Claw EA, the agent’s work is tied to a WPC, authenticated with a CST, and model calls produce gateway receipts that can be packaged into a proof bundle for audit.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the Slack surface area for the agent. Decide which channels are “request intake” (read and triage) versus “execution” (where the agent can run tools and post outcomes).</p>\n  </li>\n  <li>\n    <p>Write a WPC that describes allowed tools, approval requirements, and the minimum proof you need for the job type. Store the WPC in the WPC registry so it can be fetched and verified during runs.</p>\n  </li>\n  <li>\n    <p>Issue a CST for the Slack agent job, with a scope hash that matches the intended tool surface. If you require strict pinning, use optional policy hash pinning so the CST is only valid with that exact WPC hash.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw with a Slack channel extension (via official API or via MCP server, depending on your Slack app architecture). Configure OpenClaw tool policy and sandboxing so local execution matches the WPC intent and does not silently widen access.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy so each model call emits gateway receipts. If you use OpenRouter via fal, keep it routed through clawproxy so receipts are consistent across providers.</p>\n  </li>\n  <li>\n    <p>Enforce approvals as a first-class step. In Slack, make approvals explicit: the agent posts a proposed action, a human responds with an approval token or a structured “approve” reply, and only then does the agent proceed to tool execution under the same job-scoped CST.</p>\n  </li>\n  <li>\n    <p>At completion, generate a proof bundle that includes gateway receipts and run metadata. Store or publish it to Trust Pulse so auditors can review what was run and what the model was allowed to do.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Slack is a high-risk ingress because anyone who can post in a channel can attempt prompt injection, or can socially engineer approvals. Treat the channel as untrusted input and make execution contingent on WPC enforcement plus verifiable artifacts.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection via Slack message</td>\n      <td>A message tries to override instructions and coerce the agent into calling tools or exfiltrating data.</td>\n      <td>Policy-as-code in a WPC defines tool availability and required approvals; OpenClaw tool policy and sandboxing reduce blast radius even when the model “wants” to do more.</td>\n    </tr>\n    <tr>\n      <td>Overbroad tools accidentally enabled</td>\n      <td>An agent can access shell, filesystem, or network tools because of a loose configuration.</td>\n      <td>WPC constraints plus OpenClaw tool allow/deny lists; run regular OpenClaw security audits to catch common footguns.</td>\n    </tr>\n    <tr>\n      <td>Approval spoofing inside Slack</td>\n      <td>An attacker imitates an approver, or replays an old “approved” message to trigger execution.</td>\n      <td>Gate execution on a job-scoped CST and explicit approval checks; use marketplace anti-replay binding (job-scoped CST binding) so approvals cannot be reused across jobs.</td>\n    </tr>\n    <tr>\n      <td>Model call disputes</td>\n      <td>After an incident, you cannot prove which prompts and outputs drove a tool action.</td>\n      <td>Route model calls through clawproxy to get gateway receipts; package them into a proof bundle for verification and audit.</td>\n    </tr>\n    <tr>\n      <td>Data leakage via chat context</td>\n      <td>The agent posts sensitive content back into Slack or uses it in prompts.</td>\n      <td>Limit what the agent is allowed to read and post; structure the workflow so sensitive outputs are summarized and redacted before posting, and keep raw artifacts outside Slack when possible (enterprise buildout).</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This sketch shows a Slack-oriented WPC shape: one set of channels for intake, a tighter set for execution, and an approval gate before any irreversible action. The point is operational: Slack messages are not “permissions”, they are inputs that must map to a signed policy artifact.</p>\n<pre>{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"slack-agent-control-plane\",\n  \"channels\": {\n    \"intake\": [\"#help-agent\", \"#triage-agent\"],\n    \"execution\": [\"#agent-ops\"]\n  },\n  \"identity\": {\n    \"allowed_slack_workspaces\": [\"T123...\"],\n    \"allowed_requester_groups\": [\"oncall\", \"it-ops\"],\n    \"approver_groups\": [\"security-approvers\"]\n  },\n  \"tools\": {\n    \"allow\": [\"ticket.create\", \"ticket.update\", \"doc.search\"],\n    \"deny\": [\"shell.exec\", \"fs.write\", \"browser.control\"]\n  },\n  \"approvals\": [\n    {\n      \"when\": \"tool == 'ticket.create' || tool == 'ticket.update'\",\n      \"require\": \"human_approval_in_slack\",\n      \"approval_window_minutes\": 30\n    }\n  ],\n  \"model_calls\": {\n    \"require_gateway_receipts\": true,\n    \"provider_route\": \"via_clawproxy\"\n  }\n}</pre>\n<p>In practice, the WPC is signed and hash-addressed, then served by clawcontrols. At runtime, the CST can be bound to the scope hash and optionally pinned to the WPC hash so the job cannot “switch policies” midstream.</p>\n\n<h2>What proof do you get?</h2>\n<p>Every routed model call produces gateway receipts emitted by clawproxy. These receipts let you later verify that a specific prompt, model, and response occurred as part of an authorized run, instead of relying on best-effort logs.</p>\n<p>Claw EA bundles receipts and run metadata into a proof bundle. You can store the proof bundle and, when needed, publish it as a Trust Pulse artifact for review, including the job-scoped binding context so replays and cross-job reuse are easier to detect.</p>\n\n<h2>Rollback posture</h2>\n<p>In Slack-driven operations, rollback is mostly about stopping further actions, constraining scope, and leaving a clean paper trail. The goal is to fail closed: if policy, token scope, or receipts cannot be produced, the agent should refuse to execute.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Policy mistake discovered (tool was allowed)</td>\n      <td>Update to a tighter WPC and rotate to a new policy hash; require optional policy hash pinning for new runs.</td>\n      <td>WPC hash history plus proof bundles from prior runs showing which policy hash was used.</td>\n    </tr>\n    <tr>\n      <td>Slack channel compromised or noisy</td>\n      <td>Move execution to a restricted channel and treat previous channels as intake-only; run OpenClaw security audit to confirm no widened Gateway exposure.</td>\n      <td>Proof bundles show which channel context and which tools were invoked; audit outputs show local configuration posture.</td>\n    </tr>\n    <tr>\n      <td>Suspicious run in progress</td>\n      <td>Revoke the CST so the job cannot continue; require a fresh CST for any retry under a reviewed WPC.</td>\n      <td>CST issuance and revocation records; partial proof bundle with gateway receipts up to the stop point.</td>\n    </tr>\n    <tr>\n      <td>Need to invalidate approval replay patterns</td>\n      <td>Use job-scoped CST binding and enforce “approval must reference current job id” in the Slack workflow (enterprise buildout).</td>\n      <td>Marketplace anti-replay binding context plus proof bundles tying approvals and actions to a single job.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why not rely on a prompt that says “ask for approval”?</h3>\n<p>Because Slack messages are untrusted input and prompts are not enforcement. Policy-as-code in a WPC defines what is allowed, and the runtime can fail closed when the policy is not satisfied.</p>\n\n<h3>How do approvals show up in Slack?</h3>\n<p>Operationally, the agent posts a proposed action with the exact tool and parameters it intends to use, then waits. A human replies with an approval message, and execution proceeds only if the approval matches the job and the current WPC constraints (enterprise buildout for your preferred UX).</p>\n\n<h3>What do gateway receipts prove?</h3>\n<p>They prove that specific model calls were made through clawproxy and were receipted, instead of being ad hoc calls outside your control plane. Receipts are designed to be bundled and verified later as part of a proof bundle.</p>\n\n<h3>Can we run Slack agents without letting them touch the host?</h3>\n<p>Yes, if your tools can run sandboxed and your OpenClaw configuration keeps execution inside Docker. OpenClaw distinguishes sandboxing, tool policy, and elevated host execution, and you should avoid elevated paths unless you explicitly need them.</p>\n\n<h3>Does Claw EA provide egress allowlists and budget caps?</h3>\n<p>Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are planned or can be implemented, but they are not presented here as shipped features. The shipped core is WPC, CST, gateway receipts, proof bundles, and job-scoped anti-replay binding.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://aws.amazon.com/blogs/machine-learning/integrate-amazon-bedrock-agents-with-slack\">Integrate Amazon Bedrock Agents with Slack | Amazon Web Services</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Slack is a practical control plane for enterprise AI agents because it already has identity, channels, message history, and a place for approvals to happen in the open. Claw EA uses OpenClaw as the baseline agent runtime",
  "faqs": [
    {
      "q": "Why not rely on a prompt that says “ask for approval”?",
      "a": "Because Slack messages are untrusted input and prompts are not enforcement. Policy-as-code in a WPC defines what is allowed, and the runtime can fail closed when the policy is not satisfied."
    },
    {
      "q": "How do approvals show up in Slack?",
      "a": "Operationally, the agent posts a proposed action with the exact tool and parameters it intends to use, then waits. A human replies with an approval message, and execution proceeds only if the approval matches the job and the current WPC constraints (enterprise buildout for your preferred UX)."
    },
    {
      "q": "What do gateway receipts prove?",
      "a": "They prove that specific model calls were made through clawproxy and were receipted, instead of being ad hoc calls outside your control plane. Receipts are designed to be bundled and verified later as part of a proof bundle."
    },
    {
      "q": "Can we run Slack agents without letting them touch the host?",
      "a": "Yes, if your tools can run sandboxed and your OpenClaw configuration keeps execution inside Docker. OpenClaw distinguishes sandboxing, tool policy, and elevated host execution, and you should avoid elevated paths unless you explicitly need them."
    },
    {
      "q": "Does Claw EA provide egress allowlists and budget caps?",
      "a": "Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are planned or can be implemented, but they are not presented here as shipped features. The shipped core is WPC, CST, gateway receipts, proof bundles, and job-scoped anti-replay binding."
    }
  ],
  "sources": [
    {
      "title": "Agent management for enterprises - GitHub Docs",
      "uri": "https://docs.github.com/copilot/concepts/agents/enterprise-management"
    },
    {
      "title": "Integrate Amazon Bedrock Agents with Slack | Amazon Web Services",
      "uri": "https://aws.amazon.com/blogs/machine-learning/integrate-amazon-bedrock-agents-with-slack"
    },
    {
      "title": "Salesforce Announces 2026 Connectivity Report",
      "uri": "https://www.salesforce.com/news/stories/connectivity-report-announcement-2026/"
    },
    {
      "title": "Agentforce: The AI Agent Platform | Salesforce CA",
      "uri": "https://www.salesforce.com/ca/agentforce/"
    },
    {
      "title": "Work with AI Agents in Slack using Agentforce",
      "uri": "https://www.salesforce.com/slack/agentforce/?bc=HA"
    },
    {
      "title": "Salesforce Expands MuleSoft Agent Fabric with Automated Discovery",
      "uri": "https://www.salesforce.com/news/stories/mulesoft-agent-fabric-automated-agent-discovery/"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:03:20.661Z",
  "indexable": true
}