{
  "slug": "channels/google-chat",
  "title": "Google Chat AI Agent Control Plane | Claw EA",
  "category": "channels",
  "html": "<h2>Direct Answer</h2>\n<p>Claw EA turns Google Chat into a permissioned control plane for enterprise agents, where actions are executed only under a Work Policy Contract (WPC) and every model call is receipted. OpenClaw is the baseline agent runtime, and Claw EA adds policy-as-code, scoped tokens (CST), gateway receipts, and proof bundles so your security team can verify what happened after the fact.</p>\n<p>Prompt-only rules are not enough in chat environments because any user message can carry prompt injection, tool-jailbreak attempts, or ‚Äúact-as-admin‚Äù social engineering. The execution layer must be permissioned so the agent cannot exceed a machine-enforced tool policy even when the prompt tries to override it.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>1) Define the Google Chat surface you will allow: which spaces, which user identities, and what triggers count as valid work. If you are using a Google Chat app, this is implemented via official API handling for messages, mentions, slash commands, and interactive cards.</p>\n<p>2) Start from a minimal OpenClaw tool profile and enable sandboxing for channel sessions, then deny elevated execution by default. This constrains what the agent can do even if a chat prompt tries to escalate into filesystem or shell actions.</p>\n<p>3) Write a WPC that describes allowed tools, data handling, and approval requirements, then publish it to the WPC registry so it is signed and hash-addressed (served by clawcontrols). In Claw EA runs, pin the policy by hash so the runtime fails closed if the policy changes unexpectedly.</p>\n<p>4) Configure Claw EA to mint a CST for each job with a scope hash and optional policy hash pinning (CST is issued by clawscope). Bind the CST to the job so replaying a token in a different chat or later run is rejected.</p>\n<p>5) Route model calls through clawproxy, including OpenRouter via fal when you use that path, so you get gateway receipts for every model call. Keep the Google Chat side ‚Äúthin‚Äù and treat it as an input and approval surface, not the enforcement point.</p>\n<p>6) Implement approvals in the chat UI: the agent posts an approval request (for example, ‚ÄúSend message to space X‚Äù or ‚ÄúCreate ticket with text Y‚Äù), and only after approval do you start a job that has the CST pinned to the WPC. This can be implemented via official API interactive cards, or via an MCP server that fronts your internal approval system.</p>\n\n<h2>Threat model</h2>\n<p>Google Chat is a high-risk input channel because many people can type into the same space and past messages get quoted. Treat every message as untrusted input and assume prompt injection is routine, not exceptional.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection in a space</td>\n      <td>User message instructs the agent to ignore policy, exfiltrate data, or run unsafe tools.</td>\n      <td>Permissioned execution: OpenClaw tool policy plus sandboxing; WPC defines allowed tools and required approvals so ‚Äúignore instructions‚Äù cannot expand permissions.</td>\n    </tr>\n    <tr>\n      <td>Tool misuse via ‚Äúhelpful‚Äù automation</td>\n      <td>Agent takes action on the wrong target (wrong space, wrong customer, wrong system) because context is ambiguous.</td>\n      <td>WPC requires explicit target binding (space IDs, project IDs) and forces approvals for cross-space posting or external side effects.</td>\n    </tr>\n    <tr>\n      <td>Credential leakage in chat</td>\n      <td>Secrets or tokens get pasted into the conversation or echoed back by the agent.</td>\n      <td>Redaction discipline plus narrow tool outputs; keep secrets out of chat and use short-lived CSTs with pinned scope hash for execution identity.</td>\n    </tr>\n    <tr>\n      <td>Model call disputes</td>\n      <td>Teams cannot prove which model was called, what inputs were sent, or whether a run respected policy.</td>\n      <td>Gateway receipts from clawproxy and proof bundles for each run, suitable for verification and later audit.</td>\n    </tr>\n    <tr>\n      <td>Replay of an approval or token</td>\n      <td>An attacker reuses an earlier approval artifact or token to re-trigger an action later.</td>\n      <td>Marketplace anti-replay binding with job-scoped CST binding, plus policy hash pinning to prevent ‚Äúapprove once, run different code later.‚Äù</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the intent for a Google Chat controlled agent: accept work only from specific spaces, require mention to reduce accidental triggers, and force approvals for external side effects. The WPC is signed and hash-addressed, and the run pins to that hash.</p>\n<pre>\n{\n  \"wpc\": {\n    \"name\": \"google-chat-agent-prod\",\n    \"version\": \"2026-02-11\",\n    \"channel\": \"google_chat\",\n    \"inputs\": {\n      \"allowed_spaces\": [\"spaces/AAA...\", \"spaces/BBB...\"],\n      \"allowed_senders\": [\"users/alice@corp\", \"users/oncall@corp\"],\n      \"require_explicit_trigger\": true\n    },\n    \"tools\": {\n      \"allow\": [\"summarize\", \"draft_reply\", \"lookup_internal_doc\"],\n      \"deny\": [\"shell.exec\", \"filesystem.write\", \"browser.remote_control\"],\n      \"sandbox\": { \"mode\": \"all\", \"workspaceAccess\": \"ro\" }\n    },\n    \"approvals\": [\n      { \"when\": \"post_to_other_space\", \"required\": true },\n      { \"when\": \"external_ticket_create\", \"required\": true }\n    ],\n    \"data_handling\": {\n      \"no_secrets_in_chat\": true,\n      \"redact_outputs\": [\"tokens\", \"api_keys\"]\n    }\n  },\n  \"execution\": {\n    \"cst\": {\n      \"scope_hash\": \"sha256:...\",\n      \"policy_hash_pinning\": \"sha256:... (WPC hash)\"\n    }\n  }\n}\n</pre>\n<p>In practice, the agent can still draft text and propose actions in Google Chat, but it cannot execute the gated actions until an approval event results in a new job with the pinned WPC. This prevents ‚Äúapprove the idea‚Äù from becoming ‚Äúapprove any future action.‚Äù</p>\n\n<h2>What proof do you get?</h2>\n<p>For each run triggered from Google Chat, Claw EA can produce a proof bundle that ties together identity, policy, and model activity. The proof bundle includes gateway receipts, which are signed receipts emitted by clawproxy for model calls, so you can verify the call sequence and metadata without trusting the chat transcript.</p>\n<p>Operationally, you can attach a short ‚Äúrun receipt‚Äù summary back into the Chat thread (for example: run ID, WPC hash, and a verification status), and store the full proof bundle for audit. If you publish the bundle to the marketplace, you can view it as a Trust Pulse artifact for audit and review.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollbacks in chat need to be fast because mistakes propagate in front of users. Aim for a posture where you can stop execution immediately, then prove what happened using receipts and the pinned WPC hash.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Bad agent behavior in a space</td>\n      <td>Disable the Google Chat app in the space and stop issuing new jobs for that channel.</td>\n      <td>Proof bundle for the last runs; WPC hash shows the exact policy in force.</td>\n    </tr>\n    <tr>\n      <td>Policy bug (too-permissive tools)</td>\n      <td>Publish a tighter WPC and require policy hash pinning so old jobs cannot silently use the new policy.</td>\n      <td>WPC registry record plus run metadata showing which policy hash was pinned.</td>\n    </tr>\n    <tr>\n      <td>Suspected token misuse</td>\n      <td>Move to shorter CST lifetimes and rotate job-scoped binding; revocation workflows can be implemented if you need immediate invalidation.</td>\n      <td>Job-scoped CST binding and run logs showing which CST scope hash was accepted.</td>\n    </tr>\n    <tr>\n      <td>Dispute about a model-generated message</td>\n      <td>Freeze changes, replay from the proof bundle, and verify gateway receipts for the exact model calls used.</td>\n      <td>Gateway receipts and the proof bundle verification output.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>How does Google Chat change agent security compared to a web app?</h3>\n<p>Chat adds untrusted, multi-party input and encourages users to ‚Äútry stuff‚Äù until it works. That is why prompt-only controls fail and why you need permissioned execution under a WPC with enforced tool policy.</p>\n\n<h3>Can approvals happen directly inside Google Chat?</h3>\n<p>Yes, approvals can be implemented using interactive Chat UI elements via official API, or by routing approval events through an MCP server that talks to your internal system. The key is that approval results in a job that pins the WPC hash and mints a job-scoped CST, rather than toggling a prompt flag.</p>\n\n<h3>What do I show an auditor after an incident?</h3>\n<p>Provide the proof bundle for the run, including gateway receipts for the model calls, and the WPC hash that was pinned during execution. This makes it clear what the agent was allowed to do and what model traffic actually occurred.</p>\n\n<h3>Do I need to sandbox if I already have a WPC?</h3>\n<p>Yes, because policy describes intent, but sandboxing reduces blast radius when a tool behaves unexpectedly or a configuration is wrong. OpenClaw separates sandboxing, tool policy, and elevated execution, and you should keep elevated paths closed unless you have a concrete reason.</p>\n\n<h3>What if we want additional controls like egress allowlists or cost budgets?</h3>\n<p>Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are optional or planned items. If you need them now, they can be implemented as an enterprise buildout around the execution environment and job scheduler.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://cloud.google.com/agentspace/agentspace-enterprise/docs/access-control\">Access control with IAM (Agentspace Enterprise)</a></li>\n  <li><a href=\"https://codelabs.developers.google.com/secure-customer-service-agent/instructions\">Build a Secure Agent with Model Armor and Identity (Google Codelabs)</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Claw EA turns Google Chat into a permissioned control plane for enterprise agents, where actions are executed only under a Work Policy Contract (WPC) and every model call is receipted. OpenClaw is the baseline agent runt",
  "faqs": [
    {
      "q": "How does Google Chat change agent security compared to a web app?",
      "a": "Chat adds untrusted, multi-party input and encourages users to ‚Äútry stuff‚Äù until it works. That is why prompt-only controls fail and why you need permissioned execution under a WPC with enforced tool policy."
    },
    {
      "q": "Can approvals happen directly inside Google Chat?",
      "a": "Yes, approvals can be implemented using interactive Chat UI elements via official API, or by routing approval events through an MCP server that talks to your internal system. The key is that approval results in a job that pins the WPC hash and mints a job-scoped CST, rather than toggling a prompt flag."
    },
    {
      "q": "What do I show an auditor after an incident?",
      "a": "Provide the proof bundle for the run, including gateway receipts for the model calls, and the WPC hash that was pinned during execution. This makes it clear what the agent was allowed to do and what model traffic actually occurred."
    },
    {
      "q": "Do I need to sandbox if I already have a WPC?",
      "a": "Yes, because policy describes intent, but sandboxing reduces blast radius when a tool behaves unexpectedly or a configuration is wrong. OpenClaw separates sandboxing, tool policy, and elevated execution, and you should keep elevated paths closed unless you have a concrete reason."
    },
    {
      "q": "What if we want additional controls like egress allowlists or cost budgets?",
      "a": "Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are optional or planned items. If you need them now, they can be implemented as an enterprise buildout around the execution environment and job scheduler."
    }
  ],
  "sources": [
    {
      "title": "Agent Engine Threat Detection overview | Security Command Center",
      "uri": "https://docs.cloud.google.com/security-command-center/docs/agent-engine-threat-detection-overview"
    },
    {
      "title": "Agentspace security overview",
      "uri": "https://cloud.google.com/agentspace/docs/security-overview"
    },
    {
      "title": "üõ°Ô∏è Build a Secure Agent with Model Armor and Identity",
      "uri": "https://codelabs.developers.google.com/secure-customer-service-agent/instructions"
    },
    {
      "title": "Access control with IAM",
      "uri": "https://cloud.google.com/agentspace/agentspace-enterprise/docs/access-control"
    },
    {
      "title": "Managing access for deployed agents",
      "uri": "https://docs.cloud.google.com/agent-builder/agent-engine/manage/access"
    },
    {
      "title": "Access control",
      "uri": "https://docs.cloud.google.com/dialogflow/cx/docs/concept/access-control"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:58:15.096Z",
  "indexable": true
}