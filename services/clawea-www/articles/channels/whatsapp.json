{
  "slug": "channels/whatsapp",
  "title": "WhatsApp AI Agent Control Plane | Claw EA",
  "category": "channels",
  "html": "<p>Claw EA makes WhatsApp a controlled entry point for enterprise agents by running the agent in OpenClaw and forcing every sensitive action through policy checks, scoped credentials, and verifiable model-call evidence. You use a WPC to define what the agent is allowed to do, a CST to bind each run to that policy, and gateway receipts plus proof bundles to audit what the model actually asked for and what the system allowed.</p>\n<p>WhatsApp is a good control plane when you want approvals and lightweight operator intervention to happen in the same conversation users already use. It is not a magic security boundary, so the execution layer must be permissioned (policy-as-code), not “prompt-only,” because prompts can be overwritten by user messages and injection attempts.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this flow when you want a WhatsApp-facing agent that can answer questions, request approvals, and perform limited work with a paper trail. The WhatsApp integration itself can be done via official API or via an MCP server, depending on your environment and vendor choice.</p>\n<ol>\n  <li>\n    <p><strong>Define the WhatsApp channel contract.</strong> Decide what counts as “in-scope”: which WhatsApp numbers, which conversation types (1:1 vs group), and what the agent is allowed to do without approval. Write those rules into a WPC so enforcement does not depend on the prompt.</p>\n  </li>\n  <li>\n    <p><strong>Register the WPC and record the policy hash.</strong> Store the signed Work Policy Contract (WPC) in the WPC registry (served by clawcontrols). Treat the policy hash as a deploy artifact that you can reference in tickets and change control.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for this job, pinned to the policy.</strong> Use a CST (issued by clawscope) that includes a scope hash and, when you want fail-closed behavior, optional policy hash pinning to the WPC. This prevents a WhatsApp-triggered run from silently widening privileges.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent in OpenClaw with conservative local controls.</strong> Configure OpenClaw tool policy (allow and deny lists) and sandbox mode so that tool execution has a smaller blast radius. Make “no tools by default” the starting point, then allow only what the WPC requires.</p>\n  </li>\n  <li>\n    <p><strong>Route model traffic through clawproxy.</strong> Send model calls through clawproxy so you get gateway receipts for each call, including binding to the job-scoped CST. If you use OpenRouter via fal, route it through clawproxy for the same receipt behavior.</p>\n  </li>\n  <li>\n    <p><strong>Build approvals into the WhatsApp conversation.</strong> For actions that change state (refunds, cancellations, outbound emails, updates to CRM), require an explicit “approve” message and tie that approval to a single job-scoped CST so it cannot be replayed later. Store the approval decision as part of the run metadata that is included with the proof bundle.</p>\n  </li>\n  <li>\n    <p><strong>Produce a proof bundle and store it for audit.</strong> At the end of the run, output a proof bundle that includes gateway receipts and the policy identifiers used. Optionally store and view the artifact in Trust Pulse when you need a reviewable record.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>WhatsApp increases operational risk because any inbound message is untrusted input, and operators tend to treat chat threads as “informal.” The safe pattern is: treat WhatsApp as the UI, and treat execution as a separate permissioned system that enforces WPC and CST constraints.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection from a user message</td>\n      <td>The model is instructed to ignore policy and take an unsafe tool action.</td>\n      <td>Enforce permissions in code via WPC plus OpenClaw tool policy; the prompt can suggest, but the runtime denies disallowed tools and operations.</td>\n    </tr>\n    <tr>\n      <td>Impersonation of an approver</td>\n      <td>Someone spoofs an “approve” message to trigger a sensitive action.</td>\n      <td>Require approver identity checks outside the model (enterprise buildout) and bind the approval to a job-scoped CST so it cannot be replayed in another run.</td>\n    </tr>\n    <tr>\n      <td>Replay of an earlier approval</td>\n      <td>An attacker copies an “approved” snippet from an old chat and reuses it.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding, and verify that the approval is attached to the current job id and policy hash.</td>\n    </tr>\n    <tr>\n      <td>Model-provider dispute or audit gap</td>\n      <td>You cannot prove what the model call contained or which model was used.</td>\n      <td>Route model calls through clawproxy and retain gateway receipts; verify receipts and package them in a proof bundle for audit.</td>\n    </tr>\n    <tr>\n      <td>Over-broad local tool access</td>\n      <td>The agent can read files, hit internal URLs, or execute shell commands beyond intent.</td>\n      <td>Use OpenClaw sandboxing where appropriate and keep tool allowlists tight; treat “elevated” host execution as exceptional and explicitly gated.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This snippet is intentionally small and operational. It models a WhatsApp-triggered agent that can answer questions and open tickets, but requires explicit approval for state-changing actions and pins the run to a specific WPC hash.</p>\n<pre>{\n  \"wpc_version\": \"wpc.v1\",\n  \"channel\": {\n    \"type\": \"whatsapp\",\n    \"inbound\": {\n      \"allowed_senders\": [\"+15551230001\", \"+15551230002\"],\n      \"allow_groups\": false\n    },\n    \"approvals\": {\n      \"required_for\": [\"refund\", \"cancel_order\", \"send_external_message\"],\n      \"format\": \"APPROVE <job_id>\"\n    }\n  },\n  \"execution\": {\n    \"runtime\": \"openclaw\",\n    \"sandbox\": { \"mode\": \"all\", \"workspaceAccess\": \"ro\" },\n    \"tools\": {\n      \"allow\": [\"kb.search\", \"ticket.create\"],\n      \"deny\": [\"shell.exec\", \"filesystem.read\", \"filesystem.write\"]\n    }\n  },\n  \"auth\": {\n    \"cst\": {\n      \"require_scope_hash\": true,\n      \"pin_policy_hash\": \"b64u:POLICY_HASH_FROM_WPC_REGISTRY\"\n    }\n  },\n  \"model_calls\": {\n    \"must_go_via\": \"clawproxy\",\n    \"receipts\": \"required\"\n  }\n}</pre>\n<p>The key idea is separation of concerns: the WhatsApp message can request a refund, but the refund tool is not available unless an approval step is satisfied and the WPC permits that action. If the model tries anyway, the tool call is denied and the attempt is visible in logs and proofs.</p>\n\n<h2>What proof do you get?</h2>\n<p>For each model call routed through clawproxy, you get gateway receipts that can be verified later. Those receipts are bound to the CST used for the job, so you can show that a given run was operating under a specific scope and, when pinned, a specific WPC hash.</p>\n<p>At the run level, you get a proof bundle that collects receipts and the metadata needed to audit the run. When you need a reviewable artifact for risk, audit, or customer support escalation, you can store and view the proof bundle in Trust Pulse.</p>\n\n<h2>Rollback posture</h2>\n<p>Chat-driven agents fail in messy ways: wrong tool call, wrong recipient, wrong timing. Rollback is mostly about having tight permissions, quick disable paths, and evidence that lets humans remediate fast.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Policy mistake (too permissive)</td>\n      <td>Rotate to a stricter WPC and require CST policy hash pinning for new jobs; stop issuing CSTs for the old policy.</td>\n      <td>WPC hash in the proof bundle, and CST metadata showing which jobs ran under which policy.</td>\n    </tr>\n    <tr>\n      <td>Compromised or misused token</td>\n      <td>Revoke CST issuance path and re-issue short-lived CSTs for new jobs; invalidate the job scope.</td>\n      <td>CST usage can be correlated to gateway receipts, showing which model calls were made under that token.</td>\n    </tr>\n    <tr>\n      <td>Bad model output that triggers unsafe intent</td>\n      <td>Deny the tool call at policy enforcement; require explicit approval for the action class going forward.</td>\n      <td>Gateway receipts show the attempted model call sequence; the proof bundle shows that the runtime denied disallowed actions.</td>\n    </tr>\n    <tr>\n      <td>Wrong recipient or conversation routing</td>\n      <td>Disable the WhatsApp channel mapping (via official API or enterprise buildout) and re-enable only after allowlist review.</td>\n      <td>Run metadata plus your channel logs; proof bundle anchors the timing and job id that produced the outbound attempt.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why isn’t prompt-only control sufficient for WhatsApp agents?</h3>\n<p>Because the next inbound message can overwrite instructions, and the model can be coerced into attempting disallowed actions. Policy-as-code (WPC plus runtime enforcement) makes the permission boundary non-negotiable even when the conversation is adversarial.</p>\n\n<h3>How do approvals show up in WhatsApp?</h3>\n<p>Approvals can be a simple explicit message like “APPROVE &lt;job_id&gt;” in the same thread, with the agent refusing to proceed without it. The approval is then tied to the job-scoped CST binding so it cannot be reused for a different run.</p>\n\n<h3>What exactly is auditable after an incident?</h3>\n<p>You can produce gateway receipts for model calls and a proof bundle that groups them with job metadata and policy identifiers. That lets an auditor verify which policy was supposed to apply, which token scope was used, and what model calls were made through the proxy.</p>\n\n<h3>Can Claw EA connect directly to the WhatsApp Business Platform?</h3>\n<p>It depends on your setup. Integrations are done via official API or via an MCP server, and enterprise buildout is typical when you need strict identity, approvals, or custom routing.</p>\n\n<h3>Where does OpenClaw fit compared to Claw Bureau primitives?</h3>\n<p>OpenClaw is the baseline agent runtime that runs tools, channels, and sandboxing locally. Claw Bureau primitives add portable policy (WPC), scoped authorization (CST), and verifiable evidence (gateway receipts and proof bundles) around those runs.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-copilot-studio/publication-add-bot-to-whatsapp\">Publish an agent to WhatsApp - Microsoft Copilot Studio</a></li>\n  <li><a href=\"https://aws.amazon.com/blogs/messaging-and-targeting/best-practices-for-building-high-performance-whatsapp-ai-assistant-using-aws/\">Best practices for building high-performance WhatsApp AI assistant using AWS</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Claw EA makes WhatsApp a controlled entry point for enterprise agents by running the agent in OpenClaw and forcing every sensitive action through policy checks, scoped credentials, and verifiable model-call evidence. You",
  "faqs": [
    {
      "q": "Why isn’t prompt-only control sufficient for WhatsApp agents?",
      "a": "Because the next inbound message can overwrite instructions, and the model can be coerced into attempting disallowed actions. Policy-as-code (WPC plus runtime enforcement) makes the permission boundary non-negotiable even when the conversation is adversarial."
    },
    {
      "q": "How do approvals show up in WhatsApp?",
      "a": "Approvals can be a simple explicit message like “APPROVE <job_id>” in the same thread, with the agent refusing to proceed without it. The approval is then tied to the job-scoped CST binding so it cannot be reused for a different run."
    },
    {
      "q": "What exactly is auditable after an incident?",
      "a": "You can produce gateway receipts for model calls and a proof bundle that groups them with job metadata and policy identifiers. That lets an auditor verify which policy was supposed to apply, which token scope was used, and what model calls were made through the proxy."
    },
    {
      "q": "Can Claw EA connect directly to the WhatsApp Business Platform?",
      "a": "It depends on your setup. Integrations are done via official API or via an MCP server, and enterprise buildout is typical when you need strict identity, approvals, or custom routing."
    },
    {
      "q": "Where does OpenClaw fit compared to Claw Bureau primitives?",
      "a": "OpenClaw is the baseline agent runtime that runs tools, channels, and sandboxing locally. Claw Bureau primitives add portable policy (WPC), scoped authorization (CST), and verifiable evidence (gateway receipts and proof bundles) around those runs."
    }
  ],
  "sources": [
    {
      "title": "Publish an agent to WhatsApp - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/publication-add-bot-to-whatsapp"
    },
    {
      "title": "Publish agents to WhatsApp",
      "uri": "https://learn.microsoft.com/en-us/power-platform/release-plan/2025wave1/microsoft-copilot-studio/deploy-copilots-whatsapp-azure-communications-service-chat-sms-channels"
    },
    {
      "title": "Best practices for building high-performance WhatsApp AI assistant using AWS | Amazon Web Services",
      "uri": "https://aws.amazon.com/blogs/messaging-and-targeting/best-practices-for-building-high-performance-whatsapp-ai-assistant-using-aws/"
    },
    {
      "title": "Deploy copilots to WhatsApp, Azure Communication Services Chat and SMS channels",
      "uri": "https://learn.microsoft.com/en-us/power-platform/release-plan/2024wave2/microsoft-copilot-studio/deploy-copilots-whatsapp-azure-communications-service-chat-sms-channels"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T12:05:16.817Z",
  "indexable": true
}