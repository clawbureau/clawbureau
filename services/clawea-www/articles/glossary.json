{
  "slug": "glossary",
  "title": "Glossary: Enterprise Agent Security and Policy Terms | Claw EA",
  "category": "hubs",
  "html": "<h2>Direct Answer</h2>\n<p>This page defines the security and policy terms teams use when they run enterprise AI agents, with OpenClaw as the baseline agent runtime. The focus is on permissioned execution: machine-enforced policy-as-code that constrains tools, tokens, and model traffic, instead of relying on prompt instructions that can be bypassed.</p>\n<p>Claw EA applies this by binding runs to a WPC (Work Policy Contract), authenticating components with CST (scoped token), and producing gateway receipts and proof bundles so you can verify what actually happened after the fact.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this runbook when you need a shared language across security, platform engineering, and compliance. It is also a practical checklist for setting up a controlled agent execution path.</p>\n<ol>\n  <li>\n    <p><strong>Define the work boundary.</strong> Write down what the agent is allowed to do, what it must never do, and what data classes it can touch. Convert that into a WPC so policy is a signed, hash-addressed artifact instead of a wiki page.</p>\n  </li>\n  <li>\n    <p><strong>Bind identity and scope to the job.</strong> Issue a CST (scoped token) for the agent job, and keep its scope minimal for the tools and services required. Where appropriate, pin the CST to a specific policy hash so the run cannot silently “upgrade” its permissions.</p>\n  </li>\n  <li>\n    <p><strong>Constrain tool execution locally.</strong> In OpenClaw, set tool allow/deny profiles and decide where tools run (Docker sandbox vs host) so the local blast radius is bounded even if the model is tricked. Run the OpenClaw security audit regularly, especially after config or plugin changes.</p>\n  </li>\n  <li>\n    <p><strong>Receipt model calls.</strong> Route model traffic through clawproxy so you get gateway receipts for each model call. Treat receipts as evidence, not logs, and ensure your operations workflow knows how to retrieve and store them.</p>\n  </li>\n  <li>\n    <p><strong>Package evidence for review.</strong> Produce a proof bundle at the end of the run so audit and incident response can verify constraints, model calls, and metadata without scraping multiple systems. If you need centralized viewing, store the artifact as a Trust Pulse.</p>\n  </li>\n  <li>\n    <p><strong>Operationalize “stop the bleeding”.</strong> Decide ahead of time which switches you can pull during an incident: disabling tools, rotating CST issuance, and forcing policy hash changes. Make sure the on-call path can execute these changes without editing prompts or redeploying the whole runtime.</p>\n  </li>\n</ol>\n<p><strong>How to get started checklist:</strong></p>\n<ul>\n  <li>Pick one agent workflow and write a first-cut WPC for it (tools, data, approvals, time limits).</li>\n  <li>Run OpenClaw in sandbox mode for that workflow and tighten tool policy until it still works.</li>\n  <li>Enable clawproxy in the model path so every call emits gateway receipts.</li>\n  <li>Require CST per job, not a long-lived token shared across agents.</li>\n  <li>Make “proof bundle required” a release gate for production agent runs.</li>\n</ul>\n\n<h2>Threat model</h2>\n<p>Enterprise agents fail in repeatable ways: they take actions outside intent, they leak data, or they become hard to audit after an incident. Prompt-only controls are not stable under adversarial input because the same channel that carries instructions also carries attacks.</p>\n<p>Permissioned execution moves control into the execution layer: WPC defines allowed actions, CST gates access at call time, and gateway receipts plus proof bundles give you verifiable records.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control you want in place</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection into tool use</td>\n      <td>An attacker convinces the agent to call a sensitive tool (shell, file write, browser automation) using malicious inputs.</td>\n      <td>OpenClaw tool policy allow/deny and sandboxing to reduce blast radius, plus a WPC that explicitly enumerates allowed tool classes for the job.</td>\n    </tr>\n    <tr>\n      <td>Scope creep across runs</td>\n      <td>A token or config intended for one workflow is reused, granting broader access than expected in later jobs.</td>\n      <td>Per-job CST issuance and marketplace anti-replay binding (job-scoped CST binding). Optionally pin CST to a policy hash so the run’s authority is tied to a specific WPC.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable model behavior after incident</td>\n      <td>You cannot prove which model calls occurred, with what inputs/outputs, or whether traffic bypassed controls.</td>\n      <td>Route model calls through clawproxy to emit gateway receipts, then package them into a proof bundle for audit and verification.</td>\n    </tr>\n    <tr>\n      <td>Hidden plugin or config drift</td>\n      <td>An operator changes a plugin, tool profile, or sandbox mode and unintentionally exposes new capabilities.</td>\n      <td>Run OpenClaw security audit and review effective sandbox and tool policy settings. Treat WPC updates as controlled change with signed artifacts that are fetched and verified.</td>\n    </tr>\n    <tr>\n      <td>Over-broad external data access</td>\n      <td>The agent can pull or exfiltrate sensitive data because network and tool permissions were not bounded.</td>\n      <td>Use policy-as-code to restrict which tools can access which data classes and require approvals for high-risk actions. Egress allowlists enforced outside clawproxy can be implemented as an additional layer (optional).</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>A policy is useful only if it is enforceable and reviewable. A WPC (Work Policy Contract) is a signed, hash-addressed policy artifact served by clawcontrols, designed to be fetched and verified rather than copied into prompts.</p>\n<p>Below is a JSON-like example showing the intent you should capture; treat field names as illustrative and adapt to your internal policy conventions.</p>\n<pre>\n{\n  \"policy_name\": \"invoice-triage-prod\",\n  \"policy_hash\": \"b64u:...hash...\",\n  \"allowed_tools\": [\n    \"read_only_repo\",\n    \"ticket_comment\",\n    \"model_call_via_clawproxy\"\n  ],\n  \"denied_tools\": [\n    \"shell_exec\",\n    \"write_filesystem\",\n    \"browser_remote_control\"\n  ],\n  \"data_classes_allowed\": [\"internal\", \"confidential\"],\n  \"data_classes_denied\": [\"regulated_pii\"],\n  \"approvals\": [\n    { \"action\": \"send_external_email\", \"required\": true }\n  ],\n  \"token_requirements\": {\n    \"require_cst\": true,\n    \"pin_cst_to_policy_hash\": true,\n    \"max_ttl_minutes\": 30\n  },\n  \"evidence_requirements\": {\n    \"require_gateway_receipts\": true,\n    \"require_proof_bundle\": true\n  }\n}\n</pre>\n<p>The key idea is separation of concerns: prompts explain how to do the work, while the execution layer decides what is permitted. If the model is manipulated, the policy still blocks forbidden tool calls and forces evidence capture.</p>\n\n<h2>What proof do you get?</h2>\n<p>Claw EA produces evidence designed for verification workflows. You should assume the question after any incident will be: “Show me exactly what the agent did, and prove it ran under the intended constraints.”</p>\n<ul>\n  <li>\n    <p><strong>Gateway receipts.</strong> Signed receipts emitted by clawproxy for model calls. Use these to verify that model traffic went through the approved gateway and to correlate calls to a specific job context.</p>\n  </li>\n  <li>\n    <p><strong>Proof bundle.</strong> A harness artifact bundling receipts and related metadata for audit/verification. This is the unit you can hand to another team for review without giving them access to your runtime.</p>\n  </li>\n  <li>\n    <p><strong>Trust Pulse.</strong> A marketplace-stored artifact for audit/viewing. Use it when you want a durable place to view and share the evidence, separate from operational logs.</p>\n  </li>\n  <li>\n    <p><strong>WPC linkage.</strong> Runs can reference a WPC by hash, so reviewers can confirm which policy was intended. When paired with CST policy hash pinning, the run’s authority and its declared policy stay aligned.</p>\n  </li>\n</ul>\n\n<h2>Rollback posture</h2>\n<p>Rollback for agent systems is not just “deploy the previous version.” You need a posture that safely stops actions, constrains further access, and preserves evidence so you can understand impact.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence you keep</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Suspected prompt injection in a live channel</td>\n      <td>Disable or deny the affected tool set via policy, and force subsequent runs to use a tighter WPC hash. Keep the agent online only in read-only or no-tool mode until review is complete.</td>\n      <td>Gateway receipts for the suspect model calls and a proof bundle for the job window.</td>\n    </tr>\n    <tr>\n      <td>Token exposure or misuse</td>\n      <td>Revoke and re-issue CST for the job, and stop accepting long-lived tokens for agent execution. Require job-scoped CST binding to prevent replay in other jobs.</td>\n      <td>Token issuance and job metadata references inside the proof bundle (plus receipts for calls made with the exposed token).</td>\n    </tr>\n    <tr>\n      <td>Unexpected tool capability discovered</td>\n      <td>Tighten OpenClaw tool policy (deny list or profile change) and, if needed, move execution into sandbox mode for that agent. Re-run OpenClaw security audit and record the configuration delta.</td>\n      <td>Proof bundle plus the before/after policy hashes and the OpenClaw audit output in your change record.</td>\n    </tr>\n    <tr>\n      <td>Model route bypass suspected</td>\n      <td>Force model calls through clawproxy only, and treat any direct-to-vendor model path as non-compliant for production. Require “proof bundle required” for job completion.</td>\n      <td>Gateway receipts provide the verification anchor that traffic took the intended path.</td>\n    </tr>\n  </tbody>\n</table>\n<p>If you need network-level containment, egress allowlists enforced outside clawproxy can be implemented as an additional control (optional). Keep that change separate from application logic so rollback is fast and predictable.</p>\n\n<h2>FAQ</h2>\n\n<h3>Why is prompt-only control not enough for enterprise agents?</h3>\n<p>Prompts are part of the same input stream an attacker can manipulate. Policy-as-code puts the decision in the execution layer, so forbidden tool calls fail even when the model is persuaded to attempt them.</p>\n\n<h3>How do WPC and CST relate during a run?</h3>\n<p>A WPC defines what is allowed, and a CST is the credential the runtime presents when it tries to do work. With optional policy hash pinning, the CST can be tied to a specific WPC hash so scope and policy cannot drift mid-run.</p>\n\n<h3>What is the practical value of gateway receipts?</h3>\n<p>They let you verify that model calls went through clawproxy and were associated with a specific job context. This reduces ambiguity during incident response, vendor escalation, and internal audits.</p>\n\n<h3>How does OpenClaw fit into this glossary?</h3>\n<p>OpenClaw is the baseline agent runtime where tool policy and sandboxing are enforced locally. Claw EA complements that with portable policy artifacts (WPC), job-scoped authorization (CST), and verifiable evidence (gateway receipts and proof bundles).</p>\n\n<h3>Does this replace Microsoft Purview or other compliance tooling?</h3>\n<p>No. Treat it as execution control and evidence capture for agent runs, which can complement broader compliance and data governance programs.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://genai.owasp.org/glossary/\">LLM &amp; AI Security Glossary | OWASP GenAI Security Project</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization\">Governance and security for AI agents across the organization (Microsoft Cloud Adoption Framework)</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/purview/ai-agents\">Use Microsoft Purview to manage data security &amp; compliance for AI agents</a></li>\n</ul>",
  "description": "This page defines the security and policy terms teams use when they run enterprise AI agents, with OpenClaw as the baseline agent runtime. The focus is on permissioned execution: machine-enforced policy-as-code that cons",
  "faqs": [
    {
      "q": "Why is prompt-only control not enough for enterprise agents?",
      "a": "Prompts are part of the same input stream an attacker can manipulate. Policy-as-code puts the decision in the execution layer, so forbidden tool calls fail even when the model is persuaded to attempt them."
    },
    {
      "q": "How do WPC and CST relate during a run?",
      "a": "A WPC defines what is allowed, and a CST is the credential the runtime presents when it tries to do work. With optional policy hash pinning, the CST can be tied to a specific WPC hash so scope and policy cannot drift mid-run."
    },
    {
      "q": "What is the practical value of gateway receipts?",
      "a": "They let you verify that model calls went through clawproxy and were associated with a specific job context. This reduces ambiguity during incident response, vendor escalation, and internal audits."
    },
    {
      "q": "How does OpenClaw fit into this glossary?",
      "a": "OpenClaw is the baseline agent runtime where tool policy and sandboxing are enforced locally. Claw EA complements that with portable policy artifacts (WPC), job-scoped authorization (CST), and verifiable evidence (gateway receipts and proof bundles)."
    },
    {
      "q": "Does this replace Microsoft Purview or other compliance tooling?",
      "a": "No. Treat it as execution control and evidence capture for agent runs, which can complement broader compliance and data governance programs."
    }
  ],
  "sources": [
    {
      "title": "LLM & AI Security Glossary | Key Terms by OWASP LLM Project",
      "uri": "https://genai.owasp.org/glossary/"
    },
    {
      "title": "Use Microsoft Purview to manage data security & compliance for AI agents",
      "uri": "https://learn.microsoft.com/en-us/purview/ai-agents"
    },
    {
      "title": "Governance and security for AI agents across the organization",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization"
    },
    {
      "title": "Vertex AI glossary | Google Cloud Documentation",
      "uri": "https://docs.cloud.google.com/vertex-ai/docs/glossary"
    },
    {
      "title": "Choose your agentic AI architecture components \n\n    \n    \n       \n    \n\n     \n      \n      Stay organized with collections\n     \n     \n      \n      Save and categorize content based on your preferences.",
      "uri": "https://docs.cloud.google.com/architecture/choose-agentic-ai-architecture-components"
    },
    {
      "title": "25 Agentic AI Terms Every Business User Needs To Know - Salesforce",
      "uri": "https://www.salesforce.com/blog/agentic-ai-definitions/"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:57:18.546Z",
  "indexable": true
}