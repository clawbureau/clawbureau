{
  "slug": "channels",
  "title": "Chat Control Planes for Agents (Channels) | Claw EA",
  "category": "hubs",
  "html": "<p>Channels like Microsoft Teams and Slack are your agent’s public attack surface and your audit boundary. If you only rely on prompts, you cannot reliably stop a user from steering the agent into unsafe tools, data exposure, or unreviewed actions.</p>\n<p>Claw EA treats channels as a permissioned execution plane: OpenClaw is the baseline agent runtime, and every run is tied to a WPC (Work Policy Contract), authenticated with a CST (scoped token), and evidenced with gateway receipts and proof bundles. This gives security teams something operational to approve, verify, and roll back.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this runbook when you are turning a chat surface into an enterprise-controlled agent entry point. Keep the first deployment narrow and expand only after you can verify proofs and roll back quickly.</p>\n<ol>\n  <li>\n    <p><strong>Define the channel boundary and identity model.</strong> For Microsoft Teams, plan around Entra ID app registration and Microsoft Graph permissions/scopes, with Conditional Access and PIM for admin operations. For Slack, plan around workspace-level app install and OAuth scopes per Slack’s official API.</p>\n  </li>\n  <li>\n    <p><strong>Start with OpenClaw’s local guardrails.</strong> Configure channel allowlists and “only respond when mentioned” style behavior where supported, and run the built-in security audit regularly. Treat sandboxing and tool policy as the first blast-radius limiter before you add remote policy.</p>\n  </li>\n  <li>\n    <p><strong>Write a WPC and publish it.</strong> Create a WPC (Work Policy Contract) that specifies which channel contexts are allowed to trigger work and which tools are allowed to execute. Publish the signed, hash-addressed WPC artifact so it can be fetched and verified at runtime.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST that is pinned to the policy.</strong> Mint a CST (scoped token) from clawscope with a scope hash that matches the permitted actions, and optionally pin the policy hash to the CST. This makes the token unusable for “same token, different policy” drift.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy.</strong> Configure the agent runtime so model traffic is sent through clawproxy, which emits gateway receipts for each model call. If you use OpenRouter via fal, keep it routed through clawproxy so the receipts cover the model call path.</p>\n  </li>\n  <li>\n    <p><strong>Require proof bundles on completion and store them.</strong> For every job triggered from a channel, require a proof bundle that binds together the gateway receipts and run metadata. Store the resulting artifact in Trust Pulse for later review and spot checks.</p>\n  </li>\n</ol>\n<p><strong>How to get started checklist:</strong> pick one channel, one agent, one tool profile, and one WPC hash. Turn on sandboxing for non-main sessions, require allowlists, route models through clawproxy, and confirm you can retrieve and review the proof bundle for a single test run.</p>\n\n<h2>Threat model</h2>\n<p>Chat control planes fail in repeatable ways: the wrong user triggers the bot, the right user triggers the wrong capability, or the agent cannot prove what it did. The table below maps common channel threats to the control points you can actually operate.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection in a shared channel</td>\n      <td>A user message coerces the agent into calling high-impact tools or leaking prior context.</td>\n      <td>OpenClaw tool policy plus sandboxing for tool execution, then enforce a WPC that limits tool profiles and requires proof on completion.</td>\n    </tr>\n    <tr>\n      <td>Unauthorized user triggers the agent</td>\n      <td>Any member of a large room can invoke the agent, including external guests.</td>\n      <td>Channel allowlists and mention requirements in OpenClaw; restrict vendor-side access via Entra ID and Conditional Access, or Slack app install scope via official API.</td>\n    </tr>\n    <tr>\n      <td>Token reuse or replay across jobs</td>\n      <td>A captured token is reused to run similar work later, outside the intended request context.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding, plus optional policy hash pinning on the CST.</td>\n    </tr>\n    <tr>\n      <td>Disputed “who said what” in incident response</td>\n      <td>You cannot prove which model calls were made and under which policy.</td>\n      <td>Gateway receipts emitted by clawproxy and bundled into a proof bundle tied to the WPC hash and CST scope hash.</td>\n    </tr>\n    <tr>\n      <td>Over-broad vendor permissions</td>\n      <td>The bot app has more rights than the task needs, increasing data access and blast radius.</td>\n      <td>Use least-privilege Graph permissions/scopes for Teams and least-privilege Slack OAuth scopes; gate higher privilege changes through PIM and change control.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Channels are not just a UI; they are a multi-tenant input stream. Treat every message as untrusted input and keep the enforcement in code and policy, not in the prompt.</p>\n\n<h2>Policy-as-code example</h2>\n<p>A prompt can ask the model to “behave,” but it cannot enforce tool availability, token binding, or verifiable evidence. Permissioned execution means the runtime checks a signed WPC and a CST before work starts, and the proxy emits receipts while work is happening.</p>\n<p>Example WPC-shaped policy artifact (JSON-like) that you would sign and publish as a WPC:</p>\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"purpose\": \"Channel-triggered triage agent\",\n  \"channels\": {\n    \"teams\": { \"allowed_tenants\": [\"&lt;tenant-guid&gt;\"], \"allowed_teams\": [\"&lt;team-id&gt;\"] },\n    \"slack\": { \"allowed_workspaces\": [\"&lt;workspace-id&gt;\"], \"allowed_channels\": [\"#helpdesk-ai\"] }\n  },\n  \"tools\": {\n    \"profile\": \"triage_readonly\",\n    \"deny\": [\"exec\", \"write\", \"browser_remote_control\"]\n  },\n  \"model_calls\": {\n    \"route_via\": \"clawproxy\",\n    \"require_gateway_receipts\": true,\n    \"provider\": \"openrouter_via_fal\"\n  },\n  \"auth\": {\n    \"require_cst\": true,\n    \"cst_scope_hash\": \"&lt;hash&gt;\",\n    \"optional_policy_hash_pinning\": true\n  },\n  \"audit\": {\n    \"require_proof_bundle\": true,\n    \"store_in_trust_pulse\": true\n  }\n}\n</pre>\n<p>If you need network egress allowlists or automatic cost budget enforcement, those are optional and can be implemented, but they should not be your first line of defense. Start with enforceable tool policy, sandboxing, token binding, and receipts.</p>\n\n<h2>What proof do you get?</h2>\n<p>Each model call routed through clawproxy produces gateway receipts. Those receipts are signed, and they are designed to be checked later to confirm that a specific call happened under a specific proxy and policy context.</p>\n<p>For a channel-triggered job, Claw EA collects the gateway receipts and the run metadata into a proof bundle. The proof bundle ties together the WPC hash, the CST scope hash, and the relevant execution details so an auditor can verify the run without relying on screenshots or chat logs alone.</p>\n<p>When you need a review surface, you can store and view the artifact in Trust Pulse. Use it for spot checks, compliance sampling, and incident response timelines.</p>\n\n<h2>Rollback posture</h2>\n<p>Channel incidents tend to be fast and public. Your rollback plan should prefer “fail closed” switches that do not require redeploying the agent runtime.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop new work from a channel</td>\n      <td>Switch OpenClaw channel policy to allowlist-only or disable the channel entry for the agent.</td>\n      <td>OpenClaw security audit output plus the last proof bundle timestamp before the change.</td>\n    </tr>\n    <tr>\n      <td>Block privileged execution paths</td>\n      <td>Update tool policy to remove elevated tools and tighten sandbox mode (for example, sandbox all non-main sessions).</td>\n      <td>Configuration diff plus proof bundles showing reduced tool calls after the change.</td>\n    </tr>\n    <tr>\n      <td>Invalidate authorization in-flight</td>\n      <td>Revoke or rotate the CST (scoped token) issuance policy and re-issue a narrower CST pinned to a new WPC hash.</td>\n      <td>CST issuance and revocation records, and subsequent runs showing the new CST scope hash.</td>\n    </tr>\n    <tr>\n      <td>Prove what happened during an incident window</td>\n      <td>Freeze the relevant proof bundles and review gateway receipts for model calls that touched sensitive prompts or tool decisions.</td>\n      <td>Gateway receipts and proof bundles stored in Trust Pulse for the affected job IDs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why can’t we secure an agent with prompts alone?</h3>\n<p>Prompts are advisory text, not an enforcement layer. Policy-as-code, via a WPC plus CST checks and tool policy, is what prevents the runtime from executing forbidden actions even when the model is manipulated.</p>\n\n<h3>What is the minimum we should lock down for Microsoft Teams?</h3>\n<p>Start with Entra ID app registration hygiene, least-privilege Microsoft Graph permissions/scopes, and Conditional Access for who can administer the app. Then enforce channel allowlists and sandboxed tools in OpenClaw, and require a WPC plus CST for any execution.</p>\n\n<h3>How do Slack and Teams differ operationally as agent channels?</h3>\n<p>The security shape is similar: both are high-volume input streams with mixed-trust participants. The operational difference is the identity and permission model, which you should manage via each vendor’s official API and admin controls, while keeping execution limits in OpenClaw and WPCs.</p>\n\n<h3>What do we show auditors after a channel-triggered run?</h3>\n<p>Provide the WPC hash that governed the run, the CST scope hash used to authorize it, and the proof bundle containing gateway receipts. This is stronger than chat transcripts because it is tied to actual model call traffic and the enforced policy artifact.</p>\n\n<h3>Can we add more controls like egress allowlists or spend caps?</h3>\n<p>Yes, those controls can be implemented as optional or planned layers, depending on your environment. Do not use them as a substitute for tool policy, sandboxing, WPC enforcement, CST binding, and receipts.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/ai-foundry/control-plane/overview?view=foundry\">What Is Microsoft Foundry Control Plane?</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/copilot/microsoft-365/copilot-control-system/security-governance\">Copilot Control System Security and Governance</a></li>\n</ul>",
  "description": "Channels like Microsoft Teams and Slack are your agent’s public attack surface and your audit boundary. If you only rely on prompts, you cannot reliably stop a user from steering the agent into unsafe tools, data exposur",
  "faqs": [
    {
      "q": "Why can’t we secure an agent with prompts alone?",
      "a": "Prompts are advisory text, not an enforcement layer. Policy-as-code, via a WPC plus CST checks and tool policy, is what prevents the runtime from executing forbidden actions even when the model is manipulated."
    },
    {
      "q": "What is the minimum we should lock down for Microsoft Teams?",
      "a": "Start with Entra ID app registration hygiene, least-privilege Microsoft Graph permissions/scopes, and Conditional Access for who can administer the app. Then enforce channel allowlists and sandboxed tools in OpenClaw, and require a WPC plus CST for any execution."
    },
    {
      "q": "How do Slack and Teams differ operationally as agent channels?",
      "a": "The security shape is similar: both are high-volume input streams with mixed-trust participants. The operational difference is the identity and permission model, which you should manage via each vendor’s official API and admin controls, while keeping execution limits in OpenClaw and WPCs."
    },
    {
      "q": "What do we show auditors after a channel-triggered run?",
      "a": "Provide the WPC hash that governed the run, the CST scope hash used to authorize it, and the proof bundle containing gateway receipts. This is stronger than chat transcripts because it is tied to actual model call traffic and the enforced policy artifact."
    },
    {
      "q": "Can we add more controls like egress allowlists or spend caps?",
      "a": "Yes, those controls can be implemented as optional or planned layers, depending on your environment. Do not use them as a substitute for tool policy, sandboxing, WPC enforcement, CST binding, and receipts."
    }
  ],
  "sources": [
    {
      "title": "What Is Microsoft Foundry Control Plane?",
      "uri": "https://learn.microsoft.com/en-us/azure/ai-foundry/control-plane/overview?view=foundry"
    },
    {
      "title": "Copilot Control System Security and Governance",
      "uri": "https://learn.microsoft.com/en-us/copilot/microsoft-365/copilot-control-system/security-governance"
    },
    {
      "title": "Introducing Amazon Bedrock AgentCore Gateway",
      "uri": "https://aws.amazon.com/blogs/machine-learning/introducing-amazon-bedrock-agentcore-gateway-transforming-enterprise-ai-agent-tool-development/"
    },
    {
      "title": "Enterprise AI Agent Era: Trust, Security, Governance",
      "uri": "https://www.salesforce.com/blog/unified-trust-security-governance-for-agentic-solutions/"
    },
    {
      "title": "AI Agents and Solutions - Azure Cosmos DB",
      "uri": "https://learn.microsoft.com/en-us/azure/cosmos-db/ai-agents"
    },
    {
      "title": "Microsoft 365 Copilot Agent Management Essentials",
      "uri": "https://learn.microsoft.com/en-us/copilot/microsoft-365/agent-essentials/agent-essentials-overview"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:53:30.616Z",
  "indexable": true
}