{
  "slug": "agent-proof-and-attestation",
  "title": "Agent Proof and Attestation (Receipts and Proof Bundles) | Claw EA",
  "category": "pillars",
  "html": "<p>Agent proof and attestation is the ability to show what an agent did, under which permissions, and which model calls were made, in a way another party can verify. In Claw EA, OpenClaw is the baseline runtime, and Claw Bureau primitives add verifiable artifacts: a WPC, a CST, gateway receipts, and a proof bundle.</p>\n<p>This only works if execution is permissioned with policy-as-code, not prompt-only rules. Prompts can be bypassed by injection or tool misuse, but a WPC and CST are enforced by the execution layer and can be verified after the fact.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Decide what you need to prove and to whom.</strong> Typical recipients are internal audit, customers, or incident response. Write down which claims must be verifiable: allowed tools, model routing, and whether a specific policy was pinned.</p>\n  </li>\n  <li>\n    <p><strong>Author and publish a WPC.</strong> A WPC is a Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols). Treat the policy hash as the stable identifier you will later pin and audit against.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST tied to the job.</strong> A CST is a scoped token (issued by clawscope). Use the CST scope hash and, when you need hard guarantees, use optional policy hash pinning so the job can only run under the intended WPC.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent with model traffic routed through clawproxy.</strong> clawproxy emits gateway receipts for model calls. This is where you get verifiable evidence of what was sent to the model and what came back, plus binding metadata.</p>\n  </li>\n  <li>\n    <p><strong>Collect artifacts into a proof bundle.</strong> The proof bundle is the harness artifact bundling receipts and related metadata for audit/verification. Store it alongside any produced outputs so you can later answer “which policy and token allowed this result?”</p>\n  </li>\n  <li>\n    <p><strong>Verify before accepting results.</strong> In high-risk workflows, verification should be a gate in CI, a deployment pipeline, or a human approval step. Fail closed when the policy hash does not match, receipts are missing, or binding metadata indicates replay risk.</p>\n  </li>\n  <li>\n    <p><strong>Optionally publish to Trust Pulse.</strong> Trust Pulse is a marketplace-stored artifact for audit/viewing. Use it when you need a durable viewer surface for third parties without giving them your internal logs.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Prompt-only “policies” fail because they are advice to the model, not enforcement on execution. A well-scoped CST plus a pinned WPC moves control to something the model cannot rewrite mid-run.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (what to do)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection causes tool overreach</td>\n      <td>The agent is convinced to use a sensitive tool, exfiltrate data, or take irreversible action.</td>\n      <td>Enforce tool availability by policy-as-code (WPC) and keep the CST narrowly scoped to the intended job and tools.</td>\n    </tr>\n    <tr>\n      <td>Policy drift between “what we approved” and “what ran”</td>\n      <td>A team approves one policy, but the runtime uses a different config, or someone changes it after review.</td>\n      <td>Use WPC hash as the canonical identifier and use optional policy hash pinning in the CST so the run fails if the policy differs.</td>\n    </tr>\n    <tr>\n      <td>Replay of a previously valid token</td>\n      <td>An attacker reuses a token to repeat a run, or to attribute actions to the wrong job.</td>\n      <td>Use marketplace anti-replay binding (job-scoped CST binding) so the CST is bound to a specific job context.</td>\n    </tr>\n    <tr>\n      <td>Receipt gaps (model calls happen outside the proxy)</td>\n      <td>Some calls are not receipted, so the proof bundle no longer represents the full run.</td>\n      <td>Route model calls through clawproxy to emit gateway receipts, and treat missing receipts as verification failure for attested workflows.</td>\n    </tr>\n    <tr>\n      <td>Misconfigured OpenClaw gateway exposure</td>\n      <td>Inbound surfaces or permissive group policies allow untrusted users to trigger the agent in channels you did not intend.</td>\n      <td>Run OpenClaw security audits regularly and tighten inbound allowlists, mention requirements, and tool policy profiles before enabling attested runs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a small, JSON-like sketch of the kind of fields teams typically pin and verify. The point is not the exact schema, but the discipline: a signed WPC defines allowed execution, and the CST pins to its hash so “approved” equals “executed.”</p>\n<pre>\n{\n  \"wpc\": {\n    \"policy_hash\": \"b64u:...hash...\",\n    \"version\": \"2026-02-11\",\n    \"tools\": {\n      \"profile\": \"allowlist\",\n      \"allow\": [\"read\", \"write\", \"exec\"],\n      \"deny\": [\"browser_remote_control\", \"host_elevated_exec\"]\n    },\n    \"models\": {\n      \"route_via\": \"clawproxy\",\n      \"provider\": \"OpenRouter_via_fal\"\n    }\n  },\n  \"cst\": {\n    \"scope_hash\": \"b64u:...hash...\",\n    \"pin_policy_hash\": \"b64u:...hash...\",\n    \"job_binding\": \"required\"\n  },\n  \"verification\": {\n    \"require_gateway_receipts\": true,\n    \"fail_closed_on_missing_receipts\": true\n  }\n}</pre>\n<p>Where prompt-only policies say “do not use X,” this policy says “X is not available.” That difference is what makes verification meaningful during an incident review.</p>\n\n<h2>What proof do you get?</h2>\n<p>For each model call routed through clawproxy, you get gateway receipts: signed receipts emitted by clawproxy for model calls. These receipts are designed to be checked later so you can validate that a given response corresponds to a specific request under a specific job context.</p>\n<p>A proof bundle packages those receipts with run metadata needed for audit. In practice, you want the bundle to let a reviewer answer: which WPC was in force, which CST authorized the actions, which model calls occurred, and whether the run is consistent with your approval process.</p>\n<p>In workflows that cross organizational boundaries, the proof bundle is also your “hand-off unit.” You can provide the bundle to a customer or auditor without giving them shell access to your runner, and they can verify that the run meets the agreed policy constraints.</p>\n<p>If you publish to Trust Pulse, you get a marketplace-stored artifact for audit/viewing. Use it when you need a consistent review surface across many jobs, and when you want to reduce ad hoc “send me logs” requests.</p>\n\n<h2>Rollback posture</h2>\n<p>Attestation is only useful if you can stop and revert safely when verification fails. Your rollback posture should be explicit per job type, including what is reversible, what requires human approval, and what evidence you keep.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to require</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Agent produced an output artifact (report, patch, config)</td>\n      <td>Reject the artifact and re-run under a pinned WPC with tightened tool policy.</td>\n      <td>Proof bundle with complete gateway receipts and matching WPC policy hash.</td>\n    </tr>\n    <tr>\n      <td>Agent wrote to a repository</td>\n      <td>Revert the commit and block merges until verification passes on a new run.</td>\n      <td>Proof bundle plus a recorded mapping between job id, repo ref, and WPC hash.</td>\n    </tr>\n    <tr>\n      <td>Agent performed an external side effect (ticket updates, messaging)</td>\n      <td>Use the vendor’s official API to revert when available, otherwise document compensating actions and mark the job as non-attested.</td>\n      <td>Proof bundle and an operator note linking the side effect identifiers to the job binding.</td>\n    </tr>\n    <tr>\n      <td>Verification shows missing receipts</td>\n      <td>Treat as fail-closed for attested workflows; quarantine outputs and investigate model routing.</td>\n      <td>Receipt inventory from the proof bundle showing gaps, plus runtime config evidence for proxy routing.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>What is the difference between gateway receipts and a proof bundle?</h3>\n<p>Gateway receipts are per-model-call, signed receipts emitted by clawproxy. A proof bundle is the packaging that groups those receipts with run metadata so a verifier can check the whole job coherently.</p>\n\n<h3>Why can’t we just log prompts and responses?</h3>\n<p>Logs are easy to edit, omit, or reformat, and they do not prove what policy constrained execution. Receipts plus WPC and CST binding let you check that the run was authorized and that the model calls you see are the ones that occurred.</p>\n\n<h3>What does “permissioned execution” mean in practice?</h3>\n<p>It means the agent is constrained by policy-as-code that the runtime enforces, rather than instructions in the prompt. In Claw EA terms, the WPC defines the allowed boundary and the CST carries the scoped authorization, optionally pinned to the WPC hash.</p>\n\n<h3>How does this relate to OpenClaw sandboxing and tool policy?</h3>\n<p>OpenClaw already separates sandboxing (where tools run) from tool policy (which tools exist) and elevated execution (host escape hatch). Claw EA adds attestable controls around authorization and verification, while OpenClaw remains the baseline runtime for tool execution and local safety boundaries.</p>\n\n<h3>Can we use this with Microsoft identity and Conditional Access?</h3>\n<p>It can be implemented in enterprise buildout, typically by issuing CSTs based on your enterprise identity flow and gating job launch on your Entra ID posture. If you later call Microsoft services, do it via official API with explicit Microsoft Graph permissions/scopes and keep side effects reversible.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n</ul>",
  "description": "Agent proof and attestation is the ability to show what an agent did, under which permissions, and which model calls were made, in a way another party can verify. In Claw EA, OpenClaw is the baseline runtime, and Claw Bu",
  "faqs": [
    {
      "q": "What is the difference between gateway receipts and a proof bundle?",
      "a": "Gateway receipts are per-model-call, signed receipts emitted by clawproxy. A proof bundle is the packaging that groups those receipts with run metadata so a verifier can check the whole job coherently."
    },
    {
      "q": "Why can’t we just log prompts and responses?",
      "a": "Logs are easy to edit, omit, or reformat, and they do not prove what policy constrained execution. Receipts plus WPC and CST binding let you check that the run was authorized and that the model calls you see are the ones that occurred."
    },
    {
      "q": "What does “permissioned execution” mean in practice?",
      "a": "It means the agent is constrained by policy-as-code that the runtime enforces, rather than instructions in the prompt. In Claw EA terms, the WPC defines the allowed boundary and the CST carries the scoped authorization, optionally pinned to the WPC hash."
    },
    {
      "q": "How does this relate to OpenClaw sandboxing and tool policy?",
      "a": "OpenClaw already separates sandboxing (where tools run) from tool policy (which tools exist) and elevated execution (host escape hatch). Claw EA adds attestable controls around authorization and verification, while OpenClaw remains the baseline runtime for tool execution and local safety boundaries."
    },
    {
      "q": "Can we use this with Microsoft identity and Conditional Access?",
      "a": "It can be implemented in enterprise buildout, typically by issuing CSTs based on your enterprise identity flow and gating job launch on your Entra ID posture. If you later call Microsoft services, do it via official API with explicit Microsoft Graph permissions/scopes and keep side effects reversible."
    }
  ],
  "sources": [],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:42:19.680Z",
  "indexable": true
}