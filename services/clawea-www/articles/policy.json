{
  "slug": "policy",
  "title": "Policy Artifacts (WPC, Scoped Tokens, Proof) | Claw EA",
  "category": "hubs",
  "html": "<p>In Claw EA, “Policy Artifacts” are the objects you use to approve and constrain real execution by OpenClaw agents: WPC, CST, gateway receipts, and proof bundles. They make approvals machine-enforceable and auditable, instead of relying on prompt text that can be ignored, overwritten, or injected.</p>\n<p>Prompt-only controls describe intent, but they do not bind tool access, token scope, or model calls to a specific approved policy. Policy-as-code turns approvals into signed artifacts that the execution path can verify, fail-closed, and later prove.</p>\n<p><strong>Quick taxonomy (what lives in this hub):</strong></p>\n<ul>\n  <li><strong>Work Policy Contracts (WPC):</strong> Signed, hash-addressed policies that define what a job is allowed to do, served by clawcontrols.</li>\n  <li><strong>CST:</strong> A scoped token issued by clawscope that carries a scope hash and can optionally pin to a policy hash.</li>\n  <li><strong>Policy hash pinning:</strong> A mode where the CST is only valid for the referenced WPC hash, preventing “policy drift” mid-run.</li>\n  <li><strong>Gateway receipts:</strong> Signed receipts emitted by clawproxy for model calls, used to verify what was actually sent and received.</li>\n  <li><strong>Proof bundle:</strong> A harness artifact bundling receipts and related metadata for audit and verification.</li>\n  <li><strong>Marketplace anti-replay binding:</strong> A job-scoped CST binding that prevents reusing the same authorization context in a different job.</li>\n  <li><strong>Trust Pulse:</strong> A marketplace-stored artifact for audit/viewing when you need a durable, reviewable record.</li>\n  <li><strong>Local runtime controls (OpenClaw):</strong> Tool policy, sandboxing, and elevated mode that reduce blast radius on the host.</li>\n  <li><strong>Approvals workflow:</strong> Human or system gates that mint, sign, and distribute WPC and CST rather than “approving in chat”.</li>\n</ul>\n<p><strong>How to get started (checklist):</strong></p>\n<ul>\n  <li>Define a WPC for a single agent job and treat it like a deployment approval artifact.</li>\n  <li>Issue a CST for that job from clawscope with a tight TTL and scope hash, and optionally pin the WPC hash.</li>\n  <li>Route model traffic through clawproxy so gateway receipts are produced for each model call.</li>\n  <li>Export the proof bundle at job end and store it alongside change tickets, incident records, or compliance evidence.</li>\n</ul>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Write the WPC.</strong> Encode the job’s allowed tools, data boundaries, and operator requirements as a WPC. Keep it explicit about what is disallowed so reviewers can approve it quickly.</p>\n  </li>\n  <li>\n    <p><strong>Register and reference the WPC by hash.</strong> Store the signed WPC in the WPC registry (served by clawcontrols) and use the hash as the stable identifier. Your runbooks and tickets should reference the hash, not a mutable file path.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the job.</strong> Use clawscope to mint a CST with the minimum scope required, a short TTL, and (when needed) policy hash pinning to the WPC hash. This makes “approval” an authorization object, not a chat instruction.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent on OpenClaw with local controls enabled.</strong> Use OpenClaw tool policy and sandboxing so the local blast radius is limited even when the model behaves unexpectedly. Treat elevated mode as an exception path that must be explicitly allowed.</p>\n  </li>\n  <li>\n    <p><strong>Proxy model calls through clawproxy.</strong> Route model traffic (for example OpenRouter via fal routed through clawproxy) so gateway receipts are emitted for model calls. This gives you verifiable evidence of model I/O for the run.</p>\n  </li>\n  <li>\n    <p><strong>Export and verify the proof bundle.</strong> At the end of the job, collect the proof bundle and attach it to the change record or incident timeline. If you publish the record for reviewers, store it as a Trust Pulse for audit/viewing.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Policy artifacts exist because execution failure modes are operational, not theoretical. The goal is to make unsafe states hard to reach, and to preserve evidence when something goes wrong.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection overrides “rules”</td>\n      <td>The agent is convinced to run a tool, access data, or broaden scope despite instructions to the contrary.</td>\n      <td>Permission is enforced by WPC plus CST scope hash, not by prompt text. OpenClaw tool policy and sandboxing reduce impact if an unsafe tool is available.</td>\n    </tr>\n    <tr>\n      <td>Policy drift during a long-running job</td>\n      <td>A job starts under one policy but later operates under a different, less-reviewed version.</td>\n      <td>Use WPC hash addressing and optional policy hash pinning in the CST so the run is cryptographically tied to the approved policy artifact.</td>\n    </tr>\n    <tr>\n      <td>Token replay across jobs or environments</td>\n      <td>A token issued for one job is reused to authorize a different job, bypassing the intended approval boundary.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) prevents cross-job reuse patterns. Keep CST TTL short and rotate issuance keys under standard key management.</td>\n    </tr>\n    <tr>\n      <td>Disputes about what the model actually saw</td>\n      <td>After an incident, teams cannot reliably reconstruct prompts, tool inputs, or model outputs.</td>\n      <td>Gateway receipts from clawproxy produce a signed record of model calls. Proof bundles collect those receipts with run metadata for later verification.</td>\n    </tr>\n    <tr>\n      <td>Over-broad local execution privileges</td>\n      <td>Tools run on the host with access to files, sockets, or credentials that were not intended for the job.</td>\n      <td>Prefer OpenClaw sandboxing and strict tool allowlists. Treat elevated mode as a controlled exception and document it in the WPC so the risk is reviewed.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Optional or planned controls can be added depending on your risk profile. Egress allowlists enforced outside clawproxy, automatic cost budget enforcement, and transparency log inclusion proofs are not required to start, but can be implemented when you need stricter guarantees.</p>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact, JSON-like sketch of a WPC shape that teams commonly review. The point is not the exact schema, but the reviewable intent that gets signed, hashed, and referenced by jobs.</p>\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"customer-support-refund-assistant\",\n  \"allowed_tools\": [\"ticket.read\", \"ticket.comment\", \"refund.request\"],\n  \"denied_tools\": [\"shell.exec\", \"fs.write\", \"secrets.export\"],\n  \"data_boundaries\": {\n    \"pii\": \"redact_in_logs\",\n    \"export\": \"deny\"\n  },\n  \"model_routing\": {\n    \"must_proxy_via\": \"clawproxy\",\n    \"receipts_required\": true\n  },\n  \"approvals\": {\n    \"required\": true,\n    \"approver_group\": \"SupportOps-PIM-Eligible\"\n  },\n  \"token_constraints\": {\n    \"cst_ttl_minutes\": 30,\n    \"pin_policy_hash\": true,\n    \"job_bound\": true\n  }\n}</pre>\n<p>If you use Microsoft identity, keep the boundary clear: Entra ID, Conditional Access, and PIM can govern who is allowed to request approvals and who can mint job credentials. The WPC and CST still carry the execution-time constraints that the runtime can verify independent of the chat channel.</p>\n\n<h2>What proof do you get?</h2>\n<p>For each model call routed through clawproxy, you receive gateway receipts that can be independently checked for integrity. This is the core evidence for “what the model was asked” and “what it returned” at the time of execution.</p>\n<p>A proof bundle packages those receipts together with job metadata so you can answer audit questions without scraping logs. In practice, teams store proof bundles with change approvals, and optionally publish a Trust Pulse artifact when they need a durable record for reviewers.</p>\n<p>The approval boundary is also provable: the CST is minted with a scope hash and can optionally pin to a WPC hash. That creates a tight linkage between “what was approved” and “what was allowed to run,” even if prompts or skills change.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback in agent systems is less about reverting code and more about quickly shrinking permissions and stopping unsafe execution. The artifacts here support “fail closed” defaults: if verification fails, the job should not gain more capability.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Bad tool behavior discovered mid-run</td>\n      <td>Issue a new, tighter WPC and require a new CST for continued execution; stop issuing CST for the old policy.</td>\n      <td>WPC hashes show exactly when the policy changed; proof bundle shows which policy was active for each job window.</td>\n    </tr>\n    <tr>\n      <td>Suspected credential leak</td>\n      <td>Revoke CST (via clawscope) and rotate upstream credentials; rerun the job under a new WPC with narrowed scope.</td>\n      <td>CST issuance and revocation events plus job-scoped binding reduce ambiguity about what could be replayed.</td>\n    </tr>\n    <tr>\n      <td>Model output dispute or incident review</td>\n      <td>Freeze the proof bundle and share it with incident responders; do not rely on reconstructed prompts from chat logs.</td>\n      <td>Gateway receipts provide a signed record of model calls; proof bundle ties receipts to a specific run.</td>\n    </tr>\n    <tr>\n      <td>Local host exposure concerns</td>\n      <td>Move execution to OpenClaw sandbox mode for that agent profile and remove elevated allowances until reviewed.</td>\n      <td>OpenClaw configuration and audit outputs document the effective sandbox and tool policy posture.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why isn’t a “please ask for approval” prompt sufficient?</h3>\n<p>Because the model can be persuaded to ignore it, and the runtime cannot verify that the prompt was followed. A WPC plus CST makes the approval decision part of the authorization path, not part of a conversation.</p>\n\n<h3>How do WPC and OpenClaw tool policy relate?</h3>\n<p>OpenClaw tool policy and sandboxing are local controls that limit what tools can run and where they run. WPC is the portable, signed contract that lets your platform enforce and audit the intended permissions across jobs and environments.</p>\n\n<h3>What should we pin in the CST: scope hash, policy hash, or both?</h3>\n<p>Start with scope hash to keep tokens minimally privileged. Add policy hash pinning when you need stronger guarantees that a job cannot switch policies without re-approval.</p>\n\n<h3>Do gateway receipts capture everything the agent did?</h3>\n<p>No. Gateway receipts cover model calls routed through clawproxy, which is often the critical evidence during reviews. Tool execution evidence is typically handled by the runtime and your logging pipeline; the proof bundle is the container that keeps model-call evidence and run metadata together.</p>\n\n<h3>Can we align this with enterprise approval patterns like deployment checks?</h3>\n<p>Yes, conceptually. Many teams map WPC signing and CST issuance to the same governance expectations as pipeline approvals and checks, where the approval gate is not editable by the job itself.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops\">Pipeline deployment approvals (Azure DevOps)</a></li>\n  <li><a href=\"https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller\">Enforcing artifact attestations with a Kubernetes admission controller (GitHub Docs)</a></li>\n</ul>",
  "description": "In Claw EA, “Policy Artifacts” are the objects you use to approve and constrain real execution by OpenClaw agents: WPC, CST, gateway receipts, and proof bundles. They make approvals machine-enforceable and auditable, ins",
  "faqs": [
    {
      "q": "Why isn’t a “please ask for approval” prompt sufficient?",
      "a": "Because the model can be persuaded to ignore it, and the runtime cannot verify that the prompt was followed. A WPC plus CST makes the approval decision part of the authorization path, not part of a conversation."
    },
    {
      "q": "How do WPC and OpenClaw tool policy relate?",
      "a": "OpenClaw tool policy and sandboxing are local controls that limit what tools can run and where they run. WPC is the portable, signed contract that lets your platform enforce and audit the intended permissions across jobs and environments."
    },
    {
      "q": "What should we pin in the CST: scope hash, policy hash, or both?",
      "a": "Start with scope hash to keep tokens minimally privileged. Add policy hash pinning when you need stronger guarantees that a job cannot switch policies without re-approval."
    },
    {
      "q": "Do gateway receipts capture everything the agent did?",
      "a": "No. Gateway receipts cover model calls routed through clawproxy, which is often the critical evidence during reviews. Tool execution evidence is typically handled by the runtime and your logging pipeline; the proof bundle is the container that keeps model-call evidence and run metadata together."
    },
    {
      "q": "Can we align this with enterprise approval patterns like deployment checks?",
      "a": "Yes, conceptually. Many teams map WPC signing and CST issuance to the same governance expectations as pipeline approvals and checks, where the approval gate is not editable by the job itself."
    }
  ],
  "sources": [
    {
      "title": "Enforcing artifact attestations with a Kubernetes admission controller - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/how-tos/secure-your-work/use-artifact-attestations/enforce-artifact-attestations"
    },
    {
      "title": "Enforcing artifact attestations with a Kubernetes admission controller - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller"
    },
    {
      "title": "Pipeline deployment approvals - Azure - Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops"
    },
    {
      "title": "Create approval policies for your nodes - AWS Systems Manager",
      "uri": "https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-just-in-time-node-access-approval-policies.html"
    },
    {
      "title": "PullRequestBuildPolicy - AWS CodeBuild",
      "uri": "https://docs.aws.amazon.com/codebuild/latest/APIReference/API_PullRequestBuildPolicy.html"
    },
    {
      "title": "Example IAM policies for AWS Artifact in commercial AWS Regions",
      "uri": "https://docs.aws.amazon.com/artifact/latest/ug/example-iam-policies.html"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:00:23.760Z",
  "indexable": true
}