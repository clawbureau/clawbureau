{
  "slug": "policy/event-chain",
  "title": "Event Chains | Policy Artifact | Claw EA",
  "category": "policy",
  "html": "<h1>Event Chains</h1>\n\n<p>An Event Chain is a tamper-evident, append-only log for agent jobs where each record links to the previous record by hash and is optionally signed. Use it to make webhook and changefeed driven automation auditable, idempotent, and fail-closed when policy or identity does not validate.</p>\n<p>OpenClaw is the baseline agent runtime, but prompts alone cannot safely constrain execution. You need permissioned execution under policy-as-code so the runtime can block side effects when the Work Policy Contract (WPC) or CST does not match the job.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define your WPC as the machine-readable “what is allowed” contract for this automation. Store it in the WPC registry and treat the resulting policy hash as the stable identifier your workers must pin to.</p>\n  </li>\n  <li>\n    <p>Issue a CST for the specific job and pin it to the WPC hash (optional policy hash pinning). Use job-scoped CST binding to reduce replay across jobs.</p>\n  </li>\n  <li>\n    <p>Secure inbound webhooks and changefeeds before they touch the agent. For Microsoft-style eventing, use Microsoft Entra ID protected endpoints and validate the caller identity and audience; otherwise validate vendor signatures or shared-secret HMAC via official API guidance.</p>\n  </li>\n  <li>\n    <p>Write an Event Chain record as your first step after accepting an inbound delivery, before doing any side effects. Make the record include a deterministic idempotency key derived from the vendor event id, subject, and resource version.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw with explicit tool policy and sandbox settings, then route model calls through clawproxy to obtain gateway receipts. If you use OpenRouter via fal, keep it routed through clawproxy so receipts cover model traffic.</p>\n  </li>\n  <li>\n    <p>For each state transition (validated, planned, executed, acknowledged), append an event with a hash pointer to the previous event. On completion, produce a proof bundle that includes gateway receipts plus the Event Chain head hash and critical metadata for verification.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Event Chains are mainly about controlling side effects under unreliable delivery and hostile inputs. They complement OpenClaw’s local sandbox and tool policy boundary by adding verifiable, job-scoped history that you can check before executing and after incidents.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Webhook replay or duplicate delivery</td>\n      <td>The same vendor event is delivered multiple times, potentially causing repeated writes, repeated approvals, or repeated outbound messages.</td>\n      <td>Derive an idempotency key and record it in the Event Chain; refuse to execute side effects if the key already exists for the same WPC hash and job-scoped CST binding.</td>\n    </tr>\n    <tr>\n      <td>Forged webhook sender</td>\n      <td>An attacker posts a lookalike payload to your endpoint to trick the agent into acting.</td>\n      <td>Authenticate delivery (for example, Microsoft Entra ID for Event Grid webhook delivery) and record the verified caller identity claims in the chain before any tool execution.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection via event payload</td>\n      <td>Untrusted event fields include instructions that cause the agent to call tools outside intent.</td>\n      <td>Do not rely on prompt rules alone; enforce policy-as-code through WPC-derived tool allow/deny and OpenClaw sandboxing. Store the normalized “facts extracted” as a separate chain event so auditors can see what the agent actually used.</td>\n    </tr>\n    <tr>\n      <td>Policy drift during execution</td>\n      <td>A long-running job starts under one policy and finishes under a different one, making authorization ambiguous.</td>\n      <td>Pin to a WPC hash at job start and include it in every event record; optionally require the CST to carry the pinned policy hash and fail closed if it does not match.</td>\n    </tr>\n    <tr>\n      <td>Log tampering after incident</td>\n      <td>Someone modifies stored logs to hide a bad tool call or to alter who approved what.</td>\n      <td>Hash-chain the records and optionally sign chain heads; keep the chain head hash inside the proof bundle alongside gateway receipts so verification detects edits.</td>\n    </tr>\n    <tr>\n      <td>Infinite loops in event-driven remediation</td>\n      <td>Your handler changes a resource, which triggers another event, which triggers another change.</td>\n      <td>Include “reason” and “causal parent” fields, plus a loop guard counter in the chain; filter on specific event types and subjects so the handler does not re-trigger itself.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a minimal, schema-style example showing how to bind a job to a WPC and require deterministic idempotency. Treat it as a template for your own policy artifact, not a fixed API contract.</p>\n\n<pre>\n{\n  \"kind\": \"event_chain_policy\",\n  \"wpc_policy_hash_b64u\": \"pinned_policy_hash_here\",\n  \"cst\": {\n    \"require_job_scoped_binding\": true,\n    \"require_scope_hash_match\": true,\n    \"optional_policy_hash_pinning\": true\n  },\n  \"ingress\": {\n    \"webhook_auth\": {\n      \"mode\": \"entra_id_or_vendor_signature\",\n      \"expected_audience\": \"your_endpoint_audience\",\n      \"require_tls\": true\n    },\n    \"idempotency\": {\n      \"key_fields\": [\"vendor_event_id\", \"subject\", \"resource_version\"],\n      \"reject_duplicates\": true\n    }\n  },\n  \"event_chain\": {\n    \"hash_alg\": \"sha256\",\n    \"require_prev_hash\": true,\n    \"sign_chain_head\": \"optional\",\n    \"required_events\": [\"received\", \"authenticated\", \"validated\", \"planned\", \"executed\", \"acknowledged\"],\n    \"fail_closed_on_validation_error\": true\n  },\n  \"execution\": {\n    \"openclaw\": {\n      \"sandbox_mode\": \"all\",\n      \"tools_profile\": \"allowlist_only\",\n      \"deny_elevated_by_default\": true\n    },\n    \"model_calls\": {\n      \"require_clawproxy_gateway_receipts\": true\n    }\n  }\n}\n</pre>\n\n<p>Validation rules should be deterministic and fail-closed. If the chain breaks, the WPC hash is missing, the CST scope hash does not match, or webhook authentication fails, the worker must not execute tools and must not call models through clawproxy.</p>\n<p>For changefeeds and webhooks, validate before parsing into agent instructions. Store both the raw payload hash and a normalized view so you can later show exactly what changed without re-parsing untrusted input.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get gateway receipts for model calls emitted by clawproxy, suitable for verifying what model was called and with what request boundaries. You also get a proof bundle that can include those receipts plus job metadata and pointers to your Event Chain head hash for end-to-end audit and verification.</p>\n<p>If you publish artifacts for review, a Trust Pulse can store and display the proof bundle for auditors. This is most useful when your incident process needs a single object to attach to tickets and postmortems.</p>\n<p>For idempotency disputes, the Event Chain provides a replayable narrative: the inbound delivery identity, the idempotency decision, the policy hash in force, and the execution milestones. Verification checks should reject any bundle whose receipt signatures do not validate or whose chain head hash does not match the chain content you stored.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback is about stopping further side effects and proving what already happened. Your posture should rely on CST revocation, policy hash pinning, and tool sandbox boundaries, then use the Event Chain plus proof bundle to drive a precise cleanup.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Webhook handler deployed with wrong mapping</td>\n      <td>Revoke or expire the CSTs issued for that job class and block new job creation until WPC is corrected. Re-run only from a known chain event id, not “latest.”</td>\n      <td>Event Chain shows which payloads were accepted and which actions were executed; proof bundle anchors model-call receipts that influenced decisions.</td>\n    </tr>\n    <tr>\n      <td>Duplicate delivery caused repeated write</td>\n      <td>Stop processing when the idempotency key is seen again and mark the duplicate as “ignored.” Apply compensating actions only once, tied to the first executed event id.</td>\n      <td>Chain contains the idempotency key, first execution event, and later duplicate receipt; auditors can see deterministic duplicate suppression.</td>\n    </tr>\n    <tr>\n      <td>Policy changed mid-run</td>\n      <td>Require that every tool call checks the pinned WPC hash; if mismatch, stop and require a new job under a new CST. Do not “continue under new policy” automatically.</td>\n      <td>Each chain event repeats the WPC hash; mismatches show where execution halted, with corresponding receipts for any completed model calls.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection suspected</td>\n      <td>Quarantine the job, rotate any exposed secrets outside this layer, and re-run with stricter OpenClaw tool allowlists and sandboxing. If needed, implement egress allowlists enforced outside clawproxy (optional) to limit exfil paths.</td>\n      <td>Event Chain captures the untrusted input hash and the extracted facts; gateway receipts show model prompts and responses at the boundary.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>How is an Event Chain different from normal application logs?</h3>\n<p>Normal logs are easy to edit and hard to validate, especially after an incident. An Event Chain is append-only by construction, with hash links that make deletions and rewrites detectable.</p>\n\n<h3>Why not handle idempotency only in the webhook handler database?</h3>\n<p>You still should, but the agent execution layer needs to enforce it too. Putting the idempotency decision inside the Event Chain means every subsequent step can fail closed before tools run, even if the upstream handler is buggy.</p>\n\n<h3>Why is permissioned execution (policy-as-code) required instead of prompt-only rules?</h3>\n<p>Prompt-only rules are advisory and can be bypassed by ambiguous inputs or model behavior. A WPC plus CST constraints let the runtime block tool calls and model calls when identity, scope hash, or policy hash does not validate.</p>\n\n<h3>Do I need Microsoft Entra ID to secure my webhooks?</h3>\n<p>No, but you need strong sender authentication appropriate to the vendor. If you are using Azure Event Grid, Microsoft documents securing webhook delivery with Microsoft Entra ID; otherwise follow the vendor’s official API signing guidance and record the verified identity claims in the Event Chain.</p>\n\n<h3>What does Claw EA verify automatically versus what we must implement?</h3>\n<p>Shipped primitives cover WPC registry fetch and verify, CST issuance and scope hash, gateway receipts from clawproxy, and proof bundles with job-scoped CST binding. An Event Chain is a recommended policy artifact format you can implement in your worker and then anchor into the proof bundle; end-to-end wiring can be done via enterprise buildout.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/event-grid/secure-webhook-delivery\">Secure WebHook delivery with Microsoft Entra ID (Azure Event Grid)</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/event-grid/security-authentication\">Authenticate event delivery to event handlers (Azure Event Grid)</a></li>\n  <li><a href=\"https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-patterns-best-practices.html\">Best practices for Amazon EventBridge event patterns</a></li>\n</ul>",
  "description": "An Event Chain is a tamper-evident, append-only log for agent jobs where each record links to the previous record by hash and is optionally signed. Use it to make webhook and changefeed driven automation auditable, idemp",
  "faqs": [
    {
      "q": "How is an Event Chain different from normal application logs?",
      "a": "Normal logs are easy to edit and hard to validate, especially after an incident. An Event Chain is append-only by construction, with hash links that make deletions and rewrites detectable."
    },
    {
      "q": "Why not handle idempotency only in the webhook handler database?",
      "a": "You still should, but the agent execution layer needs to enforce it too. Putting the idempotency decision inside the Event Chain means every subsequent step can fail closed before tools run, even if the upstream handler is buggy."
    },
    {
      "q": "Why is permissioned execution (policy-as-code) required instead of prompt-only rules?",
      "a": "Prompt-only rules are advisory and can be bypassed by ambiguous inputs or model behavior. A WPC plus CST constraints let the runtime block tool calls and model calls when identity, scope hash, or policy hash does not validate."
    },
    {
      "q": "Do I need Microsoft Entra ID to secure my webhooks?",
      "a": "No, but you need strong sender authentication appropriate to the vendor. If you are using Azure Event Grid, Microsoft documents securing webhook delivery with Microsoft Entra ID; otherwise follow the vendor’s official API signing guidance and record the verified identity claims in the Event Chain."
    },
    {
      "q": "What does Claw EA verify automatically versus what we must implement?",
      "a": "Shipped primitives cover WPC registry fetch and verify, CST issuance and scope hash, gateway receipts from clawproxy, and proof bundles with job-scoped CST binding. An Event Chain is a recommended policy artifact format you can implement in your worker and then anchor into the proof bundle; end-to-end wiring can be done via enterprise buildout."
    }
  ],
  "sources": [
    {
      "title": "Reacting to Azure Policy state change events - Azure Policy",
      "uri": "https://learn.microsoft.com/en-us/azure/governance/policy/concepts/event-overview"
    },
    {
      "title": "Reacting to Azure Policy state change events - Azure Policy",
      "uri": "https://learn.microsoft.com/en-us/azure/governance/policy/concepts/event-overview?tabs=event-grid-event-schema"
    },
    {
      "title": "Best practices for Amazon EventBridge event patterns",
      "uri": "https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-patterns-best-practices.html"
    },
    {
      "title": "Azure Policy as an Event Grid source - Azure Event Grid",
      "uri": "https://learn.microsoft.com/en-us/azure/event-grid/event-schema-policy?tabs=event-grid-event-schema"
    },
    {
      "title": "Authenticate event delivery to event handlers (Azure Event Grid) - Azure Event Grid",
      "uri": "https://learn.microsoft.com/en-us/azure/event-grid/security-authentication"
    },
    {
      "title": "Secure WebHook delivery with Microsoft Entra ID - Azure Event Grid",
      "uri": "https://learn.microsoft.com/en-us/azure/event-grid/secure-webhook-delivery"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:16:59.780Z",
  "indexable": true
}