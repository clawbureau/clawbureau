{
  "slug": "policy/prompt-pack",
  "title": "Prompt Pack | Policy Artifact | Claw EA",
  "category": "policy",
  "html": "<p>A Prompt Pack is a hash-only policy artifact that commits an OpenClaw job to a specific set of prompts and routing rules, then binds execution approvals to that commitment. Instead of trusting whatever text happens to be in the live prompt, you approve a stable digest and require the runtime to prove it used that exact pack.</p>\n<p>In Claw EA, the Prompt Pack digest is referenced by a WPC and optionally pinned in the CST so the run fails closed if the prompts change. Model calls are routed through clawproxy to produce gateway receipts, and the job output is packaged as a proof bundle for audit.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Author the Prompt Pack content and compute a digest.</strong> Treat the pack as the minimal set of prompt text plus a small amount of structured metadata (version, intended tools, model class, and redaction expectations). Only the digest is used for approvals so the approval record is stable and reviewable.</p>\n  </li>\n  <li>\n    <p><strong>Create or update a WPC that references the Prompt Pack digest.</strong> The WPC is the permission boundary: it ties “what this job is allowed to do” to a signed, hash-addressed policy artifact served by clawcontrols. Reviewers approve the WPC and the Prompt Pack digest together as the execution contract.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST with scope hash and optional policy hash pinning.</strong> The CST is issued by clawscope and can carry a scope hash that constrains what the runtime may request. If you pin the policy hash, the token becomes unusable for any run that cannot present the matching WPC and Prompt Pack commitment.</p>\n  </li>\n  <li>\n    <p><strong>Run the job in OpenClaw with the WPC enforced at the execution layer.</strong> OpenClaw is the baseline agent runtime, and it already separates sandboxing from tool policy. Keep local tool policy and sandboxing tight, then use the WPC to make remote approvals and policy checks deterministic.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy for gateway receipts.</strong> When the agent calls a model, clawproxy emits signed gateway receipts for the model call. This lets you verify what model endpoint was contacted and bind the receipts to the job context you approved.</p>\n  </li>\n  <li>\n    <p><strong>Collect the proof bundle and publish to Trust Pulse as needed.</strong> A proof bundle packages the gateway receipts plus related metadata (job identity, policy references, and integrity fields) so auditors can verify the run. If you use Trust Pulse, you can store and view the artifact for later review.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Prompt-only controls fail in predictable ways because prompts are easy to edit, easy to inject into, and hard to audit after the fact. A permissioned execution layer uses policy-as-code so the runtime can fail closed on mismatches and produce verifiable evidence.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Silent prompt drift between approval and execution</td>\n      <td>A developer “tweaks” wording, a template expands differently, or a runtime fetch returns a new prompt revision. The job still runs, but the approved intent is no longer what executed.</td>\n      <td>Approve a Prompt Pack digest and reference it from a WPC. Optionally pin the policy hash in the CST so the run fails closed if the WPC or Prompt Pack commitment does not match.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection that changes tool intent</td>\n      <td>Untrusted input convinces the agent to perform a high-impact action even though the system prompt said “be careful.” Post-incident, you cannot prove which tool policy was effectively in force.</td>\n      <td>Put tool and action constraints in the WPC, not just in text. Keep OpenClaw tool policy and sandbox settings restrictive, and require WPC verification before execution proceeds.</td>\n    </tr>\n    <tr>\n      <td>Receipt gap, no way to verify model calls</td>\n      <td>After a bad output, you cannot prove which model was called, what parameters were used, or whether a different provider was substituted.</td>\n      <td>Route model calls through clawproxy and collect gateway receipts. Verify receipts during audit and include them in the proof bundle.</td>\n    </tr>\n    <tr>\n      <td>Token replay across jobs</td>\n      <td>A CST leaked from logs or CI is reused to run a different job with a different payload. The run appears authorized because the token is still valid.</td>\n      <td>Use marketplace anti-replay binding (job-scoped CST binding). Bind the CST to the job identity so it cannot be reused for a different run context.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows a minimal “Prompt Pack commitment” embedded as a reference inside a WPC. The key idea is that reviewers approve hashes and invariants, not free-form text that can drift.</p>\n\n<pre>\n{\n  \"kind\": \"wpc\",\n  \"version\": \"1\",\n  \"work\": {\n    \"name\": \"prompt-pack:customer-support-triage\",\n    \"purpose\": \"classify + draft response, no outbound actions\"\n  },\n  \"prompt_pack\": {\n    \"digest_alg\": \"sha256\",\n    \"digest_b64u\": \"m9f...E2Q\",\n    \"declared_inputs\": [\"ticket_text\", \"account_tier\"],\n    \"declared_outputs\": [\"label\", \"draft_reply\"]\n  },\n  \"execution\": {\n    \"models\": [{\n      \"route\": \"openrouter_via_fal_through_clawproxy\",\n      \"family\": \"text\",\n      \"max_output_tokens\": 600\n    }],\n    \"tools\": {\n      \"allow\": [\"read_ticket\", \"write_draft\"],\n      \"deny\": [\"send_email\", \"exec\", \"browser\"]\n    }\n  },\n  \"verification\": {\n    \"require_gateway_receipts\": true,\n    \"require_policy_hash_match\": true\n  }\n}\n</pre>\n\n<p><strong>Validation rules (fail closed):</strong> if the presented Prompt Pack digest does not match the WPC reference, execution stops. If policy hash pinning is used in the CST and the runtime cannot prove it is operating under that policy hash, the run stops.</p>\n<p>If the run is configured to require gateway receipts and clawproxy is unreachable, the run should be treated as non-compliant and halted or quarantined, depending on your operating procedure. The goal is to avoid “best effort” execution for workloads that require approvals.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get gateway receipts for each model call, emitted by clawproxy and signed so they can be verified later. These receipts are the evidence that model traffic went through the controlled path, not a direct provider call that bypasses controls.</p>\n<p>You also get a proof bundle that packages the receipts with binding metadata, including what WPC was used and what job context the CST was bound to. In audits, you verify that the Prompt Pack digest, WPC reference, and receipts all agree, and that the run is not a replay.</p>\n<p>If you store the bundle in Trust Pulse, the artifact can be viewed later for investigation and review. Keep the Prompt Pack itself in your internal repository; the approval and audit path only needs the digest and the proof bundle.</p>\n\n<h2>Rollback posture</h2>\n<p>Prompt Pack rollbacks should be operationally boring: swap a digest, update the WPC reference, and invalidate old approvals. Do not “hot edit” prompts and hope people notice, since that defeats permissioned execution approvals.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Bad prompt revision produces unsafe outputs</td>\n      <td>Revert to the last known-good Prompt Pack digest and update the WPC to reference it. Issue new CSTs pinned to the reverted policy hash.</td>\n      <td>New proof bundles show the reverted digest and the new WPC reference. Old runs remain auditable and distinguishable by digest.</td>\n    </tr>\n    <tr>\n      <td>Discovered tool overreach in policy</td>\n      <td>Tighten the WPC tool allow list and deny risky tools explicitly. Re-run OpenClaw tool policy and sandbox settings to ensure local blast radius is still limited.</td>\n      <td>Proof bundles show the updated WPC hash and continued presence of gateway receipts. OpenClaw configuration audits can be run separately for local posture.</td>\n    </tr>\n    <tr>\n      <td>Suspected CST leakage</td>\n      <td>Revoke affected CSTs via clawscope operations and rotate issuance practices. Require job-scoped CST binding so stolen tokens cannot authorize new jobs.</td>\n      <td>Subsequent runs require new CSTs and produce proof bundles bound to the new job identities. Investigation uses issuance and revocation records plus proof bundles.</td>\n    </tr>\n    <tr>\n      <td>Need to pause all runs under a prompt family</td>\n      <td>Stop issuing CSTs for that scope hash and require a new WPC version for resumption. Treat this as a controlled change, not an ad hoc prompt edit.</td>\n      <td>The absence of valid CSTs blocks new runs. Later runs show the new WPC hash and Prompt Pack digest in their proof bundles.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is permissioned execution required instead of a strong system prompt?</h3>\n<p>A system prompt is not an enforcement boundary; it is mutable text that can drift and can be overridden by injection. Permissioned execution ties approvals to WPC constraints and a Prompt Pack digest so the runtime can detect changes and fail closed.</p>\n\n<h3>What exactly is “hash-only” about a Prompt Pack?</h3>\n<p>The approval object is the digest, not the raw prompt text. You can keep the full Prompt Pack in your repository, but the execution layer only needs the digest and a deterministic way to confirm the runtime used it.</p>\n\n<h3>How does a CST relate to the Prompt Pack approval?</h3>\n<p>A CST can carry a scope hash and optionally pin a policy hash, which makes the token unusable if the runtime cannot present the intended policy commitment. This is how you prevent a valid token from being used with a different WPC or different Prompt Pack digest.</p>\n\n<h3>What do gateway receipts prove and what do they not prove?</h3>\n<p>Gateway receipts prove that model calls went through clawproxy and provide verifiable metadata for those calls. They do not prove the model’s internal reasoning, and they do not guarantee that a user did not feed malicious input, so you still need tool policy and sandboxing.</p>\n\n<h3>Can Prompt Packs be used with Microsoft prompt tooling?</h3>\n<p>Yes, you can treat prompt assets authored in Microsoft tooling as inputs to your Prompt Pack, then approve and run by digest. The binding and verification still happen at the execution layer using WPC, CST, gateway receipts, and proof bundles, independent of how the prompts were authored.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/machine-learning/prompt-flow/get-started-prompt-flow?view=azureml-api-2\">Get started with prompt flow - Azure Machine Learning</a></li>\n</ul>",
  "description": "A Prompt Pack is a hash-only policy artifact that commits an OpenClaw job to a specific set of prompts and routing rules, then binds execution approvals to that commitment. Instead of trusting whatever text happens to be",
  "faqs": [
    {
      "q": "Why is permissioned execution required instead of a strong system prompt?",
      "a": "A system prompt is not an enforcement boundary; it is mutable text that can drift and can be overridden by injection. Permissioned execution ties approvals to WPC constraints and a Prompt Pack digest so the runtime can detect changes and fail closed."
    },
    {
      "q": "What exactly is “hash-only” about a Prompt Pack?",
      "a": "The approval object is the digest, not the raw prompt text. You can keep the full Prompt Pack in your repository, but the execution layer only needs the digest and a deterministic way to confirm the runtime used it."
    },
    {
      "q": "How does a CST relate to the Prompt Pack approval?",
      "a": "A CST can carry a scope hash and optionally pin a policy hash, which makes the token unusable if the runtime cannot present the intended policy commitment. This is how you prevent a valid token from being used with a different WPC or different Prompt Pack digest."
    },
    {
      "q": "What do gateway receipts prove and what do they not prove?",
      "a": "Gateway receipts prove that model calls went through clawproxy and provide verifiable metadata for those calls. They do not prove the model’s internal reasoning, and they do not guarantee that a user did not feed malicious input, so you still need tool policy and sandboxing."
    },
    {
      "q": "Can Prompt Packs be used with Microsoft prompt tooling?",
      "a": "Yes, you can treat prompt assets authored in Microsoft tooling as inputs to your Prompt Pack, then approve and run by digest. The binding and verification still happen at the execution layer using WPC, CST, gateway receipts, and proof bundles, independent of how the prompts were authored."
    }
  ],
  "sources": [
    {
      "title": "Get started with prompt flow - Azure Machine Learning",
      "uri": "https://learn.microsoft.com/en-us/azure/machine-learning/prompt-flow/get-started-prompt-flow?view=azureml-api-2"
    },
    {
      "title": "Prerequisite for Conformance Packs for AWS Config",
      "uri": "https://docs.aws.amazon.com/config/latest/developerguide/cpack-prerequisites.html"
    },
    {
      "title": "Access control with IAM",
      "uri": "https://docs.cloud.google.com/artifact-registry/docs/access-control"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:17:51.292Z",
  "indexable": true
}