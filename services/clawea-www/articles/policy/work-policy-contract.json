{
  "slug": "policy/work-policy-contract",
  "title": "Work Policy Contracts (WPC) | Policy Artifact | Claw EA",
  "category": "policy",
  "html": "<p>Work Policy Contracts (WPC) are signed, hash-addressed policy artifacts that let you permission agent execution with policy-as-code, not prompt text. In Claw EA, a WPC is fetched and verified at run time and can be pinned to a CST so the job only runs under the intended contract.</p>\n<p>This matters because OpenClaw is a baseline agent runtime built to run real tools, and prompt-only guardrails are not enforceable when the model is under pressure from tool output, prompt injection, or user instructions. A WPC turns “should” into “must” by defining what tool calls, model routing, and approval gates are allowed before execution proceeds.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Write a minimal WPC for the job type you want to allow. Start with tool allow/deny, sandbox expectations, and model routing rules that match your OpenClaw configuration.</p>\n  </li>\n  <li>\n    <p>Publish the WPC to the WPC registry (WPC = Work Policy Contract; signed, hash-addressed policy artifact; served by clawcontrols). Record the resulting policy hash and treat it as the immutable identifier for that contract.</p>\n  </li>\n  <li>\n    <p>Issue a CST (CST = scoped token, issued by clawscope) for the agent job. Include a scope hash and, when you need strict binding, pin the WPC policy hash so the token is only valid under that exact policy.</p>\n  </li>\n  <li>\n    <p>Configure the OpenClaw runtime to route model calls through clawproxy. This produces Gateway receipts (signed receipts emitted by clawproxy for model calls) for each model request made during the run.</p>\n  </li>\n  <li>\n    <p>Start the job with the CST and the policy hash reference. The execution path should fail closed if the WPC cannot be fetched or verified, or if the CST policy hash pin does not match.</p>\n  </li>\n  <li>\n    <p>At completion, collect the proof bundle (a harness artifact bundling receipts and related metadata for audit/verification). Store it internally and, when you need a marketplace-viewable record, publish the relevant artifact to Trust Pulse.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>A WPC is designed for operational failure modes, not theoretical ones. The goal is to ensure the agent cannot expand its authority just by producing different text.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection via tool output</td>\n      <td>Tool returns hostile instructions that try to trigger file access, credential reads, or new network calls.</td>\n      <td>WPC constrains tool availability and sensitive operations; OpenClaw tool policy and sandboxing reduce blast radius, and the run should fail if the contract does not allow the attempted tool call.</td>\n    </tr>\n    <tr>\n      <td>Policy drift between runs</td>\n      <td>An operator changes local config or a skill, and the agent silently gains new capability.</td>\n      <td>Pin the policy hash in the CST so a job cannot run under a different WPC; treat the policy hash as the approval boundary.</td>\n    </tr>\n    <tr>\n      <td>Replay of a previously valid token</td>\n      <td>A captured token is reused to run a second job with the same permissions.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) reduces reuse at the job boundary and helps ensure a CST is not accepted outside its intended run context.</td>\n    </tr>\n    <tr>\n      <td>Model call dispute or missing audit trail</td>\n      <td>You cannot prove which prompts, tool outputs, or model routes were used for a decision.</td>\n      <td>Route model calls through clawproxy to produce Gateway receipts, then package them into a proof bundle for verification and audit.</td>\n    </tr>\n    <tr>\n      <td>Over-permissioned escape hatch</td>\n      <td>Agent switches to elevated execution or a broader tool profile than intended.</td>\n      <td>Make elevated tool use explicitly disallowed unless the WPC declares it; align WPC intent with OpenClaw’s sandbox vs tool policy vs elevated separation.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Some controls are outside the proxy layer. For example, egress allowlists enforced outside clawproxy can be implemented as an additional guard, but should be treated as optional design work, not assumed.</p>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact, JSON-like example of the shape teams tend to use. Your internal schema can differ, but keep the same principles: explicit tool allowlists, explicit model routing, and a clear approval boundary.</p>\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"policy_hash\": \"b64u:...\",\n  \"issuer\": \"security-team\",\n  \"purpose\": \"permissioned execution approvals for agent jobs\",\n  \"runtime\": {\n    \"baseline\": \"OpenClaw\",\n    \"sandbox_mode\": \"all\",\n    \"allow_elevated\": false\n  },\n  \"tools\": {\n    \"allow\": [\"read\", \"write\", \"exec\", \"http\"],\n    \"deny\": [\"docker_socket\", \"host_browser_control\"]\n  },\n  \"model_calls\": {\n    \"route_via\": \"clawproxy\",\n    \"allowed_providers\": [\"OpenRouter via fal\"]\n  },\n  \"approvals\": {\n    \"required_for\": [\n      {\"action\": \"exec\", \"when\": \"workspaceAccess=rw and path_matches=/prod/\"},\n      {\"action\": \"http\", \"when\": \"host_not_in_allowlist\"}\n    ]\n  },\n  \"token_binding\": {\n    \"cst_scope_hash_required\": true,\n    \"cst_policy_hash_pinning\": \"recommended\"\n  },\n  \"validation\": {\n    \"fail_closed_on_missing_wpc\": true,\n    \"fail_closed_on_hash_mismatch\": true\n  }\n}\n</pre>\n<p>The important part is validation behavior. A missing WPC, an invalid signature, or a hash mismatch should stop execution before the agent is allowed to make model calls or touch tools.</p>\n\n<h2>What proof do you get?</h2>\n<p>Each model call routed through clawproxy can emit Gateway receipts. These receipts are designed to be collected, checked, and later used to answer “what did the model see and produce” for the calls that mattered.</p>\n<p>At the run level, Claw EA can produce a proof bundle that aggregates the run metadata and the Gateway receipts. The proof bundle is the artifact you hand to audit, incident response, or verification workflows.</p>\n<p>For workflows that need a durable viewer and sharing surface, you can store artifacts in Trust Pulse. Use it as the place to point reviewers to the specific run evidence, rather than trying to reconstruct intent from logs.</p>\n\n<h2>Rollback posture</h2>\n<p>WPC-based permissioning is meant to be reversible under pressure. The core rollback move is to tighten policy and force new jobs to re-auth under a new policy hash, rather than trying to edit prompt instructions mid-incident.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop a risky capability (for example, outbound HTTP tool use)</td>\n      <td>Publish a new WPC revision that removes the tool or adds approvals; require CST policy hash pinning to the new hash for new jobs.</td>\n      <td>New proof bundles show the new policy hash reference and the absence of disallowed tool calls; Gateway receipts show reduced model activity if calls are blocked.</td>\n    </tr>\n    <tr>\n      <td>Contain a suspected token leak</td>\n      <td>Rotate issuance and revoke CSTs in clawscope; rely on job-scoped CST binding to reduce replay at the job boundary.</td>\n      <td>CST issuance and revocation records, plus proof bundles that show which CST was used for which job.</td>\n    </tr>\n    <tr>\n      <td>Prove what happened after an incident</td>\n      <td>Freeze the relevant proof bundles and publish the audit view in Trust Pulse for reviewers.</td>\n      <td>Proof bundle contents including Gateway receipts and run metadata; Trust Pulse provides a stable reference for review.</td>\n    </tr>\n    <tr>\n      <td>Reduce host exposure</td>\n      <td>Align OpenClaw settings to sandbox more sessions and remove elevated paths; ensure the WPC forbids elevated unless explicitly approved.</td>\n      <td>OpenClaw configuration and sandbox explanation output, plus proof bundles after the change that show expected execution behavior.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Automatic cost budget enforcement can be implemented, but it should be treated as planned or an enterprise buildout item. Do not rely on it as your only safety net.</p>\n\n<h2>FAQ</h2>\n<h3>Why is prompt-only policy not enough for permissioned execution approvals?</h3>\n<p>Prompt text is not an enforcement boundary because the model can be convinced to ignore it, especially when tool output contains hostile instructions. Permissioned execution requires machine-enforced checks that run before a tool call or model route is allowed.</p>\n\n<h3>How does a WPC relate to OpenClaw tool policy and sandboxing?</h3>\n<p>OpenClaw provides local controls like tool allow/deny and Docker sandboxing, and those remain your immediate safety boundary. A WPC makes those constraints portable and auditable across jobs and environments by anchoring them to a signed, hash-addressed policy artifact.</p>\n\n<h3>What does CST policy hash pinning actually prevent?</h3>\n<p>It prevents a job from silently running under a different policy than the one that was approved. If the CST is pinned to a specific WPC hash, attempts to substitute a different policy can be detected and blocked.</p>\n\n<h3>Do I get evidence of the model calls that happened during the run?</h3>\n<p>Yes, when model traffic is routed through clawproxy, you get Gateway receipts for model calls. Those receipts are packaged with metadata into a proof bundle for audit and later verification.</p>\n\n<h3>Can WPCs express human approvals like the ones used in CI/CD?</h3>\n<p>Yes at the policy layer, as an approvals gate that must be satisfied before proceeding, but the integration that collects approvals is environment-specific. If you want to map it to enterprise approval systems, do it via official API or an MCP server, and keep the WPC as the enforcement contract that the runtime checks.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops\">Pipeline deployment approvals and checks (Azure DevOps)</a></li>\n</ul>",
  "description": "Work Policy Contracts (WPC) are signed, hash-addressed policy artifacts that let you permission agent execution with policy-as-code, not prompt text. In Claw EA, a WPC is fetched and verified at run time and can be pinne",
  "faqs": [
    {
      "q": "Why is prompt-only policy not enough for permissioned execution approvals?",
      "a": "Prompt text is not an enforcement boundary because the model can be convinced to ignore it, especially when tool output contains hostile instructions. Permissioned execution requires machine-enforced checks that run before a tool call or model route is allowed."
    },
    {
      "q": "How does a WPC relate to OpenClaw tool policy and sandboxing?",
      "a": "OpenClaw provides local controls like tool allow/deny and Docker sandboxing, and those remain your immediate safety boundary. A WPC makes those constraints portable and auditable across jobs and environments by anchoring them to a signed, hash-addressed policy artifact."
    },
    {
      "q": "What does CST policy hash pinning actually prevent?",
      "a": "It prevents a job from silently running under a different policy than the one that was approved. If the CST is pinned to a specific WPC hash, attempts to substitute a different policy can be detected and blocked."
    },
    {
      "q": "Do I get evidence of the model calls that happened during the run?",
      "a": "Yes, when model traffic is routed through clawproxy, you get Gateway receipts for model calls. Those receipts are packaged with metadata into a proof bundle for audit and later verification."
    },
    {
      "q": "Can WPCs express human approvals like the ones used in CI/CD?",
      "a": "Yes at the policy layer, as an approvals gate that must be satisfied before proceeding, but the integration that collects approvals is environment-specific. If you want to map it to enterprise approval systems, do it via official API or an MCP server, and keep the WPC as the enforcement contract that the runtime checks."
    }
  ],
  "sources": [
    {
      "title": "Pipeline deployment approvals - Azure",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops"
    },
    {
      "title": "Add a manual approval action to a stage",
      "uri": "https://docs.aws.amazon.com/codepipeline/latest/userguide/approvals.html"
    },
    {
      "title": "Using AWS managed policies for AWS Artifact",
      "uri": "https://docs.aws.amazon.com/artifact/latest/ug/security-iam-awsmanpol.html"
    },
    {
      "title": "Migrating to fine-grained permissions for AWS Artifact agreements",
      "uri": "https://docs.aws.amazon.com/artifact/latest/ug/migrating-agreements-to-v2-permissions.html"
    },
    {
      "title": "Example IAM policies for AWS Artifact in commercial AWS Regions",
      "uri": "https://docs.aws.amazon.com/artifact/latest/ug/example-iam-policies.html"
    },
    {
      "title": "Actions, resources, and condition keys for AWS Artifact",
      "uri": "https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsartifact.html"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:23:34.349Z",
  "indexable": true
}