{
  "slug": "policy/urm",
  "title": "Universal Run Manifest (URM) | Policy Artifact | Claw EA",
  "category": "policy",
  "html": "<p>The Universal Run Manifest (URM) is a small, machine-validated manifest that binds an OpenClaw run to specific inputs, approvals, and expected outputs, so execution can be permissioned and auditable. In Claw EA, the URM is used alongside a WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols) and a CST = scoped token (issued by clawscope) to ensure the agent can only run work that was explicitly approved.</p>\n<p>This is different from prompt-only controls: prompts can be edited, ignored, or injected, while a permissioned execution layer can fail closed based on hashes, scope rules, and verifiable Gateway receipts emitted by clawproxy for model calls.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the work boundary in a WPC and publish it to your WPC registry (served by clawcontrols). Keep the WPC narrow: allowed tool families, model/provider constraints, and any required logging/redaction expectations.</p>\n    <p>Record the WPC hash. Treat that hash as the stable approval handle used in the URM and in CST pinning.</p>\n  </li>\n  <li>\n    <p>Create a URM for the specific job. Include the WPC hash, the job identity, the expected artifacts, and the tool and model constraints you want enforced for this run.</p>\n    <p>Store the URM in your change-controlled system (repo, ticket attachment, or artifact store) and require an approval step that is external to the agent.</p>\n  </li>\n  <li>\n    <p>Issue a CST from clawscope for the run. Use CST scope hash and, when appropriate, optional policy hash pinning to bind the CST to the intended WPC and job context.</p>\n    <p>Prefer short TTL CSTs for interactive jobs and rotate CSTs between runs to limit replay value.</p>\n  </li>\n  <li>\n    <p>Run the agent using OpenClaw as the baseline agent runtime. Configure OpenClaw tool policy and sandboxing so the local blast radius is constrained even if a tool call is approved.</p>\n    <p>Route model traffic through clawproxy (for example, OpenRouter via fal routed through clawproxy) so model calls produce Gateway receipts.</p>\n  </li>\n  <li>\n    <p>Collect the proof outputs. At minimum, capture the URM, the referenced WPC hash, the CST scope hash, and Gateway receipts, then package them into a Proof bundle for audit and verification.</p>\n    <p>Optionally store the resulting artifact in Trust Pulse for viewing and later review.</p>\n  </li>\n  <li>\n    <p>Verify before accepting outputs. Verification should check that the WPC hash matches, the CST binding is correct, and the proof bundle’s receipts are present for the relevant model calls.</p>\n    <p>If anything is missing or mismatched, treat the run as unapproved and do not merge outputs into production workflows.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>URM is designed for the common failures you see when agents are connected to tools: prompt injection, drift in config, and “it ran on a different machine with different access.” The goal is not to claim perfect security, but to make approvals explicit and to make runs verifiable after the fact.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection changes what the agent attempts</td>\n      <td>The agent tries to call tools or models outside the approved plan, or tries to exfiltrate data through model prompts.</td>\n      <td>Permissioned execution checks: URM + WPC constraints, CST scope hash, and policy hash pinning. OpenClaw tool policy and sandboxing reduces what can be reached even when the model misbehaves.</td>\n    </tr>\n    <tr>\n      <td>Config drift between approval and execution</td>\n      <td>The run uses a different tool profile, a broader sandbox bind mount, or a different provider than the one reviewers assumed.</td>\n      <td>URM records intended policy hashes and run identity. OpenClaw includes concrete sandbox and tool policy controls, so the operator can lock to known-safe settings and audit them regularly.</td>\n    </tr>\n    <tr>\n      <td>Token replay or job confusion</td>\n      <td>A CST issued for one job is reused to run another job, or is replayed in a different environment.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) plus short TTLs. URM carries the job identifier that must match the CST binding and the proof bundle metadata.</td>\n    </tr>\n    <tr>\n      <td>Disputed model call history</td>\n      <td>You cannot prove which model/provider was called or whether a sensitive prompt was sent.</td>\n      <td>Gateway receipts emitted by clawproxy for model calls. A Proof bundle aggregates receipts and metadata so verification can be performed later.</td>\n    </tr>\n    <tr>\n      <td>Local tool execution overreach</td>\n      <td>An agent with shell access reads or modifies files, or uses elevated execution on the host.</td>\n      <td>Use OpenClaw sandboxing and tool allow/deny profiles; avoid elevated execution unless explicitly approved. Run OpenClaw security audit regularly to catch footguns.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>A URM should be small and deterministic. Think “approval envelope”: it names the policy (WPC), the run identity, the allowed execution envelope, and the artifacts you expect back.</p>\n<p>Below is a minimal schema-style snippet. Field names are illustrative; the important part is that the values are stable, hashable, and validated before execution and again at verification time.</p>\n<pre>\n{\n  \"urm_version\": \"1\",\n  \"job\": {\n    \"job_id\": \"acct:finops|proj:close|run:2026-02-11T10:15Z\",\n    \"requested_by\": \"user:alice\",\n    \"approved_by\": [\"user:finops-lead\"],\n    \"approval_ref\": \"ticket:FIN-1842\"\n  },\n  \"policy\": {\n    \"wpc_hash_b64u\": \"WPC_HASH_HERE\",\n    \"cst_scope_hash\": \"SCOPE_HASH_HERE\",\n    \"policy_hash_pinning\": true\n  },\n  \"execution\": {\n    \"agent_runtime\": \"OpenClaw\",\n    \"tool_profile\": \"finops-readonly\",\n    \"sandbox_mode\": \"all\",\n    \"model_routing\": \"via clawproxy\"\n  },\n  \"inputs\": [\n    {\"name\": \"ledger_export.csv\", \"sha256\": \"INPUT_SHA256\"}\n  ],\n  \"expected_outputs\": [\n    {\"name\": \"close_report.pdf\", \"sha256\": null},\n    {\"name\": \"recon_summary.json\", \"sha256\": null}\n  ],\n  \"retention\": {\n    \"proof_bundle_days\": 180,\n    \"notes\": \"Align with your pipeline/run retention policy\"\n  }\n}\n</pre>\n<p>Validation rules should be fail closed. If the WPC hash cannot be fetched and verified, if the CST scope hash does not match, or if the run is missing required Gateway receipts, treat the execution as unapproved.</p>\n\n<h2>What proof do you get?</h2>\n<p>URM itself is not the proof; it is the approval and intent record. The proof is created by binding URM to real execution artifacts that are hard to fake after the fact.</p>\n<p>In Claw EA, the core proof elements are:</p>\n<ul>\n  <li>\n    <p><strong>Gateway receipts</strong> emitted by clawproxy for model calls. These are used to verify that specific model requests happened through the approved proxy path.</p>\n  </li>\n  <li>\n    <p><strong>Proof bundle</strong> that packages the receipts and related metadata needed for audit and verification. This is what you hand to an auditor or to an internal incident review.</p>\n  </li>\n  <li>\n    <p><strong>WPC reference</strong> by hash, so the verifier can retrieve and validate the signed policy artifact from clawcontrols and confirm which policy was in force.</p>\n  </li>\n  <li>\n    <p><strong>CST binding evidence</strong>, including CST scope hash and, when used, policy hash pinning. This shows the token was intended for this policy and job context.</p>\n  </li>\n  <li>\n    <p><strong>Trust Pulse</strong> storage/viewer (optional) to store the resulting artifact for later viewing and review.</p>\n  </li>\n</ul>\n<p>Operationally, this gives you a clean separation: reviewers approve URM + WPC, operators run OpenClaw under those constraints, and verification checks that receipts and policy bindings match what was approved.</p>\n\n<h2>Rollback posture</h2>\n<p>URM is designed to make rollback boring. If a run is later deemed incorrect, you can identify exactly which job ID produced which outputs and which policy approvals were used.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Revoke future execution for the job</td>\n      <td>Revoke the CST and require a new URM approval for any rerun.</td>\n      <td>CST issuance and revocation records (from clawscope) plus the URM job_id referenced by the run.</td>\n    </tr>\n    <tr>\n      <td>Invalidate outputs from a suspect run</td>\n      <td>Quarantine artifacts produced by the run_id and block promotion to downstream systems.</td>\n      <td>Proof bundle ties outputs to URM metadata and Gateway receipts, so you can target the specific run.</td>\n    </tr>\n    <tr>\n      <td>Roll back to a prior approved behavior</td>\n      <td>Re-run with a previously approved WPC hash and a new CST, rather than editing prompts in place.</td>\n      <td>Hash-addressed WPC references in URM let you select a known prior policy without ambiguity.</td>\n    </tr>\n    <tr>\n      <td>Reduce blast radius after an incident</td>\n      <td>Tighten OpenClaw tool policy and sandbox mode, then require a new URM approval for the widened scope later.</td>\n      <td>OpenClaw configuration is auditable locally; URM documents the intended execution envelope for the job.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Retention matters for rollback because you cannot investigate what you no longer have. Align proof bundle retention with your existing CI/CD or pipeline retention policies so evidence is available for the period your org expects to investigate incidents.</p>\n\n<h2>FAQ</h2>\n<h3>Why do I need URM if I already have a prompt and a checklist?</h3>\n<p>A prompt and checklist are advisory and can be bypassed by injection or operator error. URM is a machine-checked artifact that binds the approval to a WPC hash, a CST scope hash, and the expected proof outputs.</p>\n\n<h3>Is URM a replacement for OpenClaw tool policy and sandboxing?</h3>\n<p>No. OpenClaw controls the local boundary: which tools exist and where they run (Docker vs host). URM complements that by binding approvals and producing verifiable proof when execution happens.</p>\n\n<h3>What is the minimum I should store for audit?</h3>\n<p>Store the URM, the referenced WPC hash, and the Proof bundle containing Gateway receipts. If you need a central viewer, store the artifact in Trust Pulse.</p>\n\n<h3>What fails closed in a URM workflow?</h3>\n<p>Typical fail-closed checks include: WPC cannot be fetched and verified, CST scope hash mismatch, missing Gateway receipts for model calls, or job-scoped binding mismatch. When a check fails, treat the run as unapproved and do not accept outputs.</p>\n\n<h3>How do approvals work for high-risk tools?</h3>\n<p>Put the approval in policy-as-code, not in the prompt. For high-risk tools, require a narrower WPC, shorter CST TTL, and stricter OpenClaw tool allow/deny profiles, then require a new URM when scope changes.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/policies/retention?view=azure-devops\">Retention policies for builds, releases, and test - Azure Pipelines</a></li>\n</ul>",
  "description": "The Universal Run Manifest (URM) is a small, machine-validated manifest that binds an OpenClaw run to specific inputs, approvals, and expected outputs, so execution can be permissioned and auditable. In Claw EA, the URM ",
  "faqs": [
    {
      "q": "Why do I need URM if I already have a prompt and a checklist?",
      "a": "A prompt and checklist are advisory and can be bypassed by injection or operator error. URM is a machine-checked artifact that binds the approval to a WPC hash, a CST scope hash, and the expected proof outputs."
    },
    {
      "q": "Is URM a replacement for OpenClaw tool policy and sandboxing?",
      "a": "No. OpenClaw controls the local boundary: which tools exist and where they run (Docker vs host). URM complements that by binding approvals and producing verifiable proof when execution happens."
    },
    {
      "q": "What is the minimum I should store for audit?",
      "a": "Store the URM, the referenced WPC hash, and the Proof bundle containing Gateway receipts. If you need a central viewer, store the artifact in Trust Pulse."
    },
    {
      "q": "What fails closed in a URM workflow?",
      "a": "Typical fail-closed checks include: WPC cannot be fetched and verified, CST scope hash mismatch, missing Gateway receipts for model calls, or job-scoped binding mismatch. When a check fails, treat the run as unapproved and do not accept outputs."
    },
    {
      "q": "How do approvals work for high-risk tools?",
      "a": "Put the approval in policy-as-code, not in the prompt. For high-risk tools, require a narrower WPC, shorter CST TTL, and stricter OpenClaw tool allow/deny profiles, then require a new URM when scope changes."
    }
  ],
  "sources": [
    {
      "title": "Using artifact attestations to establish provenance for builds - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/how-tos/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds"
    },
    {
      "title": "Using artifact attestations to establish provenance for builds - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds"
    },
    {
      "title": "Retention policies for builds, releases, and test - Azure Pipelines",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/pipelines/policies/retention?view=azure-devops"
    },
    {
      "title": "Artifact Registry roles and permissions - Google Cloud Documentation",
      "uri": "https://docs.cloud.google.com/iam/docs/roles-permissions/artifactregistry"
    },
    {
      "title": "Dataflow security and permissions",
      "uri": "https://cloud.google.com/dataflow/docs/concepts/security-and-permissions"
    },
    {
      "title": "Secure-by-default Certification for proactive Security Engagement",
      "uri": "https://www.salesforce.com/blog/secure-by-default-certification-for-proactive-security-engagement/"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:22:47.920Z",
  "indexable": true
}