{
  "slug": "policy/receipt-binding",
  "title": "Receipt Binding | Policy Artifact | Claw EA",
  "category": "policy",
  "html": "<p>Receipt binding is how you prove that a specific agent run happened under a specific policy artifact, and that its model calls were not replayed, swapped, or mixed from another run. In Claw EA, the binding links a WPC, a job-scoped CST, and gateway receipts into a proof bundle that can be verified later, fail-closed.</p>\n<p>This matters because OpenClaw is the baseline agent runtime, and prompt-only controls do not constrain tools, network paths, or model providers in a way you can audit. Permissioned execution approvals require policy-as-code plus cryptographic linkage, not “the model promised to behave.”</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this runbook when you need approvals for a run and an audit trail you can replay in verification tooling. The goal is to make every model call and decision traceable to the WPC and the job identity.</p>\n<ol>\n  <li>\n    <p>Define and publish the policy artifact as a WPC. Treat the WPC as the machine-readable approval boundary: tool profile, allowed providers, and any required human gates live here.</p>\n    <p>Store the signed, hash-addressed WPC in the WPC registry (served by clawcontrols), and record the policy hash in your change ticket.</p>\n  </li>\n  <li>\n    <p>Issue a job-scoped CST for the run. The CST is issued by clawscope and should include a scope hash that reflects the job identity and the intended permissions.</p>\n    <p>Optionally pin the WPC hash in the CST so a token minted for Policy A cannot be used to execute under Policy B.</p>\n  </li>\n  <li>\n    <p>Start the OpenClaw agent run with the policy selected and the CST attached to the execution context. Keep the agent’s tool configuration aligned with the WPC so local allow/deny lists and sandboxing match the contract.</p>\n    <p>Run OpenClaw’s security audit regularly to reduce operator footguns before you rely on receipts for approvals.</p>\n  </li>\n  <li>\n    <p>Route model traffic through clawproxy. Each model call produces gateway receipts that are signed and include the metadata needed to bind the call to the job identity.</p>\n    <p>If you use OpenRouter via fal, keep the provider route consistent so receipts describe the actual provider path used.</p>\n  </li>\n  <li>\n    <p>Collect the proof bundle at the end of the run. The proof bundle is the harness artifact that packages gateway receipts plus run metadata (run id, agent id, policy hash, scope hash, timestamps, and relevant config fingerprints).</p>\n    <p>Store the proof bundle for audit, and optionally publish the result into a Trust Pulse artifact for viewing.</p>\n  </li>\n  <li>\n    <p>Verify before approval. Verification should check WPC authenticity, CST binding, and receipt signatures and linkage; if any check fails, the run should not be marked approved or used to justify downstream actions.</p>\n    <p>Keep verification outputs attached to your ticket so approvals are tied to evidence, not screenshots.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Receipt binding is designed for operational failure modes: replayed receipts, policy swapping, and cross-run mixing. The controls below assume an attacker can influence prompts and can attempt to reuse artifacts from other runs.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (what to verify)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Receipt replay from a prior job</td>\n      <td>An attacker tries to attach old gateway receipts to a new approval request.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding; verify job id and CST binding claims match the proof bundle run metadata.</td>\n    </tr>\n    <tr>\n      <td>Policy substitution</td>\n      <td>A run is executed under a looser policy, but presented as if it ran under a stricter one.</td>\n      <td>Verify WPC signature and policy hash, then check optional policy hash pinning in the CST and match it to the proof bundle policy hash.</td>\n    </tr>\n    <tr>\n      <td>Cross-run receipt mixing</td>\n      <td>Receipts from multiple runs are merged to fabricate an execution story.</td>\n      <td>Verify all gateway receipts share the same run id, job id, and scope hash, and that receipt timestamps and sequence metadata are consistent.</td>\n    </tr>\n    <tr>\n      <td>Out-of-band model calls</td>\n      <td>The agent calls a model directly, bypassing clawproxy, so no receipts exist.</td>\n      <td>Fail approvals if required receipt coverage is incomplete; enforce “receipts required” in the WPC and verify the provider path is routed through clawproxy.</td>\n    </tr>\n    <tr>\n      <td>Tool escalation through local misconfig</td>\n      <td>OpenClaw tools run with broader access than the policy intended (for example elevated exec on host).</td>\n      <td>Bind proof metadata to the effective tool policy and sandbox mode; verify OpenClaw configuration fingerprints match the WPC expectations and reject mismatches.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a minimal, schema-style example showing what you want bound together. The exact field names vary by enterprise buildout, but the semantics should be stable: hash-addressed policy, scoped token identity, and receipts that reference both.</p>\n\n<pre>\n{\n  \"wpc\": {\n    \"policy_hash_b64u\": \"WPC_HASH\",\n    \"issuer\": \"clawcontrols\",\n    \"version\": \"v1\",\n    \"intent\": \"permissioned execution approvals\"\n  },\n  \"approval_requirements\": {\n    \"receipts_required\": true,\n    \"min_receipt_count\": 1,\n    \"deny_if_policy_mismatch\": true\n  },\n  \"execution_binding\": {\n    \"job_id\": \"job_2026_02_11_001\",\n    \"run_id\": \"run_7f1c...\",\n    \"agent_id\": \"agent_finops_bot\",\n    \"scope_hash\": \"SCOPE_HASH\",\n    \"cst_policy_hash_pinning\": \"WPC_HASH\"\n  },\n  \"model_routing\": {\n    \"must_use_clawproxy\": true,\n    \"allowed_model_routes\": [\n      { \"provider\": \"openrouter_via_fal\", \"models\": [\"allowed-prefix/*\"] }\n    ]\n  }\n}\n</pre>\n\n<p>Validation should be fail-closed. If a proof bundle claims policy hash X but the CST is pinned to policy hash Y, the run is not “partially valid”; it is not eligible for approval.</p>\n\n<p>Similarly, if receipts exist but do not cover the required portion of model calls (for example missing the calls that generated the final decision), treat it as an incomplete record. If you need completeness guarantees, make “receipts required” part of the WPC and enforce it consistently.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get three layers of evidence that are meant to be checked together. Each layer limits a different kind of tampering, and the full chain is what supports permissioned execution approvals.</p>\n\n<p>First, the WPC is the signed policy artifact: a Work Policy Contract (WPC) served by clawcontrols and addressed by its hash. This is the “what was allowed” statement, and the hash is what you pin and reference everywhere else.</p>\n\n<p>Second, the CST is the per-job authorization artifact: a scoped token (CST) issued by clawscope. Its scope hash describes the authorized context, and optional policy hash pinning prevents token reuse under a different WPC.</p>\n\n<p>Third, gateway receipts are the per-call evidence emitted by clawproxy for model calls. A proof bundle packages these receipts with run metadata so you can verify that the model traffic for this run was mediated and that the receipts belong to this job.</p>\n\n<p>Operationally, you should treat the proof bundle as the approval packet. If you publish a Trust Pulse artifact, it becomes the convenient viewing surface, but your audit decision should still be anchored on verifying the proof bundle contents and signatures.</p>\n\n<h2>Rollback posture</h2>\n<p>Receipt binding supports safe rollback because you can quickly distinguish “policy changed,” “token scope changed,” and “provider path changed.” The table below is a practical set of rollback actions and what evidence to check before resuming execution.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to check</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Revert to prior policy</td>\n      <td>Re-select the prior WPC by its policy hash and re-issue a new CST for the new job.</td>\n      <td>WPC hash matches the approved version; CST policy hash pinning matches; new proof bundle references the reverted WPC.</td>\n    </tr>\n    <tr>\n      <td>Invalidate a compromised token</td>\n      <td>Revoke the CST and mint a new job-scoped CST; do not reuse proof bundles from the compromised job.</td>\n      <td>CST identity changes; receipts for the new run bind to the new job id; anti-replay binding rejects reuse of old receipts.</td>\n    </tr>\n    <tr>\n      <td>Switch model route</td>\n      <td>Update the WPC to allow the new route and require clawproxy mediation, then re-run with a new CST.</td>\n      <td>Proof bundle shows the new provider path in receipts; no gaps in receipt coverage for the decision-critical calls.</td>\n    </tr>\n    <tr>\n      <td>Quarantine a suspect run</td>\n      <td>Stop approvals for that run id, keep artifacts immutable, and re-run under the same WPC with a new job id.</td>\n      <td>Verification output flags the mismatch (policy hash, scope hash, or receipt signatures); quarantined proof bundle is preserved for audit.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is policy-as-code required instead of prompt-only instructions?</h3>\n<p>Prompt-only controls do not bind tools, model routes, or token scope to an enforceable contract, and they are easy to bypass via injection or operator error. A WPC provides a hash-addressed, signed artifact that can be pinned in a CST and checked against gateway receipts.</p>\n\n<h3>What exactly is “receipt binding” in Claw EA terms?</h3>\n<p>It is the linkage between a WPC (policy hash), a job-scoped CST (scope hash and optional policy hash pinning), and gateway receipts (signed call records). The proof bundle packages these so a verifier can reject replays, policy swaps, and cross-run mixing.</p>\n\n<h3>Can I approve a run if some model calls have receipts and others do not?</h3>\n<p>You can, but you should treat it as a different approval class because the unreceipted calls are not verifiable. If your process requires permissioned execution approvals, make receipt coverage a WPC requirement and fail approvals when coverage is incomplete.</p>\n\n<h3>How does this relate to OpenClaw’s local sandbox and tool policy?</h3>\n<p>OpenClaw controls local execution through sandboxing, tool policy, and elevated mode, which reduces blast radius at runtime. Receipt binding complements that by proving which policy and route were used, and by producing artifacts you can verify after the run.</p>\n\n<h3>Is this similar to cloud compliance attestations?</h3>\n<p>Conceptually, yes: you are producing an attestation-like record that a system operated under declared policy. The difference is that receipt binding is centered on model call mediation and job-scoped authorization, rather than only marking a resource as compliant.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/governance/policy/concepts/attestation-structure\">Details of the Azure Policy attestation structure</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/attestation/author-sign-policy\">How to author an Azure Attestation policy</a></li>\n</ul>",
  "description": "Receipt binding is how you prove that a specific agent run happened under a specific policy artifact, and that its model calls were not replayed, swapped, or mixed from another run. In Claw EA, the binding links a WPC, a",
  "faqs": [
    {
      "q": "Why is policy-as-code required instead of prompt-only instructions?",
      "a": "Prompt-only controls do not bind tools, model routes, or token scope to an enforceable contract, and they are easy to bypass via injection or operator error. A WPC provides a hash-addressed, signed artifact that can be pinned in a CST and checked against gateway receipts."
    },
    {
      "q": "What exactly is “receipt binding” in Claw EA terms?",
      "a": "It is the linkage between a WPC (policy hash), a job-scoped CST (scope hash and optional policy hash pinning), and gateway receipts (signed call records). The proof bundle packages these so a verifier can reject replays, policy swaps, and cross-run mixing."
    },
    {
      "q": "Can I approve a run if some model calls have receipts and others do not?",
      "a": "You can, but you should treat it as a different approval class because the unreceipted calls are not verifiable. If your process requires permissioned execution approvals, make receipt coverage a WPC requirement and fail approvals when coverage is incomplete."
    },
    {
      "q": "How does this relate to OpenClaw’s local sandbox and tool policy?",
      "a": "OpenClaw controls local execution through sandboxing, tool policy, and elevated mode, which reduces blast radius at runtime. Receipt binding complements that by proving which policy and route were used, and by producing artifacts you can verify after the run."
    },
    {
      "q": "Is this similar to cloud compliance attestations?",
      "a": "Conceptually, yes: you are producing an attestation-like record that a system operated under declared policy. The difference is that receipt binding is centered on model call mediation and job-scoped authorization, rather than only marking a resource as compliant."
    }
  ],
  "sources": [
    {
      "title": "Details of the Azure Policy attestation structure - Azure Policy",
      "uri": "https://learn.microsoft.com/en-us/azure/governance/policy/concepts/attestation-structure"
    },
    {
      "title": "How to author an Azure Attestation policy",
      "uri": "https://learn.microsoft.com/en-us/azure/attestation/author-sign-policy"
    },
    {
      "title": "Implementing authorization in Amazon Verified Permissions",
      "uri": "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/authorization.html"
    },
    {
      "title": "Actions, resources, and condition keys for AWS Glue",
      "uri": "https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsglue.html"
    },
    {
      "title": "Policy \n\n    \n    \n       \n    \n\n     \n      \n      Stay organized with collections\n     \n     \n      \n      Save and categorize content based on your preferences.",
      "uri": "https://docs.cloud.google.com/artifact-registry/docs/reference/rest/v1/Policy"
    },
    {
      "title": "Artifact Signing FAQ | Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/azure/artifact-signing/faq"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:19:38.377Z",
  "indexable": true
}