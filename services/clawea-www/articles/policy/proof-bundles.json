{
  "slug": "policy/proof-bundles",
  "title": "Proof Bundles | Policy Artifact | Claw EA",
  "category": "policy",
  "html": "<p>A proof bundle is the artifact you keep when you need to prove what an agent did, under which policy, and which model calls happened. In Claw EA, proof bundles package gateway receipts (from clawproxy) plus run metadata so a verifier can fail-closed if anything is missing or tampered with.</p>\n<p>OpenClaw is the baseline agent runtime, but prompts are not a permission system. If you want repeatable controls, you need permissioned execution using policy-as-code, with a WPC and a CST that binds the run to explicit, machine-enforced constraints.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the policy you want enforced as a WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols). Treat the WPC hash as the stable identifier for what was allowed.</p>\n    <p>Keep the WPC small and explicit: allowed providers, tool boundaries, redaction expectations, and required proof outputs.</p>\n  </li>\n  <li>\n    <p>Issue a CST = scoped token (issued by clawscope) for the job. Use CST scope hash and optional policy hash pinning so the token is only valid for the intended scope, and optionally only for that WPC hash.</p>\n    <p>This is what turns “the agent should” into “the agent can only”. Prompts can be edited; token scope cannot.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw with model traffic routed through clawproxy. The proxy emits gateway receipts for model calls, which become the cryptographic evidence for what was requested and returned at the model boundary.</p>\n    <p>If you need tool isolation, rely on OpenClaw sandbox and tool policy controls locally. The proof bundle is compatible with sandboxed execution, but sandboxing and policy are distinct concerns.</p>\n  </li>\n  <li>\n    <p>Collect receipts and run metadata into a proof bundle. The bundle should include the WPC reference (hash) and enough binding data to show the receipts came from the run that used the CST.</p>\n    <p>Do not “summarize” receipts into logs. Keep the raw receipt envelopes so verification can be deterministic.</p>\n  </li>\n  <li>\n    <p>Verify the proof bundle using a fail-closed verifier flow. Verification should check signatures, binding between run and receipts, and consistency with the pinned WPC hash when present.</p>\n    <p>If any required component is missing (for example, receipts for model calls), treat the bundle as unverifiable and downgrade or reject the run for audit purposes.</p>\n  </li>\n  <li>\n    <p>Optionally store the proof bundle as a Trust Pulse for later viewing and audit. Trust Pulse is the marketplace-stored artifact for audit/viewing.</p>\n    <p>For high-sensitivity environments, keep an offline copy of the proof bundle and verify it without relying on network availability.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Proof bundles are designed for post-run verification: what happened, under what constraints, and whether the model boundary is intact. They do not prevent every failure mode in real time, but they make policy bypasses and missing evidence detectable.</p>\n<p>The core operational goal is simple: if someone alters the story after the fact, verification fails.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt-only “policy” gets ignored</td>\n      <td>The agent is instructed to behave, but it can still call tools or models outside intended boundaries when coerced.</td>\n      <td>Permissioned execution: WPC reference plus CST scope hash and optional policy hash pinning. Prompts guide behavior; CST constrains capability.</td>\n    </tr>\n    <tr>\n      <td>Receipts are removed or replaced</td>\n      <td>A run looks clean because the riskiest model calls are omitted from logs.</td>\n      <td>Gateway receipts are signed by clawproxy, then included in the proof bundle. Verification fails if required receipts are absent or signatures do not validate.</td>\n    </tr>\n    <tr>\n      <td>Replay of a previously authorized token</td>\n      <td>An attacker reuses a valid CST to run a different job and tries to pass it off as the original.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) makes tokens job-bound so they cannot be reused across runs without detection.</td>\n    </tr>\n    <tr>\n      <td>Policy drift between approval and execution</td>\n      <td>Teams approve “Policy A”, but the agent runs under “Policy B” due to config changes or operator error.</td>\n      <td>Pin the WPC hash and include the WPC hash reference inside the proof bundle. Verification checks the pinned hash matches the bundle’s declared policy.</td>\n    </tr>\n    <tr>\n      <td>Local tool blast radius in the runtime</td>\n      <td>Even with good model receipts, a misconfigured runtime could allow unsafe filesystem or process access.</td>\n      <td>Use OpenClaw sandbox and tool policy, and regularly run the OpenClaw security audit to catch common footguns. Proof bundles help detect model boundary behavior, not fix local OS hardening.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the minimum idea: a WPC hash that identifies the policy artifact, plus CST constraints that pin the policy and bind the run. Treat it like a contract between approvers, operators, and auditors.</p>\n<p>Keep the fields explicit, and make verification requirements part of the policy so missing evidence becomes a hard failure.</p>\n\n<pre>\n{\n  \"job\": {\n    \"id\": \"job_2026_02_11_001\",\n    \"runtime\": \"openclaw\",\n    \"purpose\": \"Generate weekly ops report from internal tickets\"\n  },\n  \"policy\": {\n    \"wpc_hash_b64u\": \"WPC_HASH_BASE64URL\",\n    \"require_gateway_receipts\": true,\n    \"require_proof_bundle\": true\n  },\n  \"auth\": {\n    \"cst_required\": true,\n    \"cst_scope_hash\": \"SCOPE_HASH\",\n    \"pin_wpc_hash\": \"WPC_HASH_BASE64URL\",\n    \"job_scoped_binding\": true\n  },\n  \"model_boundary\": {\n    \"proxy\": \"clawproxy\",\n    \"receipts\": \"gateway_receipts\"\n  },\n  \"verification\": {\n    \"fail_closed\": true,\n    \"min_acceptable_result\": \"verified_receipts_and_bindings\"\n  }\n}\n</pre>\n\n<p>Why this is not prompt-only: prompts can request “do not access X”, but the agent can still be induced to do it. A WPC plus CST turns approvals into enforceable constraints, and the proof bundle makes the run auditable.</p>\n\n<h2>What proof do you get?</h2>\n<p>A proof bundle is the unit you hand to an auditor or to your own incident response workflow. It is a harness artifact bundling receipts and related metadata for audit/verification.</p>\n<p>In practice, you get four concrete things: a policy reference, an authorization binding, signed model-call receipts, and a verification outcome that can be repeated later.</p>\n\n<ul>\n  <li>\n    <p><strong>WPC reference</strong>: the WPC hash that identifies the exact policy artifact that should have governed the run. This is how you avoid “we meant the other config file” debates.</p>\n  </li>\n  <li>\n    <p><strong>CST binding</strong>: evidence that a CST was used, with CST scope hash and optional policy hash pinning. This is how you show capability was constrained, not merely requested.</p>\n  </li>\n  <li>\n    <p><strong>Gateway receipts</strong>: signed receipts emitted by clawproxy for model calls. These are the cryptographic receipts for the model boundary, usable for verification after the run.</p>\n  </li>\n  <li>\n    <p><strong>Proof bundle envelope</strong>: a single package that ties the above together with run identifiers and metadata so the bundle can be verified as a whole. If you store it in Trust Pulse, you also get a consistent artifact location for review.</p>\n  </li>\n</ul>\n\n<p>Verification rules should be strict. If signatures do not validate, if receipt-to-run binding fails, or if the pinned WPC hash does not match, the correct outcome is “unverified” rather than “best effort”.</p>\n\n<h2>Rollback posture</h2>\n<p>Proof bundles do not automatically undo side effects, but they make rollback and containment operationally faster. They answer: what changed, which tools were invoked, and which model calls preceded each action, so you can triage with evidence.</p>\n<p>Rollback should be planned as a playbook paired with the WPC. The WPC defines what actions are allowed; the rollback playbook defines what actions are taken when verification fails or output is incorrect.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop further runs under the same policy</td>\n      <td>Revoke or expire CSTs for the job scope, and rotate to a new job scope hash for the next attempt.</td>\n      <td>Proof bundle shows CST binding and scope hash; clawscope history supports why the run was blocked going forward.</td>\n    </tr>\n    <tr>\n      <td>Invalidate outputs generated under disputed constraints</td>\n      <td>Mark artifacts as non-authoritative if the proof bundle fails verification, or if required receipts are missing.</td>\n      <td>Verification report from the proof bundle, plus missing or invalid gateway receipts.</td>\n    </tr>\n    <tr>\n      <td>Re-run with tightened permissions</td>\n      <td>Issue a new CST with narrower scope and optionally pin to an updated WPC hash. Use OpenClaw tool policy and sandbox settings to reduce local blast radius.</td>\n      <td>New proof bundle references the new WPC hash; differences are mechanically comparable by policy hash.</td>\n    </tr>\n    <tr>\n      <td>Post-incident audit package</td>\n      <td>Export the proof bundle and store it as a Trust Pulse for shared review, while keeping an offline copy for incident response.</td>\n      <td>Trust Pulse artifact plus the underlying proof bundle and gateway receipts for independent verification.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>What is the difference between gateway receipts and a proof bundle?</h3>\n<p>Gateway receipts are signed receipts emitted by clawproxy for model calls. A proof bundle collects those receipts plus run metadata and bindings so verification can be done on the whole run, not on individual calls.</p>\n\n<h3>Why is policy-as-code required instead of putting rules in the prompt?</h3>\n<p>A prompt is advisory: it can be changed, ignored, or overridden by injection. A WPC plus a CST is enforceable: the CST scope hash and optional policy hash pinning constrain what the runtime is allowed to do, and the proof bundle provides evidence that those constraints were in effect.</p>\n\n<h3>Can I verify a proof bundle offline?</h3>\n<p>Yes, that is the intent. Store the proof bundle and verify signatures and bindings without needing to rely on live access to the runtime environment.</p>\n\n<h3>Does a proof bundle prove tool actions on the host?</h3>\n<p>It proves the model boundary via gateway receipts, and it binds the run to a declared policy and token scope. Host and tool execution safety still relies on OpenClaw sandbox and tool policy controls, plus your OS and deployment hardening.</p>\n\n<h3>What happens if a receipt is missing?</h3>\n<p>Verification should fail-closed if the WPC requires receipts and the bundle cannot prove the model calls. Operationally, treat the run as unauditable and do not promote its outputs to authoritative status.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://docs.github.com/en/actions/how-tos/secure-your-work/use-artifact-attestations/verify-attestations-offline\">Verifying attestations offline (GitHub Docs)</a></li>\n  <li><a href=\"https://docs.github.com/en/actions/concepts/security/artifact-attestations\">Artifact attestations (GitHub Docs)</a></li>\n</ul>",
  "description": "A proof bundle is the artifact you keep when you need to prove what an agent did, under which policy, and which model calls happened. In Claw EA, proof bundles package gateway receipts (from clawproxy) plus run metadata ",
  "faqs": [
    {
      "q": "What is the difference between gateway receipts and a proof bundle?",
      "a": "Gateway receipts are signed receipts emitted by clawproxy for model calls. A proof bundle collects those receipts plus run metadata and bindings so verification can be done on the whole run, not on individual calls."
    },
    {
      "q": "Why is policy-as-code required instead of putting rules in the prompt?",
      "a": "A prompt is advisory: it can be changed, ignored, or overridden by injection. A WPC plus a CST is enforceable: the CST scope hash and optional policy hash pinning constrain what the runtime is allowed to do, and the proof bundle provides evidence that those constraints were in effect."
    },
    {
      "q": "Can I verify a proof bundle offline?",
      "a": "Yes, that is the intent. Store the proof bundle and verify signatures and bindings without needing to rely on live access to the runtime environment."
    },
    {
      "q": "Does a proof bundle prove tool actions on the host?",
      "a": "It proves the model boundary via gateway receipts, and it binds the run to a declared policy and token scope. Host and tool execution safety still relies on OpenClaw sandbox and tool policy controls, plus your OS and deployment hardening."
    },
    {
      "q": "What happens if a receipt is missing?",
      "a": "Verification should fail-closed if the WPC requires receipts and the bundle cannot prove the model calls. Operationally, treat the run as unauditable and do not promote its outputs to authoritative status."
    }
  ],
  "sources": [
    {
      "title": "NIST Special Publication 800-63C",
      "uri": "https://pages.nist.gov/800-63-4/sp800-63c.html"
    },
    {
      "title": "Verifying attestations offline - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/how-tos/secure-your-work/use-artifact-attestations/verify-attestations-offline"
    },
    {
      "title": "Artifact attestations - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/concepts/security/artifact-attestations"
    },
    {
      "title": "Using artifact attestations to establish provenance for builds - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:18:41.664Z",
  "indexable": true
}