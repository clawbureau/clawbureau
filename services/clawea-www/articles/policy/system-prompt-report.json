{
  "slug": "policy/system-prompt-report",
  "title": "System Prompt Report | Policy Artifact | Claw EA",
  "category": "policy",
  "html": "<h2>Direct Answer</h2>\n<p>A System Prompt Report is a policy artifact that makes an agent’s “prompt commitments” auditable and enforceable during execution, not just readable in a text file. In Claw EA, the report is bound to a WPC and enforced through CST scoping plus gateway receipts and a proof bundle, so approvals can be verified after the run and checked before the run proceeds.</p>\n<p>OpenClaw is the baseline agent runtime here, but prompt text alone is not a control plane. Permissioned execution requires policy-as-code with fail-closed verification, because prompts can be overridden, injected, or simply ignored by tools and plugins at runtime.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>This runbook is written for teams that need execution approvals tied to what the agent was actually allowed to do. It assumes you already run agents in OpenClaw and want a durable approval record that survives prompt edits and model changes.</p>\n<ol>\n  <li>\n    <p>Define the intended system prompt commitments as a stable “report template.” Include what must be true (constraints), what may vary (parameters), and what is disallowed (explicit prohibitions).</p>\n  </li>\n  <li>\n    <p>Encode the enforcement intent in a WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols). Treat the WPC hash as the approval target, not a mutable prompt string.</p>\n  </li>\n  <li>\n    <p>Issue a CST = scoped token (issued by clawscope) for the job. Use CST scope hash and, when you need strict approvals, pin the policy hash so the run is bound to a specific WPC.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy so you receive gateway receipts for model calls. If you use OpenRouter, run it via fal routed through clawproxy so the same receipt mechanism applies.</p>\n  </li>\n  <li>\n    <p>At start-of-run, verify the WPC fetched by hash and verify CST claims. If verification fails, block tool execution and model egress rather than “best-effort” continuing.</p>\n  </li>\n  <li>\n    <p>At end-of-run, collect the proof bundle (a harness artifact bundling receipts and related metadata for audit/verification). Store it where your auditors can access it, optionally publishing a Trust Pulse for marketplace-stored artifact storage/viewer.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>The System Prompt Report exists because prompt text is not a security boundary. Your real boundary is the execution layer: which tools can run, which models can be called, and which identities can mint or reuse permissions.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control in Claw EA and OpenClaw</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection overrides “commitments”</td>\n      <td>An external message convinces the agent to ignore the system prompt and perform a restricted action.</td>\n      <td>Bind execution to a WPC and enforce via CST scope hash and optional policy hash pinning. Use OpenClaw tool policy and sandboxing to reduce blast radius.</td>\n    </tr>\n    <tr>\n      <td>Silent policy drift</td>\n      <td>The prompt changes after approval, but the job still runs and looks “approved” in chat logs.</td>\n      <td>Approve the WPC hash, not the prompt string. Require fail-closed fetch/verify of the WPC at run start and record the hash in the proof bundle.</td>\n    </tr>\n    <tr>\n      <td>Token replay across jobs</td>\n      <td>A CST from a previous run is reused to execute a new run with the same privileges.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) so the token is bound to a specific job context.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable model usage</td>\n      <td>You cannot prove which model was called, with what request, under what policy.</td>\n      <td>Gateway receipts emitted by clawproxy for model calls, then bundled into a proof bundle for later verification.</td>\n    </tr>\n    <tr>\n      <td>Over-broad tool access in the runtime</td>\n      <td>The agent has shell or filesystem access beyond what the prompt intended, so one mistake becomes a system compromise.</td>\n      <td>Use OpenClaw tool policy allow and deny lists plus Docker sandboxing. Treat “elevated” host execution as an explicit exception with separate approval.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows a minimal schema-style System Prompt Report that can be referenced by, or embedded into, a WPC. The point is not the exact fields, but that the report is deterministic, reviewable, and bindable to execution via hashes.</p>\n<pre>\n{\n  \"artifact_type\": \"system_prompt_report\",\n  \"version\": \"1\",\n  \"system_prompt_sha256\": \"base16...\",\n  \"commitments\": [\n    {\n      \"id\": \"no_secret_exfil\",\n      \"statement\": \"Do not output secrets or raw credentials.\",\n      \"enforcement\": \"fail_closed\"\n    },\n    {\n      \"id\": \"tools_minimal\",\n      \"statement\": \"Only use allowlisted tools; no host elevated execution.\",\n      \"enforcement\": \"fail_closed\"\n    }\n  ],\n  \"approvals\": [\n    {\n      \"approver\": \"security-team\",\n      \"scope\": \"job_class:finance-recon\",\n      \"approved_wpc_hash\": \"b64u...\",\n      \"expires_utc\": \"2026-12-31T00:00:00Z\"\n    }\n  ],\n  \"runtime_bindings\": {\n    \"cst_scope_hash_required\": true,\n    \"policy_hash_pinning\": \"required\",\n    \"receipts_required\": true\n  }\n}\n</pre>\n<p>Validation rules should be simple and strict. If the WPC hash does not match what was approved, or if a CST is missing the expected scope hash, the run should stop before any external model calls or tool actions occur.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get two layers of evidence: what policy was supposed to apply, and what actually happened. The WPC provides the signed, hash-addressed policy artifact; the proof bundle provides execution evidence tied to the run.</p>\n<p>Concretely, the proof bundle can include the WPC hash reference, CST claim details (including scope hash and any policy hash pinning), and gateway receipts for model calls. Gateway receipts are signed receipts emitted by clawproxy, which means you can later verify that model calls occurred through the controlled path rather than an unlogged side channel.</p>\n<p>For cross-team reviews, publish the proof bundle to a Trust Pulse when you need a marketplace-stored artifact for audit/viewing. That gives auditors a stable handle to inspect what was approved and what was executed, without relying on mutable chat transcripts.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback is mainly about stopping unsafe repetition and returning to a known-good policy state. With policy hash pinning, you can roll back by switching the approved WPC hash and rejecting jobs that present an unapproved hash.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to check</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt or policy change found to be unsafe</td>\n      <td>Revert to last approved WPC hash and require CST policy hash pinning to that hash.</td>\n      <td>Proof bundle shows the WPC hash used for each run and whether pinning was present in CST claims.</td>\n    </tr>\n    <tr>\n      <td>Suspected token misuse</td>\n      <td>Invalidate the job path and require a fresh CST per job with anti-replay binding.</td>\n      <td>Proof bundle plus job metadata show whether a CST was job-scoped and whether reuse occurred.</td>\n    </tr>\n    <tr>\n      <td>Model routing bypass suspected</td>\n      <td>Block runs that do not produce gateway receipts and require clawproxy routing for model calls.</td>\n      <td>Gateway receipts presence, signature validity, and matching run identifiers inside the proof bundle.</td>\n    </tr>\n    <tr>\n      <td>Tool blast radius too wide</td>\n      <td>Tighten OpenClaw tool policy profile and enable sandboxing for the affected sessions.</td>\n      <td>OpenClaw security audit output and configuration diffs for tool allow and deny plus sandbox mode.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Some orgs also pair this with enterprise identity controls. For Microsoft environments, you can align approvals to Entra ID groups and record operator actions in Microsoft Purview audit logs, but the enforcement still needs to happen in the agent execution path.</p>\n\n<h2>FAQ</h2>\n<h3>Why isn’t a system prompt enough for permissioned execution approvals?</h3>\n<p>A system prompt is advisory text to a model, and it can be subverted by injection, tool misuse, or runtime configuration changes. Permissioned execution approvals need machine-enforced constraints, which is why the approval target should be a WPC hash plus CST scoping and receipt-backed verification.</p>\n\n<h3>What exactly is approved when we “approve a System Prompt Report”?</h3>\n<p>You are approving an immutable reference: the WPC hash that encodes the enforcement rules and the bindings required for the run. The report is the readable summary, but the approval should point at the hash-addressed artifact to prevent silent drift.</p>\n\n<h3>How do we verify the agent really used the approved model routing?</h3>\n<p>Require gateway receipts for model calls emitted by clawproxy and include them in the proof bundle. A verifier can then validate signatures and confirm calls were made through the controlled gateway path.</p>\n\n<h3>Can we integrate approvals with Entra ID or Microsoft Graph?</h3>\n<p>Yes, via official API or an enterprise buildout, you can map “who may approve” to Entra ID groups and enforce operator workflows outside the agent. Keep the enforcement decision inside the run boundary by binding execution to WPC plus CST, not to a UI-only approval checkbox.</p>\n\n<h3>What should “fail-closed” mean in practice?</h3>\n<p>If the WPC cannot be fetched and verified by hash, if CST claims do not match the expected scope hash, or if gateway receipts are missing, the job should not proceed to external model calls or tool execution. This prevents “partial runs” that look compliant but are not verifiable.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://nist.gov/publications/policy-machine-features-architecture-and-specification\">NIST Policy Machine: Features, Architecture, and Specification</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/purview/audit-log-activities\">Audit log activities | Microsoft Learn</a></li>\n</ul>",
  "description": "A System Prompt Report is a policy artifact that makes an agent’s “prompt commitments” auditable and enforceable during execution, not just readable in a text file. In Claw EA, the report is bound to a WPC and enforced t",
  "faqs": [
    {
      "q": "Why isn’t a system prompt enough for permissioned execution approvals?",
      "a": "A system prompt is advisory text to a model, and it can be subverted by injection, tool misuse, or runtime configuration changes. Permissioned execution approvals need machine-enforced constraints, which is why the approval target should be a WPC hash plus CST scoping and receipt-backed verification."
    },
    {
      "q": "What exactly is approved when we “approve a System Prompt Report”?",
      "a": "You are approving an immutable reference: the WPC hash that encodes the enforcement rules and the bindings required for the run. The report is the readable summary, but the approval should point at the hash-addressed artifact to prevent silent drift."
    },
    {
      "q": "How do we verify the agent really used the approved model routing?",
      "a": "Require gateway receipts for model calls emitted by clawproxy and include them in the proof bundle. A verifier can then validate signatures and confirm calls were made through the controlled gateway path."
    },
    {
      "q": "Can we integrate approvals with Entra ID or Microsoft Graph?",
      "a": "Yes, via official API or an enterprise buildout, you can map “who may approve” to Entra ID groups and enforce operator workflows outside the agent. Keep the enforcement decision inside the run boundary by binding execution to WPC plus CST, not to a UI-only approval checkbox."
    },
    {
      "q": "What should “fail-closed” mean in practice?",
      "a": "If the WPC cannot be fetched and verified by hash, if CST claims do not match the expected scope hash, or if gateway receipts are missing, the job should not proceed to external model calls or tool execution. This prevents “partial runs” that look compliant but are not verifiable."
    }
  ],
  "sources": [
    {
      "title": "NIST Internal or Interagency Report (NISTIR) 7987 Rev. 1, Policy Machine: Features, Architecture, and Specification",
      "uri": "https://csrc.nist.gov/pubs/ir/7987/r1/final"
    },
    {
      "title": "Policy Machine: Features, Architecture, and Specification",
      "uri": "https://nist.gov/publications/policy-machine-features-architecture-and-specification"
    },
    {
      "title": "Audit log activities | Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/purview/audit-log-activities"
    },
    {
      "title": "Using AWS managed policies for AWS Artifact",
      "uri": "https://docs.aws.amazon.com/artifact/latest/ug/security-iam-awsmanpol.html"
    },
    {
      "title": "[DL.SCM.3] Use artifact repositories with enforced authentication ...",
      "uri": "https://docs.aws.amazon.com/wellarchitected/latest/devops-guidance/dl.scm.3-use-artifact-repositories-with-enforced-authentication-and-authorization.html"
    },
    {
      "title": "Example IAM policies for AWS Artifact in commercial AWS Regions",
      "uri": "https://docs.aws.amazon.com/artifact/latest/ug/example-iam-policies.html"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:21:11.052Z",
  "indexable": true
}