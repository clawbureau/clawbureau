{
  "slug": "policy/scoped-tokens",
  "title": "Scoped Tokens (CST) | Policy Artifact | Claw EA",
  "category": "policy",
  "html": "<p>CST (scoped token) is the execution approval artifact you hand to an agent run so it can call approved services and tools under machine-checked constraints. In Claw EA, CSTs are issued by clawscope and are typically bound to a specific policy (a WPC) and a specific job context to prevent reuse.</p>\n<p>This matters because OpenClaw is a baseline agent runtime with real tool access, and prompt-only “rules” are not an enforcement layer. Permissioned execution means the runtime and gateways can fail closed when the token, scope hash, or pinned policy hash does not match what was approved.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this when you want an agent run that is approval-driven, auditable, and resistant to token replay. The goal is to make “what was allowed” explicit in a WPC and make “what was used” provable via receipts and a proof bundle.</p>\n<ol>\n  <li>\n    <p>Write a WPC for the work. Keep it narrow: which model traffic is allowed through clawproxy, which OpenClaw tools are allowed, and which high-risk capabilities are denied by default.</p>\n  </li>\n  <li>\n    <p>Publish the WPC to the WPC registry in clawcontrols. Treat the WPC hash as the policy identity and use it as the reference in change control.</p>\n  </li>\n  <li>\n    <p>Configure the OpenClaw Gateway tool policy and sandboxing to match the WPC intent. This keeps local execution aligned with the remote policy layer, especially for exec and filesystem tools.</p>\n  </li>\n  <li>\n    <p>Request a CST from clawscope with a scope hash that encodes the minimum permissions needed, and optionally pin the policy hash to the WPC. If you run via a marketplace job, use the job-scoped CST binding to prevent anti-replay failures later.</p>\n  </li>\n  <li>\n    <p>Run the agent. Route model calls through clawproxy (for example, OpenRouter via fal routed through clawproxy) so every model call produces gateway receipts.</p>\n  </li>\n  <li>\n    <p>Collect the proof bundle at the end of the run. Store it as an audit artifact and optionally publish it into Trust Pulse for easier review and sharing.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>CSTs reduce “ambient authority” by tying agent capability to an explicit scope hash and, when used, a pinned WPC hash. They do not replace OpenClaw’s local sandbox and tool policy; they complement it so remote calls and approvals are verifiable and fail closed.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection causes the agent to attempt unapproved actions</td>\n      <td>The model tries to call tools or services outside the intended run plan</td>\n      <td>OpenClaw tool allow/deny plus sandboxing for local tools, and CST scope hash checks for remote calls; deny-by-default behavior means missing permissions fail closed</td>\n    </tr>\n    <tr>\n      <td>Stolen token is replayed in a different job</td>\n      <td>An attacker reuses a CST to run the same permissions elsewhere</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding; token use outside the expected job context is rejected</td>\n    </tr>\n    <tr>\n      <td>Policy drift between what was approved and what executed</td>\n      <td>The runtime runs with looser settings than reviewers expected</td>\n      <td>Optional policy hash pinning in CST, plus WPC fetch/verify; a token intended for one WPC will not validate against a different policy hash</td>\n    </tr>\n    <tr>\n      <td>Operator disputes what the model actually sent to a provider</td>\n      <td>Logs are incomplete or can be edited after the fact</td>\n      <td>Gateway receipts emitted by clawproxy for model calls; receipts are signed and can be bundled for later verification</td>\n    </tr>\n    <tr>\n      <td>Local tool escape hatch is enabled</td>\n      <td>Sandboxed sessions still run host commands through elevated execution</td>\n      <td>Align OpenClaw elevated settings with the WPC and treat any elevated permission as a separate approval tier; investigate sessions where elevated was enabled</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a minimal, JSON-like example of what you should be thinking about when you mint a CST for an agent run. The enforcement point is not the prompt; it is the token’s scope hash and the pinned WPC hash that the execution layer verifies before allowing protected actions.</p>\n<pre>\n{\n  \"wpc_ref\": {\n    \"wpc_hash_b64u\": \"WPC_HASH_HERE\",\n    \"pin_policy_hash\": true\n  },\n  \"cst_request\": {\n    \"aud\": \"clawproxy\",\n    \"ttl_seconds\": 1800,\n    \"job_binding\": {\n      \"job_id\": \"job-2026-02-11-0142\",\n      \"anti_replay\": true\n    },\n    \"scope\": {\n      \"scope_hash\": \"SCOPE_HASH_HERE\",\n      \"allow\": [\n        \"model.call:openrouter_via_fal\",\n        \"bundle.write:proof_bundle\"\n      ],\n      \"deny\": [\n        \"tools.elevated\",\n        \"egress.any\"\n      ]\n    }\n  },\n  \"validation_rules\": {\n    \"fail_closed_on_missing_scope\": true,\n    \"fail_closed_on_wpc_mismatch\": true,\n    \"require_signed_receipts_for_model_calls\": true\n  }\n}\n</pre>\n<p>In practice, the “allow” list should map to concrete operations you can audit. If you need to reach external systems, do it explicitly via official API, via MCP server, or via enterprise buildout, then scope the CST to exactly those calls.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get gateway receipts for model calls when traffic goes through clawproxy. Receipts are the unit you can verify later to confirm which model endpoint was called, when it was called, and what policy and job context the call was bound to.</p>\n<p>You also get a proof bundle that packages those receipts with the related run metadata so an auditor can verify the run without reconstructing logs from multiple systems. If you publish it, Trust Pulse stores the artifact for audit/viewing, which is useful when multiple teams need to review the same run evidence.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback for agent execution should be procedural and fast. The objective is to stop further action (token invalidation and policy tightening), then preserve evidence (receipts and proof bundles) for incident review.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Revoke the CST</td>\n      <td>Stop the current run and invalidate the token so retries fail closed</td>\n      <td>CST issuance and revocation records from clawscope, plus the final proof bundle for what already happened</td>\n    </tr>\n    <tr>\n      <td>Pin a tighter WPC and re-mint a CST</td>\n      <td>Publish a new WPC with narrower permissions and require policy hash pinning for the replacement CST</td>\n      <td>WPC hashes (old and new) and proof bundle references showing which policy was in effect per run</td>\n    </tr>\n    <tr>\n      <td>Reduce local blast radius in OpenClaw</td>\n      <td>Switch sandbox mode to cover more sessions and tighten tool allow/deny; disable elevated where possible</td>\n      <td>OpenClaw security audit outputs and the tool policy configuration diff tied to the incident window</td>\n    </tr>\n    <tr>\n      <td>Force model traffic back through clawproxy</td>\n      <td>Block direct provider calls in your agent configuration so all model calls generate receipts</td>\n      <td>Gateway receipts continuity across runs, showing no gaps in receipted traffic</td>\n    </tr>\n  </tbody>\n</table>\n<p>Some controls, like egress allowlists enforced outside clawproxy and automatic cost budget enforcement, are optional or can be implemented depending on your environment. Treat those as part of an enterprise buildout plan rather than assumptions.</p>\n\n<h2>FAQ</h2>\n\n<h3>Why is policy-as-code necessary instead of prompt-only instructions?</h3>\n<p>Prompts can be ignored, overwritten by later context, or exploited by injection. Policy-as-code makes enforcement happen at the execution layer, where CST validation and pinned WPC hashes can deny actions deterministically.</p>\n\n<h3>What is the difference between a WPC and a CST?</h3>\n<p>A WPC is the signed, hash-addressed policy artifact served by clawcontrols. A CST is the scoped token issued by clawscope that carries the approved scope hash and can optionally pin to the WPC hash so the runtime can verify the run is operating under the approved policy.</p>\n\n<h3>How does Claw EA prevent CST replay across jobs?</h3>\n<p>For marketplace runs, job-scoped CST binding provides anti-replay so a CST cannot be lifted from one job and reused for another. If the job binding does not match, validation should fail closed.</p>\n\n<h3>What does “gateway receipts” mean operationally?</h3>\n<p>Gateway receipts are signed receipts emitted by clawproxy for model calls. You store them in a proof bundle so you can later verify that specific model traffic happened under a specific token and policy context.</p>\n\n<h3>Does this replace OpenClaw sandboxing and tool policy?</h3>\n<p>No. OpenClaw’s sandbox and tool policy remain the local safety boundary, and CSTs add permissioned, auditable access for remote calls and approvals.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/process/access-tokens?view=azure-devops\">Understand job access tokens - Azure Pipelines - Microsoft Learn</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops\">Pipeline deployment approvals - Azure Pipelines - Microsoft Learn</a></li>\n</ul>",
  "description": "CST (scoped token) is the execution approval artifact you hand to an agent run so it can call approved services and tools under machine-checked constraints. In Claw EA, CSTs are issued by clawscope and are typically boun",
  "faqs": [
    {
      "q": "Why is policy-as-code necessary instead of prompt-only instructions?",
      "a": "Prompts can be ignored, overwritten by later context, or exploited by injection. Policy-as-code makes enforcement happen at the execution layer, where CST validation and pinned WPC hashes can deny actions deterministically."
    },
    {
      "q": "What is the difference between a WPC and a CST?",
      "a": "A WPC is the signed, hash-addressed policy artifact served by clawcontrols. A CST is the scoped token issued by clawscope that carries the approved scope hash and can optionally pin to the WPC hash so the runtime can verify the run is operating under the approved policy."
    },
    {
      "q": "How does Claw EA prevent CST replay across jobs?",
      "a": "For marketplace runs, job-scoped CST binding provides anti-replay so a CST cannot be lifted from one job and reused for another. If the job binding does not match, validation should fail closed."
    },
    {
      "q": "What does “gateway receipts” mean operationally?",
      "a": "Gateway receipts are signed receipts emitted by clawproxy for model calls. You store them in a proof bundle so you can later verify that specific model traffic happened under a specific token and policy context."
    },
    {
      "q": "Does this replace OpenClaw sandboxing and tool policy?",
      "a": "No. OpenClaw’s sandbox and tool policy remain the local safety boundary, and CSTs add permissioned, auditable access for remote calls and approvals."
    }
  ],
  "sources": [
    {
      "title": "Assigning permissions to jobs - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/using-jobs/assigning-permissions-to-jobs"
    },
    {
      "title": "Understand job access tokens - Azure Pipelines - Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/pipelines/process/access-tokens?view=azure-devops"
    },
    {
      "title": "Pipeline deployment approvals - Azure - Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops"
    },
    {
      "title": "GitHub and GitHub Enterprise Server access token - AWS CodeBuild",
      "uri": "https://docs.aws.amazon.com/codebuild/latest/userguide/access-tokens-github.html"
    },
    {
      "title": "Create a scoped access policy",
      "uri": "https://cloud.google.com/vpc-service-controls/docs/manage-policies"
    },
    {
      "title": "Scoped policies",
      "uri": "https://cloud.google.com/access-context-manager/docs/scoped-policies"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:20:25.960Z",
  "indexable": true
}