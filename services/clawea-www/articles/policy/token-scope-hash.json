{
  "slug": "policy/token-scope-hash",
  "title": "Token Scope Hash | Policy Artifact | Claw EA",
  "category": "policy",
  "html": "<p>Token Scope Hash is a deterministic digest of what a CST is allowed to do, computed from a canonical “scope set” and optionally pinned to a WPC. It lets the execution layer approve or deny tool and model actions using policy-as-code, not prompt text, and it gives auditors a stable identifier to compare “what was allowed” across runs.</p>\n<p>In Claw EA, OpenClaw is the baseline agent runtime, but the permission boundary must be enforced outside the model. A Token Scope Hash is how you bind “this run may do X” to a job-scoped CST and then verify, fail-closed, that every call stayed inside that boundary.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>This is the operational flow for permissioned execution approvals using Token Scope Hash, WPC, CST, gateway receipts, and proof bundles. It assumes you run agents under OpenClaw and route model calls through clawproxy.</p>\n<ol>\n  <li>\n    <p><strong>Write a WPC that describes the allowed work.</strong> Keep it tool-oriented and environment-specific: which tools, which providers, and which data classes are permitted. Store the signed, hash-addressed policy artifact in the WPC registry (served by clawcontrols).</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the job.</strong> Request a CST (issued by clawscope) with a scope set that matches the WPC intent. Turn on optional policy hash pinning so the CST is bound to a specific WPC hash when you need strict approvals.</p>\n  </li>\n  <li>\n    <p><strong>Compute the Token Scope Hash from canonical scope material.</strong> Canonicalize the scope set (sorting, stable JSON encoding, no implicit defaults) and hash it. Treat the resulting Token Scope Hash as the approval handle: it is what you check in logs, tickets, and change review.</p>\n  </li>\n  <li>\n    <p><strong>Configure OpenClaw to run with least privilege locally.</strong> Use tool policy allow/deny and sandbox settings so that even a compromised prompt cannot expand permissions on the host. Run OpenClaw’s security audit regularly to catch footguns like open inbound policies or elevated tool settings.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy.</strong> The provider route emits gateway receipts for each model call. Receipts should be bound to the job-scoped CST to prevent replay across jobs (marketplace anti-replay binding).</p>\n  </li>\n  <li>\n    <p><strong>On completion, package and verify the proof bundle.</strong> Create a proof bundle that includes receipts and metadata required for audit. Verify that the Token Scope Hash in the run matches the CST claims and, if pinned, that the WPC hash matches what was approved.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Token Scope Hash solves a specific class of problems: “the agent did something it was never approved to do” and “we cannot prove what permissions were in force.” It does not replace sandboxing or tool policy in OpenClaw; it complements them by making permissions explicit, hashed, and reviewable.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt-only approvals get bypassed</td>\n      <td>A user or injected content convinces the model it is “allowed” to access extra tools or data.</td>\n      <td>Enforce permissions via CST + Token Scope Hash and verify against WPC; deny if missing or mismatched (fail-closed).</td>\n    </tr>\n    <tr>\n      <td>Scope inflation via ambiguous representation</td>\n      <td>Two “equivalent” scope documents serialize differently, leading to inconsistent approvals and weak auditability.</td>\n      <td>Canonicalize scope material (sorted keys, explicit defaults) and hash the canonical bytes only.</td>\n    </tr>\n    <tr>\n      <td>Policy drift between approval and execution</td>\n      <td>A policy is updated after approval; the run accidentally uses new permissions.</td>\n      <td>Optional policy hash pinning: CST can be tied to a specific WPC hash, so drift causes a hard mismatch.</td>\n    </tr>\n    <tr>\n      <td>Token replay across jobs</td>\n      <td>A CST from one run is reused to authorize a different run.</td>\n      <td>Use marketplace anti-replay binding (job-scoped CST binding) and verify job identifiers in receipts and bundles.</td>\n    </tr>\n    <tr>\n      <td>Unprovable model calls</td>\n      <td>You cannot prove which model saw which inputs, which breaks incident response and audit.</td>\n      <td>Route through clawproxy and require gateway receipts for model calls; include them in the proof bundle.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This snippet shows the minimum fields you should treat as “scope material” for hashing. The important rule is that the Token Scope Hash is derived from a canonical version of this material, not from free-form text or runtime interpretation.</p>\n\n<pre>\n{\n  \"version\": \"scope.v1\",\n  \"job\": {\n    \"job_id\": \"job_2026_02_11_001\",\n    \"anti_replay\": \"job_scoped\"\n  },\n  \"policy\": {\n    \"wpc_hash_b64u\": \"WPC_HASH_HERE\",\n    \"pin_policy_hash\": true\n  },\n  \"scopes\": [\n    \"models:openrouter/*\",\n    \"tools:read\",\n    \"tools:write:workspace\",\n    \"tools:exec:sandbox_only\"\n  ],\n  \"limits\": {\n    \"max_ttl_seconds\": 3600\n  },\n  \"hash\": {\n    \"scope_hash_alg\": \"sha256\",\n    \"scope_hash_b64u\": \"DERIVED_FROM_CANONICAL_SCOPE_MATERIAL\"\n  }\n}\n</pre>\n\n<p><strong>Validation rules (fail-closed):</strong> reject the run if the CST is missing required claims, if the computed Token Scope Hash does not match the CST scope hash, or if policy hash pinning is enabled and the WPC hash does not match. Also reject if the job binding is absent when anti-replay is required, or if TTL exceeds the approved maximum.</p>\n<p><strong>Why not prompt-only:</strong> prompts are mutable and not reliably enforceable at the execution boundary. Policy-as-code makes approvals machine-checkable, and hashing makes approvals comparable across systems, tickets, and audits.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get two classes of proof: what permissions were granted, and what the agent actually did. The permission grant is represented by the CST (issued by clawscope) and its scope hash, optionally tied to a WPC hash from the WPC registry (served by clawcontrols).</p>\n<p>The “what happened” proof comes from gateway receipts: signed receipts emitted by clawproxy for model calls. Receipts, plus job metadata and relevant config identifiers, are packaged into a proof bundle for audit and later verification.</p>\n<p>For marketplace-facing workflows, you can store and view the resulting artifact as a Trust Pulse. Operationally, this gives you a single object to hand to reviewers: approved policy hash, Token Scope Hash, and the receipts that show model calls were made under that scope.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback in permissioned execution is about removing permissions quickly and proving that the rollback took effect. Because the approval handle is the Token Scope Hash and the runtime handle is the CST, rollback focuses on token revocation, policy pinning, and verifying that new runs cannot proceed with old grants.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Policy mistake in WPC</td>\n      <td>Publish a corrected WPC and require policy hash pinning for new CST issuance; do not “edit in place” for approvals.</td>\n      <td>New CSTs show a different pinned WPC hash; proof bundles show which hash was used per run.</td>\n    </tr>\n    <tr>\n      <td>Over-broad scope in CST</td>\n      <td>Revoke the CST and re-issue with a reduced scope set, producing a new Token Scope Hash.</td>\n      <td>Revocation record plus proof bundles for subsequent runs that show the new scope hash.</td>\n    </tr>\n    <tr>\n      <td>Suspected token replay</td>\n      <td>Invalidate job binding expectations and force job-scoped CST binding for the affected workflow.</td>\n      <td>Receipts and proof bundle metadata show job identifiers and binding; mismatches fail verification.</td>\n    </tr>\n    <tr>\n      <td>Model routing incident</td>\n      <td>Temporarily require all model calls to be routed through clawproxy for receipt coverage.</td>\n      <td>Gateway receipts in proof bundles; missing receipts become a hard audit failure for high-trust runs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>What is actually hashed in a Token Scope Hash?</h3>\n<p>Hash the canonical scope material: an ordered list of scopes plus any binding fields you require for approval, such as job binding mode and the pinned WPC hash. Do not hash free-form text, timestamps that vary run-to-run, or derived defaults that can change across versions.</p>\n\n<h3>Why do I need WPC if I already have CST scopes?</h3>\n<p>A WPC is the signed, hash-addressed policy artifact that you can review, approve, and reference independently of a token issuance event. CST scopes are the runtime grant; pinning them to a WPC hash is how you ensure the runtime grant matches the reviewed policy.</p>\n\n<h3>How does this relate to OpenClaw tool policy and sandboxing?</h3>\n<p>OpenClaw tool policy and sandboxing reduce local blast radius and decide which tools are callable and where they run. Token Scope Hash and CST constrain and prove the remote authorization envelope for the run, especially around model calls and cross-system approvals.</p>\n\n<h3>What does “fail-closed” mean here?</h3>\n<p>If the Token Scope Hash cannot be recomputed deterministically, or it does not match the CST claims, the run should be treated as unauthorized. Likewise, if policy hash pinning is required and the WPC hash cannot be verified, verification should fail rather than guess.</p>\n\n<h3>Can I integrate this with Microsoft approvals or access models?</h3>\n<p>Yes, but it is an enterprise buildout: you typically map internal approval events to “issue CST with scope hash X pinned to WPC hash Y” and then require proof bundles for completion. If you also use Microsoft systems, treat Microsoft Graph permissions/scopes and Entra ID Conditional Access as separate controls from Claw EA’s CST and WPC, and connect them via your approval workflow logic via official API.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://openpolicyagent.org/docs/policy-reference/builtins/tokens\">Token Verification | Open Policy Agent</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/process/access-tokens?view=azure-devops&tabs=yaml\">Understand job access tokens - Azure Pipelines</a></li>\n</ul>",
  "description": "Token Scope Hash is a deterministic digest of what a CST is allowed to do, computed from a canonical “scope set” and optionally pinned to a WPC. It lets the execution layer approve or deny tool and model actions using po",
  "faqs": [
    {
      "q": "What is actually hashed in a Token Scope Hash?",
      "a": "Hash the canonical scope material: an ordered list of scopes plus any binding fields you require for approval, such as job binding mode and the pinned WPC hash. Do not hash free-form text, timestamps that vary run-to-run, or derived defaults that can change across versions."
    },
    {
      "q": "Why do I need WPC if I already have CST scopes?",
      "a": "A WPC is the signed, hash-addressed policy artifact that you can review, approve, and reference independently of a token issuance event. CST scopes are the runtime grant; pinning them to a WPC hash is how you ensure the runtime grant matches the reviewed policy."
    },
    {
      "q": "How does this relate to OpenClaw tool policy and sandboxing?",
      "a": "OpenClaw tool policy and sandboxing reduce local blast radius and decide which tools are callable and where they run. Token Scope Hash and CST constrain and prove the remote authorization envelope for the run, especially around model calls and cross-system approvals."
    },
    {
      "q": "What does “fail-closed” mean here?",
      "a": "If the Token Scope Hash cannot be recomputed deterministically, or it does not match the CST claims, the run should be treated as unauthorized. Likewise, if policy hash pinning is required and the WPC hash cannot be verified, verification should fail rather than guess."
    },
    {
      "q": "Can I integrate this with Microsoft approvals or access models?",
      "a": "Yes, but it is an enterprise buildout: you typically map internal approval events to “issue CST with scope hash X pinned to WPC hash Y” and then require proof bundles for completion. If you also use Microsoft systems, treat Microsoft Graph permissions/scopes and Entra ID Conditional Access as separate controls from Claw EA’s CST and WPC, and connect them via your approval workflow logic via official API."
    }
  ],
  "sources": [
    {
      "title": "Token Verification | Open Policy Agent",
      "uri": "https://openpolicyagent.org/docs/policy-reference/builtins/tokens"
    },
    {
      "title": "Security",
      "uri": "https://www.openpolicyagent.org/docs/v0.26.0/security/"
    },
    {
      "title": "6cc0f4a8240307a7343de5db1260fb36",
      "uri": "https://gist.github.com/martindale/6cc0f4a8240307a7343de5db1260fb36"
    },
    {
      "title": "Build Azure Repos Git repositories - Azure Pipelines",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/pipelines/repos/azure-repos-git?view=azure-devops"
    },
    {
      "title": "Token-based repository permissions in Azure Container Registry",
      "uri": "https://learn.microsoft.com/en-us/azure/container-registry/container-registry-token-based-repository-permissions"
    },
    {
      "title": "Understand job access tokens - Azure Pipelines",
      "uri": "https://learn.microsoft.com/en-us/azure/devops/pipelines/process/access-tokens?view=azure-devops&tabs=yaml"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:21:55.076Z",
  "indexable": true
}