{
  "slug": "supply-chain",
  "title": "Agent Supply Chain Security (Skills and Plugins) | Claw EA",
  "category": "hubs",
  "html": "<h2>Direct Answer</h2>\n<p>Agent supply chain security is about controlling what “skills”, plugins, dependencies, and MCP servers an agent can load, and proving what it actually used during a run. In Claw EA, OpenClaw is the baseline agent runtime, and Claw Bureau primitives add permissioned execution: WPC = Work Policy Contract, CST = scoped token, gateway receipts, and proof bundles.</p>\n<p>Prompt-only controls are not enough because compromised tools can ignore instructions while still appearing compliant. You need machine-enforced policy-as-code that gates tool loading, model egress, and job identity, then produces evidence you can verify later.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this runbook when you are introducing a new skill, plugin, or MCP server into an OpenClaw deployment managed under Claw EA. The goal is to keep changes small, permissioned, and auditable.</p>\n<ol>\n  <li>\n    <p><strong>Inventory what can execute.</strong> List OpenClaw extensions (plugins), skills (prompt docs), and any MCP servers used by tools. Include transitive dependencies and where they are installed from (registry, git, internal artifact store).</p>\n  </li>\n  <li>\n    <p><strong>Define a WPC for the job class.</strong> Create a WPC = Work Policy Contract that expresses allowed tool families, allowed providers, required sandbox posture, and any policy hash pinning expectations for the run. Keep it specific to the workflow, not “general agent use”.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST bound to that WPC.</strong> Use clawscope to issue a CST = scoped token whose scope hash matches the intended permissions, with optional policy hash pinning to the WPC. Treat this as the runtime “capability envelope” for the agent job, not a user login token.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy.</strong> Configure the agent so model traffic goes via clawproxy to obtain gateway receipts for each model call. If you use OpenRouter via fal, route it through clawproxy so the same receipt format covers those calls.</p>\n  </li>\n  <li>\n    <p><strong>Constrain execution locally in OpenClaw.</strong> Apply OpenClaw tool allow/deny and sandbox configuration so that even a compromised prompt cannot access tools you did not intend. Re-run OpenClaw’s security audit after changing configs or enabling new extensions.</p>\n  </li>\n  <li>\n    <p><strong>Run in a canary lane first.</strong> Execute the job in a low-privilege environment with production-like inputs but no production credentials. Collect the proof bundle and review what tools were invoked and what model calls occurred.</p>\n  </li>\n  <li>\n    <p><strong>Promote with evidence.</strong> Promote the skill/plugin/MCP server to broader use only after you can consistently produce a proof bundle, and you can explain each permission in the WPC. Store the resulting audit artifacts in Trust Pulse for later review.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Skills, plugins, and MCP servers expand the trusted computing base of an agent. The common failure mode is that a compromised component runs inside a trusted path and performs actions that your prompt would never authorize.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control in Claw EA</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Dependency tampering in a plugin or MCP server</td>\n      <td>A malicious update adds hidden tool calls, exfiltration, or policy bypass behavior during normal operation.</td>\n      <td>Permissioned execution via WPC constraints plus CST scope hash, and post-run verification using gateway receipts and the proof bundle. Treat new versions as new supply chain entries and re-approve.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection that requests extra tools</td>\n      <td>Model is tricked into calling tools that are present but should not be reachable for that job.</td>\n      <td>OpenClaw tool policy and sandboxing to reduce tool blast radius, backed by WPC that specifies what is allowed for the job. Prompt text is advisory; the policy gates execution.</td>\n    </tr>\n    <tr>\n      <td>MCP server misbinding or tool spoofing</td>\n      <td>The agent believes it is calling one tool, but it is routed to a different server or a different implementation with broader behavior.</td>\n      <td>Pin expected tool surfaces in policy-as-code, and require that the CST used for the job is job-scoped (anti-replay binding). Review proof bundles for unexpected tool names or unexpected call patterns.</td>\n    </tr>\n    <tr>\n      <td>Over-broad credentials embedded in runtime</td>\n      <td>A plugin obtains long-lived credentials from disk or environment and uses them outside intended scope.</td>\n      <td>Use CST for Claw Bureau access and keep enterprise credentials out of the agent where possible. For external systems, prefer short-lived tokens via official API flows and limit what the tool can request.</td>\n    </tr>\n    <tr>\n      <td>Silent policy drift</td>\n      <td>Config changes expand permissions over time and nobody notices until an incident.</td>\n      <td>Hash-addressed WPC and optional policy hash pinning in the CST to make drift detectable. Use OpenClaw security audit as a recurring control after config changes.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the shape of a permissioned execution contract for a job that uses a small toolset, sandboxed execution, and model calls routed through clawproxy. The point is that the agent cannot “talk its way” into additional capability because the WPC is enforced outside the prompt.</p>\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"invoice-reconcile-canary\",\n  \"policy_hash\": \"hash-addressed-by-clawcontrols\",\n  \"tools\": {\n    \"allow\": [\"read\", \"write\", \"exec\", \"http\"],\n    \"deny\": [\"browser_control\", \"docker_socket\", \"host_elevated_exec\"]\n  },\n  \"sandbox\": {\n    \"mode\": \"all\",\n    \"workspace_access\": \"ro\"\n  },\n  \"model_egress\": {\n    \"route_via\": \"clawproxy\",\n    \"receipts_required\": true\n  },\n  \"token\": {\n    \"type\": \"CST\",\n    \"scope_hash_required\": true,\n    \"policy_hash_pinning\": \"optional\"\n  },\n  \"job_binding\": {\n    \"anti_replay\": \"job-scoped CST binding\"\n  }\n}\n</pre>\n\n<h2>What proof do you get?</h2>\n<p>For model traffic routed through clawproxy, you get gateway receipts: signed receipts emitted by clawproxy for model calls. These receipts can be verified later to confirm which model endpoint was called, when it was called, and that the call flowed through the expected gateway.</p>\n<p>Claw EA packages those receipts with run metadata into a proof bundle, which is the unit you hand to audit, incident response, or a customer security review. When you need a durable place for review and sharing, store the proof bundle (or its references) as a Trust Pulse artifact.</p>\n<p>Operationally, this lets you answer two questions that matter in incidents: what permissions were granted (WPC + CST scope hash), and what actually happened (gateway receipts inside the proof bundle). You can also compare canary and production runs to detect drift in tool use.</p>\n\n<h2>Rollback posture</h2>\n<p>Supply chain incidents are usually time-sensitive, so rollback needs to be mechanical. Aim for rollbacks that remove capability first, then fix code, then reintroduce capability with a new WPC and new CST issuance rules.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to capture</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Plugin version suspected compromised</td>\n      <td>Disable the extension in OpenClaw allowlists and redeploy with the last known good version. Keep the WPC tightened until you finish root cause analysis.</td>\n      <td>Proof bundle from the last good run and the first bad run, plus the WPC hashes used in each.</td>\n    </tr>\n    <tr>\n      <td>MCP server behavior changed</td>\n      <td>Stop using that MCP server and switch the agent workflow to a minimal alternative path (or no tool path) via policy-as-code. Treat the MCP server as untrusted until you can re-validate.</td>\n      <td>Gateway receipts around the time of change, including tool invocation patterns that indicate misbinding or spoofing.</td>\n    </tr>\n    <tr>\n      <td>Over-permissioned job class discovered</td>\n      <td>Issue a new WPC that removes the extra tools and pin the policy hash in new CST issuance. Expire or revoke old CST where operationally feasible.</td>\n      <td>Diff of WPCs by hash, and a proof bundle showing the job still completes with reduced permissions.</td>\n    </tr>\n    <tr>\n      <td>Unexpected model routing or provider drift</td>\n      <td>Require clawproxy routing for the job class and reject runs that cannot produce gateway receipts. Re-run canary with the same inputs to confirm stable behavior.</td>\n      <td>Gateway receipts that show the provider path, correlated to the CST scope hash used for that job.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>What is the difference between a skill and a plugin in OpenClaw?</h3>\n<p>A skill is prompt-injected documentation intended to guide the agent, while a plugin is executable code that can add tools or providers. Supply chain risk is higher for plugins and MCP servers, but skills can still introduce unsafe behavior if they change operational procedures.</p>\n\n<h3>Why not rely on prompts like “do not exfiltrate data”?</h3>\n<p>Prompts are not an execution boundary, and compromised dependencies can ignore them. Policy-as-code in a WPC plus enforced scoping in a CST makes the allowed actions explicit and machine-checkable.</p>\n\n<h3>How do WPC and CST work together during a run?</h3>\n<p>The WPC defines the allowed work policy as a signed, hash-addressed artifact served by clawcontrols. The CST is issued by clawscope with a scope hash that represents the permitted capability, with optional policy hash pinning to ensure the token is used only under the intended WPC.</p>\n\n<h3>What do gateway receipts tell me that logs do not?</h3>\n<p>Gateway receipts are signed receipts emitted by clawproxy for model calls, designed for later verification. Logs are useful, but they are easier to omit, alter, or mis-correlate across systems compared to a proof bundle that packages receipts with run metadata.</p>\n\n<h3>How should we think about MCP servers in enterprise environments?</h3>\n<p>Treat an MCP server like an internal microservice that exposes tools to an agent, and apply the same change control you would to production services. Use minimal permissions, explicit tool allowlists, and require verifiable model egress via clawproxy when possible.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://owasp.org/www-project-mcp-top-10/2025/MCP04-2025%E2%80%93Software-Supply-Chain-Attacks&Dependency-Tampering\">OWASP MCP Top 10: Software Supply Chain Attacks &amp; Dependency Tampering</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/developer/ai/intro-agents-mcp\">Microsoft Learn: Build Agents using Model Context Protocol on Azure</a></li>\n</ul>",
  "description": "Agent supply chain security is about controlling what “skills”, plugins, dependencies, and MCP servers an agent can load, and proving what it actually used during a run. In Claw EA, OpenClaw is the baseline agent runtime",
  "faqs": [
    {
      "q": "What is the difference between a skill and a plugin in OpenClaw?",
      "a": "A skill is prompt-injected documentation intended to guide the agent, while a plugin is executable code that can add tools or providers. Supply chain risk is higher for plugins and MCP servers, but skills can still introduce unsafe behavior if they change operational procedures."
    },
    {
      "q": "Why not rely on prompts like “do not exfiltrate data”?",
      "a": "Prompts are not an execution boundary, and compromised dependencies can ignore them. Policy-as-code in a WPC plus enforced scoping in a CST makes the allowed actions explicit and machine-checkable."
    },
    {
      "q": "How do WPC and CST work together during a run?",
      "a": "The WPC defines the allowed work policy as a signed, hash-addressed artifact served by clawcontrols. The CST is issued by clawscope with a scope hash that represents the permitted capability, with optional policy hash pinning to ensure the token is used only under the intended WPC."
    },
    {
      "q": "What do gateway receipts tell me that logs do not?",
      "a": "Gateway receipts are signed receipts emitted by clawproxy for model calls, designed for later verification. Logs are useful, but they are easier to omit, alter, or mis-correlate across systems compared to a proof bundle that packages receipts with run metadata."
    },
    {
      "q": "How should we think about MCP servers in enterprise environments?",
      "a": "Treat an MCP server like an internal microservice that exposes tools to an agent, and apply the same change control you would to production services. Use minimal permissions, explicit tool allowlists, and require verifiable model egress via clawproxy when possible."
    }
  ],
  "sources": [
    {
      "title": "Software Supply Chain Attacks & Dependency Tampering",
      "uri": "https://owasp.org/www-project-mcp-top-10/2025/MCP04-2025%E2%80%93Software-Supply-Chain-Attacks&Dependency-Tampering"
    },
    {
      "title": "OWASP MCP Top 10",
      "uri": "https://owasp.org/www-project-mcp-top-10/"
    },
    {
      "title": "OWASP/www-project-mcp-top-10 - GitHub",
      "uri": "https://github.com/OWASP/www-project-mcp-top-10"
    },
    {
      "title": "Build Agents using Model Context Protocol on Azure",
      "uri": "https://learn.microsoft.com/en-us/azure/developer/ai/intro-agents-mcp"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:02:23.509Z",
  "indexable": true
}