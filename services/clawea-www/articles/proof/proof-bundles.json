{
  "slug": "proof/proof-bundles",
  "title": "Proof Bundles for Agent Runs | Claw EA",
  "category": "proof",
  "html": "<p>Proof bundles let you verify what an agent run actually did by packaging gateway receipts, policy references, and run metadata into one artifact you can re-check later. In Claw EA, the proof bundle is built around Work Policy Contracts (WPC), CST (scoped token), and gateway receipts, so verification can fail closed when any binding is missing or mismatched.</p>\n<p>OpenClaw is the baseline agent runtime, but prompt-only guardrails are not sufficient because prompts can be overridden at runtime by user input, tool output, or injection. For enterprise runs, the execution layer must be permissioned with policy-as-code so the harness enforces what tools and model routes are allowed, regardless of what the model “decides.”</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Write a WPC for the job.</strong> Define allowed model routing (for example OpenRouter via fal routed through clawproxy), tool allow/deny, and any run bindings you care about (job id, environment, dataset identifiers). Store and serve the signed, hash-addressed WPC from clawcontrols.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST scoped to that WPC.</strong> Use clawscope to issue a CST (scoped token) that includes a scope hash and, optionally, policy hash pinning to the WPC hash. This makes the token useless outside the intended permission envelope.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent through clawproxy.</strong> Configure the OpenClaw provider to route model calls through clawproxy so each call emits gateway receipts. If a model call is made outside the proxy, you should treat the run as “unproven” for model-IO coverage.</p>\n  </li>\n  <li>\n    <p><strong>Collect the proof bundle.</strong> At the end of the run, gather the proof bundle (the harness artifact bundling receipts and related metadata for audit/verification). Store it in your retention system and optionally publish the artifact to Trust Pulse for viewing.</p>\n  </li>\n  <li>\n    <p><strong>Verify the bundle before acting on results.</strong> Submit the proof bundle to your verifier workflow (for example, clawverify via official API) and fail closed on signature failures, missing bindings, or token replay indicators. Record the verification result alongside the business output (PR merge, ticket update, deployment artifact).</p>\n  </li>\n  <li>\n    <p><strong>Set retention and access rules.</strong> Keep the full bundle for high-risk runs, and keep a reduced bundle (hashes plus minimal metadata) for routine runs. Separate “audit material” from “secret material” so you can retain proofs without retaining plaintext secrets.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Proof bundles do not prevent unsafe behavior by themselves. They help you detect when a run stepped outside approved routes, when receipts were tampered with, or when a token was replayed.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection pushes the agent to use broader tools</td>\n      <td>The model tries to call tools that were not intended for the job (filesystem, shell, browser control, or external HTTP).</td>\n      <td>Policy-as-code in a WPC plus OpenClaw tool policy and sandboxing limit what is callable and where it executes. Verification checks that the WPC hash referenced by the run matches what you approved.</td>\n    </tr>\n    <tr>\n      <td>Model traffic bypasses the proxy</td>\n      <td>The run “works,” but you have no gateway receipts for some model calls, so you cannot prove what was sent or received.</td>\n      <td>Route model providers via clawproxy so gateway receipts are emitted for each call. Treat missing receipts as an incomplete proof bundle and gate downstream actions on verification.</td>\n    </tr>\n    <tr>\n      <td>Receipt or bundle tampering after the run</td>\n      <td>An operator edits logs or swaps model outputs to make the run appear compliant.</td>\n      <td>Gateway receipts are signed by clawproxy; the proof bundle includes hashes that bind payloads, timestamps, and policy references. Verification fails if signatures or hashes do not match.</td>\n    </tr>\n    <tr>\n      <td>CST replay across jobs</td>\n      <td>A valid token is reused to run a different job under the same identity, causing unauthorized work that still “looks authenticated.”</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) reduces replay risk. Additionally, scope hash and optional policy hash pinning constrain where the token is accepted.</td>\n    </tr>\n    <tr>\n      <td>Local execution escape</td>\n      <td>A tool runs on the host unexpectedly (for example via an “elevated” escape hatch) and accesses local credentials or files.</td>\n      <td>Use OpenClaw sandboxing and avoid elevated execution unless explicitly required. Pair local hardening (audit) with WPC restrictions so the intended execution mode is reviewable and enforceable.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>A WPC should be specific enough that reviewers can reason about it and verifiers can bind runs to it. The key is that policy lives outside the prompt and is enforced by the harness, not “suggested” to the model.</p>\n<p>Example shape (JSON-like) that teams commonly version-control before registering it as a WPC in clawcontrols:</p>\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"support-triage-agent\",\n  \"intent\": \"Classify tickets and draft replies. No external posting.\",\n  \"model_routing\": {\n    \"must_use_proxy\": true,\n    \"allowed\": [\n      { \"provider\": \"openrouter_via_fal\", \"via\": \"clawproxy\" }\n    ]\n  },\n  \"tools\": {\n    \"allow\": [\"read\", \"search_repo\", \"create_draft\"],\n    \"deny\": [\"exec\", \"write\", \"browser_control\", \"webhook_post\"]\n  },\n  \"data_handling\": {\n    \"log_payloads\": \"hash_only\",\n    \"retain_days\": 30\n  },\n  \"bindings\": {\n    \"job_scope_required\": true\n  }\n}</pre>\n<p>Then issue a CST (from clawscope) that is scoped to the run and optionally pins the WPC hash. This is what turns “policy text” into a permission boundary that survives prompt injection and operator error.</p>\n\n<h2>What proof do you get?</h2>\n<p>A proof bundle is the container you hand to audit, security, or a verifier service. It typically includes: the WPC hash reference (and often the fetched WPC itself), the CST scope hash context, and gateway receipts for each model call routed via clawproxy.</p>\n<p>What is signed: gateway receipts are signed by clawproxy, and the WPC is a signed artifact served by clawcontrols. What is hashed: the bundle includes hashes that bind the run metadata and receipt set, so post-run edits can be detected. What is replayable: raw receipts can be copied, so you mitigate replay by binding CST to a job scope and by verifying bundle bindings against the job you expected.</p>\n<p>Example (abridged) bundle shape you can expect to retain and re-verify:</p>\n<pre>{\n  \"bundle_version\": \"v1\",\n  \"run\": {\n    \"run_id\": \"run_2026_02_11_001\",\n    \"agent_runtime\": \"OpenClaw\",\n    \"started_at\": \"2026-02-11T10:12:05Z\"\n  },\n  \"policy\": {\n    \"wpc_hash\": \"b64u:...\",\n    \"wpc_source\": \"clawcontrols\"\n  },\n  \"auth\": {\n    \"cst_scope_hash\": \"b64u:...\",\n    \"job_binding\": \"job_7f3c...\"\n  },\n  \"receipts\": [\n    {\n      \"type\": \"gateway_receipt\",\n      \"issuer\": \"clawproxy\",\n      \"model\": \"openrouter/...\",\n      \"request_hash\": \"b64u:...\",\n      \"response_hash\": \"b64u:...\",\n      \"signature\": \"b64u:...\"\n    }\n  ]\n}</pre>\n<p>Verification workflow: check WPC signature and hash-addressing, check CST scope hash and (if present) policy hash pinning, verify each gateway receipt signature, and confirm the job-scoped binding matches the job context you are approving. If you publish to Trust Pulse, you get a consistent place to store and view the artifact, but you should still keep your own retention copy if policy requires it.</p>\n<p>Common pitfalls: allowing multiple model routes “temporarily,” not failing closed on missing receipts, and storing plaintext prompts in the same place as proof artifacts. Keep proofs verifiable, but keep secrets compartmentalized.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback is about stopping further damage and preserving evidence. Proof bundles help because you can quickly answer “what was called, under what policy, using which token scope,” then revoke or tighten accordingly.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to capture</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Suspect CST misuse</td>\n      <td>Revoke the CST in clawscope, then re-issue a new CST with tighter scope hash and shorter TTL for the replacement run.</td>\n      <td>Proof bundle plus the CST scope hash and job binding referenced by the run.</td>\n    </tr>\n    <tr>\n      <td>Policy too permissive</td>\n      <td>Register a new WPC (new hash) with reduced tools or restricted model routing, and require policy hash pinning in the next CST issuance.</td>\n      <td>Old and new WPC hashes, plus verifier results showing which runs used which policy.</td>\n    </tr>\n    <tr>\n      <td>Missing receipts for some model calls</td>\n      <td>Stop accepting the run output for high-impact actions until routing is corrected to clawproxy. Re-run with proxy-only model routing.</td>\n      <td>Bundle showing receipt gaps, and OpenClaw configuration evidence showing provider routing for the rerun.</td>\n    </tr>\n    <tr>\n      <td>Local tool execution incident</td>\n      <td>Tighten OpenClaw sandbox mode and tool allowlists, and remove elevated execution paths unless explicitly required.</td>\n      <td>OpenClaw audit results plus the proof bundle metadata showing execution mode expectations.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>How is a proof bundle different from “logs”?</h3>\n<p>Logs are easy to edit and hard to verify. A proof bundle is structured for verification: it binds gateway receipts, policy references (WPC hash), and run metadata so tampering is detectable.</p>\n\n<h3>Do proof bundles prove what tools did on the host?</h3>\n<p>They prove what is included in the bundle, especially model calls via gateway receipts and the policy bindings around the run. Host-side tool execution is primarily controlled by OpenClaw tool policy and sandboxing, so you should treat the bundle as part of a broader execution posture.</p>\n\n<h3>What should we retain, and for how long?</h3>\n<p>Retain full bundles for high-risk runs (production changes, external comms, security-sensitive actions). For routine runs, many teams retain hashes plus minimal metadata and keep plaintext prompts or outputs in a separate encrypted system with stricter access.</p>\n\n<h3>Can we verify bundles automatically in CI or a gatekeeper?</h3>\n<p>Yes, if your workflow can submit the bundle to a verifier (for example, clawverify via official API) and fail closed. Gate on “verified receipts present,” “WPC hash matches,” and “job-scoped CST binding matches the job being approved.”</p>\n\n<h3>What makes policy-as-code necessary if we already have good prompts?</h3>\n<p>Prompts are instructions, not enforcement, and they are vulnerable to injection and tool output manipulation. Policy-as-code in a WPC is enforced by the harness and is cryptographically referenceable, so reviewers can approve a specific policy hash and verifiers can check it later.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + common footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n</ul>",
  "description": "Proof bundles let you verify what an agent run actually did by packaging gateway receipts, policy references, and run metadata into one artifact you can re-check later. In Claw EA, the proof bundle is built around Work P",
  "faqs": [
    {
      "q": "How is a proof bundle different from “logs”?",
      "a": "Logs are easy to edit and hard to verify. A proof bundle is structured for verification: it binds gateway receipts, policy references (WPC hash), and run metadata so tampering is detectable."
    },
    {
      "q": "Do proof bundles prove what tools did on the host?",
      "a": "They prove what is included in the bundle, especially model calls via gateway receipts and the policy bindings around the run. Host-side tool execution is primarily controlled by OpenClaw tool policy and sandboxing, so you should treat the bundle as part of a broader execution posture."
    },
    {
      "q": "What should we retain, and for how long?",
      "a": "Retain full bundles for high-risk runs (production changes, external comms, security-sensitive actions). For routine runs, many teams retain hashes plus minimal metadata and keep plaintext prompts or outputs in a separate encrypted system with stricter access."
    },
    {
      "q": "Can we verify bundles automatically in CI or a gatekeeper?",
      "a": "Yes, if your workflow can submit the bundle to a verifier (for example, clawverify via official API) and fail closed. Gate on “verified receipts present,” “WPC hash matches,” and “job-scoped CST binding matches the job being approved.”"
    },
    {
      "q": "What makes policy-as-code necessary if we already have good prompts?",
      "a": "Prompts are instructions, not enforcement, and they are vulnerable to injection and tool output manipulation. Policy-as-code in a WPC is enforced by the harness and is cryptographically referenceable, so reviewers can approve a specific policy hash and verifiers can check it later."
    }
  ],
  "sources": [],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:30:19.609Z",
  "indexable": true
}