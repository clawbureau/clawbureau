{
  "slug": "proof/gateway-receipts",
  "title": "Gateway Receipts for Agents | Claw EA",
  "category": "proof",
  "html": "<p>Gateway receipts are signed records of each model call made by an agent through clawproxy, designed so you can later prove what was requested, what policy context applied, and whether the response you used matches what the gateway saw.</p>\n<p>In Claw EA, receipts are generated while running OpenClaw as the baseline agent runtime, then packaged into a proof bundle so verification can be automated and fail closed when something is missing or mismatched.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>This runbook assumes your agents send model traffic through clawproxy (for example OpenRouter via fal routed through clawproxy) and that you want a verifiable audit artifact after each run.</p>\n<ol>\n  <li>\n    <p><strong>Publish a WPC and treat it as the execution contract.</strong> A WPC is a Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols). Your operator workflow should start by choosing a WPC hash for the job and keeping it stable for the run.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the job with scope hash and optional policy hash pinning.</strong> A CST is a scoped token (issued by clawscope). If you pin the policy hash, the token can be constrained to a specific WPC so “same scope, different policy” fails verification later.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy using that CST.</strong> Do not rely on the agent prompt to “promise” it only used certain models or tools. The gateway is where you can measure and bind what actually happened.</p>\n  </li>\n  <li>\n    <p><strong>Collect gateway receipts for every model call.</strong> Gateway receipts are signed receipts emitted by clawproxy for model calls. Store them with job metadata such as the job id, agent id, and the WPC hash that was intended for the run.</p>\n  </li>\n  <li>\n    <p><strong>Assemble a proof bundle and verify it before accepting outputs.</strong> A proof bundle is a harness artifact bundling receipts and related metadata for audit/verification. Verification should check signatures, binding fields, and that the receipts cover the set of outputs you plan to act on.</p>\n  </li>\n  <li>\n    <p><strong>Optionally publish the result to Trust Pulse.</strong> Trust Pulse is a marketplace-stored artifact for audit/viewing. Use it when you need a stable external reference for reviewers without giving them direct access to internal logs.</p>\n  </li>\n</ol>\n<p>Common pitfall: teams only log prompts and responses. That is useful for debugging, but it is not a receipt, and it does not prove the messages were the ones actually sent to the model provider.</p>\n\n<h2>Threat model</h2>\n<p>Receipts are meant to address concrete failure modes: prompt tampering, post-hoc log editing, and replay of “good” outputs under a different policy context. The goal is not perfect security, it is tamper-evident evidence that can be verified independently.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt-only policy bypass</td>\n      <td>An agent is instructed to ignore rules and call a different model, request disallowed content, or exfiltrate via the model output.</td>\n      <td>Permissioned execution via WPC plus CST scope hash, with model calls routed through clawproxy so every call is receipted.</td>\n    </tr>\n    <tr>\n      <td>Post-hoc audit log editing</td>\n      <td>Someone edits application logs to make it look like a safer prompt or different response was used.</td>\n      <td>Gateway receipts are signed at the proxy. A proof bundle can be validated later without trusting the application log pipeline.</td>\n    </tr>\n    <tr>\n      <td>Receipt replay across jobs</td>\n      <td>A prior “good” receipt or response is reused to justify a different run, or to satisfy a downstream reviewer.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) ties artifacts to a job context so replay fails verification.</td>\n    </tr>\n    <tr>\n      <td>Policy drift between run and review</td>\n      <td>The policy changes after execution, but reviewers assume today’s policy was enforced during the run.</td>\n      <td>WPC is hash-addressed and can be referenced by hash in the job record and pinned via CST optional policy hash pinning.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Why permissioned execution must be policy-as-code instead of prompt-only: prompts are not an enforcement boundary. OpenClaw already treats tool policy and sandboxing as the local safety boundary, and receipts extend that idea to model traffic by making the network-level call auditable.</p>\n\n<h2>Policy-as-code example</h2>\n<p>Below is a JSON-like example showing how you can bind an agent run to a WPC hash and require that model calls are receipted through the gateway. Treat this as shape and intent; your exact fields depend on your enterprise buildout.</p>\n<pre>{\n  \"job\": {\n    \"job_id\": \"job_2026_02_11_143200Z\",\n    \"agent_runtime\": \"OpenClaw\",\n    \"wpc_policy_hash_b64u\": \"wpc_7uQm...pinned\",\n    \"auth\": {\n      \"cst_required\": true,\n      \"cst_scope_hash\": \"scope_9d2c...evidence\",\n      \"pin_wpc_hash\": true\n    },\n    \"model_gateway\": {\n      \"route_via\": \"clawproxy\",\n      \"require_gateway_receipts\": true\n    }\n  }\n}</pre>\n<p>This is the key operational difference from “just add rules to the system prompt.” The WPC and CST define what is allowed, and the gateway receipts prove what was actually called under that contract.</p>\n\n<h2>What proof do you get?</h2>\n<p>At minimum you get gateway receipts for each model call, and a proof bundle that packages those receipts with enough metadata to verify them later. Verification checks the signature on each receipt, then checks bindings such as job context, CST scope hash, and any pinned WPC policy hash.</p>\n<p>What is signed: the receipt envelope emitted by clawproxy, including fields that bind the receipt to the gateway’s view of the request and response. What is hashed: canonicalized content references (for example message payload digests) so you can detect edits even if you store the full payload elsewhere.</p>\n<p>What is replayable: any artifact can be copied as a file, so replay defense depends on binding. The shipped control is marketplace anti-replay binding (job-scoped CST binding), which makes “valid receipt, wrong job” fail when you verify in the expected job context.</p>\n<p>A minimal receipt and proof bundle shape (illustrative) looks like this:</p>\n<pre>{\n  \"proof_bundle\": {\n    \"job_id\": \"job_2026_02_11_143200Z\",\n    \"wpc_policy_hash_b64u\": \"wpc_7uQm...pinned\",\n    \"cst_scope_hash\": \"scope_9d2c...evidence\",\n    \"receipts\": [\n      {\n        \"receipt_id\": \"rct_001\",\n        \"gateway\": \"clawproxy\",\n        \"model\": \"openrouter/...via_fal\",\n        \"request_hash\": \"h_req_...\",\n        \"response_hash\": \"h_res_...\",\n        \"issued_at\": \"2026-02-11T14:32:10Z\",\n        \"signature\": \"sig_...\"\n      }\n    ]\n  }\n}</pre>\n<p>Common verification pitfall: teams verify signatures but forget to verify bindings. A valid signature only proves clawproxy issued a receipt, not that it was issued for your job, your policy hash, and your intended scope.</p>\n\n<h2>Rollback posture</h2>\n<p>Receipts help you roll back safely because you can distinguish “the agent said it did X” from “the gateway observed X.” In an incident, you typically pause automation, quarantine outputs, then re-run verification before reinstating write privileges.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop acting on agent outputs</td>\n      <td>Switch to read-only mode for downstream systems and require human approval for writes (enterprise buildout).</td>\n      <td>Proof bundle existence and completeness for the affected job ids.</td>\n    </tr>\n    <tr>\n      <td>Invalidate compromised scope</td>\n      <td>Rotate and re-issue CST for the next run, and treat the old CST as untrusted for new jobs.</td>\n      <td>CST scope hash in proof bundles distinguishes old runs from new runs.</td>\n    </tr>\n    <tr>\n      <td>Re-run with tightened policy</td>\n      <td>Publish a new WPC and pin it, then rerun the job so the new policy hash is unambiguous during review.</td>\n      <td>WPC hash references in job records and proof bundles show which contract applied to each run.</td>\n    </tr>\n    <tr>\n      <td>Audit what the model actually saw</td>\n      <td>Reconstruct the sequence of model calls from receipts and compare to application logs for drift.</td>\n      <td>Gateway receipts provide a proxy-level ground truth for model traffic.</td>\n    </tr>\n  </tbody>\n</table>\n<p>If you need stronger containment, egress allowlists enforced outside clawproxy can be implemented, but they are optional and environment-specific. The same is true for automatic cost budget enforcement and transparency log inclusion proofs, which are planned or can be implemented based on your requirements.</p>\n\n<h2>FAQ</h2>\n<h3>Are gateway receipts the same as application logs?</h3>\n<p>No. Logs are writable by whoever controls the logging pipeline, while gateway receipts are signed artifacts emitted at the proxy for each model call and intended for later verification.</p>\n\n<h3>What do gateway receipts prove, exactly?</h3>\n<p>They prove that clawproxy observed and signed a specific model call under specific binding metadata, and that the request and response hashes match what you are presenting later. They do not prove the internal weights of a closed model provider.</p>\n\n<h3>Why can’t we enforce policy with a system prompt?</h3>\n<p>A prompt is guidance, not enforcement. Permissioned execution uses WPC and CST to define allowed behavior, then uses gateway receipts to prove what was actually executed at the model boundary.</p>\n\n<h3>What causes verification to fail most often?</h3>\n<p>Mismatched job context, missing receipts for some calls, or policy drift where the WPC hash used during review is not the one pinned for the run. Another common issue is routing some calls outside clawproxy, which creates unreceipted gaps.</p>\n\n<h3>Do receipts cover tools and filesystem actions too?</h3>\n<p>Gateway receipts cover model calls made through clawproxy. For tool execution, OpenClaw’s sandbox and tool policy controls are the local safety boundary, and the proof bundle focuses on receipted model traffic plus related run metadata.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://pages.nist.gov/800-63-4/sp800-63c/Federation/\">NIST SP 800-63C: Common Federation Requirements</a></li>\n</ul>",
  "description": "Gateway receipts are signed records of each model call made by an agent through clawproxy, designed so you can later prove what was requested, what policy context applied, and whether the response you used matches what t",
  "faqs": [
    {
      "q": "Are gateway receipts the same as application logs?",
      "a": "No. Logs are writable by whoever controls the logging pipeline, while gateway receipts are signed artifacts emitted at the proxy for each model call and intended for later verification."
    },
    {
      "q": "What do gateway receipts prove, exactly?",
      "a": "They prove that clawproxy observed and signed a specific model call under specific binding metadata, and that the request and response hashes match what you are presenting later. They do not prove the internal weights of a closed model provider."
    },
    {
      "q": "Why can’t we enforce policy with a system prompt?",
      "a": "A prompt is guidance, not enforcement. Permissioned execution uses WPC and CST to define allowed behavior, then uses gateway receipts to prove what was actually executed at the model boundary."
    },
    {
      "q": "What causes verification to fail most often?",
      "a": "Mismatched job context, missing receipts for some calls, or policy drift where the WPC hash used during review is not the one pinned for the run. Another common issue is routing some calls outside clawproxy, which creates unreceipted gaps."
    },
    {
      "q": "Do receipts cover tools and filesystem actions too?",
      "a": "Gateway receipts cover model calls made through clawproxy. For tool execution, OpenClaw’s sandbox and tool policy controls are the local safety boundary, and the proof bundle focuses on receipted model traffic plus related run metadata."
    }
  ],
  "sources": [
    {
      "title": "Common Federation Requirements - NIST Pages",
      "uri": "https://pages.nist.gov/800-63-4/sp800-63c/Federation/"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:28:01.676Z",
  "indexable": true
}