{
  "slug": "guides",
  "title": "Implementation Guides for Permissioned Agents | Claw EA",
  "category": "hubs",
  "html": "<p>This hub collects implementation guides for running permissioned enterprise agents on Claw EA, using OpenClaw as the baseline agent runtime. The goal is to make agent execution verifiable and restrictable using policy-as-code, rather than relying on prompt text to “behave.”</p>\n<p>In practice, you express allowed actions as a WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols), bind runtime access using a CST = scoped token (issued by clawscope), route model calls through clawproxy for gateway receipts, and retain a proof bundle for audit and rollback.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this as the default path for a first production pilot. Keep the first WPC small, then widen only after you can review receipts and prove that enforcement is working.</p>\n<ol>\n  <li>\n    <p><strong>Pick one job shape and one tool surface.</strong> Example: “triage inbound tickets and draft responses,” with a single write surface (your ticketing system via official API or via MCP server) and read-only access elsewhere.</p>\n  </li>\n  <li>\n    <p><strong>Write a WPC that describes the allowed work.</strong> The WPC should encode tool allow/deny, sandbox requirements, and model routing constraints that you can check mechanically. A prompt can guide behavior, but it cannot enforce it when the model decides to call tools anyway.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST with scope hash and optional policy hash pinning.</strong> Use clawscope to mint a CST that is job-scoped, with the intended scope hash and, when appropriate, a pinned WPC hash. This keeps “what the agent can do” bound to a signed artifact, not to a chat transcript.</p>\n  </li>\n  <li>\n    <p><strong>Configure OpenClaw to run with strict tool policy and sandboxing.</strong> Use OpenClaw tool policy (allow/deny profiles) plus sandbox mode to reduce local blast radius, and avoid elevated execution unless you can justify it. Treat elevated as a last-resort escape hatch that must be explicitly permissioned.</p>\n  </li>\n  <li>\n    <p><strong>Route model traffic through clawproxy and capture gateway receipts.</strong> For LLM calls, route through clawproxy so each model call emits gateway receipts. If you use OpenRouter via fal, run it through clawproxy so receipts can be verified later.</p>\n  </li>\n  <li>\n    <p><strong>Require proof review before widening privileges.</strong> On each pilot run, archive the proof bundle, verify it, and review the tool and model-call boundaries you actually observed. Only then update the WPC and re-issue CSTs for the next iteration.</p>\n  </li>\n</ol>\n<p><strong>How to get started checklist:</strong> define one WPC, run one OpenClaw agent in sandbox mode, issue one job-scoped CST, route all model calls through clawproxy, and require a proof bundle attached to every run before sign-off.</p>\n\n<h2>Threat model</h2>\n<p>Enterprise agent security fails most often at the execution layer: the agent gains a tool it should not have, or it uses a permitted tool in an unpermitted way. Prompt-only controls are advisory and can be bypassed by prompt injection, tool descriptions that drift, or plugin behavior that changes.</p>\n<p>The controls below treat policies and tokens as signed constraints and require verifiable evidence after the run.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (operational)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection causes unsafe tool use</td>\n      <td>The model is convinced to call a tool that changes state or exfiltrates data</td>\n      <td>Enforce tool allow/deny via OpenClaw tool policy and sandboxing; express the allowed work as a WPC and require CST policy hash pinning for runs that change state</td>\n    </tr>\n    <tr>\n      <td>Token replay across jobs</td>\n      <td>A captured token is reused to run a different job or widen access</td>\n      <td>Use marketplace anti-replay binding with job-scoped CST binding; rotate CSTs per job and revoke quickly on suspicion</td>\n    </tr>\n    <tr>\n      <td>Model call disputes after an incident</td>\n      <td>You cannot prove which prompts and model responses occurred during execution</td>\n      <td>Route model calls through clawproxy to generate gateway receipts; bundle receipts into a proof bundle for independent verification</td>\n    </tr>\n    <tr>\n      <td>Sandbox escape or host impact</td>\n      <td>Tool execution touches host filesystem or processes beyond intent</td>\n      <td>Run tools in OpenClaw Docker sandbox where possible; avoid elevated execution unless the WPC explicitly allows it and the run is limited in scope</td>\n    </tr>\n    <tr>\n      <td>Unbounded outbound calls</td>\n      <td>The agent uses HTTP tooling to reach arbitrary hosts and leak data</td>\n      <td>Implement egress allowlists enforced outside clawproxy (optional, can be implemented) and keep the WPC tool allowlist minimal; review receipts and tool logs for unexpected destinations</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>A WPC should be a portable, signed contract that the runtime can fetch and verify, and that your reviewers can diff like code. The key difference from “prompt rules” is that this policy is intended to be enforced mechanically, and referenced by hash in the CST when you need strict pinning.</p>\n<p>Example JSON-like structure (illustrative):</p>\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"intent\": \"ticket-triage-draft-only\",\n  \"model_routing\": {\n    \"provider\": \"openrouter_via_fal\",\n    \"must_route_through\": \"clawproxy\"\n  },\n  \"openclaw\": {\n    \"sandbox\": { \"mode\": \"all\", \"workspaceAccess\": \"ro\" },\n    \"tools\": {\n      \"allow\": [\"read\", \"search\", \"http_get\"],\n      \"deny\": [\"exec\", \"write\", \"edit\", \"apply_patch\"],\n      \"elevated\": { \"allow\": [] }\n    }\n  },\n  \"data_handling\": {\n    \"redact\": [\"secrets\", \"tokens\"]\n  }\n}\n</pre>\n<p>For a production run that can change state, issue a CST that includes a scope hash for the job and optional policy hash pinning to the WPC hash you approved. This makes “what was allowed” checkable even when prompts and skills evolve.</p>\n\n<h2>What proof do you get?</h2>\n<p>Every model call routed through clawproxy can produce gateway receipts. Receipts are designed to be verified later, so you can answer “what did the model see and say” without relying on an application log that might be incomplete or edited.</p>\n<p>Claw EA groups those receipts and related metadata into a proof bundle per run. The proof bundle is the unit you hand to security review, compliance sampling, or incident response to reconstruct the execution boundary and validate it independently.</p>\n<p>For org-wide viewing and audit workflows, you can store and view artifacts as a Trust Pulse. For replay resistance, use marketplace anti-replay binding (job-scoped CST binding) so a token from one job cannot be reused to generate “valid-looking” proof for another job.</p>\n\n<h2>Rollback posture</h2>\n<p>Permissioned agents need a rollback plan that is fast, testable, and evidence-driven. Treat rollback as a set of switches you can flip without debating what happened, because the proof bundle and gateway receipts already anchor the record.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to confirm</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Suspected credential or token leak</td>\n      <td>Revoke the CST and re-issue job-scoped CSTs with narrower scope hash; rotate affected secrets</td>\n      <td>Proof bundle shows last valid run; subsequent calls fail to authenticate, and no new gateway receipts appear for the revoked CST</td>\n    </tr>\n    <tr>\n      <td>Tool misuse or unexpected side effects</td>\n      <td>Update the WPC to deny the tool or require a stricter sandbox mode; pin the new WPC hash in new CSTs</td>\n      <td>Diff between WPC versions plus proof bundles that demonstrate the tool is no longer called</td>\n    </tr>\n    <tr>\n      <td>Model output dispute (what was sent to the model)</td>\n      <td>Freeze changes, verify gateway receipts from clawproxy, and re-run with the same WPC and a fresh CST for reproduction</td>\n      <td>Verified gateway receipts and the associated proof bundle; comparison across runs is anchored by receipts</td>\n    </tr>\n    <tr>\n      <td>Network exfiltration concern</td>\n      <td>Temporarily remove outbound HTTP tools from the allowlist and implement egress allowlists enforced outside clawproxy (optional, can be implemented)</td>\n      <td>Receipts and tool logs show no outbound calls after the policy change</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why isn’t prompt-only “do not exfiltrate data” sufficient?</h3>\n<p>Prompt rules are not enforcement. When an agent can call tools, the execution layer must be permissioned with policy-as-code so that disallowed actions cannot execute even if the model is manipulated.</p>\n\n<h3>How do WPC and CST work together during a run?</h3>\n<p>The WPC defines the approved work boundary as a signed artifact. The CST is the runtime credential that can carry a scope hash and optionally pin the policy hash, so a run is bound to both “who/what can run” and “what is allowed.”</p>\n\n<h3>What do gateway receipts cover and what do they not cover?</h3>\n<p>Gateway receipts cover model calls routed through clawproxy, so you can verify what was sent and returned at the model boundary. They do not automatically prove what happened inside every external system, so you still pair this with system-side logs via official API or enterprise buildout.</p>\n\n<h3>Can we integrate enterprise identity like Entra ID?</h3>\n<p>Yes, typically by issuing CSTs based on your enterprise identity workflow and binding runs to job context, with enforcement in Claw Bureau services. If you need Entra ID features like Conditional Access or PIM to gate who can mint or approve tokens, that is usually done as an enterprise buildout around your existing identity plane.</p>\n\n<h3>Do you block egress by default?</h3>\n<p>Claw EA focuses on permissioned execution, receipts, and proof bundles. Egress allowlists enforced outside clawproxy are optional and can be implemented when your environment requires network-level controls.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization\">Microsoft Cloud Adoption Framework: Governance and security for AI agents across the organization</a></li>\n  <li><a href=\"https://genai.owasp.org/resource/securing-agentic-applications-guide-1-0/\">OWASP: Securing Agentic Applications Guide 1.0</a></li>\n</ul>",
  "description": "This hub collects implementation guides for running permissioned enterprise agents on Claw EA, using OpenClaw as the baseline agent runtime. The goal is to make agent execution verifiable and restrictable using policy-as",
  "faqs": [
    {
      "q": "Why isn’t prompt-only “do not exfiltrate data” sufficient?",
      "a": "Prompt rules are not enforcement. When an agent can call tools, the execution layer must be permissioned with policy-as-code so that disallowed actions cannot execute even if the model is manipulated."
    },
    {
      "q": "How do WPC and CST work together during a run?",
      "a": "The WPC defines the approved work boundary as a signed artifact. The CST is the runtime credential that can carry a scope hash and optionally pin the policy hash, so a run is bound to both “who/what can run” and “what is allowed.”"
    },
    {
      "q": "What do gateway receipts cover and what do they not cover?",
      "a": "Gateway receipts cover model calls routed through clawproxy, so you can verify what was sent and returned at the model boundary. They do not automatically prove what happened inside every external system, so you still pair this with system-side logs via official API or enterprise buildout."
    },
    {
      "q": "Can we integrate enterprise identity like Entra ID?",
      "a": "Yes, typically by issuing CSTs based on your enterprise identity workflow and binding runs to job context, with enforcement in Claw Bureau services. If you need Entra ID features like Conditional Access or PIM to gate who can mint or approve tokens, that is usually done as an enterprise buildout around your existing identity plane."
    },
    {
      "q": "Do you block egress by default?",
      "a": "Claw EA focuses on permissioned execution, receipts, and proof bundles. Egress allowlists enforced outside clawproxy are optional and can be implemented when your environment requires network-level controls."
    }
  ],
  "sources": [
    {
      "title": "Securing Agentic Applications Guide 1.0",
      "uri": "https://genai.owasp.org/resource/securing-agentic-applications-guide-1-0/"
    },
    {
      "title": "Governance and security for AI agents across the organization",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization"
    },
    {
      "title": "AI agents in enterprises: Best practices with Amazon Bedrock ...",
      "uri": "https://aws.amazon.com/blogs/machine-learning/ai-agents-in-enterprises-best-practices-with-amazon-bedrock-agentcore/"
    },
    {
      "title": "Agent Factory Recap: Securing AI Agents in Production",
      "uri": "https://cloud.google.com/blog/topics/developers-practitioners/agent-factory-recap-securing-ai-agents-in-production"
    },
    {
      "title": "Best Practices for Secure Agentforce Implementation",
      "uri": "https://www.salesforce.com/blog/best-practices-for-secure-agentforce-implementation-2/"
    },
    {
      "title": "Best Practices for Building Secure Agentforce Service Agents",
      "uri": "https://admin.salesforce.com/blog/2025/best-practices-for-building-secure-agentforce-service-agents"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:58:29.854Z",
  "indexable": true
}