{
  "slug": "controls",
  "title": "Agent Controls (Policy-as-Code) | Claw EA",
  "category": "hubs",
  "html": "<h2>Direct Answer</h2>\n<p>Enterprise AI agents need controls that are enforced by the execution layer, not just requested in a prompt. Claw EA runs OpenClaw as the baseline agent runtime, then adds permissioned execution using WPC = Work Policy Contract, CST = scoped token, gateway receipts, and proof bundles so you can prove what the agent was allowed to do and what it actually did.</p>\n<p>Prompt-only guardrails fail when the agent is tool-calling, long-running, or exposed to untrusted inputs. Policy-as-code makes the allowed actions machine-checkable and verifiable at runtime, and it gives you artifacts you can audit after the fact.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Define the job boundary and identity.</strong> Decide what a “job” is for your org (ticket, alert, incident, or workflow instance) and what data classification it may touch. If you use Microsoft, align this to Entra ID app identities, Microsoft Graph permissions/scopes, Conditional Access posture, and PIM for operator actions, via official APIs and enterprise buildout where needed.</p>\n  </li>\n  <li>\n    <p><strong>Write a WPC and treat it as the source of truth.</strong> Create a WPC = Work Policy Contract that states which tools, providers, and data classes are allowed. Store it as a signed, hash-addressed policy artifact served by clawcontrols, and reference the policy hash in your run configuration.</p>\n  </li>\n  <li>\n    <p><strong>Configure OpenClaw tool policy and sandboxing to match the WPC.</strong> Use OpenClaw tool allow/deny lists and sandbox modes to reduce blast radius, then keep any host-level “elevated” paths tightly gated. Validate the effective configuration using OpenClaw’s built-in inspection and security audit guidance.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST that is job-scoped and policy-pinned.</strong> Obtain a CST = scoped token issued by clawscope for the specific job, with a scope hash and optional policy hash pinning. Prefer short TTLs and one job per CST to support marketplace anti-replay binding (job-scoped CST binding).</p>\n  </li>\n  <li>\n    <p><strong>Route model traffic through clawproxy for receipts.</strong> Run model calls through clawproxy so you get gateway receipts (signed receipts emitted by clawproxy for model calls). If you use OpenRouter, it is supported via fal routed through clawproxy.</p>\n  </li>\n  <li>\n    <p><strong>Collect a proof bundle for every run and store it where auditors can find it.</strong> Archive the proof bundle (the harness artifact bundling receipts and metadata for audit/verification). If you use Trust Pulse, store the artifact there for viewing and later review.</p>\n  </li>\n</ol>\n<p><strong>Quick start checklist:</strong> (1) smallest tool allowlist that still works, (2) sandbox “all” for untrusted channels, (3) WPC hash pinned, (4) job-scoped CST, (5) clawproxy receipts on, (6) proof bundle archived.</p>\n\n<h2>Threat model</h2>\n<p>Agent controls should assume the agent can be coerced by prompt injection, can make mistakes, and can be triggered unexpectedly in real channels. The goal is to constrain execution, then generate evidence that those constraints were applied.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (operational)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection causes unsafe tool use</td>\n      <td>The model attempts shell, file, or network actions outside intended scope</td>\n      <td>OpenClaw tool allow/deny lists plus sandboxing; WPC defines allowed tool classes and is enforced as a policy artifact, not a prompt suggestion</td>\n    </tr>\n    <tr>\n      <td>Credential or token replay</td>\n      <td>A copied token is reused to run extra work after the job ends</td>\n      <td>Job-scoped CST binding (marketplace anti-replay binding) and short-lived CST issuance from clawscope</td>\n    </tr>\n    <tr>\n      <td>Unverifiable model activity</td>\n      <td>You cannot prove which model calls were made, with what policy context</td>\n      <td>Route calls through clawproxy to emit gateway receipts; bundle receipts into a proof bundle tied to the job and policy hash</td>\n    </tr>\n    <tr>\n      <td>Overbroad provider access</td>\n      <td>The agent can switch to a different provider or model class than expected</td>\n      <td>WPC constrains allowed providers and models; enforce routing through clawproxy where model calls are receipted and policy context can be checked</td>\n    </tr>\n    <tr>\n      <td>Data exfiltration via allowed tools</td>\n      <td>The agent sends sensitive data to external endpoints using legitimate tools</td>\n      <td>Minimize tool surface area; require explicit tool-by-tool justification in the WPC; egress allowlists enforced outside clawproxy are planned or can be implemented as an enterprise buildout</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact example of how teams express “what is allowed” as a signed WPC and then bind execution to it. Keep it small and explicit, and treat every expansion as a reviewed change.</p>\n<pre><code>{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"ops-triage-agent\",\n  \"policy_intent\": \"Triage alerts, summarize logs, open a ticket\",\n  \"constraints\": {\n    \"tools\": {\n      \"allow\": [\"read\", \"write\", \"http\", \"ticket_create\"],\n      \"deny\": [\"exec\", \"process\", \"browser_control\", \"elevated_exec\"]\n    },\n    \"sandbox\": {\n      \"mode\": \"all\",\n      \"workspace_access\": \"ro\"\n    },\n    \"models\": {\n      \"allowed_routes\": [\"openrouter_via_fal_via_clawproxy\"],\n      \"deny_legacy\": true\n    },\n    \"data\": {\n      \"max_classification\": \"internal\",\n      \"redaction_required\": true\n    }\n  },\n  \"token_binding\": {\n    \"cst_scope_hash_required\": true,\n    \"policy_hash_pinning\": \"required\"\n  }\n}</code></pre>\n<p>In practice, the WPC is stored as a signed, hash-addressed artifact served by clawcontrols, and the run uses that policy hash as the binding reference. The CST is issued by clawscope with scope hash and optional policy hash pinning so a token cannot be reused under a different policy.</p>\n\n<h2>What proof do you get?</h2>\n<p>Claw EA is designed so you can answer two audit questions: what was permitted, and what occurred. You get both, and they are cryptographically linkable at the job level.</p>\n<ul>\n  <li>\n    <p><strong>WPC reference:</strong> the hash-addressed WPC stored in the registry (served by clawcontrols), used as the canonical statement of allowed behavior for the run.</p>\n  </li>\n  <li>\n    <p><strong>CST binding:</strong> a CST issued by clawscope with a scope hash, with optional policy hash pinning, so the token context matches the intended job and policy.</p>\n  </li>\n  <li>\n    <p><strong>Gateway receipts:</strong> signed receipts emitted by clawproxy for each model call, suitable for later verification and correlation.</p>\n  </li>\n  <li>\n    <p><strong>Proof bundle:</strong> a single harness artifact bundling receipts and related metadata for audit/verification, suitable for storage alongside the ticket, incident record, or run log.</p>\n  </li>\n  <li>\n    <p><strong>Trust Pulse (optional storage/viewing):</strong> store the artifact in Trust Pulse so reviewers can view the run evidence without reassembling it from multiple systems.</p>\n  </li>\n</ul>\n\n<h2>Rollback posture</h2>\n<p>Controls are only useful if you can unwind changes safely after a bad run. Treat rollback as part of the control plane, with a defined evidence trail for what was reverted and why.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to retain</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Policy change expands tool access</td>\n      <td>Revert to prior WPC hash and redeploy agent config pinned to the earlier hash</td>\n      <td>Old and new WPC hashes, change approval record, proof bundles from runs under each hash</td>\n    </tr>\n    <tr>\n      <td>Token misuse suspected</td>\n      <td>Revoke the CST issuance path and rotate affected secrets; issue new job-scoped CSTs only</td>\n      <td>CST issuance and revocation records (from clawscope) plus associated proof bundles</td>\n    </tr>\n    <tr>\n      <td>Unsafe model behavior observed</td>\n      <td>Temporarily restrict allowed routes in the WPC; keep routing through clawproxy for receipts</td>\n      <td>Gateway receipts around the incident window and the policy hash that governed the run</td>\n    </tr>\n    <tr>\n      <td>Sandbox escape concern</td>\n      <td>Disable elevated paths and force sandbox “all” while investigating; reduce workspace mounts</td>\n      <td>OpenClaw config diff, OpenClaw security audit output, and proof bundles for affected jobs</td>\n    </tr>\n  </tbody>\n</table>\n<p>Automatic cost budget enforcement is planned or can be implemented, but do not treat it as a substitute for tool policy. Start by limiting what the agent can do, then meter and review what it did using receipts and proof bundles.</p>\n\n<h2>FAQ</h2>\n<h3>Why is prompt-only control insufficient for enterprise agents?</h3>\n<p>Prompts are not enforcement. Once an agent can call tools, a single bad instruction can trigger real side effects unless the execution layer rejects the action.</p>\n<p>Policy-as-code creates a deterministic allow/deny boundary, and the evidence (receipts and proof bundles) lets you verify compliance after the run.</p>\n\n<h3>How does this relate to OpenClaw tool policy and sandboxing?</h3>\n<p>OpenClaw provides local controls like sandboxing, tool policy, and elevated execution gates. Claw EA complements that with portable policy artifacts (WPC) and verifiable model-call evidence (gateway receipts and proof bundles).</p>\n\n<h3>What do we pin: the token, the policy, or both?</h3>\n<p>Pin both when you can. Use a job-scoped CST with a scope hash, and enable optional policy hash pinning so a token cannot be reused under a different WPC.</p>\n\n<h3>Can we use Microsoft Entra ID and Microsoft Graph with this?</h3>\n<p>Yes, typically by aligning job identity and approvals to Entra ID and using Microsoft Graph permissions/scopes for downstream access, via official API and enterprise buildout. Keep Graph scopes narrow, and use Conditional Access and PIM for privileged operations.</p>\n\n<h3>What is the minimum evidence package we should store per job?</h3>\n<p>Store the WPC hash reference, the CST context (job-scoped binding), and the proof bundle containing gateway receipts. That set is usually enough to reconstruct what was allowed and what model calls occurred.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization\">Governance and security for AI agents across the organization (Microsoft Learn)</a></li>\n  <li><a href=\"https://aws.amazon.com/blogs/security/the-agentic-ai-security-scoping-matrix-a-framework-for-securing-autonomous-ai-systems/\">The Agentic AI Security Scoping Matrix (AWS Security Blog)</a></li>\n</ul>",
  "description": "Enterprise AI agents need controls that are enforced by the execution layer, not just requested in a prompt. Claw EA runs OpenClaw as the baseline agent runtime, then adds permissioned execution using WPC = Work Policy C",
  "faqs": [
    {
      "q": "Why is prompt-only control insufficient for enterprise agents?",
      "a": "Prompts are not enforcement. Once an agent can call tools, a single bad instruction can trigger real side effects unless the execution layer rejects the action."
    },
    {
      "q": "How does this relate to OpenClaw tool policy and sandboxing?",
      "a": "OpenClaw provides local controls like sandboxing, tool policy, and elevated execution gates. Claw EA complements that with portable policy artifacts (WPC) and verifiable model-call evidence (gateway receipts and proof bundles)."
    },
    {
      "q": "What do we pin: the token, the policy, or both?",
      "a": "Pin both when you can. Use a job-scoped CST with a scope hash, and enable optional policy hash pinning so a token cannot be reused under a different WPC."
    },
    {
      "q": "Can we use Microsoft Entra ID and Microsoft Graph with this?",
      "a": "Yes, typically by aligning job identity and approvals to Entra ID and using Microsoft Graph permissions/scopes for downstream access, via official API and enterprise buildout. Keep Graph scopes narrow, and use Conditional Access and PIM for privileged operations."
    },
    {
      "q": "What is the minimum evidence package we should store per job?",
      "a": "Store the WPC hash reference, the CST context (job-scoped binding), and the proof bundle containing gateway receipts. That set is usually enough to reconstruct what was allowed and what model calls occurred."
    }
  ],
  "sources": [
    {
      "title": "Governance and security for AI agents across the organization",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization"
    },
    {
      "title": "The Agentic AI Security Scoping Matrix: A framework for ... - AWS",
      "uri": "https://aws.amazon.com/blogs/security/the-agentic-ai-security-scoping-matrix-a-framework-for-securing-autonomous-ai-systems/"
    },
    {
      "title": "Securing Agentic AI: The Agentic AI Security Scoping Matrix",
      "uri": "https://aws.amazon.com/ai/security/agentic-ai-scoping-matrix/"
    },
    {
      "title": "AI agent security: How to protect digital sidekicks (and your business)",
      "uri": "https://cloud.google.com/transform/ai-agent-security-how-to-protect-digital-sidekicks-and-your-business/"
    },
    {
      "title": "Agent Engine Threat Detection overview",
      "uri": "https://cloud.google.com/security-command-center/docs/agent-engine-threat-detection-overview"
    },
    {
      "title": "Your Complete Guide to AI Agent Testing - Salesforce",
      "uri": "https://www.salesforce.com/agentforce/ai-agents/security/"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:55:26.367Z",
  "indexable": true
}