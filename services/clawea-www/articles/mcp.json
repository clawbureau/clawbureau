{
  "slug": "mcp",
  "title": "MCP (Model Context Protocol) for Enterprise Agents | Claw EA",
  "category": "hubs",
  "html": "<h2>Direct Answer</h2>\n<p>MCP (Model Context Protocol) is a standard way to expose tools and context to an agent, but in enterprise environments MCP alone is not a security boundary. Claw EA treats MCP as a tool transport and adds permissioned execution around it using WPC (Work Policy Contract), CST (scoped token), gateway receipts, and proof bundles.</p>\n<p>OpenClaw is the baseline agent runtime: it runs the agent, loads tools, and can sandbox tool execution. Claw EA focuses on making MCP tool use verifiable and constrained by policy-as-code instead of relying on prompt-only instructions.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>This runbook assumes you already have an MCP server (vendor-hosted, self-hosted, or an internal service exposed via MCP server). The goal is to make every MCP tool call auditable and tied to an explicit policy artifact.</p>\n<ol>\n  <li>\n    <p><strong>Inventory MCP tools and classify them.</strong> List each tool, its data access, and its side effects (read-only lookup vs write vs money movement). Decide which tools must be blocked by default until reviewed.</p>\n  </li>\n  <li>\n    <p><strong>Author a WPC for the job type.</strong> Write a Work Policy Contract (WPC) that names which MCP tools are allowed, which arguments are constrained, and what data classes are permitted. Store the signed, hash-addressed WPC in the WPC registry (served by clawcontrols).</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST bound to the WPC.</strong> Use clawscope to issue a CST (scoped token) that includes a scope hash and, when you want fail-closed behavior, policy hash pinning to the WPC. This makes “correct policy, correct token” a machine check, not a prompt suggestion.</p>\n  </li>\n  <li>\n    <p><strong>Route model traffic through clawproxy for receipts.</strong> Configure the agent so model calls are routed through clawproxy, which emits gateway receipts for model calls. If you use OpenRouter via fal, keep it routed through clawproxy so you still get receipts.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent with OpenClaw tool policy and sandboxing.</strong> Use OpenClaw tool allow/deny lists and sandbox configuration to reduce local blast radius. Treat MCP tools as “external capabilities” and still keep local exec and file tools tightly gated.</p>\n  </li>\n  <li>\n    <p><strong>Collect the proof bundle and publish what you need.</strong> After each run, export a proof bundle that includes gateway receipts and metadata needed for verification. Optionally store a Trust Pulse artifact for reviewers and auditors to view.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>MCP introduces a clean interface for tools, but the main enterprise risk is not the protocol itself. The risk is unpermissioned execution: an agent can be induced to call tools with unsafe parameters, against the wrong tenant, or at the wrong time.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection into MCP tool calls</td>\n      <td>The agent is coerced into calling a sensitive MCP tool (or a safe tool with unsafe arguments) after seeing untrusted content.</td>\n      <td>Enforce allowlists and argument constraints in WPC (policy-as-code). Pair with OpenClaw tool policy so only approved tools exist at runtime.</td>\n    </tr>\n    <tr>\n      <td>Confused deputy across identities</td>\n      <td>The agent uses a high-privilege credential to serve a lower-privilege request, or crosses tenant boundaries.</td>\n      <td>Use CST scoping and optional policy hash pinning so the token is only valid for the intended job policy. Keep identity separation per agent or per job, not per prompt.</td>\n    </tr>\n    <tr>\n      <td>Tool substitution or server swap</td>\n      <td>An operator or attacker points the agent at a different MCP server that implements the same tool names but different behavior.</td>\n      <td>Bind runs to a specific WPC and record the tool endpoint metadata inside the proof bundle. Make “approved server list” part of policy review (can be implemented via MCP server governance).</td>\n    </tr>\n    <tr>\n      <td>Undetected model-side changes</td>\n      <td>A model call produces unexpected tool selection or parameterization, and you cannot reconstruct why it happened.</td>\n      <td>Gateway receipts from clawproxy provide signed evidence of model calls. Proof bundles package receipts with run metadata for later verification.</td>\n    </tr>\n    <tr>\n      <td>Local host compromise via tool execution</td>\n      <td>If the agent can execute shell or modify files, a single bad action can change the host or exfiltrate secrets.</td>\n      <td>Use OpenClaw sandboxing to move tool execution into Docker where appropriate, and avoid elevated tool modes except when explicitly required.</td>\n    </tr>\n    <tr>\n      <td>Replay of prior approvals or tokens</td>\n      <td>A previously valid token is reused to run an unapproved job, or the same “approved action” is executed twice.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) reduces replay risk by tying authorization to a job context. Preserve proof bundles so replay investigations have concrete evidence.</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Why policy-as-code and not prompt-only: a prompt can ask the model to “only use Tool A,” but the model can still be induced to ignore that instruction. A WPC is a signed artifact that the execution layer can verify and enforce, even when the model is wrong or manipulated.</p>\n\n<p>If your MCP tools touch Microsoft systems, treat the identity plane as part of the threat model. Use Entra ID app registrations and explicit Microsoft Graph permissions/scopes, and consider Conditional Access and PIM for administrative paths; enforcement happens in Microsoft and your MCP server, not in the prompt.</p>\n\n<h2>Policy-as-code example</h2>\n<p>This is a simplified, JSON-like sketch of what teams typically capture in a WPC for MCP tool use. The key is that the WPC is signed and hash-addressed, and the run can be pinned to its policy hash.</p>\n\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"mcp-enterprise-agent-baseline\",\n  \"allowed_tools\": [\n    {\n      \"tool\": \"mcp://crm/search_accounts\",\n      \"constraints\": {\n        \"tenant\": \"contoso\",\n        \"fields_allowlist\": [\"id\", \"name\", \"status\"],\n        \"max_results\": 25\n      }\n    },\n    {\n      \"tool\": \"mcp://tickets/create\",\n      \"constraints\": {\n        \"project_allowlist\": [\"IT-HELPDESK\"],\n        \"priority_allowlist\": [\"low\", \"medium\"],\n        \"no_secrets_in_description\": true\n      }\n    }\n  ],\n  \"deny_tools\": [\n    \"mcp://payments/*\",\n    \"mcp://admin/*\"\n  ],\n  \"model_routing\": {\n    \"require_clawproxy_receipts\": true\n  },\n  \"token_requirements\": {\n    \"require_cst_scope_hash\": true,\n    \"policy_hash_pinning\": \"optional\"\n  }\n}\n</pre>\n\n<p>Operationally, you use this WPC to drive two checks: can the tool be called at all, and do the arguments match constraints. When policy hash pinning is enabled, a CST that is not tied to this WPC will fail closed.</p>\n\n<h2>What proof do you get?</h2>\n<p>Claw EA produces evidence you can hand to security and compliance without asking them to “trust the prompt.” You get gateway receipts (signed receipts emitted by clawproxy for model calls) and a proof bundle (a harness artifact bundling receipts and related metadata for audit/verification).</p>\n<p>In practice, that means you can answer: which model was called, when, with what request metadata, and which run that call belonged to. For workflows that need a reviewer-friendly artifact, you can store a Trust Pulse so auditors can view the run evidence in a consistent place.</p>\n\n<ul>\n  <li>\n    <p><strong>Gateway receipts:</strong> signed evidence of model calls routed through clawproxy.</p>\n  </li>\n  <li>\n    <p><strong>Proof bundle:</strong> package of receipts plus run metadata (policy references, token binding context, and other verification inputs).</p>\n  </li>\n  <li>\n    <p><strong>WPC references:</strong> a hash-addressed pointer to the exact Work Policy Contract used for the run, fetched and verified from the WPC registry.</p>\n  </li>\n  <li>\n    <p><strong>CST binding signals:</strong> scope hash and optional policy hash pinning details, so you can show the run was authorized under a specific policy context.</p>\n  </li>\n</ul>\n\n<h2>Rollback posture</h2>\n<p>MCP adoption often starts with “add tools quickly,” but enterprise rollback needs to be mechanical. You want a small number of levers that can disable capabilities without editing prompts or redeploying every agent.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop a risky MCP tool across all agents</td>\n      <td>Update the WPC to deny the tool and require policy hash pinning for new CST issuance.</td>\n      <td>WPC hash change plus proof bundles showing which runs used which policy hash.</td>\n    </tr>\n    <tr>\n      <td>Reduce scope for a job type</td>\n      <td>Issue new CSTs with narrower scope hash; rotate short TTL CSTs and stop minting old scopes.</td>\n      <td>CST issuance and revocation records, and proof bundles tied to the new CST scope hash.</td>\n    </tr>\n    <tr>\n      <td>Cut off unreceipted model calls</td>\n      <td>Enforce “require clawproxy receipts” at the routing layer; runs without gateway receipts fail compliance review.</td>\n      <td>Presence or absence of gateway receipts in the proof bundle.</td>\n    </tr>\n    <tr>\n      <td>Contain host impact</td>\n      <td>Switch OpenClaw sessions to sandboxed execution and tighten tool allowlists; avoid elevated tools.</td>\n      <td>OpenClaw configuration diffs plus audit output from the OpenClaw security audit process.</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Some rollback levers are environment-specific, like network egress allowlists outside clawproxy. Those controls are optional and can be implemented, but you should not rely on them as your only containment.</p>\n\n<h2>FAQ</h2>\n\n<h3>What is MCP and what does it change for enterprise agents?</h3>\n<p>MCP standardizes how an agent discovers and calls tools exposed by an MCP server. For enterprises, the change is that tool surface area expands quickly, so you need policy and evidence around tool calls, not just a client SDK.</p>\n\n<h3>Why is prompt-only governance insufficient for MCP tool security?</h3>\n<p>Prompts are advisory and can be overridden by injection, tool descriptions, or model behavior. Policy-as-code via a signed WPC lets the execution layer enforce allowlists and constraints even when the model is wrong.</p>\n\n<h3>How do WPC and CST work together during an MCP-driven run?</h3>\n<p>The WPC defines what is permitted, and the CST carries the scoped authorization to execute under that policy context. With optional policy hash pinning, the CST becomes invalid if it is not tied to the intended WPC hash.</p>\n\n<h3>What can auditors verify from gateway receipts and proof bundles?</h3>\n<p>They can verify that model calls were routed through clawproxy and were receipted, and that those receipts are bundled with run metadata. They can also verify which WPC hash and CST binding context applied to the run.</p>\n\n<h3>Do you support Microsoft MCP scenarios?</h3>\n<p>Yes, but enforcement depends on the identity plane and the MCP server implementation. Use Entra ID identities and Microsoft Graph permissions/scopes as the underlying authorization, then wrap agent execution with WPC, CST, gateway receipts, and proof bundles for governance and audit.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://modelcontextprotocol.io/docs/tutorials/security/security_best_practices\">Security Best Practices - Model Context Protocol</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/agent-framework/user-guide/model-context-protocol/\">Model Context Protocol | Microsoft Learn</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n</ul>",
  "description": "MCP (Model Context Protocol) is a standard way to expose tools and context to an agent, but in enterprise environments MCP alone is not a security boundary. Claw EA treats MCP as a tool transport and adds permissioned ex",
  "faqs": [
    {
      "q": "What is MCP and what does it change for enterprise agents?",
      "a": "MCP standardizes how an agent discovers and calls tools exposed by an MCP server. For enterprises, the change is that tool surface area expands quickly, so you need policy and evidence around tool calls, not just a client SDK."
    },
    {
      "q": "Why is prompt-only governance insufficient for MCP tool security?",
      "a": "Prompts are advisory and can be overridden by injection, tool descriptions, or model behavior. Policy-as-code via a signed WPC lets the execution layer enforce allowlists and constraints even when the model is wrong."
    },
    {
      "q": "How do WPC and CST work together during an MCP-driven run?",
      "a": "The WPC defines what is permitted, and the CST carries the scoped authorization to execute under that policy context. With optional policy hash pinning, the CST becomes invalid if it is not tied to the intended WPC hash."
    },
    {
      "q": "What can auditors verify from gateway receipts and proof bundles?",
      "a": "They can verify that model calls were routed through clawproxy and were receipted, and that those receipts are bundled with run metadata. They can also verify which WPC hash and CST binding context applied to the run."
    },
    {
      "q": "Do you support Microsoft MCP scenarios?",
      "a": "Yes, but enforcement depends on the identity plane and the MCP server implementation. Use Entra ID identities and Microsoft Graph permissions/scopes as the underlying authorization, then wrap agent execution with WPC, CST, gateway receipts, and proof bundles for governance and audit."
    }
  ],
  "sources": [
    {
      "title": "Security Best Practices - Model Context Protocol",
      "uri": "https://modelcontextprotocol.io/docs/tutorials/security/security_best_practices"
    },
    {
      "title": "Model Context Protocol",
      "uri": "https://learn.microsoft.com/en-us/agent-framework/user-guide/model-context-protocol/"
    },
    {
      "title": "Build and register a Model Context Protocol (MCP) server",
      "uri": "https://learn.microsoft.com/en-us/azure/ai-foundry/mcp/build-your-own-mcp-server?view=foundry"
    },
    {
      "title": "Connect Once, Integrate Anywhere with MCP",
      "uri": "https://developer.microsoft.com/blog/connect-once-integrate-anywhere-with-mcps"
    },
    {
      "title": "Model Context Protocol: What Is MCP for Generative AI? - Salesforce",
      "uri": "https://www.salesforce.com/agentforce/mcp-support/model-context-protocol/"
    },
    {
      "title": "Build Agents using Model Context Protocol on Azure",
      "uri": "https://learn.microsoft.com/en-us/azure/developer/ai/intro-agents-mcp"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:59:20.573Z",
  "indexable": true
}