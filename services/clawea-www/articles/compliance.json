{
  "slug": "compliance",
  "title": "Compliance for Permissioned Agents | Claw EA",
  "category": "hubs",
  "html": "<p>Enterprise compliance for AI agents fails when “policy” lives only in prompts. Claw EA makes execution permissioned by enforcing policy-as-code for what tools can run, under which identities, and with verifiable evidence from each run.</p>\n<p>OpenClaw is the baseline agent runtime, and Claw Bureau primitives (WPC, CST, gateway receipts, proof bundle) give you enforceable constraints plus audit-grade artifacts that can be reviewed after the fact.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define what the agent is allowed to do as a Work Policy Contract (WPC). Keep it narrow: specific tools, specific data classes, and explicit escalation paths for anything risky.</p>\n    <p>Store the signed WPC in the WPC registry so it is hash-addressed and fetchable for verification.</p>\n  </li>\n  <li>\n    <p>Issue a CST (scoped token) for the job from clawscope. Bind it to the job scope, and optionally pin the policy hash so the token is only valid under the intended WPC.</p>\n    <p>This prevents “same token, different task” drift when agents get reused across workflows.</p>\n  </li>\n  <li>\n    <p>Route model traffic through clawproxy. This produces gateway receipts for each model call so you can later prove what was sent and what came back, under which CST and policy context.</p>\n    <p>If you use OpenRouter via fal, route it through clawproxy so the receipts are emitted consistently.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw with tool policy and sandboxing turned on for the right sessions. Use OpenClaw’s tool allow/deny controls to keep local execution tight, and use sandboxing to reduce the impact of mistakes.</p>\n    <p>Do not rely on “the prompt says don’t do X” when X is a tool call or filesystem access.</p>\n  </li>\n  <li>\n    <p>Collect a proof bundle after the job completes. The proof bundle bundles gateway receipts and run metadata into one harness artifact suitable for audit and verification.</p>\n    <p>Store the proof bundle and, when you need a human-friendly view, publish the relevant artifact into Trust Pulse for audit viewing.</p>\n  </li>\n  <li>\n    <p>Map the controls to your compliance target and evidence expectations. For SOC 2 Type II, focus on access control, change management of WPCs, and evidencing execution via receipts and proof bundles.</p>\n    <p>For HIPAA and GDPR, focus on data minimization, redaction posture, and provable boundaries around where PHI or personal data can flow.</p>\n  </li>\n</ol>\n<p><strong>How to get started checklist:</strong> pick one agent workflow, write one WPC, enforce it via CST pinning, route model calls through clawproxy, and require a proof bundle as the only acceptable completion artifact for production runs.</p>\n\n<h2>Threat model</h2>\n<p>Compliance issues show up as concrete failure modes: a prompt-injected tool call, an agent using the wrong identity, or an unreviewable action path. Permissioned execution shifts the control point from “what the model claims” to “what the runtime allows.”</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection triggers an unintended tool</td>\n      <td>The agent follows adversarial instructions and calls a high-impact tool (shell, file write, data export).</td>\n      <td>WPC defines tool allowlist; OpenClaw tool policy and sandboxing constrain local execution; CST scope hash ensures the job cannot “grow” permissions mid-run.</td>\n    </tr>\n    <tr>\n      <td>Policy drift across environments</td>\n      <td>Dev policy differs from prod, but prompts and behaviors look similar, so mistakes ship.</td>\n      <td>Use a hash-addressed WPC and optionally pin the policy hash in the CST so runs can be rejected if the wrong policy is loaded.</td>\n    </tr>\n    <tr>\n      <td>Model call disputes (who said what?)</td>\n      <td>You cannot prove the prompts, tool arguments, or outputs that led to an action.</td>\n      <td>Route calls through clawproxy to emit gateway receipts, then package them into a proof bundle for audits and incident response.</td>\n    </tr>\n    <tr>\n      <td>Token replay across jobs</td>\n      <td>A token issued for one workflow gets reused to run a different workflow.</td>\n      <td>Marketplace anti-replay binding with job-scoped CST binding reduces cross-job reuse risk, and policy hash pinning tightens it further.</td>\n    </tr>\n    <tr>\n      <td>Excessive autonomy and unclear boundaries</td>\n      <td>The agent expands actions beyond the intended purpose, especially under vague prompts.</td>\n      <td>Least privilege in WPC and CST scope design; separate “read-only” and “write” workflows into different policies and tokens.</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><strong>Compliance mapping, operationally:</strong> SOC 2 Type II is mostly about repeatable controls and evidence, HIPAA is about protecting PHI and restricting disclosures, and GDPR is about lawful processing plus minimization and accountability. Claw EA focuses on controlling and proving execution, not just documenting intent.</p>\n<p><strong>Common subtopics this hub covers:</strong> SOC 2 Type II (control effectiveness evidence), HIPAA (PHI boundaries), GDPR (data minimization and accountability), FedRAMP (evidence discipline and boundary definition), ISO 27001 (risk treatment and operational control), vendor risk reviews (repeatable questionnaires plus proof), incident response (reconstructing actions), and change control (WPC lifecycle).</p>\n\n<h2>Policy-as-code example</h2>\n<p>Prompt text is not enforceable. A WPC is policy-as-code that the execution layer can fetch and verify, and the CST can optionally pin by hash so the agent cannot silently switch policies.</p>\n\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"policy_hash\": \"b64u:...\",\n  \"job\": {\n    \"purpose\": \"support_ticket_triage\",\n    \"data_classification\": [\"internal\", \"pii_limited\"]\n  },\n  \"tools\": {\n    \"allow\": [\n      {\"name\": \"ticket.read\", \"constraints\": {\"project\": \"SUPPORT\"}},\n      {\"name\": \"ticket.comment\", \"constraints\": {\"max_chars\": 1200}},\n      {\"name\": \"kb.search\", \"constraints\": {\"sources\": [\"approved_kb\"]}}\n    ],\n    \"deny\": [\n      {\"name\": \"shell.exec\"},\n      {\"name\": \"file.write\"},\n      {\"name\": \"email.send\"}\n    ]\n  },\n  \"model_routing\": {\n    \"require_proxy_receipts\": true,\n    \"provider\": \"openrouter_via_fal\"\n  },\n  \"token\": {\n    \"require_cst_scope_hash\": true,\n    \"optional_pin_policy_hash\": true,\n    \"job_scoped_binding\": true\n  },\n  \"audit\": {\n    \"require_proof_bundle\": true,\n    \"publish_to_trust_pulse\": \"on_release\"\n  }\n}</pre>\n\n<p>This style forces an explicit decision: if you want email sending or file writes, you add them to policy, assign a narrower CST, and accept the audit footprint. That is the difference between permissioned execution and prompt-only control.</p>\n\n<h2>What proof do you get?</h2>\n<p>Every model call routed through clawproxy yields gateway receipts. Those receipts are designed to be machine-verifiable evidence that a specific request/response occurred under a specific CST and policy context.</p>\n<p>A proof bundle is the run artifact that packages receipts plus related metadata so audits are not a pile of logs. When you need a durable audit view, you can store and view a Trust Pulse artifact, keeping evidence review separate from the runtime.</p>\n<p>In practice, this means you can answer: which policy was in force (WPC hash), which token scope was used (CST scope hash and any pinning), what model calls happened (gateway receipts), and which run produced the output (proof bundle identifier and metadata).</p>\n\n<h2>Rollback posture</h2>\n<p>Agent rollbacks need to be fast and boring. Permissioned execution helps because the primary rollback is often “tighten policy and re-issue tokens,” not “rewrite prompts and hope.”</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Agent starts taking unexpected actions</td>\n      <td>Revoke CST issuance for the workflow, then issue a new CST with narrower scope and policy hash pinning.</td>\n      <td>CST issuance and revocation trail plus proof bundle showing the last known-good run.</td>\n    </tr>\n    <tr>\n      <td>Suspected prompt injection via an external channel</td>\n      <td>Disable the risky tools in WPC, keep read-only tools, and force sandboxed execution for non-main sessions in OpenClaw.</td>\n      <td>Updated WPC hash, and gateway receipts showing tool and model behavior before and after the change.</td>\n    </tr>\n    <tr>\n      <td>Compliance scope changes (PII allowed becomes not allowed)</td>\n      <td>Split policy into two WPCs (PII-free default, PII-approved exception) and require different CSTs per workflow.</td>\n      <td>Proof bundles for each run, with policy hashes demonstrating which rules applied.</td>\n    </tr>\n    <tr>\n      <td>Provider dispute or incident review</td>\n      <td>Quarantine outputs, freeze the proof bundle set for the incident window, and verify receipts for the relevant jobs.</td>\n      <td>Gateway receipts and proof bundles suitable for independent verification.</td>\n    </tr>\n    <tr>\n      <td>Need tighter outbound controls</td>\n      <td>Egress allowlists enforced outside clawproxy can be implemented as an environment control if required by policy.</td>\n      <td>Documented boundary and network control evidence (implementation-dependent).</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why isn’t a “do not exfiltrate data” prompt enough?</h3>\n<p>Prompts are not enforcement and are not stable under adversarial input. Compliance needs hard boundaries: tool allow/deny, scoped identity via CST, and evidence via gateway receipts and proof bundles.</p>\n\n<h3>How does this help with SOC 2 Type II evidence?</h3>\n<p>SOC 2 Type II asks whether controls are operating over time. WPCs give you a controlled, hash-addressed policy artifact, and proof bundles plus gateway receipts provide repeatable evidence that runs followed the intended execution path.</p>\n\n<h3>What changes for HIPAA workflows?</h3>\n<p>You treat PHI as a distinct data class with tighter WPC constraints and narrower CST scopes. You also design workflows so PHI handling is explicit and produces proof bundles that can be audited for disclosures and access patterns.</p>\n\n<h3>What changes for GDPR workflows?</h3>\n<p>You separate lawful processing purposes into distinct WPCs and keep default policies data-minimal. Proof bundles support accountability by showing which policy was in force and what model calls occurred for a given processing purpose.</p>\n\n<h3>Can we use Microsoft controls like Entra ID and Purview with this?</h3>\n<p>Yes, typically via official API or via an MCP server in an enterprise buildout. Use Microsoft terminology and boundaries: Entra ID identities, Microsoft Graph permissions/scopes, Conditional Access, and PIM for access governance, and use Purview guidance for managing compliance for AI interactions.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/purview/ai-agents\">Use Microsoft Purview to manage data security &amp; compliance for AI agents</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/entra/agent-id/identity-professional/security-for-ai\">Security for AI agents with Microsoft Entra Agent ID</a></li>\n  <li><a href=\"https://docs.aws.amazon.com/wellarchitected/latest/generative-ai-lens/gensec05-bp01.html\">GENSEC05-BP01 Implement least privilege access and permissions boundaries for agentic workflows</a></li>\n</ul>",
  "description": "Enterprise compliance for AI agents fails when “policy” lives only in prompts. Claw EA makes execution permissioned by enforcing policy-as-code for what tools can run, under which identities, and with verifiable evidence",
  "faqs": [
    {
      "q": "Why isn’t a “do not exfiltrate data” prompt enough?",
      "a": "Prompts are not enforcement and are not stable under adversarial input. Compliance needs hard boundaries: tool allow/deny, scoped identity via CST, and evidence via gateway receipts and proof bundles."
    },
    {
      "q": "How does this help with SOC 2 Type II evidence?",
      "a": "SOC 2 Type II asks whether controls are operating over time. WPCs give you a controlled, hash-addressed policy artifact, and proof bundles plus gateway receipts provide repeatable evidence that runs followed the intended execution path."
    },
    {
      "q": "What changes for HIPAA workflows?",
      "a": "You treat PHI as a distinct data class with tighter WPC constraints and narrower CST scopes. You also design workflows so PHI handling is explicit and produces proof bundles that can be audited for disclosures and access patterns."
    },
    {
      "q": "What changes for GDPR workflows?",
      "a": "You separate lawful processing purposes into distinct WPCs and keep default policies data-minimal. Proof bundles support accountability by showing which policy was in force and what model calls occurred for a given processing purpose."
    },
    {
      "q": "Can we use Microsoft controls like Entra ID and Purview with this?",
      "a": "Yes, typically via official API or via an MCP server in an enterprise buildout. Use Microsoft terminology and boundaries: Entra ID identities, Microsoft Graph permissions/scopes, Conditional Access, and PIM for access governance, and use Purview guidance for managing compliance for AI interactions."
    }
  ],
  "sources": [
    {
      "title": "Use Microsoft Purview to manage data security & compliance for ...",
      "uri": "https://learn.microsoft.com/en-us/purview/ai-agent-365"
    },
    {
      "title": "Use Microsoft Purview to manage data security & compliance for AI agents",
      "uri": "https://learn.microsoft.com/en-us/purview/ai-agents"
    },
    {
      "title": "GENSEC05-BP01 Implement least privilege access and permissions boundaries for agentic workflows",
      "uri": "https://docs.aws.amazon.com/wellarchitected/latest/generative-ai-lens/gensec05-bp01.html"
    },
    {
      "title": "Agent Factory Recap: Securing AI Agents in Production",
      "uri": "https://cloud.google.com/blog/topics/developers-practitioners/agent-factory-recap-securing-ai-agents-in-production"
    },
    {
      "title": "Agent IAM and the Principle of Least Privilege",
      "uri": "https://community.sap.com/t5/security-and-compliance-blog-posts/limiting-agent-autonomy-least-privilege-and-tool-access-for-agentic-ai/ba-p/14224584"
    },
    {
      "title": "Security for AI agents with Microsoft Entra Agent ID",
      "uri": "https://learn.microsoft.com/en-us/entra/agent-id/identity-professional/security-for-ai"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:54:24.859Z",
  "indexable": true
}