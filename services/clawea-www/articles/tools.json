{
  "slug": "tools",
  "title": "Enterprise Tools for Permissioned Agents | Claw EA",
  "category": "hubs",
  "html": "<p>Claw EA provides enterprise tools for running permissioned agents where execution is controlled by policy-as-code, not by prompts. OpenClaw is the baseline agent runtime, and Claw Bureau primitives add machine-verifiable authorization and audit artifacts around model calls and tool execution.</p>\n<p>Prompt-only controls fail because the model can be coerced into taking actions you did not intend, especially when tool access is broad. A permissioned execution layer ties actions to a signed Work Policy Contract (WPC), a CST (scoped token), and gateway receipts, so you can prove what was allowed and what actually happened.</p>\n<p><strong>Tools taxonomy (what this hub covers):</strong></p>\n<ul>\n  <li><strong>Work Policy Contracts (WPC):</strong> define the allowed tools, constraints, and identity bindings as a signed, hash-addressed artifact served by clawcontrols.</li>\n  <li><strong>CST (scoped token):</strong> issue job-scoped, least-privilege tokens from clawscope and pin them to a WPC hash when you need strict policy binding.</li>\n  <li><strong>Model gatewaying:</strong> route model calls through clawproxy to get gateway receipts and a consistent enforcement point for what the agent can request.</li>\n  <li><strong>Proof bundles:</strong> produce a proof bundle that packages receipts and metadata for verification and audit.</li>\n  <li><strong>Microsoft Graph:</strong> call Microsoft Graph via official API with explicit Microsoft Graph permissions/scopes, mapped to tool-level policies in your WPC.</li>\n  <li><strong>Outlook / mail actions:</strong> constrain mailbox operations (read, draft, send, delete) via Graph scopes and per-job CST, with receipts for model decisions leading to the action.</li>\n  <li><strong>Files and data access:</strong> restrict filesystem and workspace access using OpenClaw sandboxing and tool policy, then align remote calls to the WPC.</li>\n  <li><strong>Browser automation:</strong> keep browser control scoped, and prefer sandboxed browsers where possible; treat remote browser control as a high-risk tool.</li>\n  <li><strong>Approvals and change control:</strong> can be implemented as an enterprise buildout so high-impact actions require an external approval step, before a CST is issued for that step.</li>\n</ul>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Start with an OpenClaw tool inventory.</strong> List every tool the agent can call (shell, browser, HTTP, Graph client, ticketing client) and decide which ones must be disabled by default. Use OpenClaw tool policy and sandbox settings to set a small baseline blast radius before you add any enterprise permissions.</p>\n  </li>\n  <li>\n    <p><strong>Author a WPC for the job class.</strong> Put concrete constraints in the WPC: allowed tools, allowed model routing, and external APIs that are permitted (for example “Graph mail read” but not “send”). Store the WPC in the WPC registry so it can be fetched and verified consistently.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for a single job.</strong> Use clawscope to mint a CST with the minimum scope set for the run, and include a scope hash that corresponds to the allowed tool and API set. If you need strict change control, enable optional policy hash pinning so the CST is only valid with the intended WPC hash.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy.</strong> Configure the agent’s model provider path to go through clawproxy so each model call emits gateway receipts. If you use OpenRouter via fal, route that traffic through clawproxy as well so receipts are still produced.</p>\n  </li>\n  <li>\n    <p><strong>Integrate enterprise actions via official APIs.</strong> For Microsoft 365 actions, call Microsoft Graph via official API and keep Graph permissions/scopes explicit, reviewed, and minimal. Use Entra ID controls like Conditional Access and PIM for the human operators and service principals that can issue or approve agent credentials.</p>\n  </li>\n  <li>\n    <p><strong>Run, then verify the output artifacts.</strong> After the job completes, collect the proof bundle and verify it in your audit pipeline. Store the resulting artifact in Trust Pulse for later inspection and for incident response timelines.</p>\n  </li>\n</ol>\n<p><strong>Getting started checklist:</strong> pick one narrow workflow, write one WPC, issue one CST per job, force model traffic through clawproxy, and reject runs that do not produce a proof bundle. Add additional tools only after you can explain and test the failure modes for that tool.</p>\n\n<h2>Threat model</h2>\n<p>Enterprise agents fail in predictable ways: an attacker influences the prompt, the agent gains broader privileges than intended, or you cannot reconstruct who allowed what after an incident. The controls below are designed to make failures bounded and auditable, even when the model output is unreliable.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (permissioned execution)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection causes tool misuse</td>\n      <td>The model is tricked into calling a high-impact tool (send email, delete files, exfiltrate data).</td>\n      <td>WPC restricts which tools and actions exist; OpenClaw tool policy and sandboxing reduce local blast radius; CST enforces least privilege for remote calls.</td>\n    </tr>\n    <tr>\n      <td>Over-scoped credentials</td>\n      <td>A token or app registration grants broad Microsoft Graph permissions, so one compromise impacts many mailboxes.</td>\n      <td>CST is job-scoped and can be pinned to a WPC hash; keep Graph permissions/scopes minimal and separate read from send; use Entra ID governance (Conditional Access, PIM) around who can provision credentials.</td>\n    </tr>\n    <tr>\n      <td>Replay of a prior authorization</td>\n      <td>An old token or request is replayed to repeat an action after the job is over.</td>\n      <td>Marketplace anti-replay binding ties authorization to a specific job-scoped CST binding, reducing re-use outside the intended run window.</td>\n    </tr>\n    <tr>\n      <td>Disputed “who did what” after an incident</td>\n      <td>You have logs, but they are incomplete or easy to forge, so audit and forensics stall.</td>\n      <td>Gateway receipts from clawproxy capture model call metadata; proof bundles package receipts plus related metadata for verification and audit; Trust Pulse stores the artifact for later review.</td>\n    </tr>\n    <tr>\n      <td>Sandbox escape or host-impact tool usage</td>\n      <td>A tool runs on the host or mounts sensitive paths, turning a bad decision into host compromise.</td>\n      <td>Use OpenClaw sandboxing modes and keep “elevated” execution tightly gated; treat bind mounts and host browser control as explicit exceptions that must be justified in policy.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the kind of concrete, reviewable constraints you want in a WPC. The point is not the syntax, but that policy is a signed artifact with a stable hash, not a paragraph in a prompt.</p>\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"mail-triage-outlook-readonly\",\n  \"allowed_models\": [\n    { \"provider\": \"openrouter_via_fal\", \"route\": \"through_clawproxy\" }\n  ],\n  \"tools\": {\n    \"openclaw\": {\n      \"sandbox_mode\": \"all\",\n      \"tool_allowlist\": [\"http\", \"graph_mail_read\", \"graph_calendar_read\", \"summarize\"]\n    },\n    \"deny\": [\"shell\", \"filesystem_write\", \"graph_mail_send\", \"graph_mail_delete\"]\n  },\n  \"external_access\": {\n    \"microsoft_graph\": {\n      \"via\": \"official_api\",\n      \"permissions_scopes\": [\n        \"Mail.Read\",\n        \"Calendars.Read\"\n      ],\n      \"tenant_boundary\": \"single-tenant\"\n    }\n  },\n  \"token_requirements\": {\n    \"require_cst\": true,\n    \"cst_scope_hash\": \"sha256:...expected...\",\n    \"optional_policy_hash_pinning\": true\n  },\n  \"audit\": {\n    \"require_gateway_receipts\": true,\n    \"require_proof_bundle\": true,\n    \"store_to_trust_pulse\": true\n  }\n}</pre>\n<p>If you need approvals for “send mail” or “create user,” that is typically done as an enterprise buildout where the approval system issues a new CST for the approved step. Keep the WPC split into stages so a read-only agent cannot silently transition into a write-capable agent.</p>\n\n<h2>What proof do you get?</h2>\n<p>For each model call routed through clawproxy, you get gateway receipts that can be checked later to confirm the call happened under the expected controls. Those receipts become part of a proof bundle, which is the unit you hand to audit and incident response when you need to reconstruct decisions and authorization.</p>\n<p>Operationally, the proof bundle ties together the WPC hash (what was allowed), the CST scope hash (what was authorized for this job), and the gateway receipts (what the model calls looked like at the gateway). When you store the artifact in Trust Pulse, you have a consistent place to review runs without depending on ad hoc log retention.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback for agents should be a planned playbook, not a debate during an incident. The goal is to quickly stop unsafe action, narrow permissions, and preserve evidence without destroying the audit trail.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to check</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Suspected token compromise</td>\n      <td>Revoke the CST and re-issue a new CST with a narrower scope hash; shorten TTL for the job class.</td>\n      <td>Proof bundle for the last known-good run; confirm CST scope hash and job binding match expectations.</td>\n    </tr>\n    <tr>\n      <td>Tool is being abused (ex: mail send)</td>\n      <td>Update the WPC to remove the tool or switch to read-only stage; require a new WPC hash for any further runs.</td>\n      <td>Gateway receipts showing tool-triggering prompts and model outputs leading to the action.</td>\n    </tr>\n    <tr>\n      <td>Model routing drift or provider confusion</td>\n      <td>Force model traffic through clawproxy only and reject runs without receipts; pin to approved routes (for example OpenRouter via fal through clawproxy).</td>\n      <td>Receipts indicating the routed provider path and the presence of required receipt fields.</td>\n    </tr>\n    <tr>\n      <td>Local execution risk increases</td>\n      <td>Switch OpenClaw sandboxing to a stricter mode and reduce workspace access; remove elevated execution paths.</td>\n      <td>OpenClaw security audit output plus proof bundles from runs before and after the change.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are often requested as additional guardrails. Those are optional or planned items and should be treated as separate implementation workstreams.</p>\n\n<h2>FAQ</h2>\n<h3>Why is prompt-only “do not send email” not sufficient?</h3>\n<p>Because the model does not enforce anything, it only generates text and tool calls. Permissioned execution enforces the boundary in code, using a WPC and a CST, so the action is rejected even if the model tries.</p>\n\n<h3>How do WPC and CST work together in practice?</h3>\n<p>The WPC defines the allowed surface area as a signed artifact with a stable hash. The CST is issued per job with a scope hash and can optionally be pinned to the WPC hash, so policy changes do not silently apply to a running job.</p>\n\n<h3>What do gateway receipts cover?</h3>\n<p>Gateway receipts are signed receipts emitted by clawproxy for model calls. They help you verify that model traffic went through the expected gateway and can be packaged into a proof bundle for audit.</p>\n\n<h3>Can Claw EA enforce Microsoft Graph scopes automatically?</h3>\n<p>Claw EA can constrain what the agent is allowed to attempt by policy and by only issuing CST for approved Graph actions. Actual Graph authorization is still governed by Entra ID and the app’s configured Microsoft Graph permissions/scopes, which you should manage with standard enterprise controls like Conditional Access and PIM.</p>\n\n<h3>What is the minimum setup to be meaningfully safer?</h3>\n<p>Run OpenClaw with sandboxing enabled for tool execution, put a WPC in place for one workflow, and require a per-job CST. Route model calls through clawproxy so every run yields gateway receipts and a proof bundle.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/entra/agent-id/identity-professional/security-for-ai\">Security for AI agents with Microsoft Entra Agent ID</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/build-secure-process\">Process to build agents across your organization (Cloud Adoption Framework)</a></li>\n</ul>",
  "description": "Claw EA provides enterprise tools for running permissioned agents where execution is controlled by policy-as-code, not by prompts. OpenClaw is the baseline agent runtime, and Claw Bureau primitives add machine-verifiable",
  "faqs": [
    {
      "q": "Why is prompt-only “do not send email” not sufficient?",
      "a": "Because the model does not enforce anything, it only generates text and tool calls. Permissioned execution enforces the boundary in code, using a WPC and a CST, so the action is rejected even if the model tries."
    },
    {
      "q": "How do WPC and CST work together in practice?",
      "a": "The WPC defines the allowed surface area as a signed artifact with a stable hash. The CST is issued per job with a scope hash and can optionally be pinned to the WPC hash, so policy changes do not silently apply to a running job."
    },
    {
      "q": "What do gateway receipts cover?",
      "a": "Gateway receipts are signed receipts emitted by clawproxy for model calls. They help you verify that model traffic went through the expected gateway and can be packaged into a proof bundle for audit."
    },
    {
      "q": "Can Claw EA enforce Microsoft Graph scopes automatically?",
      "a": "Claw EA can constrain what the agent is allowed to attempt by policy and by only issuing CST for approved Graph actions. Actual Graph authorization is still governed by Entra ID and the app’s configured Microsoft Graph permissions/scopes, which you should manage with standard enterprise controls like Conditional Access and PIM."
    },
    {
      "q": "What is the minimum setup to be meaningfully safer?",
      "a": "Run OpenClaw with sandboxing enabled for tool execution, put a WPC in place for one workflow, and require a per-job CST. Route model calls through clawproxy so every run yields gateway receipts and a proof bundle."
    }
  ],
  "sources": [
    {
      "title": "Security for AI agents with Microsoft Entra Agent ID",
      "uri": "https://learn.microsoft.com/en-us/entra/agent-id/identity-professional/security-for-ai"
    },
    {
      "title": "Process to build agents across your organization - Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/build-secure-process"
    },
    {
      "title": "AI agents in enterprises: Best practices with Amazon Bedrock ...",
      "uri": "https://aws.amazon.com/blogs/machine-learning/ai-agents-in-enterprises-best-practices-with-amazon-bedrock-agentcore/"
    },
    {
      "title": "The Agentic AI Security Scoping Matrix: A framework for ... - AWS",
      "uri": "https://aws.amazon.com/blogs/security/the-agentic-ai-security-scoping-matrix-a-framework-for-securing-autonomous-ai-systems/"
    },
    {
      "title": "AI agent security: How to protect digital sidekicks (and your business)",
      "uri": "https://cloud.google.com/transform/ai-agent-security-how-to-protect-digital-sidekicks-and-your-business/"
    },
    {
      "title": "Agent IAM and the Principle of Least Privilege",
      "uri": "https://community.sap.com/t5/security-and-compliance-blog-posts/limiting-agent-autonomy-least-privilege-and-tool-access-for-agentic-ai/ba-p/14224584"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:03:33.743Z",
  "indexable": true
}