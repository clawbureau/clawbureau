{
  "slug": "audit/tamper-evident-logs",
  "title": "Tamper-evident Audit Logs for Agents | Claw EA",
  "category": "audit",
  "html": "<p>Tamper-evident audit logs for agents require more than saving chat transcripts. You need a permissioned execution layer that binds “what was allowed” (policy) to “what actually happened” (tool and model calls), then produces verifiable evidence you can retain and replay for audits.</p>\n<p>Claw EA runs OpenClaw as the baseline agent runtime, then adds Work Policy Contracts (WPC), CST, gateway receipts, and proof bundles so you can prove an agent run followed a specific policy, using artifacts that are signed, hashed, and verifiable later.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define what must be auditable for your agents: model calls, tool invocations, tool outputs, policy decisions, and operator approvals. Decide what must be retained in raw form versus redacted form, and for how long.</p>\n    <p>Write this down as an evidence checklist that security and internal audit both sign off on.</p>\n  </li>\n  <li>\n    <p>Publish a WPC in the WPC registry and treat its policy hash as the stable identifier for “allowed behavior.” The WPC is signed and hash-addressed, so audit reviewers can fetch the exact policy later and confirm it has not changed.</p>\n    <p>This is the key difference versus prompt-only controls: prompts are not a permission boundary, and they are easy to edit without leaving a reliable compliance trail.</p>\n  </li>\n  <li>\n    <p>Issue a CST from clawscope for each job run, scoped to the minimum capabilities needed. Enable optional policy hash pinning so the CST is bound to the exact WPC hash expected for that run.</p>\n    <p>This prevents “policy drift” where the agent runs under a different policy than the one the ticket or approval referenced.</p>\n  </li>\n  <li>\n    <p>Route model traffic through clawproxy so each model call emits gateway receipts. Store gateway receipts alongside run metadata, including job identifiers and the CST scope hash.</p>\n    <p>For OpenRouter via fal, keep the same pattern: model requests still go through clawproxy so the evidence format stays consistent.</p>\n  </li>\n  <li>\n    <p>Bundle evidence into a proof bundle at the end of the run. Retain the proof bundle in your evidence store and optionally publish a Trust Pulse for easy viewing and third-party audit workflows.</p>\n    <p>Keep an internal pointer from your ticketing system to the proof bundle hash, not to a mutable URL.</p>\n  </li>\n  <li>\n    <p>Verify before you ship: re-verify a sample of proof bundles as part of CI or release gates for agent changes. Treat verification failures as a production incident, because “no proof” usually means “no audit.”</p>\n    <p>Also run OpenClaw’s local security audit periodically to reduce common gateway configuration footguns that undermine your overall posture.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Tamper-evident logs are designed for environments where you assume failures, mistakes, and incentives to edit history. The table below lists common failure modes and the specific control you should expect to hold.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control you rely on</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt-only “policy” is bypassed</td>\n      <td>An injected instruction convinces the model to call risky tools or exfiltrate data, and the prompt transcript is later “cleaned up.”</td>\n      <td>Permissioned execution via WPC plus tool policy and sandboxing in OpenClaw. Evidence is anchored by signed WPC and run-bound receipts, not by editable chat text.</td>\n    </tr>\n    <tr>\n      <td>Evidence replay or substitution</td>\n      <td>A proof artifact from one run is reused to “prove” a different run, or receipts are mixed across jobs.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding, plus consistent job identifiers inside the proof bundle metadata.</td>\n    </tr>\n    <tr>\n      <td>Selective deletion of bad events</td>\n      <td>Someone removes the one model call or tool step that looks suspicious, leaving the rest of the log intact.</td>\n      <td>Proof bundle integrity checks over receipt sets and metadata, so missing or altered components fail verification.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable “screenshots of logs”</td>\n      <td>An auditor receives exports with no cryptographic binding to the original system and no stable identifiers.</td>\n      <td>Gateway receipts are signed, and WPC is hash-addressed and fetchable for verification. Auditors can re-check signatures and hashes independently.</td>\n    </tr>\n    <tr>\n      <td>Overbroad execution surface</td>\n      <td>A single configuration mistake exposes the gateway, a browser control port, or elevated host execution to untrusted users.</td>\n      <td>OpenClaw’s security audit and strict tool profiles reduce the chance of “open rooms plus dangerous tools.” Treat these checks as required operational hygiene, not optional.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a JSON-like sketch of what teams typically pin for auditability: the WPC identity, the CST constraints, and retention rules. The important part is that the run is permissioned by artifacts that can be fetched and verified later, not by whatever prompt text happened to be used that day.</p>\n<pre><code>{\n  \"job\": {\n    \"job_id\": \"job_2026_02_11_00123\",\n    \"agent_runtime\": \"OpenClaw\",\n    \"wpc\": {\n      \"policy_hash_b64u\": \"wpc_hash_here\",\n      \"required\": true\n    }\n  },\n  \"auth\": {\n    \"cst\": {\n      \"issuer\": \"clawscope\",\n      \"scope_hash\": \"scope_hash_here\",\n      \"pin_policy_hash\": \"wpc_hash_here\",\n      \"ttl_seconds\": 3600\n    }\n  },\n  \"model_calls\": {\n    \"route_via\": \"clawproxy\",\n    \"require_gateway_receipts\": true\n  },\n  \"evidence\": {\n    \"proof_bundle\": {\n      \"include\": [\"gateway_receipts\", \"job_metadata\", \"policy_reference\"],\n      \"store_immutable\": true\n    },\n    \"retention\": {\n      \"raw_days\": 30,\n      \"redacted_days\": 365,\n      \"legal_hold\": \"manual\"\n    }\n  }\n}</code></pre>\n<p>If you need egress allowlists outside clawproxy, automatic cost budget enforcement, or transparency log inclusion proofs, those are optional or planned items and should be treated as separate implementation workstreams.</p>\n\n<h2>What proof do you get?</h2>\n<p>In Claw EA, the minimum tamper-evident evidence set is: the signed WPC reference, the CST scope hash (and optional policy hash pinning), gateway receipts for each model call, and a proof bundle that packages the run context. The goal is to answer “what was allowed?” and “what happened?” with artifacts that can be checked later without trusting the operator who exports them.</p>\n<p>What is signed: gateway receipts are signed by clawproxy, and the WPC is a signed artifact served by clawcontrols. What is hashed: the WPC is hash-addressed, CST includes a scope hash, and the proof bundle includes stable identifiers so you can detect missing or swapped components.</p>\n<p>What is replayable: auditors can replay verification, meaning they can re-check signatures and policy hashes and confirm receipts belong to the job context. This is not “replaying the agent,” it is replaying the evidence validation steps so a reviewer can reach the same conclusion independently.</p>\n<p>A compact “shape” of the evidence often looks like this:</p>\n<pre><code>{\n  \"proof_bundle_id\": \"pb_...\",\n  \"job_id\": \"job_...\",\n  \"wpc_policy_hash_b64u\": \"wpc_...\",\n  \"cst_scope_hash\": \"scope_...\",\n  \"receipts\": [\n    {\n      \"receipt_id\": \"r_...\",\n      \"provider\": \"openrouter_via_fal\",\n      \"model\": \"model_name\",\n      \"request_hash\": \"h_req_...\",\n      \"response_hash\": \"h_res_...\",\n      \"signature\": \"sig_...\"\n    }\n  ],\n  \"timestamps\": {\n    \"started_at\": \"2026-02-11T10:00:00Z\",\n    \"ended_at\": \"2026-02-11T10:07:12Z\"\n  }\n}</code></pre>\n<p>Common pitfalls: logging only the final assistant message, storing mutable “latest policy” instead of pinning a policy hash, and letting teams bypass the proxy path for “just one quick test.” Those shortcuts tend to surface during incident response, when you discover the evidence gaps are exactly where you needed proof.</p>\n\n<h2>Rollback posture</h2>\n<p>Tamper-evident audit logs are most useful when they support safe rollback after a bad run. Rollback should be operationally boring: revoke credentials, stop new work, and preserve evidence without depending on anyone’s memory of what happened.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence you should keep</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Agent started calling an unexpected model or route</td>\n      <td>Require routing via clawproxy for model calls and block direct paths in your deployment config. Re-run verification on the last known good proof bundle and compare WPC and scope hashes.</td>\n      <td>Gateway receipts showing provider and model, plus the proof bundle for the incident window.</td>\n    </tr>\n    <tr>\n      <td>Policy changed and behavior drifted</td>\n      <td>Roll back to the previous WPC hash and re-issue CST with policy hash pinning to that hash. Treat any run without a pinned policy hash as lower confidence during review.</td>\n      <td>WPC hashes for each release, CST scope hashes per job, and proof bundles before and after the change.</td>\n    </tr>\n    <tr>\n      <td>Suspected credential misuse during a run</td>\n      <td>Revoke CST issuance paths for the affected job pattern, rotate downstream secrets out of band, and keep the evidence immutable. Confirm the receipts and job binding to rule out cross-job substitution.</td>\n      <td>Proof bundle, gateway receipts, and the run’s job-scoped CST binding context.</td>\n    </tr>\n    <tr>\n      <td>Need to satisfy retention and audit export requirements</td>\n      <td>Store proof bundles in an immutable evidence store, and use Trust Pulse for audit viewing when appropriate. Keep redaction rules explicit and versioned so reviewers know what was removed and why.</td>\n      <td>Proof bundle identifiers, retention policy versions, and any redaction configuration tied to the job.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is prompt-only governance not enough?</h3>\n<p>Prompts are not a permission system, and they are easy to edit after the fact. A permissioned execution layer uses WPC and CST so the run is constrained by machine-enforced policy, and the audit trail binds that policy to actual model and tool activity.</p>\n\n<h3>What should we retain for “audit replay evidence”?</h3>\n<p>Retain WPC policy hashes, CST scope hashes, gateway receipts for model calls, and the proof bundle for each job. Add run metadata such as job id, timestamps, and the agent version so reviewers can re-check evidence without relying on mutable environment state.</p>\n\n<h3>How does tamper-evidence work if logs are stored in our systems?</h3>\n<p>Tamper-evidence comes from signatures and hashes that fail verification if altered, even if the storage system is compromised later. You still need good storage controls, but verification lets you detect edits and missing components instead of trusting exports at face value.</p>\n\n<h3>Do we get a Microsoft-style audit log feed automatically?</h3>\n<p>Not by default. If you need to align with Microsoft audit practices, you can map agent events and evidence references into your own logging pipeline via official API or enterprise buildout, and keep proof bundles as the cryptographic source of truth.</p>\n\n<h3>What is the fastest way to find configuration mistakes before incidents?</h3>\n<p>Run OpenClaw’s security audit regularly and treat failures as blockers, especially after changing network exposure, tool profiles, or sandbox settings. Pair that with “verify a proof bundle sample” in CI so you catch missing receipts or unpinned policy hashes early.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://aos.owasp.org/spec/trace/events\">Supported Events - Agent Observability Standard</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-copilot-studio/admin-logging-copilot-studio\">View audit logs for admins, makers, and users of Copilot Studio - Microsoft Copilot Studio</a></li>\n</ul>",
  "description": "Tamper-evident audit logs for agents require more than saving chat transcripts. You need a permissioned execution layer that binds “what was allowed” (policy) to “what actually happened” (tool and model calls), then prod",
  "faqs": [
    {
      "q": "Why is prompt-only governance not enough?",
      "a": "Prompts are not a permission system, and they are easy to edit after the fact. A permissioned execution layer uses WPC and CST so the run is constrained by machine-enforced policy, and the audit trail binds that policy to actual model and tool activity."
    },
    {
      "q": "What should we retain for “audit replay evidence”?",
      "a": "Retain WPC policy hashes, CST scope hashes, gateway receipts for model calls, and the proof bundle for each job. Add run metadata such as job id, timestamps, and the agent version so reviewers can re-check evidence without relying on mutable environment state."
    },
    {
      "q": "How does tamper-evidence work if logs are stored in our systems?",
      "a": "Tamper-evidence comes from signatures and hashes that fail verification if altered, even if the storage system is compromised later. You still need good storage controls, but verification lets you detect edits and missing components instead of trusting exports at face value."
    },
    {
      "q": "Do we get a Microsoft-style audit log feed automatically?",
      "a": "Not by default. If you need to align with Microsoft audit practices, you can map agent events and evidence references into your own logging pipeline via official API or enterprise buildout, and keep proof bundles as the cryptographic source of truth."
    },
    {
      "q": "What is the fastest way to find configuration mistakes before incidents?",
      "a": "Run OpenClaw’s security audit regularly and treat failures as blockers, especially after changing network exposure, tool profiles, or sandbox settings. Pair that with “verify a proof bundle sample” in CI so you catch missing receipts or unpinned policy hashes early."
    }
  ],
  "sources": [
    {
      "title": "Supported Events - Agent Observability Standard",
      "uri": "https://aos.owasp.org/spec/trace/events"
    },
    {
      "title": "how U.S. immigration enforcement uses data and AI to ... - GitHub Gist",
      "uri": "https://gist.github.com/ruvnet/da9609939270e3870de465a63352b005"
    },
    {
      "title": "View audit logs for admins, makers, and users of Copilot Studio - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/admin-logging-copilot-studio"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:26:45.280Z",
  "indexable": true
}