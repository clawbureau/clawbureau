{
  "slug": "controls/two-person-rule",
  "title": "Two-person rule for Agents | Policy-as-Code Control | Claw EA",
  "category": "controls",
  "html": "<p>A two-person rule for agents means the agent cannot complete specific high-risk actions unless a second human approves the exact action payload. In Claw EA, you implement this as permissioned execution: a Work Policy Contract (WPC) defines which actions require approval, scoped tokens (CST, from clawscope) constrain what can run, and clawproxy emits gateway receipts so you can prove what the model actually called.</p>\n<p>This is stronger than prompt-only instructions because prompts are advisory and can be overwritten by tool output, injected content, or simple model error. The execution layer must be policy-as-code so the runtime can fail closed when approvals are missing, regardless of what the model “decides.”</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the “break-glass” surface. List the exact tool calls and parameters that must require dual approval, such as “send email externally,” “transfer funds,” “create OAuth consent,” “change firewall rules,” or “export customer data.”</p>\n    <p>Keep this list parameter-aware so you can approve a specific recipient, amount, tenant, or dataset, not a vague intent.</p>\n  </li>\n  <li>\n    <p>Encode the rule in a WPC. The WPC should declare an approval policy that maps tool routes to “requires second approver,” plus which identities are eligible approvers and what evidence must be recorded.</p>\n    <p>Store the signed, hash-addressed WPC in the WPC registry (served by clawcontrols), and treat the WPC hash as the change-controlled unit.</p>\n  </li>\n  <li>\n    <p>Issue a CST with policy hash pinning. When starting a job, request a CST (issued by clawscope) whose scope hash reflects the allowed tool surface, and optionally pin the WPC hash so the job cannot silently switch policies mid-run.</p>\n    <p>Use job-scoped CST binding to reduce replay risk across jobs, especially for approval-bearing steps.</p>\n  </li>\n  <li>\n    <p>Enforce the gate at execution time in the OpenClaw runtime. OpenClaw is the baseline agent runtime: use its tool policy and sandbox boundary to keep the default tool set minimal, and route model calls through clawproxy for receipting.</p>\n    <p>For the two-person rule, wrap the sensitive tools so they first create an “approval request” object, then block until an approver supplies an approval artifact that matches the exact request hash.</p>\n  </li>\n  <li>\n    <p>Integrate the approver identity system. In Microsoft environments, the approver check typically maps to Entra ID group membership, optionally requiring PIM activation for the approver role, and Conditional Access for device and location constraints.</p>\n    <p>When the approved action is a Microsoft 365 operation, run it via official API using Microsoft Graph permissions/scopes that match the WPC and the CST scope.</p>\n  </li>\n  <li>\n    <p>Record proof and verify. For every model call, clawproxy emits gateway receipts; attach the approval artifact, WPC hash, and CST scope hash into a proof bundle.</p>\n    <p>Publish the bundle to Trust Pulse for audit viewing when you need a persistent artifact that can be reviewed later.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>The two-person rule is primarily about preventing a single compromised path from completing irreversible actions. The control must assume the model can be tricked, the operator can be rushed, and the agent can be induced to ask for broader access than intended.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (two-person rule implementation)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection through email, web pages, or tickets</td>\n      <td>The agent is steered to execute a high-risk tool call (exfiltrate data, add an external mailbox rule, or send funds) while presenting it as routine work.</td>\n      <td>WPC marks the tool route as “dual approval required” and blocks execution unless an independent approver signs an approval artifact for the exact payload hash.</td>\n    </tr>\n    <tr>\n      <td>Single-operator compromise (phished admin, stolen workstation session)</td>\n      <td>An attacker can drive the agent to run actions that look like normal operator commands.</td>\n      <td>Separation of duties: the runner CST cannot complete gated actions; it can only create approval requests. A second identity must approve, and the approval is validated against the WPC rules.</td>\n    </tr>\n    <tr>\n      <td>Tool misuse due to model error or ambiguous instruction</td>\n      <td>The model chooses the wrong recipient, wrong tenant, wrong dataset, or wrong environment, causing real impact without malice.</td>\n      <td>Parameter-aware approvals: approver signs the exact destination, scope, and bounds. Any mismatch causes a fail-closed execution denial.</td>\n    </tr>\n    <tr>\n      <td>Replay of an approval or token</td>\n      <td>A previously approved payload is re-used in a different job, or a CST is replayed to bypass fresh approval.</td>\n      <td>Marketplace anti-replay binding via job-scoped CST binding, plus approval artifacts bound to a job id and WPC hash. Proof bundles show the bindings for review.</td>\n    </tr>\n    <tr>\n      <td>Policy drift during an incident</td>\n      <td>Operators “temporarily” weaken the guardrail, and the weaker state persists.</td>\n      <td>Pin the WPC hash in the CST so the job is cryptographically tied to the reviewed policy. Rotate the WPC hash for any change, and treat it as a deployment.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a deliberately small JSON-like example showing how teams typically express a two-person rule as a WPC-backed contract. The key is that the policy describes specific tool routes, required approver identities, and what must be bound into the approval artifact.</p>\n\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"two_person_rule_enterprise_agents\",\n  \"requires\": {\n    \"approval\": {\n      \"mode\": \"two_person\",\n      \"min_approvers\": 2,\n      \"independent_of_requester\": true,\n      \"approver_identities\": {\n        \"provider\": \"entra_id\",\n        \"allowed_groups\": [\"Agent-Approvers-Prod\"],\n        \"require_pim_activation\": \"optional\"\n      },\n      \"bind\": [\"job_id\", \"wpc_hash\", \"tool_route\", \"payload_hash\", \"expires_at\"]\n    }\n  },\n  \"gated_tool_routes\": [\n    { \"route\": \"m365.graph.sendMail\", \"when\": { \"external_recipient\": true } },\n    { \"route\": \"m365.graph.addAppRoleAssignment\" },\n    { \"route\": \"payments.transfer\", \"when\": { \"amount_usd_gte\": 500 } },\n    { \"route\": \"storage.export\", \"when\": { \"dataset\": \"customer_pii\" } }\n  ],\n  \"token_requirements\": {\n    \"cst\": {\n      \"scope_hash_required\": true,\n      \"pin_wpc_hash\": true,\n      \"job_scoped_binding\": true\n    }\n  },\n  \"logging\": {\n    \"require_gateway_receipts\": true,\n    \"bundle\": \"proof_bundle\"\n  }\n}\n</pre>\n\n<p>In OpenClaw, you pair this with tool policy and sandbox defaults so the agent cannot bypass the gate by calling a more generic tool. If you must allow an “elevated” path, treat it as gated and approval-required, since it bypasses sandbox protection.</p>\n\n<h2>What proof do you get?</h2>\n<p>For every model call routed through clawproxy, you get gateway receipts that identify the model call inputs and outputs in a signed, verifiable form. These receipts are the core evidence that the model traffic you audited is the model traffic that occurred.</p>\n<p>Claw EA packages receipts plus job metadata into a proof bundle. A typical bundle includes the WPC hash used for enforcement, the CST scope hash (and optional policy hash pinning), the approval artifact hashes, and enough metadata to reconstruct whether the two-person gate was satisfied at the moment of execution.</p>\n<p>When you need a durable audit view, you can store the resulting artifact in Trust Pulse. This gives reviewers a single object to inspect without relying on ad hoc logs from the agent host.</p>\n\n<h2>Rollback posture</h2>\n<p>Two-person rule rollbacks should be designed to fail safe. Your goal is to stop high-risk actions quickly while keeping low-risk read-only workflows available for incident response.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence you should retain</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Approver channel compromised</td>\n      <td>Remove approver eligibility (Entra ID group change), and rotate to a new approver group referenced by a new WPC hash.</td>\n      <td>Proof bundles before and after the WPC change, plus the WPC hashes and gateway receipts for any attempted gated actions.</td>\n    </tr>\n    <tr>\n      <td>Runner token suspected leaked</td>\n      <td>Revoke the CST and re-issue with tighter scope hash and shorter TTL. Keep gated tools blocked until a new job-scoped CST binding is in place.</td>\n      <td>CST identifiers and revocation records, and proof bundles showing which job ids were bound to which CST scope hashes.</td>\n    </tr>\n    <tr>\n      <td>Policy too strict, business outage</td>\n      <td>Temporarily move specific routes from “two-person” to “one-person” in a new WPC, limited to a narrow allowlist and short expiry, then revert.</td>\n      <td>Both WPC versions (hashes), plus receipts proving no disallowed routes were called during the temporary window.</td>\n    </tr>\n    <tr>\n      <td>Model provider incident or unexpected tool behavior</td>\n      <td>Disable the affected tool route in OpenClaw tool policy and keep the two-person gate intact for all remaining sensitive routes.</td>\n      <td>OpenClaw configuration diff, gateway receipts that show the last successful calls, and the proof bundle boundary for the incident window.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Isn’t a prompt instruction like “always ask for approval” enough?</h3>\n<p>No. Prompt-only controls are not binding, and the agent can be induced to skip them through injection, confusion, or tool output that reframes the task.</p>\n<p>Policy-as-code makes approval a runtime precondition enforced with WPC rules and CST scoping, not a suggestion.</p>\n\n<h3>How do I keep approvals specific, not “approve anything the agent does”?</h3>\n<p>Require the approval artifact to bind the tool route and a payload hash. This forces the approver to sign the concrete recipient, amount, dataset, or permission scope.</p>\n<p>If the agent changes any parameter, the hash changes and execution fails closed.</p>\n\n<h3>Can this work with Microsoft 365 actions?</h3>\n<p>Yes, when your agent performs actions via official API using Microsoft Graph permissions/scopes that match your WPC. The two-person gate should protect permission-changing operations (like app role assignments) and external communications (like sending mail outside the domain).</p>\n<p>Use Entra ID group membership for approvers, and consider Conditional Access and PIM to reduce who can approve and under what conditions.</p>\n\n<h3>What prevents an approval from being reused later?</h3>\n<p>Bind approvals to a job id and WPC hash, and use job-scoped CST binding for the job that consumes the approval. That way, even a copied approval artifact is not valid in a different job context.</p>\n<p>Your proof bundle should make these bindings visible to auditors.</p>\n\n<h3>What do auditors actually verify?</h3>\n<p>They verify that the WPC hash in the bundle matches the reviewed policy, that the CST scope hash aligns with the intended tool surface, and that the gateway receipts show only permitted model calls. For gated actions, they also verify the approval artifact bindings and timing.</p>\n<p>This is the difference between “we think it asked for approval” and “we can prove it could not execute without approval.”</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security</a></li>\n  <li><a href=\"https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/policy.html\">Amazon Bedrock AgentCore Policy: Control Agent-to-Tool Interactions</a></li>\n</ul>",
  "description": "A two-person rule for agents means the agent cannot complete specific high-risk actions unless a second human approves the exact action payload. In Claw EA, you implement this as permissioned execution: a Work Policy Con",
  "faqs": [
    {
      "q": "Isn’t a prompt instruction like “always ask for approval” enough?",
      "a": "No. Prompt-only controls are not binding, and the agent can be induced to skip them through injection, confusion, or tool output that reframes the task."
    },
    {
      "q": "How do I keep approvals specific, not “approve anything the agent does”?",
      "a": "Require the approval artifact to bind the tool route and a payload hash. This forces the approver to sign the concrete recipient, amount, dataset, or permission scope."
    },
    {
      "q": "Can this work with Microsoft 365 actions?",
      "a": "Yes, when your agent performs actions via official API using Microsoft Graph permissions/scopes that match your WPC. The two-person gate should protect permission-changing operations (like app role assignments) and external communications (like sending mail outside the domain)."
    },
    {
      "q": "What prevents an approval from being reused later?",
      "a": "Bind approvals to a job id and WPC hash, and use job-scoped CST binding for the job that consumes the approval. That way, even a copied approval artifact is not valid in a different job context."
    },
    {
      "q": "What do auditors actually verify?",
      "a": "They verify that the WPC hash in the bundle matches the reviewed policy, that the CST scope hash aligns with the intended tool surface, and that the gateway receipts show only permitted model calls. For gated actions, they also verify the approval artifact bindings and timing."
    }
  ],
  "sources": [
    {
      "title": "Amazon Bedrock AgentCore Policy: Control Agent-to-Tool Interactions",
      "uri": "https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/policy.html"
    },
    {
      "title": "A Developer's Guide to Multi-Agent Systems with ADK - Google Cloud",
      "uri": "https://cloud.google.com/blog/topics/developers-practitioners/building-collaborative-ai-a-developers-guide-to-multi-agent-systems-with-adk"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:15:51.646Z",
  "indexable": true
}