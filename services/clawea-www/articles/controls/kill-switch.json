{
  "slug": "controls/kill-switch",
  "title": "Kill switch and emergency halt for Agents | Policy-as-Code Control | Claw EA",
  "category": "controls",
  "html": "<p>A kill switch is a policy-enforced emergency halt that stops an agent run from taking new actions, even if the agent keeps generating text. In Claw EA, the practical control is: deny tool execution and deny model egress at the execution layer, using a WPC and CST enforcement, rather than relying on a “please stop” prompt.</p>\n<p>OpenClaw is the baseline agent runtime: it already separates tool policy (what tools are callable) from sandboxing (where tools run). The kill switch works when the runtime and proxy are permissioned by policy-as-code, so a compromised prompt cannot talk its way around the control.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define what “halt” means for your agents. Most teams choose: no tool calls, no outbound model calls, and a visible “halted” status for operators.</p>\n    <p>Be explicit whether read-only tools (for example, file read) are allowed during halt. Default to deny-all tools to stop data movement during incidents.</p>\n  </li>\n  <li>\n    <p>Author a WPC that can express a global deny for tools and a proxy-side deny for model calls. Store the WPC in the WPC registry so it is signed and hash-addressed.</p>\n    <p>Use a “policy hash” you can pin to runs, so the runtime can fetch and verify the exact WPC content via clawcontrols.</p>\n  </li>\n  <li>\n    <p>Issue CSTs from clawscope with optional policy hash pinning. This makes the token unusable if the policy changes, which is helpful during incident response.</p>\n    <p>For high-risk agents, keep CST TTL short so operator actions take effect quickly without waiting on long-lived credentials.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy so you get gateway receipts for every model request. In practice, this is where you can fail closed if the WPC indicates “halt.”</p>\n    <p>OpenRouter via fal routed through clawproxy is available if you want a consistent receipting path for model egress.</p>\n  </li>\n  <li>\n    <p>Enforce tool policy inside OpenClaw so tool execution stops locally even if the agent is still “thinking.” Keep sandboxing on for non-main sessions or all sessions based on your exposure surface.</p>\n    <p>Do not rely on skills or prompts for enforcement. Skills are documentation injected into the prompt; they are not a security boundary.</p>\n  </li>\n  <li>\n    <p>Trigger the kill switch by updating which WPC a job uses (or switching the WPC to deny-all), and require that new CSTs pin to the “halt” policy hash. For in-flight jobs, revoke CSTs to force the next authorization check to fail.</p>\n    <p>When you need additional containment, you can also disable inbound chat triggers using OpenClaw channel policies (for example, lock rooms down to allowlists or require mention).</p>\n  </li>\n  <li>\n    <p>Collect evidence. Export gateway receipts and assemble a proof bundle for each impacted job run, then store the relevant artifacts in Trust Pulse for review.</p>\n    <p>Use the proof bundle as the definitive record of what model calls occurred before the halt and what was blocked after.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>The main risk is that a prompt-only “stop” instruction is not binding. If the agent is compromised by prompt injection, it can ignore instructions and keep calling tools or exfiltrating via model egress unless execution is permissioned.</p>\n<p>Kill switches should assume the model can be adversarial. The control point must be outside the model, enforced by the runtime and the proxy using WPC and CST checks.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection attempts to keep acting</td>\n      <td>The agent continues issuing tool calls or “just one more” action despite an operator halt request.</td>\n      <td>Tool calls denied by policy-as-code at the runtime boundary (OpenClaw tool policy). Model egress denied by clawproxy using WPC and CST checks.</td>\n    </tr>\n    <tr>\n      <td>Model egress used for data exfiltration</td>\n      <td>Sensitive snippets are sent out in model prompts, even if local tools are locked down.</td>\n      <td>Route model calls through clawproxy to fail closed and to emit gateway receipts for review. Use CST policy hash pinning so “halt” is enforced consistently.</td>\n    </tr>\n    <tr>\n      <td>Operator confusion during incident response</td>\n      <td>Multiple teams disagree on whether an agent was halted, when, and under which policy version.</td>\n      <td>WPC is hash-addressed and signed, so “what policy was in force” is unambiguous. Proof bundles tie together receipts and run metadata for later verification.</td>\n    </tr>\n    <tr>\n      <td>Replay or cross-job token reuse</td>\n      <td>A CST captured from one job is reused to keep making calls after a halt elsewhere.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) reduces reuse across jobs. Revoke CSTs during the incident to stop authorization checks from passing.</td>\n    </tr>\n    <tr>\n      <td>Sandbox escape or host-level blast radius</td>\n      <td>Misconfiguration allows elevated execution on the host, widening impact during a compromise.</td>\n      <td>Use OpenClaw sandboxing for tool execution and minimize “elevated” tool paths. Audit configuration regularly and treat elevated execution as an exception.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the shape of a kill switch policy as code. The WPC is the signed, hash-addressed artifact; the important part is that enforcement happens outside the prompt, and the CST can pin to the WPC hash.</p>\n<pre>\n{\n  \"wpc\": {\n    \"name\": \"emergency-halt\",\n    \"version\": \"2026-02-11\",\n    \"mode\": \"halt\"\n  },\n  \"enforcement\": {\n    \"tools\": {\n      \"default\": \"deny\",\n      \"allow\": []\n    },\n    \"model_egress\": {\n      \"default\": \"deny\"\n    }\n  },\n  \"token_requirements\": {\n    \"cst\": {\n      \"require_scope_hash\": true,\n      \"optional_policy_hash_pinning\": true\n    }\n  },\n  \"audit\": {\n    \"require_gateway_receipts\": true,\n    \"emit_proof_bundle\": true\n  }\n}\n</pre>\n<p>Operationally, you roll this out by making new jobs reference the WPC hash for “emergency-halt,” and by revoking CSTs associated with runs you must stop. If your process requires approvals, you can gate WPC publication and CST issuance through your existing change control.</p>\n\n<h2>What proof do you get?</h2>\n<p>When model calls go through clawproxy, you receive gateway receipts for each call. Those receipts are designed for later verification: they let you show what was called, when, and under which authorization context, without asking engineers to reconstruct logs by hand.</p>\n<p>Claw EA can bundle receipts plus run metadata into a proof bundle. You can store the artifact in Trust Pulse so security and audit teams have a stable object to view during review and post-incident writeups.</p>\n<p>In an emergency halt scenario, the proof you want is both positive and negative. Positive proof shows the last allowed calls before the kill switch; negative proof shows subsequent calls were blocked due to WPC and CST enforcement (or that the agent was unable to obtain a valid CST after revocation).</p>\n\n<h2>Rollback posture</h2>\n<p>A kill switch is only useful if “halt” is reversible without guesswork. Rollback should be a controlled re-authorization: publish or select a non-halt WPC, mint new CSTs pinned to that policy, and re-enable the minimum tool profile needed to resume work.</p>\n<p>Do not “unhalt” by telling the agent it is safe again. Prompt-only unhalts are indistinguishable from attacker instructions, and they do not restore the permission boundary cleanly.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Halt all tools for a job</td>\n      <td>Switch job to a normal-operation WPC hash and re-issue CSTs for that job. Re-enable only the required OpenClaw tool allowlist profile.</td>\n      <td>WPC hashes before and after, plus proof bundle showing the halt window and subsequent allowed calls.</td>\n    </tr>\n    <tr>\n      <td>Halt model egress</td>\n      <td>Update WPC to allow model egress again and issue new CSTs pinned to that policy hash. Validate clawproxy path is still emitting gateway receipts.</td>\n      <td>Gateway receipts resume with the new policy context; the proof bundle boundary demonstrates when egress reopened.</td>\n    </tr>\n    <tr>\n      <td>Revoke tokens during incident</td>\n      <td>After root cause is addressed, mint fresh CSTs with short TTL and job binding. Avoid reusing older tokens even if they are unexpired.</td>\n      <td>Token issuance and revocation audit events from clawscope, linked to the job metadata in the proof bundle.</td>\n    </tr>\n    <tr>\n      <td>Lock down inbound triggers</td>\n      <td>Restore OpenClaw channel policies gradually, starting with allowlists and mention requirements. Keep high-risk channels gated until monitoring is stable.</td>\n      <td>OpenClaw configuration diff plus runtime audit output demonstrating the new effective policy.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why isn’t a prompt-based “stop” good enough?</h3>\n<p>Because prompts are not enforcement. If the agent is manipulated, it can ignore “stop” while continuing to call tools or send data to a model endpoint.</p>\n<p>A kill switch must be enforced at the execution layer using policy-as-code, so the runtime and proxy deny actions regardless of what the model says.</p>\n\n<h3>What is the smallest useful kill switch in production?</h3>\n<p>Deny tool execution in the runtime and deny model egress in the proxy. This prevents both local side effects and outbound data movement, even if the agent keeps generating text.</p>\n<p>OpenClaw’s tool policy and sandboxing model makes this separation explicit: stop “what tools can run” and stop “where tools can run.”</p>\n\n<h3>How do WPC and CST work together during an emergency halt?</h3>\n<p>The WPC defines the binding policy (for example, halt mode) and is signed and hash-addressed. The CST is issued by clawscope, can carry a scope hash, and can optionally pin to the WPC hash so it cannot be used under a different policy.</p>\n<p>During an incident you typically both switch to a halt WPC and revoke CSTs for in-flight runs to force re-authorization to fail.</p>\n\n<h3>What do I show an auditor after we hit the kill switch?</h3>\n<p>Show gateway receipts for model calls and a proof bundle per job run that ties receipts to run metadata. Store the incident-relevant artifacts in Trust Pulse so reviewers have stable references.</p>\n<p>This avoids “trust us” narratives and supports a concrete timeline: last allowed call, halt activation, and post-halt blocks.</p>\n\n<h3>Does this replace OpenClaw’s built-in security audit and sandboxing?</h3>\n<p>No. OpenClaw’s local controls reduce blast radius on the host and help prevent common misconfigurations, and you should still run its security audit regularly.</p>\n<p>Claw EA adds a permissioned execution and verification layer around runs, including WPC-based policy fetch/verify, CST enforcement, and receipted model egress via clawproxy.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security</a></li>\n  <li><a href=\"https://codelabs.developers.google.com/codelabs/production-ready-ai-roadshow/2-evaluating-multi-agent-systems/evaluating-multi-agent-systems?hl=en\">From \"vibe checks\" to data-driven Agent Evaluation (Google Codelabs)</a></li>\n</ul>",
  "description": "A kill switch is a policy-enforced emergency halt that stops an agent run from taking new actions, even if the agent keeps generating text. In Claw EA, the practical control is: deny tool execution and deny model egress ",
  "faqs": [
    {
      "q": "Why isn’t a prompt-based “stop” good enough?",
      "a": "Because prompts are not enforcement. If the agent is manipulated, it can ignore “stop” while continuing to call tools or send data to a model endpoint."
    },
    {
      "q": "What is the smallest useful kill switch in production?",
      "a": "Deny tool execution in the runtime and deny model egress in the proxy. This prevents both local side effects and outbound data movement, even if the agent keeps generating text."
    },
    {
      "q": "How do WPC and CST work together during an emergency halt?",
      "a": "The WPC defines the binding policy (for example, halt mode) and is signed and hash-addressed. The CST is issued by clawscope, can carry a scope hash, and can optionally pin to the WPC hash so it cannot be used under a different policy."
    },
    {
      "q": "What do I show an auditor after we hit the kill switch?",
      "a": "Show gateway receipts for model calls and a proof bundle per job run that ties receipts to run metadata. Store the incident-relevant artifacts in Trust Pulse so reviewers have stable references."
    },
    {
      "q": "Does this replace OpenClaw’s built-in security audit and sandboxing?",
      "a": "No. OpenClaw’s local controls reduce blast radius on the host and help prevent common misconfigurations, and you should still run its security audit regularly."
    }
  ],
  "sources": [
    {
      "title": "From \"vibe checks\" to data-driven Agent Evaluation",
      "uri": "https://codelabs.developers.google.com/codelabs/production-ready-ai-roadshow/2-evaluating-multi-agent-systems/evaluating-multi-agent-systems?hl=en"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:11:37.614Z",
  "indexable": true
}