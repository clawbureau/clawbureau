{
  "slug": "controls/secret-boundary",
  "title": "Secrets isolation and scoped credentials for Agents | Policy-as-Code Control | Claw EA",
  "category": "controls",
  "html": "<h2>Direct Answer</h2>\n<p>Secrets isolation means your agent cannot read or reuse credentials unless the execution layer grants a narrowly scoped, short-lived credential for the specific job and tool. In Claw EA, you do this by binding a WPC to the run, issuing a CST with a scope hash (optionally pinned to the WPC hash), and routing model calls through clawproxy so you get gateway receipts and a proof bundle.</p>\n<p>This control must live in permissioned execution (policy-as-code), not in prompts, because prompts are not a security boundary. A prompt can be overridden by injection, but a tool boundary plus token scope checks fail closed when the agent tries to access data or call tools outside the allowed contract.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Inventory secrets and classify them by blast radius. Split by purpose (read-only vs write, environment vs tenant) and decide which tools actually need each credential.</p>\n  </li>\n  <li>\n    <p>Write a WPC that declares allowed tools, allowed model routing, and which secret classes may be requested. Keep it job-specific (for example, “read from one storage prefix” rather than “access storage”).</p>\n  </li>\n  <li>\n    <p>Register the WPC in the WPC registry and use proxy fetch/verify at runtime so the agent runner only accepts signed, hash-addressed policy artifacts. Treat the WPC hash as the change control anchor for reviews.</p>\n  </li>\n  <li>\n    <p>Issue a CST from clawscope for the job with a scope hash, and (recommended) pin it to the WPC hash so the token cannot be reused under a different policy. Use marketplace anti-replay binding (job-scoped CST binding) so copying a token between jobs does not work.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw as the baseline runtime with tool policy and sandboxing enabled. Use OpenClaw tool allow/deny profiles to remove secret-touching tools from the default surface area, then add only what the WPC allows.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy (OpenRouter via fal routed through clawproxy is available) so every model call produces gateway receipts. At the end of the run, collect the proof bundle and store it in Trust Pulse for later audit viewing.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Secrets isolation is mainly about stopping unreviewed credential use and stopping lateral movement when an agent is tricked. The table below lists concrete failure modes and the controls you should rely on in Claw EA plus OpenClaw.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (permissioned execution)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection asks the agent to “print env vars” or “cat credential files”</td>\n      <td>The agent attempts to read local secret material and exfiltrate it via chat or a network tool.</td>\n      <td>OpenClaw sandboxing to reduce filesystem access, plus tool policy to deny file-read tools or deny paths by design. Keep secrets out of the sandbox filesystem, and require a CST-backed tool call to obtain any runtime credential.</td>\n    </tr>\n    <tr>\n      <td>Credential reuse across jobs</td>\n      <td>A leaked token from one run is replayed in a different run or environment.</td>\n      <td>CST with marketplace anti-replay binding (job-scoped CST binding). Optional policy hash pinning ties the CST to a specific WPC hash.</td>\n    </tr>\n    <tr>\n      <td>Overbroad credentials (single token grants full tenant access)</td>\n      <td>Any tool that can reach the credential can read or write unrelated resources.</td>\n      <td>WPC forces least privilege at the execution layer: only the narrow tool set is allowed, and the token scope hash must match. For Microsoft environments, reduce Microsoft Graph permissions/scopes and prefer separate app registrations per agent class via enterprise buildout.</td>\n    </tr>\n    <tr>\n      <td>Shadow tool path to the network</td>\n      <td>The agent uses a “generic HTTP” tool or shell to send secrets to an attacker.</td>\n      <td>Tool policy denies generic network tools unless explicitly required. If you need additional network constraints, egress allowlists enforced outside clawproxy are optional and can be implemented in your environment.</td>\n    </tr>\n    <tr>\n      <td>Unattributed model calls and missing audit trail</td>\n      <td>You cannot prove which model calls happened under which policy, so you cannot investigate incidents.</td>\n      <td>clawproxy emits gateway receipts for model calls; proof bundles bind receipts to job metadata and the policy reference. Store in Trust Pulse for consistent review.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the shape of a WPC-like policy artifact that gates secret access to only a specific tool and binds the job to a specific scope hash. Treat it as illustrative and adapt it to your internal policy schema and review workflow.</p>\n\n<pre>\n{\n  \"policy_kind\": \"wpc\",\n  \"policy_version\": \"v1\",\n  \"intent\": \"Secrets boundary for outbound integrations\",\n  \"agent_runtime\": \"OpenClaw\",\n  \"tools\": {\n    \"allow\": [\n      \"provider:clawproxy/openrouter_via_fal\",\n      \"tool:storage.readonly\",\n      \"tool:ticketing.create\"\n    ],\n    \"deny\": [\n      \"tool:shell.exec\",\n      \"tool:http.request\",\n      \"tool:filesystem.read\"\n    ]\n  },\n  \"secrets\": {\n    \"minting\": \"cst_required\",\n    \"allowed_secret_classes\": [\"ticketing_write_scoped\", \"storage_read_scoped\"],\n    \"max_ttl_seconds\": 900\n  },\n  \"auth\": {\n    \"cst_scope_hash\": \"sha256:BASE64URL...\",\n    \"pin_policy_hash\": true\n  },\n  \"model_calls\": {\n    \"must_route_via\": \"clawproxy\",\n    \"receipts_required\": true\n  }\n}\n</pre>\n\n<p>The operational point is that secret material is not “in the prompt” and not “in the filesystem by default.” It is only reachable through allowed tools, under a CST that is scoped for this job and optionally pinned to the WPC hash.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get evidence that the agent ran under an explicit policy and that model calls occurred through a receipting gateway. This is useful when you need to answer “which job used which credential class” and “was this output produced under the approved controls.”</p>\n<p>At a minimum, Claw EA can produce gateway receipts from clawproxy for model calls, then bundle them into a proof bundle with job metadata and policy references. You can store and view the resulting artifacts in Trust Pulse for audit and incident response review.</p>\n<p>When you pin a CST to a policy hash, the audit story is simpler: the credential used by the run is cryptographically bound to a specific WPC hash, not just to a human ticket or a prompt. That reduces ambiguity during investigations and supports fail-closed verification.</p>\n\n<h2>Rollback posture</h2>\n<p>Secrets isolation should be easy to roll back without widening access silently. Prefer “deny by default, then widen with a new WPC hash” rather than editing a live configuration file in place.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>A tool starts failing because it no longer sees a credential</td>\n      <td>Issue a new WPC that explicitly allows the minimal required tool and secret class, then re-issue a CST pinned to the new WPC hash.</td>\n      <td>New WPC hash plus proof bundle for the rerun, showing the updated allowed tool set and gateway receipts.</td>\n    </tr>\n    <tr>\n      <td>You suspect token leakage during a job</td>\n      <td>Rotate by revoking or expiring CST issuance for that job and re-run with a new job-scoped CST binding.</td>\n      <td>CST issuance records (from clawscope) plus proof bundles that show which runs used which job binding.</td>\n    </tr>\n    <tr>\n      <td>A policy change accidentally broadened access</td>\n      <td>Revert by deploying the previous WPC hash and refusing to run jobs pinned to the widened policy hash.</td>\n      <td>Proxy fetch/verify logs showing which WPC hash was used, and proof bundles that tie runs to the prior policy reference.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is prompt-only “do not leak secrets” insufficient?</h3>\n<p>Because prompts are advisory text, not an enforcement point. If an agent can read a secret from disk or call a network tool, injection can override the instruction; policy-as-code removes the capability in the first place.</p>\n\n<h3>Where should secrets live if not in the agent workspace?</h3>\n<p>Keep long-lived secrets in your enterprise secret manager, and only mint short-lived, job-scoped credentials for the specific tool that needs them. In Claw EA, treat CST issuance and WPC pinning as the guardrails around that minting step.</p>\n\n<h3>How does this relate to OpenClaw sandboxing and tool policy?</h3>\n<p>OpenClaw sandboxing limits where tools run (container vs host) and tool policy limits which tools can be called. Secrets isolation layers on top by making credentials conditional on a WPC and CST, so even allowed tools cannot exceed the contract.</p>\n\n<h3>Can I use Microsoft Entra ID and Microsoft Graph with this control?</h3>\n<p>Yes, via official API and standard Microsoft application permissions/scopes, but you should keep Graph permissions narrow and separate read vs write apps. If you need Conditional Access or PIM enforcement patterns for agent identities, that is typically an enterprise buildout aligned to your tenant policies.</p>\n\n<h3>What exactly can auditors verify later?</h3>\n<p>They can review the WPC hash referenced by the job, the CST scope hash behavior (including optional policy hash pinning), and gateway receipts for the model calls. They can also inspect the proof bundle stored in Trust Pulse to tie evidence back to a specific run.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (security audit and credential storage considerations)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/databricks/generative-ai/agent-framework/agent-authentication\">Microsoft Learn: Authentication for AI agents (Azure Databricks)</a></li>\n</ul>",
  "description": "Secrets isolation means your agent cannot read or reuse credentials unless the execution layer grants a narrowly scoped, short-lived credential for the specific job and tool. In Claw EA, you do this by binding a WPC to t",
  "faqs": [
    {
      "q": "Why is prompt-only “do not leak secrets” insufficient?",
      "a": "Because prompts are advisory text, not an enforcement point. If an agent can read a secret from disk or call a network tool, injection can override the instruction; policy-as-code removes the capability in the first place."
    },
    {
      "q": "Where should secrets live if not in the agent workspace?",
      "a": "Keep long-lived secrets in your enterprise secret manager, and only mint short-lived, job-scoped credentials for the specific tool that needs them. In Claw EA, treat CST issuance and WPC pinning as the guardrails around that minting step."
    },
    {
      "q": "How does this relate to OpenClaw sandboxing and tool policy?",
      "a": "OpenClaw sandboxing limits where tools run (container vs host) and tool policy limits which tools can be called. Secrets isolation layers on top by making credentials conditional on a WPC and CST, so even allowed tools cannot exceed the contract."
    },
    {
      "q": "Can I use Microsoft Entra ID and Microsoft Graph with this control?",
      "a": "Yes, via official API and standard Microsoft application permissions/scopes, but you should keep Graph permissions narrow and separate read vs write apps. If you need Conditional Access or PIM enforcement patterns for agent identities, that is typically an enterprise buildout aligned to your tenant policies."
    },
    {
      "q": "What exactly can auditors verify later?",
      "a": "They can review the WPC hash referenced by the job, the CST scope hash behavior (including optional policy hash pinning), and gateway receipts for the model calls. They can also inspect the proof bundle stored in Trust Pulse to tie evidence back to a specific run."
    }
  ],
  "sources": [
    {
      "title": "Authentication for AI agents - Azure Databricks | Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/azure/databricks/generative-ai/agent-framework/agent-authentication"
    },
    {
      "title": "Introducing Amazon Bedrock AgentCore: Securely deploy and ...",
      "uri": "https://aws.amazon.com/blogs/aws/introducing-amazon-bedrock-agentcore-securely-deploy-and-operate-ai-agents-at-any-scale/"
    },
    {
      "title": "Managing access for deployed agents",
      "uri": "https://docs.cloud.google.com/agent-builder/agent-engine/manage/access"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:14:10.037Z",
  "indexable": true
}