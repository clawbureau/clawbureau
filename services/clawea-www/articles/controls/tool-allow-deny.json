{
  "slug": "controls/tool-allow-deny",
  "title": "Tool allow/deny lists for Agents | Policy-as-Code Control | Claw EA",
  "category": "controls",
  "html": "<p>Tool allow/deny lists are a machine-enforced boundary that determines which tools an agent is allowed to call at runtime. In OpenClaw, this maps to tool policy controls like tool profiles and explicit allow and deny lists, and it is one of the fastest ways to reduce blast radius when an agent gets confused or is prompt-injected.</p>\n<p>For enterprise use, prompt-only rules are not sufficient because they are not binding: the model can ignore them, and you cannot reliably prove what was allowed at execution time. Claw EA makes the boundary permissioned by binding tool policy to a WPC and issuing a CST that pins to that policy, then producing gateway receipts and a proof bundle for audit.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Inventory the agent’s tools and group them into profiles (for example: “read-only M365”, “ticketing write”, “devops break-glass”). Start with the smallest set that still completes the workflow, and keep shell and filesystem write tools out of the default profile.</p>\n  </li>\n  <li>\n    <p>Define OpenClaw tool policy: a base tool profile plus explicit <span>allow</span> and <span>deny</span> overrides per agent and per provider. Keep “elevated” tools separate so you can require a different approval path before host execution is possible.</p>\n  </li>\n  <li>\n    <p>Create a WPC that expresses the intended tool boundary and reference it by hash, so the policy used at runtime is unambiguous. Store the WPC in the WPC registry and treat updates as a code change with review, not as a prompt tweak.</p>\n  </li>\n  <li>\n    <p>Issue a CST (from clawscope) for the job with scope hash and optional policy hash pinning to the WPC. Use marketplace anti-replay binding so the CST is job-scoped and cannot be reused across runs.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy so you get gateway receipts for each model call, tied to the job and its CST. Keep the agent runtime fail-closed: if the proxy cannot verify the pinned policy hash, do not proceed with tool execution.</p>\n  </li>\n  <li>\n    <p>After execution, collect the proof bundle and store it with the job record, and optionally publish the Trust Pulse for external review. Use this as the evidence package for “what was allowed” and “what was actually called” during the run.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Allow/deny lists are about preventing capability escalation, not making the model “behave.” Your baseline assumption should be: prompts are attacker-controlled inputs, tool schemas can be misused, and the model will sometimes attempt dangerous calls even when instructed not to.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection triggers a high-impact tool</td>\n      <td>The agent tries to call shell, write files, or perform a destructive API operation because text asked it to.</td>\n      <td>Default-deny tool profile plus explicit allow list for only the tools needed in that workflow.</td>\n    </tr>\n    <tr>\n      <td>Tool confusion and parameter abuse</td>\n      <td>The agent uses a legitimate tool with unsafe arguments (for example, wildcard deletes, bulk email, or posting secrets into a ticket).</td>\n      <td>Split tools into narrow actions and deny bulk or admin variants; require a separate profile for risky operations.</td>\n    </tr>\n    <tr>\n      <td>Plugin sprawl expands attack surface</td>\n      <td>New extensions introduce tools that become callable by accident after a config change.</td>\n      <td>Pin tool availability to a reviewed profile and deny unknown tools by default; run OpenClaw security audit after changes.</td>\n    </tr>\n    <tr>\n      <td>Cross-run token reuse</td>\n      <td>A token minted for one job is replayed to run additional actions later.</td>\n      <td>Marketplace anti-replay binding with a job-scoped CST binding, and short TTL issuance policy.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable “policy drift” during an incident</td>\n      <td>After a bad run, you cannot prove whether the agent was allowed to call a tool or whether the config changed mid-run.</td>\n      <td>WPC hash addressing plus CST optional policy hash pinning, and a proof bundle that includes gateway receipts.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows a WPC-style policy intent for a Microsoft 365 workflow: the agent may read from Microsoft Graph via official API, but cannot send mail, delete files, or call host execution tools. In practice, you map this to OpenClaw tool policy (profile + allow + deny) and then pin the WPC hash into the CST.</p>\n\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"m365-readonly-triage\",\n  \"tools\": {\n    \"profile\": \"readonly\",\n    \"allow\": [\n      \"mcp.microsoft_graph.users.read\",\n      \"mcp.microsoft_graph.mail.read\",\n      \"mcp.microsoft_graph.calendar.read\",\n      \"web.get\",\n      \"text.search\"\n    ],\n    \"deny\": [\n      \"mcp.microsoft_graph.mail.send\",\n      \"mcp.microsoft_graph.files.delete\",\n      \"exec\",\n      \"write\",\n      \"apply_patch\",\n      \"tools.elevated.*\"\n    ]\n  },\n  \"token_binding\": {\n    \"require_cst_scope_hash\": true,\n    \"optional_policy_hash_pinning\": true,\n    \"job_scoped_anti_replay\": true\n  }\n}</pre>\n\n<p>If you are using Entra ID for Microsoft Graph, treat Graph permissions and Conditional Access as a second boundary, not the primary one. The allow/deny list should still block “mail.send” even if an app registration accidentally has that Graph permission, and PIM should be used to limit when elevated permissions are even available.</p>\n\n<h2>What proof do you get?</h2>\n<p>Each model call routed through clawproxy yields gateway receipts, which you can later verify and correlate to a specific job and CST. This is the minimal evidence that the model traffic was mediated and recorded under the configured constraints.</p>\n<p>At the end of a run, Claw EA produces a proof bundle that packages the gateway receipts and related metadata needed for audit and verification. If you publish it, the Trust Pulse serves as the stored artifact for viewing and third-party review.</p>\n\n<h2>Rollback posture</h2>\n<p>Tool allow/deny lists are effective because rollback is operationally simple: you can remove a tool from the allow list and rerun under a new WPC, without changing prompts or retraining anything. For incidents, design your profiles so you can rapidly drop to “read-only” and still preserve basic triage.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Disable a risky tool (for example, mail send)</td>\n      <td>Update tool profile and deny list, publish a new WPC, and issue a new CST pinned to the new policy hash.</td>\n      <td>Proof bundle shows policy hash change boundary across runs, with gateway receipts per run.</td>\n    </tr>\n    <tr>\n      <td>Freeze tool surface during an incident</td>\n      <td>Drop to a minimal “read-only” profile and deny elevated tools; keep workflows running for investigation.</td>\n      <td>WPC hash reference in job record plus receipts tied to job-scoped CST binding.</td>\n    </tr>\n    <tr>\n      <td>Re-enable a tool with tighter scope</td>\n      <td>Replace a broad tool with narrower tools and only allow the narrow set; keep bulk variants denied.</td>\n      <td>Proof bundle and gateway receipts show which tool calls occurred and whether denied calls were blocked.</td>\n    </tr>\n    <tr>\n      <td>Post-incident audit and replay review</td>\n      <td>Verify receipts and policy bindings; compare effective tool policy across affected jobs.</td>\n      <td>Gateway receipts plus proof bundle, and optional Trust Pulse for external viewing.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>How is a tool allow/deny list different from telling the agent “do not do X”?</h3>\n<p>A prompt is guidance that the model can ignore or misunderstand. A tool allow/deny list is enforced by the runtime, so disallowed calls cannot execute even if the model requests them.</p>\n\n<h3>Where does this control live in OpenClaw?</h3>\n<p>OpenClaw has a distinct tool policy layer that determines which tools are callable, separate from sandboxing (where tools run) and elevated execution (host escape hatch). Use tool profiles and explicit allow and deny lists, then verify the effective configuration with OpenClaw’s inspection and security audit tooling.</p>\n\n<h3>How do WPC and CST make this policy enforceable across a fleet?</h3>\n<p>A WPC is a signed, hash-addressed policy artifact served by clawcontrols, so the policy is stable and referencable. A CST (issued by clawscope) can include scope hash and optional policy hash pinning, so the job token is cryptographically bound to the intended policy version.</p>\n\n<h3>What evidence can I show an auditor after a bad run?</h3>\n<p>Gateway receipts from clawproxy show mediated model calls, and the proof bundle packages those receipts with metadata for verification. Together with the WPC hash and the CST binding, you can show what the agent was allowed to do and what it attempted during that job.</p>\n\n<h3>Does this replace Microsoft Graph permissions and Entra ID controls?</h3>\n<p>No. Graph permissions, Conditional Access, and PIM remain necessary for identity and least privilege, but they do not control the agent runtime’s tool surface by themselves. Use both: Graph to constrain what a tool could do, and tool allow/deny lists to constrain what the agent is allowed to try.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security</a></li>\n  <li><a href=\"https://www.openpolicyagent.org/docs\">Open Policy Agent (OPA) Documentation</a></li>\n</ul>",
  "description": "Tool allow/deny lists are a machine-enforced boundary that determines which tools an agent is allowed to call at runtime. In OpenClaw, this maps to tool policy controls like tool profiles and explicit allow and deny list",
  "faqs": [
    {
      "q": "How is a tool allow/deny list different from telling the agent “do not do X”?",
      "a": "A prompt is guidance that the model can ignore or misunderstand. A tool allow/deny list is enforced by the runtime, so disallowed calls cannot execute even if the model requests them."
    },
    {
      "q": "Where does this control live in OpenClaw?",
      "a": "OpenClaw has a distinct tool policy layer that determines which tools are callable, separate from sandboxing (where tools run) and elevated execution (host escape hatch). Use tool profiles and explicit allow and deny lists, then verify the effective configuration with OpenClaw’s inspection and security audit tooling."
    },
    {
      "q": "How do WPC and CST make this policy enforceable across a fleet?",
      "a": "A WPC is a signed, hash-addressed policy artifact served by clawcontrols, so the policy is stable and referencable. A CST (issued by clawscope) can include scope hash and optional policy hash pinning, so the job token is cryptographically bound to the intended policy version."
    },
    {
      "q": "What evidence can I show an auditor after a bad run?",
      "a": "Gateway receipts from clawproxy show mediated model calls, and the proof bundle packages those receipts with metadata for verification. Together with the WPC hash and the CST binding, you can show what the agent was allowed to do and what it attempted during that job."
    },
    {
      "q": "Does this replace Microsoft Graph permissions and Entra ID controls?",
      "a": "No. Graph permissions, Conditional Access, and PIM remain necessary for identity and least privilege, but they do not control the agent runtime’s tool surface by themselves. Use both: Graph to constrain what a tool could do, and tool allow/deny lists to constrain what the agent is allowed to try."
    }
  ],
  "sources": [
    {
      "title": "Open Policy Agent (OPA)",
      "uri": "https://www.openpolicyagent.org/docs"
    },
    {
      "title": "Open Policy Agent",
      "uri": "https://openpolicyagent.org/"
    },
    {
      "title": "Amazon Bedrock AgentCore Policy: Control Agent-to-Tool Interactions",
      "uri": "https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/policy.html"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:14:52.670Z",
  "indexable": true
}