{
  "slug": "controls/budgets",
  "title": "Token and cost budgets for Agents | Policy-as-Code Control | Claw EA",
  "category": "controls",
  "html": "<h2>Direct Answer</h2>\n<p>Token and cost budgets only work when they are enforced by the execution layer, not by a prompt. In Claw EA, you express budgets in a WPC and bind a job to that policy using a CST, so the runtime can prove what policy governed the run and what was actually spent.</p>\n<p>OpenClaw is the baseline agent runtime: it already separates sandboxing from tool policy and provides an operational boundary where budget checks can be implemented. Gateway receipts and a proof bundle let you reconcile usage after the fact, and, where you choose, fail closed when the budget would be exceeded.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define a budgeted policy as a WPC. Include limits such as max tokens per call, max tokens per job, and an optional max cost per job in USD.</p>\n    <p>Keep the policy narrow: include model allowlists and tool allowlists so a budget exception cannot be “fixed” by switching to a higher-cost model or by invoking extra tools.</p>\n  </li>\n  <li>\n    <p>Publish the WPC to the WPC registry and record its policy hash. Treat the policy hash as the deployment artifact you promote through environments.</p>\n    <p>In change control, review the diff of the policy payload, not just a human description.</p>\n  </li>\n  <li>\n    <p>Issue a CST for the job and pin it to the budget policy hash. This makes the job’s authorization and its budget contract inseparable in downstream verification.</p>\n    <p>Use job-scoped CST binding to reduce replay risk, so a token from one job cannot be reused to run another job under a different context.</p>\n  </li>\n  <li>\n    <p>Run the agent in OpenClaw with tool policy and sandbox settings aligned to the WPC. Use OpenClaw tool policy to control which tools exist, and sandboxing to limit blast radius when tools execute.</p>\n    <p>For model calls, route traffic through clawproxy so each call produces gateway receipts tied to the job and policy context.</p>\n  </li>\n  <li>\n    <p>Implement budget checks at the runtime boundary. Today this is typically done in the OpenClaw provider/tool plugin (or via an MCP server) by reading the pinned policy hash and maintaining a per-job usage ledger.</p>\n    <p>Automatic cost budget enforcement inside clawproxy is planned, so plan for both “monitor” mode (audit and alert) and “enforce” mode (fail closed) depending on your risk tolerance.</p>\n  </li>\n  <li>\n    <p>Collect gateway receipts and emit a proof bundle at the end of the job. Store the proof bundle in your evidence system, or publish it to Trust Pulse when you need a stable artifact for audit viewing.</p>\n    <p>Reconcile token totals and approximate cost from receipts against provider billing exports (via official API) as a separate finance control.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Budgets fail when they are only “instructions” to the model. A model can ignore the instruction, split work into more calls, switch models, or route work through unmetered tools unless the execution layer blocks those paths.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt-only budget bypass</td>\n      <td>The agent keeps calling the model after “reaching the limit” because nothing enforces the limit at the call boundary.</td>\n      <td>Put budgets in a WPC and enforce at the provider/tool boundary; route model calls through clawproxy so every call is receipted.</td>\n    </tr>\n    <tr>\n      <td>Model switching to increase spend</td>\n      <td>The agent moves from a cheap model to an expensive one to “finish faster”, defeating cost assumptions.</td>\n      <td>WPC model allowlist plus CST policy hash pinning; reject calls for models not permitted by the pinned policy.</td>\n    </tr>\n    <tr>\n      <td>Token fragmentation</td>\n      <td>The agent splits a task into many smaller calls to evade per-call token limits and inflate total usage.</td>\n      <td>Use both per-call limits and per-job limits in the WPC; track cumulative totals in the runtime ledger, and fail closed when exceeded.</td>\n    </tr>\n    <tr>\n      <td>Replay of an authorized token</td>\n      <td>A CST captured from logs or a misconfigured host is reused to run additional calls outside the intended job window.</td>\n      <td>Marketplace anti-replay binding with job-scoped CST binding; keep CST TTL short and rotate frequently.</td>\n    </tr>\n    <tr>\n      <td>Tool side-channel spend</td>\n      <td>The agent offloads work to tools that call external LLMs or services directly, outside your metering.</td>\n      <td>OpenClaw tool policy to restrict tools; require that model access occurs only via the clawproxy-routed provider in the approved profile.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact, JSON-like sketch of a WPC payload that expresses token and cost budgets. Enforcement can be “monitor” (audit-only) or “enforce” (fail closed), depending on what you wire into your OpenClaw provider plugin or MCP server.</p>\n<pre>{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"agent-budgets-prod\",\n  \"job\": {\n    \"max_runtime_seconds\": 1800,\n    \"budget\": {\n      \"max_tokens_per_call\": 4096,\n      \"max_tokens_per_job\": 120000,\n      \"max_cost_usd_per_job\": 25.00,\n      \"enforcement_mode\": \"monitor\"\n    }\n  },\n  \"model_policy\": {\n    \"allowed_models\": [\n      \"openrouter:.../gpt-4o-mini\",\n      \"openrouter:.../claude-3.5-sonnet\"\n    ]\n  },\n  \"tool_policy\": {\n    \"profile\": \"allowlist\",\n    \"allow\": [\"read\", \"write\", \"exec\", \"http\"],\n    \"deny\": [\"elevated.exec\"]\n  },\n  \"receipt_policy\": {\n    \"require_gateway_receipts\": true,\n    \"require_proof_bundle_on_completion\": true\n  }\n}</pre>\n<p>Operationally, you pin the WPC policy hash into the CST at job start, and you reject any model call whose effective policy hash does not match. That makes “which budget applied” verifiable later, even if the agent output is messy.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get gateway receipts for model calls emitted by clawproxy. Receipts are the durable unit you can count and verify: model, timestamps, and accounting-relevant metadata that can be rolled up into totals for a job.</p>\n<p>At the end of a run, you produce a proof bundle that packages receipts and related metadata needed for audit and verification. If you need a stable artifact for sharing or review, you can store and view it via Trust Pulse.</p>\n<p>Budgets become auditable in two directions. You can show the intended limits (the WPC hash and content) and the actual usage (receipts plus the derived totals), and you can explain any “fail closed” event as a policy decision rather than an operator guess.</p>\n\n<h2>Rollback posture</h2>\n<p>Budget controls should have a safe rollback that does not widen privileges. Treat rollbacks as policy changes: create a new WPC, pin the new hash, and re-run with explicit evidence.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Job hits token or cost cap mid-run</td>\n      <td>Stop the job and re-run with a new WPC that raises limits, plus a tighter tool/model allowlist if needed.</td>\n      <td>Old and new WPC hashes, CST policy hash pinning for each job, proof bundles showing where the cap triggered.</td>\n    </tr>\n    <tr>\n      <td>Unexpected model spend spike</td>\n      <td>Roll back to a cheaper allowed model set by publishing a new WPC, then pin and re-issue CSTs for subsequent jobs.</td>\n      <td>Gateway receipts showing the model used per call, plus the WPC model allowlist for the run.</td>\n    </tr>\n    <tr>\n      <td>Tool path bypasses metering</td>\n      <td>Disable or deny the tool in OpenClaw tool policy and re-run in sandboxed mode; require model access via clawproxy-routed provider only.</td>\n      <td>OpenClaw config snapshot, WPC tool policy, and proof bundle demonstrating all model calls were receipted.</td>\n    </tr>\n    <tr>\n      <td>Credential exposure concerns</td>\n      <td>Revoke CSTs, rotate upstream provider keys, and re-run with shorter CST TTL and stricter job scoping.</td>\n      <td>Revocation logs (your system), job-scoped CST binding evidence, and proof bundles for affected jobs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why can’t I just tell the agent “do not exceed $10” in the prompt?</h3>\n<p>Because prompts are not a permission boundary. Budgets need a call-site decision: allow or deny the next model call, enforced by the runtime or proxy under a pinned policy hash.</p>\n\n<h3>What is the minimum I need to deploy to get budget evidence?</h3>\n<p>Use a WPC to define the limits, issue a CST pinned to that policy hash, and route model calls through clawproxy to generate gateway receipts. Then package receipts into a proof bundle for the job.</p>\n\n<h3>Do you enforce cost budgets automatically at the proxy?</h3>\n<p>Automatic cost budget enforcement is planned. Today you can implement enforcement in your OpenClaw provider/tool plugin (or via MCP server) and use gateway receipts plus the pinned WPC to prove what happened.</p>\n\n<h3>How does this relate to Microsoft 365 agents and Graph permissions?</h3>\n<p>Budgets are separate from Graph permissions. Use Entra ID and least-privilege Microsoft Graph scopes to limit what actions are possible, then use WPC budgets to limit how much model work is permitted while performing those actions via official API.</p>\n\n<h3>What happens if I need to raise limits for a single incident?</h3>\n<p>Create a new WPC with the temporary limits, pin it in a job-scoped CST, and run a separate job. That gives you a clean audit trail showing the exception policy and the proof bundle for the exception run.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit guidance)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n</ul>",
  "description": "Token and cost budgets only work when they are enforced by the execution layer, not by a prompt. In Claw EA, you express budgets in a WPC and bind a job to that policy using a CST, so the runtime can prove what policy go",
  "faqs": [
    {
      "q": "Why can’t I just tell the agent “do not exceed $10” in the prompt?",
      "a": "Because prompts are not a permission boundary. Budgets need a call-site decision: allow or deny the next model call, enforced by the runtime or proxy under a pinned policy hash."
    },
    {
      "q": "What is the minimum I need to deploy to get budget evidence?",
      "a": "Use a WPC to define the limits, issue a CST pinned to that policy hash, and route model calls through clawproxy to generate gateway receipts. Then package receipts into a proof bundle for the job."
    },
    {
      "q": "Do you enforce cost budgets automatically at the proxy?",
      "a": "Automatic cost budget enforcement is planned. Today you can implement enforcement in your OpenClaw provider/tool plugin (or via MCP server) and use gateway receipts plus the pinned WPC to prove what happened."
    },
    {
      "q": "How does this relate to Microsoft 365 agents and Graph permissions?",
      "a": "Budgets are separate from Graph permissions. Use Entra ID and least-privilege Microsoft Graph scopes to limit what actions are possible, then use WPC budgets to limit how much model work is permitted while performing those actions via official API."
    },
    {
      "q": "What happens if I need to raise limits for a single incident?",
      "a": "Create a new WPC with the temporary limits, pin it in a job-scoped CST, and run a separate job. That gives you a clean audit trail showing the exception policy and the proof bundle for the exception run."
    }
  ],
  "sources": [],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:06:45.146Z",
  "indexable": true
}