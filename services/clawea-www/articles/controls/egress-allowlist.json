{
  "slug": "controls/egress-allowlist",
  "title": "Egress allowlist (domains, IPs) for Agents | Policy-as-Code Control | Claw EA",
  "category": "controls",
  "html": "<p>An egress allowlist limits where an agent is permitted to send network traffic, typically by restricting domains and IP ranges at the execution layer. In Claw EA, you define the allowlist as policy-as-code in a WPC and bind execution to that policy using a CST, so the agent cannot “prompt its way” into new network access.</p>\n<p>Egress allowlist enforcement is optional and is typically implemented outside clawproxy, at the sandbox or infrastructure boundary (container networking, host firewall, VPC egress, or a dedicated egress proxy). Claw EA focuses on making the intent and the run verifiable: the WPC is hash-addressed and the run can produce proof bundles with gateway receipts for model calls.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this runbook when running OpenClaw as the baseline agent runtime and you want predictable outbound traffic boundaries. The goal is to fail closed: if the allowlist cannot be enforced, the job should not run.</p>\n<ol>\n  <li>\n    <p>Write an egress allowlist policy in a WPC.</p>\n    <p>Include the exact domains (and subdomain rules) plus IP CIDRs you want to permit, and include an explicit default deny.</p>\n  </li>\n  <li>\n    <p>Publish the WPC to the WPC registry and record the policy hash.</p>\n    <p>Because the WPC is signed and hash-addressed, you can pin later execution to the specific policy version instead of “latest”.</p>\n  </li>\n  <li>\n    <p>Issue a CST for the job with optional policy hash pinning.</p>\n    <p>The CST should be job-scoped so it cannot be replayed across jobs, and the scope hash should reflect the exact egress allowlist intent.</p>\n  </li>\n  <li>\n    <p>Enforce egress at the execution boundary (optional; implemented outside clawproxy).</p>\n    <p>Common patterns are: run tools in Docker with controlled networking, attach a dedicated egress proxy that only permits allowlisted destinations, or enforce host-level firewall rules bound to the sandbox process identity.</p>\n  </li>\n  <li>\n    <p>Route model traffic through clawproxy so you get Gateway receipts.</p>\n    <p>This makes model calls auditable even if the agent is compromised, because the receipts are emitted by clawproxy and can be verified later.</p>\n  </li>\n  <li>\n    <p>Export the run’s proof bundle and store it for review.</p>\n    <p>Store the proof bundle internally and, when appropriate, publish a Trust Pulse artifact for audit viewing.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Egress allowlists are about containment: assume the agent will eventually see malicious instructions and try to reach unexpected endpoints. Prompt-only controls are not sufficient because they do not change what the process can do once a tool can open sockets.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection causes data exfiltration</td>\n      <td>The agent tries to POST secrets or files to an attacker-controlled domain.</td>\n      <td>Default-deny egress, allowlist only required vendor APIs; keep tools sandboxed and reduce filesystem access.</td>\n    </tr>\n    <tr>\n      <td>SSRF to internal network</td>\n      <td>The agent reaches RFC1918 or metadata IPs and extracts credentials or config.</td>\n      <td>Deny private CIDRs and metadata IPs; explicitly allow only known public CIDRs if needed.</td>\n    </tr>\n    <tr>\n      <td>DNS-based bypass</td>\n      <td>The agent uses DNS to resolve domains that later point to disallowed IPs, or uses raw IPs to bypass domain rules.</td>\n      <td>Enforce by IP at the network boundary; if you allow domains, resolve and pin to permitted IP ranges where possible.</td>\n    </tr>\n    <tr>\n      <td>Tool-side network access escapes model proxying</td>\n      <td>Even if model calls go through clawproxy, a tool can still call the internet directly.</td>\n      <td>Implement egress enforcement outside clawproxy; treat clawproxy receipts as model-call evidence, not full network coverage.</td>\n    </tr>\n    <tr>\n      <td>Policy drift between environments</td>\n      <td>Dev runs allow broad internet while prod is locked down; incidents become hard to reproduce.</td>\n      <td>Bind job execution to a WPC hash and include the WPC hash in the run metadata so reviewers can compare runs deterministically.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a JSON-like sketch of how teams typically represent egress allowlists in a WPC. The key point is that the allowlist is machine-enforced at runtime and referenced by hash, not described in natural language prompts.</p>\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"control\": \"egress_allowlist\",\n  \"default\": \"deny\",\n  \"allow\": {\n    \"domains\": [\n      { \"pattern\": \"api.openai.com\", \"ports\": [443] },\n      { \"pattern\": \"*.openrouter.ai\", \"ports\": [443] },\n      { \"pattern\": \"github.com\", \"ports\": [443] }\n    ],\n    \"ip_cidrs\": [\n      \"93.184.216.34/32\",\n      \"151.101.0.0/16\"\n    ]\n  },\n  \"deny\": {\n    \"ip_cidrs\": [\n      \"10.0.0.0/8\",\n      \"172.16.0.0/12\",\n      \"192.168.0.0/16\",\n      \"169.254.169.254/32\"\n    ]\n  },\n  \"notes\": \"Enforce at sandbox/egress proxy. Fail closed if enforcement unavailable.\"\n}\n</pre>\n<p>Operationally, you use the WPC hash as the stable identifier. A CST can then be issued with optional policy hash pinning so a job cannot silently switch to a weaker allowlist.</p>\n\n<h2>What proof do you get?</h2>\n<p>For model calls routed through clawproxy, you get Gateway receipts that can be independently verified later. Those receipts can be bundled into a proof bundle with run metadata, including the CST scope hash and the WPC hash you intended to enforce.</p>\n<p>Egress allowlist enforcement itself typically happens outside clawproxy, so “proof of blocked sockets” depends on your enforcement point. In an enterprise buildout, teams commonly attach firewall or egress-proxy decision logs to the same proof bundle so an auditor can see both: (1) the policy (WPC hash) and (2) what was actually attempted and allowed/denied at the network boundary.</p>\n<p>If you publish the run externally, you can store a Trust Pulse artifact for audit viewing. Keep the Trust Pulse content minimal and redact sensitive destinations where required by policy.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback should be safe by construction: when egress policy breaks a workflow, your rollback should be to a known-good WPC hash, not to “open internet”. Keep rollback actions explicit and logged so you can explain why outbound access widened and for how long.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>A needed vendor endpoint is missing</td>\n      <td>Create a new WPC that adds only the required domain or CIDR and pin jobs to the new WPC hash.</td>\n      <td>WPC hash diff plus job CST scope hash showing the new policy binding.</td>\n    </tr>\n    <tr>\n      <td>Enforcement layer is unavailable</td>\n      <td>Fail closed and pause jobs; do not silently run without egress enforcement.</td>\n      <td>Run record indicating job did not start, plus operator change ticket outside the proof bundle (your system of record).</td>\n    </tr>\n    <tr>\n      <td>Incident response needs temporary containment</td>\n      <td>Swap to a restrictive WPC (deny all except essential APIs) and shorten CST lifetimes for new jobs.</td>\n      <td>New WPC hash, CST issuance logs, and proof bundles for affected jobs.</td>\n    </tr>\n    <tr>\n      <td>Suspected exfil attempt</td>\n      <td>Keep the allowlist; rotate secrets and invalidate CSTs; then re-run under the same WPC to reproduce safely.</td>\n      <td>Gateway receipts for model calls, plus any captured egress decision logs attached to the proof bundle.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is policy-as-code required instead of prompt-only instructions?</h3>\n<p>Prompt text does not change OS permissions, network routing, or tool access. If a tool can open a socket, a compromised prompt can still instruct it to exfiltrate data unless the execution layer is permissioned by a machine-enforced policy.</p>\n\n<h3>Is egress allowlisting shipped in Claw EA?</h3>\n<p>Egress allowlists enforced outside clawproxy are optional and are typically implemented at your sandbox or infrastructure boundary. Claw EA shipped primitives help you bind runs to a WPC (policy) and produce verifiable artifacts like Gateway receipts and proof bundles.</p>\n\n<h3>Does clawproxy prove that all network traffic was allowlisted?</h3>\n<p>No. clawproxy produces Gateway receipts for model calls that it handles, not for arbitrary tool egress. For full egress evidence, attach network enforcement logs from your egress proxy or firewall to the proof bundle via an enterprise buildout.</p>\n\n<h3>How does this relate to OpenClaw tool policy and sandboxing?</h3>\n<p>OpenClaw tool policy decides which tools are callable, and sandboxing decides where tools run (for example, in Docker). Egress allowlisting complements those controls by restricting where those tools can talk over the network, ideally at the sandbox boundary.</p>\n\n<h3>What should we allowlist first?</h3>\n<p>Start with the smallest set: only the model API endpoints you need (for example OpenRouter via fal routed through clawproxy) and any required business APIs. Add destinations one by one based on observed failures, and always encode changes as a new WPC hash.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://github.github.com/gh-aw/introduction/architecture/\">Security Architecture | GitHub Agentic Workflows</a></li>\n</ul>",
  "description": "An egress allowlist limits where an agent is permitted to send network traffic, typically by restricting domains and IP ranges at the execution layer. In Claw EA, you define the allowlist as policy-as-code in a WPC and b",
  "faqs": [
    {
      "q": "Why is policy-as-code required instead of prompt-only instructions?",
      "a": "Prompt text does not change OS permissions, network routing, or tool access. If a tool can open a socket, a compromised prompt can still instruct it to exfiltrate data unless the execution layer is permissioned by a machine-enforced policy."
    },
    {
      "q": "Is egress allowlisting shipped in Claw EA?",
      "a": "Egress allowlists enforced outside clawproxy are optional and are typically implemented at your sandbox or infrastructure boundary. Claw EA shipped primitives help you bind runs to a WPC (policy) and produce verifiable artifacts like Gateway receipts and proof bundles."
    },
    {
      "q": "Does clawproxy prove that all network traffic was allowlisted?",
      "a": "No. clawproxy produces Gateway receipts for model calls that it handles, not for arbitrary tool egress. For full egress evidence, attach network enforcement logs from your egress proxy or firewall to the proof bundle via an enterprise buildout."
    },
    {
      "q": "How does this relate to OpenClaw tool policy and sandboxing?",
      "a": "OpenClaw tool policy decides which tools are callable, and sandboxing decides where tools run (for example, in Docker). Egress allowlisting complements those controls by restricting where those tools can talk over the network, ideally at the sandbox boundary."
    },
    {
      "q": "What should we allowlist first?",
      "a": "Start with the smallest set: only the model API endpoints you need (for example OpenRouter via fal routed through clawproxy) and any required business APIs. Add destinations one by one based on observed failures, and always encode changes as a new WPC hash."
    }
  ],
  "sources": [
    {
      "title": "Security Architecture | GitHub Agentic Workflows",
      "uri": "https://github.github.com/gh-aw/introduction/architecture/"
    },
    {
      "title": "Managing access for deployed agents",
      "uri": "https://cloud.google.com/vertex-ai/generative-ai/docs/agent-engine/manage/access"
    },
    {
      "title": "Managing access for deployed agents",
      "uri": "https://cloud.google.com/agent-builder/agent-engine/manage/access"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:08:39.075Z",
  "indexable": true
}