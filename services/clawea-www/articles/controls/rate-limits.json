{
  "slug": "controls/rate-limits",
  "title": "Rate limits and concurrency limits for Agents | Policy-as-Code Control | Claw EA",
  "category": "controls",
  "html": "<p>Rate limits and concurrency limits are a policy-as-code control that caps how fast an agent can call models and how many requests it can run at once. In Claw EA, you express those limits in a WPC and bind them to execution using a CST, so the agent runtime cannot “talk itself out” of the limits with a better prompt.</p>\n<p>OpenClaw is a good baseline runtime for this because it already separates tool policy from sandboxing, but prompt-only controls still fail under load, retries, or prompt injection. The execution layer must be permissioned so the system can reject requests (for example with 429 behavior) even when the model is pushing to continue.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Decide what you are limiting and where you want the limit enforced. Common split: concurrency limits at the gateway edge (per job, per agent, per tenant) and rate limits at the model egress (per model route or per key).</p>\n    <p>Write down targets like “max 4 in-flight model calls per job” and “max 60 requests per minute per agent,” plus what to do on overflow (fail fast vs queue).</p>\n  </li>\n  <li>\n    <p>Encode the limits into a WPC and treat the policy hash as the change control boundary. Keep the policy small and explicit: which agent IDs it applies to, what counters exist, and what the overflow response must be.</p>\n    <p>Store the WPC in the WPC registry and reference it by its hash in your deployment notes and approvals.</p>\n  </li>\n  <li>\n    <p>Issue a CST for the agent job that includes a scope hash for the allowed actions and optionally pins the policy hash to the WPC you just published. This ensures a stolen token cannot be reused broadly, and it prevents a job from silently switching to a looser policy.</p>\n    <p>Use job-scoped CST binding so replays of the same token in a different job context are rejected.</p>\n  </li>\n  <li>\n    <p>Route model traffic through clawproxy so every model call produces gateway receipts. If you are using OpenRouter via fal, keep that routing inside clawproxy so the receipt is still emitted for each request.</p>\n    <p>Make the agent runtime treat 429 responses as a hard “backoff and stop” condition, not as a suggestion to keep trying forever.</p>\n  </li>\n  <li>\n    <p>Configure OpenClaw tool policy and sandbox settings to reduce the blast radius when throttling triggers retries. For example, keep tool execution sandboxed so a retry storm cannot also become a filesystem or process storm on the host.</p>\n    <p>Use OpenClaw’s inspector and security audit routines during rollout to catch common configuration footguns (open inbound triggers, elevated tools, permissive profiles).</p>\n  </li>\n  <li>\n    <p>Capture a proof bundle per job run that includes the gateway receipts, the CST scope hash (and pinned WPC hash if used), and job metadata (agent id, session id, timestamps). Publish the resulting artifact to Trust Pulse for review when you need a human-readable audit trail.</p>\n    <p>On incidents, your first triage step becomes “verify the bundle, confirm which limits were in effect, and identify where overflow occurred.”</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Rate and concurrency controls are not just about cost. They are also about stabilizing execution when the agent faces adversarial inputs, unexpected fan-out, or tool feedback loops.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Retry storm from transient 5xx or timeouts</td>\n      <td>Agent creates a self-inflicted DDoS against your model route or proxy, starving other workloads and spiking spend.</td>\n      <td>Concurrency caps plus fail-fast overflow; enforce at execution boundary via WPC plus CST binding.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection causes fan-out</td>\n      <td>A single inbound message triggers many tool calls (search, browse, summarize), multiplying model calls per user action.</td>\n      <td>Per-job or per-session concurrency and per-minute rate limits; keep OpenClaw tool policy tight so the agent cannot add new tools to “work around” the limit.</td>\n    </tr>\n    <tr>\n      <td>Runaway parallelism in multi-agent workflows</td>\n      <td>Planner spawns sub-agents that all call models concurrently, saturating quotas and causing cascading failures.</td>\n      <td>Tenant-level and job-level in-flight caps; require a distinct CST per job so counters cannot be bypassed by spawning new processes.</td>\n    </tr>\n    <tr>\n      <td>Noisy neighbor across teams</td>\n      <td>One team’s agent load affects others and makes latency unpredictable.</td>\n      <td>Scope limits per org/team baked into WPC, and enforced at the proxy edge with deterministic overflow behavior.</td>\n    </tr>\n    <tr>\n      <td>“Prompt-only policy” bypass</td>\n      <td>The model is instructed to ignore limits, or a different prompt template removes the reminder to throttle.</td>\n      <td>Permissioned execution: the proxy or runtime rejects excess calls regardless of the prompt, and the result is auditable through gateway receipts.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is an intentionally small, JSON-like sketch of what teams usually encode in a WPC. The important part is that limits are machine-checked at the execution layer, and the job’s CST can optionally pin the WPC hash so the policy cannot drift mid-run.</p>\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"agent-rate-and-concurrency-guardrails\",\n  \"applies_to\": {\n    \"agent_ids\": [\"support-triage\", \"invoice-recon\"],\n    \"environments\": [\"prod\"]\n  },\n  \"limits\": {\n    \"model_calls\": {\n      \"max_in_flight_per_job\": 4,\n      \"max_requests_per_minute_per_agent\": 60,\n      \"overflow\": {\n        \"mode\": \"fail_fast\",\n        \"http_status\": 429\n      }\n    }\n  },\n  \"enforcement\": {\n    \"require_cst\": true,\n    \"cst_job_binding\": true,\n    \"optional_policy_hash_pinning\": true\n  },\n  \"audit\": {\n    \"require_gateway_receipts\": true,\n    \"bundle_on_job_close\": true\n  }\n}\n</pre>\n<p>If you also run Microsoft-facing agents, apply the same pattern to outbound calls to Microsoft Graph via official API and limit concurrency per app registration. Pair that with Entra ID Conditional Access and PIM for who can update the WPC and who can mint CSTs, so policy edits do not become an untracked backdoor.</p>\n\n<h2>What proof do you get?</h2>\n<p>For each model call routed through clawproxy you get gateway receipts that can be verified later. Those receipts include enough structured metadata to show which job made the call and when, so an auditor can see whether an overflow condition occurred and how often.</p>\n<p>At the end of a run you can produce a proof bundle that packages the receipts plus job metadata, including the CST scope hash and any pinned WPC hash. For human review, you can store and view the resulting artifact in Trust Pulse, which is useful when you need to compare “policy intended” versus “policy actually enforced.”</p>\n\n<h2>Rollback posture</h2>\n<p>Rate and concurrency controls should be easy to tighten quickly and safe to loosen deliberately. Rollbacks should always preserve verifiability: you want to know which policy version was active for each job, even during an emergency change.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Tighten max in-flight (for example 8 to 4)</td>\n      <td>Publish a new WPC and issue new CSTs pinned to the new WPC hash; let existing jobs complete or stop them explicitly.</td>\n      <td>Proof bundle shows pinned policy hash; gateway receipts show reduced concurrency after cutover.</td>\n    </tr>\n    <tr>\n      <td>Loosen request rate temporarily</td>\n      <td>Time-box the policy change and require approval for CST issuance; avoid editing an existing WPC in place.</td>\n      <td>Two distinct WPC hashes in Trust Pulse with timestamps; job-scoped CST binding prevents replay across the window.</td>\n    </tr>\n    <tr>\n      <td>Disable throttling during incident triage</td>\n      <td>Prefer raising caps rather than removing enforcement entirely; keep receipts on so you can reconstruct impact later.</td>\n      <td>Gateway receipts remain continuous; proof bundles remain verifiable even if limits were higher.</td>\n    </tr>\n    <tr>\n      <td>Change agent behavior to reduce load</td>\n      <td>Adjust OpenClaw tool policy and skill prompts, but treat these as secondary controls that do not replace enforcement.</td>\n      <td>OpenClaw configuration change records plus the same proxy receipts demonstrate whether behavior actually changed.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>What is the difference between rate limits and concurrency limits?</h3>\n<p>Rate limits cap how many requests happen over time (for example per minute). Concurrency limits cap how many requests can be in flight at the same moment, which is what prevents bursty parallel fan-out.</p>\n\n<h3>Why can’t we just instruct the agent to “go slower” in the prompt?</h3>\n<p>Prompts are not enforcement. Under retries, injection, or “helpful” behavior, the model will still attempt extra calls unless the execution layer rejects them.</p>\n\n<h3>Where should limits be enforced in an OpenClaw deployment?</h3>\n<p>Keep the agent’s local tool execution constrained using OpenClaw tool policy and sandbox settings, and enforce model-call limits at the proxy boundary. That keeps limits consistent across agents and produces uniform gateway receipts for audit.</p>\n\n<h3>How do WPC and CST work together for throttling?</h3>\n<p>The WPC defines the rules, and the CST is the job credential that can carry a scope hash and optionally pin a specific policy hash. That combination makes policy selection explicit and limits the blast radius of token reuse.</p>\n\n<h3>What does an auditor actually verify?</h3>\n<p>They verify gateway receipts and the proof bundle, then check that the job’s CST scope hash and pinned WPC hash match the policy that was approved. If throttling was triggered, the receipts show the timing and the overflow outcomes.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/api-management/limit-concurrency-policy\">Azure API Management policy reference: limit-concurrency</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/api-management/azure-openai-token-limit-policy\">Azure API Management policy reference: azure-openai-token-limit</a></li>\n</ul>",
  "description": "Rate limits and concurrency limits are a policy-as-code control that caps how fast an agent can call models and how many requests it can run at once. In Claw EA, you express those limits in a WPC and bind them to executi",
  "faqs": [
    {
      "q": "What is the difference between rate limits and concurrency limits?",
      "a": "Rate limits cap how many requests happen over time (for example per minute). Concurrency limits cap how many requests can be in flight at the same moment, which is what prevents bursty parallel fan-out."
    },
    {
      "q": "Why can’t we just instruct the agent to “go slower” in the prompt?",
      "a": "Prompts are not enforcement. Under retries, injection, or “helpful” behavior, the model will still attempt extra calls unless the execution layer rejects them."
    },
    {
      "q": "Where should limits be enforced in an OpenClaw deployment?",
      "a": "Keep the agent’s local tool execution constrained using OpenClaw tool policy and sandbox settings, and enforce model-call limits at the proxy boundary. That keeps limits consistent across agents and produces uniform gateway receipts for audit."
    },
    {
      "q": "How do WPC and CST work together for throttling?",
      "a": "The WPC defines the rules, and the CST is the job credential that can carry a scope hash and optionally pin a specific policy hash. That combination makes policy selection explicit and limits the blast radius of token reuse."
    },
    {
      "q": "What does an auditor actually verify?",
      "a": "They verify gateway receipts and the proof bundle, then check that the job’s CST scope hash and pinned WPC hash match the policy that was approved. If throttling was triggered, the receipts show the timing and the overflow outcomes."
    }
  ],
  "sources": [
    {
      "title": "Limit concurrency",
      "uri": "https://learn.microsoft.com/en-us/azure/api-management/limit-concurrency-policy"
    },
    {
      "title": "Azure API Management policy reference - azure-openai-token-limit",
      "uri": "https://learn.microsoft.com/en-us/azure/api-management/azure-openai-token-limit-policy"
    },
    {
      "title": "Amazon Bedrock AgentCore Policy: Control Agent-to-Tool Interactions",
      "uri": "https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/policy.html"
    },
    {
      "title": "AI agents in enterprises: Best practices with Amazon Bedrock ...",
      "uri": "https://aws.amazon.com/blogs/machine-learning/ai-agents-in-enterprises-best-practices-with-amazon-bedrock-agentcore/"
    },
    {
      "title": "Quotas",
      "uri": "https://cloud.google.com/agent-assist/docs/quotas"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:13:20.407Z",
  "indexable": true
}