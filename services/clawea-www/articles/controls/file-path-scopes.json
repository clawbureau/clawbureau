{
  "slug": "controls/file-path-scopes",
  "title": "File path read/write scopes for Agents | Policy-as-Code Control | Claw EA",
  "category": "controls",
  "html": "<h2>Direct Answer</h2>\n<p>File path read/write scopes are machine-enforced rules that constrain what an agent can read from disk and where it can write, down to specific directories and patterns. In Claw EA, you treat these rules as policy-as-code so they are enforced at execution time, not “requested” via a prompt.</p>\n<p>This matters because prompt-only controls do not survive prompt injection, tool misuse, or a plugin that ignores instructions. With OpenClaw as the baseline agent runtime, you can combine sandboxing, tool policy, and a signed WPC to make filesystem access predictable and auditable.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Inventory the agent’s real file needs by task. Split into read scopes (inputs, templates, reference docs) and write scopes (outputs, reports, patches), and list exact paths for each environment.</p>\n  </li>\n  <li>\n    <p>Decide your boundary: host or sandbox. Prefer running file tools in an OpenClaw sandbox (Docker) and only mount the minimum directories required, explicitly setting <span>ro</span> or <span>rw</span> on each bind mount.</p>\n  </li>\n  <li>\n    <p>Reduce the available tool surface. In OpenClaw, keep your tool profile tight and deny any file or shell tools you do not need, because unrestricted exec can bypass file policies by generating new tooling paths.</p>\n  </li>\n  <li>\n    <p>Write a WPC = Work Policy Contract that declares allowed read and write path patterns, plus explicit denies for high-risk locations. Store the WPC in the WPC registry (served by clawcontrols) so the policy is a signed, hash-addressed artifact.</p>\n  </li>\n  <li>\n    <p>Issue a CST = scoped token (issued by clawscope) for the job, including the scope hash and optionally pinning the policy hash. Use marketplace anti-replay binding (job-scoped CST binding) so a CST cannot be reused outside the intended run.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy so you get gateway receipts for model calls. This gives you verification-grade evidence of which model requests were made under which CST and policy context.</p>\n  </li>\n  <li>\n    <p>At the end of the run, export the proof bundle and store it for audit, optionally publishing to Trust Pulse for viewing. If you need per-file open/read/write telemetry, implement it in your OpenClaw tool wrappers and include the resulting logs as additional artifacts alongside the proof bundle.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>File scopes primarily prevent “local data spill” and “local persistence” failures, where an agent reads secrets or writes into sensitive areas. They also reduce lateral movement when a tool or plugin is compromised, because the allowed filesystem surface is small.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection asks the agent to read secrets</td>\n      <td>The agent attempts to read SSH keys, cloud credentials, browser profiles, or <span>.env</span> files and exfiltrate them.</td>\n      <td>Default-deny read scopes with explicit allowlists; keep secrets outside any mounted sandbox binds; avoid mounting home directories.</td>\n    </tr>\n    <tr>\n      <td>Path traversal and wildcard abuse</td>\n      <td>The agent targets <span>../</span> or broad globs to escape intended directories.</td>\n      <td>Normalize paths and enforce prefix checks; disallow relative paths; use explicit patterns and deny rules for parent traversal tokens.</td>\n    </tr>\n    <tr>\n      <td>Symlink escape</td>\n      <td>A path inside an allowed directory is a symlink to a disallowed location, causing reads or writes to land outside the scope.</td>\n      <td>Resolve realpath before authorization; disallow symlink following for sensitive tools; enforce “no symlink” in write targets.</td>\n    </tr>\n    <tr>\n      <td>Persistence by writing into startup or config locations</td>\n      <td>The agent writes to shell rc files, scheduled tasks, service definitions, or app plugin directories.</td>\n      <td>Explicit deny list for known persistence locations; write scopes restricted to a dedicated output directory; sandboxed execution.</td>\n    </tr>\n    <tr>\n      <td>Log and artifact poisoning</td>\n      <td>The agent overwrites evidence files, modifies logs, or replaces a report after review.</td>\n      <td>Separate write scopes for outputs vs evidence; append-only log strategy (can be implemented); store proof bundles out-of-band.</td>\n    </tr>\n  </tbody>\n</table>\n<p>On Windows fleets, pair path scopes with NTFS ACLs and separate service accounts to ensure the OS denies access even if a tool is misconfigured. In Microsoft environments, identity controls like Entra ID Conditional Access and PIM apply to interactive access and admin elevation, but they do not replace per-job file scopes inside the agent runtime.</p>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows a compact, JSON-like policy shape you can carry as a WPC and translate into OpenClaw sandbox binds plus tool-level checks. Keep it explicit: list what is allowed, then deny the rest.</p>\n<pre>{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"agent-file-scopes:v3\",\n  \"target_runtime\": \"openclaw\",\n  \"filesystem\": {\n    \"read_allow\": [\n      \"/workspace/input/**\",\n      \"/workspace/templates/**\",\n      \"C:\\\\\\\\agent\\\\\\\\input\\\\\\\\**\"\n    ],\n    \"write_allow\": [\n      \"/workspace/output/**\",\n      \"C:\\\\\\\\agent\\\\\\\\output\\\\\\\\**\"\n    ],\n    \"deny\": [\n      \"/home/**/.ssh/**\",\n      \"/etc/**\",\n      \"/proc/**\",\n      \"/var/run/docker.sock\",\n      \"C:\\\\\\\\Users\\\\\\\\**\\\\\\\\.ssh\\\\\\\\**\",\n      \"C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\**\"\n    ],\n    \"rules\": {\n      \"require_absolute_paths\": true,\n      \"resolve_realpath_before_check\": true,\n      \"deny_symlink_write_targets\": true\n    }\n  },\n  \"openclaw\": {\n    \"sandbox\": {\n      \"mode\": \"all\",\n      \"workspaceAccess\": \"rw\",\n      \"docker_binds\": [\n        { \"host\": \"/srv/agent/input\",  \"container\": \"/workspace/input\",  \"mode\": \"ro\" },\n        { \"host\": \"/srv/agent/output\", \"container\": \"/workspace/output\", \"mode\": \"rw\" }\n      ]\n    },\n    \"tools\": {\n      \"deny\": [\"elevated.exec\"],\n      \"allow\": [\"read\", \"write\", \"edit\", \"apply_patch\"]\n    }\n  }\n}</pre>\n<p>Operationally, treat the WPC hash as the stable identifier. Your deployment should fetch and verify the WPC from clawcontrols, then configure the runtime from that artifact so “what was enforced” is deterministic.</p>\n\n<h2>What proof do you get?</h2>\n<p>For model traffic, clawproxy emits gateway receipts for model calls. Those receipts can be bundled with job metadata into a proof bundle, so an auditor can verify which model calls occurred under a specific CST and the pinned WPC hash.</p>\n<p>For filesystem controls, the proof you can always show is the policy artifact itself: the signed, hash-addressed WPC plus the CST scope hash and optional policy hash pinning. If you need per-operation evidence like “file X was written at time Y,” implement file tool wrappers that log allowed and denied accesses and include those logs as additional artifacts alongside the proof bundle.</p>\n<p>Where appropriate, publish the proof bundle to Trust Pulse for storage and viewing. Keep the policy hash, CST identifiers, and receipt IDs consistent across your incident response workflow so you can answer “what ran under what rules” without reconstructing state from prompts.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback for file scope controls should be fail-closed. When something goes wrong, your safest move is to reduce write permissions, rotate the CST, and rerun under a tighter WPC rather than trying to “undo” unknown writes.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Agent wrote to an unexpected directory</td>\n      <td>Update the WPC to remove the write scope, re-issue a CST pinned to the new policy hash, and rerun in a fresh workspace/output directory.</td>\n      <td>New WPC hash in the WPC registry; CST scope hash; proof bundle showing the change boundary.</td>\n    </tr>\n    <tr>\n      <td>Suspected secret exposure via local reads</td>\n      <td>Move secrets out of any mounted paths, tighten read scopes to a minimal input directory, and rotate impacted credentials outside the agent system.</td>\n      <td>WPC deny rules; OpenClaw sandbox bind list (as config artifact); gateway receipts showing what model calls occurred during the window.</td>\n    </tr>\n    <tr>\n      <td>Need to temporarily allow a new output path for a hotfix</td>\n      <td>Create a short-lived WPC variant that adds a single write path and expires operationally by issuing a short-TTL CST, then revert to the prior WPC hash after the run.</td>\n      <td>Two WPC hashes (before and after); job-scoped CST binding; proof bundles for both runs.</td>\n    </tr>\n    <tr>\n      <td>Tooling bypass attempt via elevated execution</td>\n      <td>Keep <span>tools.elevated</span> denied by default; if it must exist, gate it behind separate operational approvals (can be implemented) and isolate it to a break-glass agent profile.</td>\n      <td>OpenClaw effective tool policy via inspection; WPC policy that denies elevated exec; proof bundle tying the run to that policy hash.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n<h3>Why are prompt instructions not enough for file safety?</h3>\n<p>Because the model can be induced to ignore them, and tools can be invoked in ways your prompt did not anticipate. Policy-as-code makes the runtime deny the operation even if the model requests it.</p>\n\n<h3>Should I enforce file scopes in the sandbox, the tool layer, or both?</h3>\n<p>Both when possible. Use the sandbox to reduce what the process can see, and use tool-layer checks to enforce exact path rules and to handle cases like symlink resolution.</p>\n\n<h3>How do I handle Windows paths and mixed OS fleets?</h3>\n<p>Write OS-specific allowlists and deny lists, and keep the effective policy explicit per environment. On Windows, also rely on NTFS ACLs to ensure the OS denies access even if an agent tool is misconfigured.</p>\n\n<h3>Can an agent still leak data if it can read allowed files?</h3>\n<p>Yes, it can summarize or copy allowed content into outputs or model messages. File scopes reduce what can be read, and clawproxy gateway receipts give you evidence of model calls, but you still need data classification and redaction decisions for what enters the workspace.</p>\n\n<h3>What is the minimum audit package I should retain?</h3>\n<p>Retain the WPC artifact (by hash), the CST scope hash and any policy hash pinning, and the proof bundle containing gateway receipts for model calls. If you add file access logs, retain them as immutable artifacts referenced by the same job metadata.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security</a></li>\n  <li><a href=\"https://openpolicyagent.org/docs/latest/policy-reference\">Policy Reference | Open Policy Agent</a></li>\n</ul>",
  "description": "File path read/write scopes are machine-enforced rules that constrain what an agent can read from disk and where it can write, down to specific directories and patterns. In Claw EA, you treat these rules as policy-as-cod",
  "faqs": [
    {
      "q": "Why are prompt instructions not enough for file safety?",
      "a": "Because the model can be induced to ignore them, and tools can be invoked in ways your prompt did not anticipate. Policy-as-code makes the runtime deny the operation even if the model requests it."
    },
    {
      "q": "Should I enforce file scopes in the sandbox, the tool layer, or both?",
      "a": "Both when possible. Use the sandbox to reduce what the process can see, and use tool-layer checks to enforce exact path rules and to handle cases like symlink resolution."
    },
    {
      "q": "How do I handle Windows paths and mixed OS fleets?",
      "a": "Write OS-specific allowlists and deny lists, and keep the effective policy explicit per environment. On Windows, also rely on NTFS ACLs to ensure the OS denies access even if an agent tool is misconfigured."
    },
    {
      "q": "Can an agent still leak data if it can read allowed files?",
      "a": "Yes, it can summarize or copy allowed content into outputs or model messages. File scopes reduce what can be read, and clawproxy gateway receipts give you evidence of model calls, but you still need data classification and redaction decisions for what enters the workspace."
    },
    {
      "q": "What is the minimum audit package I should retain?",
      "a": "Retain the WPC artifact (by hash), the CST scope hash and any policy hash pinning, and the proof bundle containing gateway receipts for model calls. If you add file access logs, retain them as immutable artifacts referenced by the same job metadata."
    }
  ],
  "sources": [
    {
      "title": "Policy Reference | Open Policy Agent",
      "uri": "https://openpolicyagent.org/docs/latest/policy-reference"
    },
    {
      "title": "Some notes on AI Agent Rule / Instruction / Context files / etc · GitHub",
      "uri": "https://gist.github.com/0xdevalias/f40bc5a6f84c4c5ad862e314894b2fa6"
    },
    {
      "title": "Managing access for deployed agents",
      "uri": "https://docs.cloud.google.com/agent-builder/agent-engine/manage/access"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:09:44.094Z",
  "indexable": true
}