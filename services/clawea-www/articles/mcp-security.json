{
  "slug": "mcp-security",
  "title": "MCP Security for Enterprise Agents | Claw EA",
  "category": "pillars",
  "html": "<h2>Direct Answer</h2>\n<p>MCP security for enterprise agents comes down to one rule: treat every MCP tool as a production capability with its own authorization, audit trail, and rollback plan. Prompt-only “don’t do bad things” controls fail because the model can be tricked, the context can be spoofed, and the tool surface is often broader than you think.</p>\n<p>Claw EA runs OpenClaw as the baseline agent runtime and adds a permissioned execution layer: WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols), CST = scoped token (issued by clawscope), gateway receipts (from clawproxy), and proof bundles. The goal is to make MCP tool usage verifiable, minimally scoped, and easy to disable safely when something goes wrong.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Inventory MCP servers and classify tool actions.</strong> List every MCP server your OpenClaw agents can reach (local and remote), then group tools into read-only, write, and irreversible actions (payments, deletes, role changes). This classification becomes the input to your policy and token scopes.</p>\n  </li>\n  <li>\n    <p><strong>Define a WPC that expresses the allowed MCP tool surface.</strong> Use a WPC to pin what tools are callable, under what conditions (environment, job type), and what data classes are permitted. Keep the first policy narrow, then widen only when you have proof that the agent needs it.</p>\n  </li>\n  <li>\n    <p><strong>Issue CST per job and pin the policy hash.</strong> For each agent job, mint a CST with a scope hash and (optionally) policy hash pinning so the runtime cannot silently expand privileges mid-run. Use short CST lifetimes and job-scoped binding to reduce replay risk.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy to produce gateway receipts.</strong> Put clawproxy on the model egress path so you get signed gateway receipts for each model call used during tool planning and tool execution. This is your “what did the model see and decide” evidence when an incident happens.</p>\n  </li>\n  <li>\n    <p><strong>Run OpenClaw with tool policy and sandboxing aligned to the WPC.</strong> OpenClaw already separates sandbox (where tools run) from tool policy (which tools exist) and elevated execution (host escape hatch). Configure OpenClaw so local execution is constrained even if an MCP tool misbehaves or the model is prompt-injected.</p>\n  </li>\n  <li>\n    <p><strong>Collect proof bundles for every job that can change state.</strong> Generate a proof bundle that ties together the WPC reference, the CST scope hash, and gateway receipts. Store the bundle for review and later verification, and publish to Trust Pulse when you need a marketplace-stored artifact for audit/viewing.</p>\n  </li>\n  <li>\n    <p><strong>Practice rollback and kill switches.</strong> Predefine which MCP tools can be globally disabled by policy, which require human approval in your surrounding systems, and which require enterprise buildout to safely mediate. The safe posture is “fail closed” when policy cannot be fetched or verified.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>MCP changes the attack surface from “bad answer in a chat” to “untrusted instructions that can invoke real tools.” Your security plan should assume prompt injection, context spoofing, mis-scoped credentials, and tool servers that return malicious outputs.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Confused deputy via MCP tool chaining</td>\n      <td>The agent is tricked into using a high-privilege tool to act on attacker-supplied targets (emails, URLs, tenants, repos).</td>\n      <td>Express allowed targets and action classes in a WPC; issue per-job CST with scope hash; prefer narrow tools over general “http_request” style tools.</td>\n    </tr>\n    <tr>\n      <td>Context spoofing from an MCP server</td>\n      <td>An MCP server returns “trusted looking” context that causes the model to authorize actions it should not take.</td>\n      <td>Treat MCP outputs as untrusted; require explicit allowlisted tool calls in policy; use OpenClaw tool policy to deny generic executors unless needed.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection via documents or tickets</td>\n      <td>Untrusted text instructs the agent to exfiltrate secrets, expand permissions, or disable logging.</td>\n      <td>Permissioned execution (WPC + CST) so the model cannot grant itself tools; run OpenClaw tools in sandbox where possible; keep elevated execution tightly gated.</td>\n    </tr>\n    <tr>\n      <td>Credential overbreadth in enterprise identity systems</td>\n      <td>A token with broad Microsoft Graph permissions (or other vendor scopes) enables unintended data access and write actions.</td>\n      <td>Use least-privilege permissions and Conditional Access plus PIM where applicable; map the effective permission set into the WPC and keep CST scopes narrower than the underlying identity token.</td>\n    </tr>\n    <tr>\n      <td>Replay of an agent run token</td>\n      <td>A captured token is reused to rerun actions out of band, potentially against new targets.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding; short CST TTLs; pin policy hash so a replay cannot be combined with a broader policy.</td>\n    </tr>\n    <tr>\n      <td>Audit gaps when model calls bypass the proxy</td>\n      <td>Some model calls happen “direct,” leaving no evidence of what the agent was instructed by the model.</td>\n      <td>Route model calls through clawproxy to emit gateway receipts; treat missing receipts as a verification failure for regulated jobs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a simplified JSON-like sketch of a WPC that governs MCP tools. In practice, a WPC is a signed, hash-addressed policy artifact served by clawcontrols, and you pin its hash when issuing a CST.</p>\n\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"policy_name\": \"mcp-enterprise-agent-minimal\",\n  \"allowed_tools\": [\n    { \"kind\": \"mcp\", \"server\": \"crm-mcp\", \"tools\": [\"search_customer\", \"get_case\"] },\n    { \"kind\": \"mcp\", \"server\": \"tickets-mcp\", \"tools\": [\"read_ticket\", \"comment_ticket\"] }\n  ],\n  \"denied_tools\": [\n    { \"kind\": \"mcp\", \"server\": \"*\", \"tools\": [\"http_request\", \"shell\", \"file_write\"] }\n  ],\n  \"data_classes\": {\n    \"allow\": [\"internal\", \"customer_provided\"],\n    \"deny\": [\"secrets\", \"credentials\", \"payment_instruments\"]\n  },\n  \"model_egress\": {\n    \"require_proxy_receipts\": true,\n    \"provider\": \"openrouter_via_fal\"\n  },\n  \"token_constraints\": {\n    \"cst_max_ttl_seconds\": 900,\n    \"require_scope_hash\": true,\n    \"policy_hash_pinning\": \"required\"\n  }\n}\n</pre>\n\n<p>The key design choice is that tools are authorized by machine-enforced policy, not by natural-language instructions. Prompts help the agent do the job, but they do not decide what the job is allowed to do.</p>\n\n<h2>What proof do you get?</h2>\n<p>For MCP-governed work, you want proof that (1) the agent ran under a specific policy, (2) the policy could not be silently widened, and (3) the model calls used to plan actions are auditable. Claw Bureau primitives are built around those needs.</p>\n<p>Gateway receipts are signed receipts emitted by clawproxy for model calls, so you can later verify what model endpoint was used and when. A proof bundle packages the receipts plus related metadata for audit/verification, including the CST scope hash and (when used) the pinned WPC hash.</p>\n<p>If you need an artifact that can be viewed and shared in a controlled way, you can store the result as a Trust Pulse. For external verification workflows, the proof bundle is the portable unit you hand to a verifier or auditor.</p>\n\n<h2>Rollback posture</h2>\n<p>MCP incidents are usually not “the agent went rogue,” they are “a tool had too much power” or “a context source was untrusted.” Rollback needs to be operational: disable capabilities quickly, preserve evidence, and restart with narrower scopes.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Suspect an MCP server is returning malicious context</td>\n      <td>Update WPC to deny that MCP server’s tools; reissue CST for affected jobs; rerun only read-only workflows until validated.</td>\n      <td>Proof bundle showing the prior WPC hash and the gateway receipts for model calls during the incident window.</td>\n    </tr>\n    <tr>\n      <td>Tool permissions found too broad (ex: write actions enabled)</td>\n      <td>Create a narrower WPC, pin it for new CST issuance, and rotate underlying vendor credentials via official API procedures.</td>\n      <td>Diff of WPC versions by hash; job-scoped CST binding limits replay; receipts show which model calls led to tool invocation.</td>\n    </tr>\n    <tr>\n      <td>Model egress bypass detected</td>\n      <td>Fail closed for regulated jobs until egress is routed through clawproxy; for emergency continuity, run read-only jobs only.</td>\n      <td>Absence of gateway receipts is itself a detection signal; subsequent runs produce receipts for comparison.</td>\n    </tr>\n    <tr>\n      <td>Need to invalidate active runs quickly</td>\n      <td>Revoke CST issuance at clawscope and deny the WPC for new jobs; restart runs with new CST and updated policy.</td>\n      <td>Proof bundles for completed jobs remain verifiable; revoked tokens stop new work from continuing under the old scope.</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Some controls are commonly implemented around this core, but are not assumed shipped in all deployments. For example: egress allowlists enforced outside clawproxy can be implemented, and automatic cost budget enforcement is planned.</p>\n\n<h2>FAQ</h2>\n\n<h3>Why is prompt-only security not enough for MCP tools?</h3>\n<p>Because MCP turns text into actions, and the model can be manipulated by prompt injection, context spoofing, or tool outputs. A permissioned execution layer uses WPC and CST so that even a tricked model cannot exceed the allowed tool surface.</p>\n\n<h3>What is the minimal policy you recommend for first MCP deployments?</h3>\n<p>Start with read-only tools and a short-lived CST per job, with policy hash pinning. Deny generic executors and any tool that can exfiltrate arbitrary data until you have a concrete, reviewed need.</p>\n\n<h3>How does this relate to OpenClaw sandboxing and tool policy?</h3>\n<p>OpenClaw controls where tools run (sandbox), which tools are available (tool policy), and whether any execution can escape to host (elevated). Your WPC should align with those settings so the local runtime boundary matches the remote authorization boundary.</p>\n\n<h3>How do you handle Microsoft environments without over-granting access?</h3>\n<p>Use least-privilege Microsoft Graph permissions/scopes, and apply Conditional Access and PIM where appropriate. Then ensure the agent’s CST and WPC are narrower than the underlying identity grants, so the agent can only exercise a reviewed subset of capabilities.</p>\n\n<h3>What artifacts should I retain for audit after an MCP incident?</h3>\n<p>Retain the proof bundle for the affected jobs, including gateway receipts, the CST scope hash, and the referenced WPC hash. That lets you show what policy was in force and what model calls occurred, even if you later rotate credentials.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://modelcontextprotocol.io/docs/tutorials/security/security_best_practices\">Security Best Practices - Model Context Protocol</a></li>\n  <li><a href=\"https://owasp.org/www-project-mcp-top-10/\">OWASP MCP Top 10</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/copilot/security/developer/mcp-overview\">Security Copilot Model Context Protocol</a></li>\n</ul>",
  "description": "MCP security for enterprise agents comes down to one rule: treat every MCP tool as a production capability with its own authorization, audit trail, and rollback plan. Prompt-only “don’t do bad things” controls fail becau",
  "faqs": [
    {
      "q": "Why is prompt-only security not enough for MCP tools?",
      "a": "Because MCP turns text into actions, and the model can be manipulated by prompt injection, context spoofing, or tool outputs. A permissioned execution layer uses WPC and CST so that even a tricked model cannot exceed the allowed tool surface."
    },
    {
      "q": "What is the minimal policy you recommend for first MCP deployments?",
      "a": "Start with read-only tools and a short-lived CST per job, with policy hash pinning. Deny generic executors and any tool that can exfiltrate arbitrary data until you have a concrete, reviewed need."
    },
    {
      "q": "How does this relate to OpenClaw sandboxing and tool policy?",
      "a": "OpenClaw controls where tools run (sandbox), which tools are available (tool policy), and whether any execution can escape to host (elevated). Your WPC should align with those settings so the local runtime boundary matches the remote authorization boundary."
    },
    {
      "q": "How do you handle Microsoft environments without over-granting access?",
      "a": "Use least-privilege Microsoft Graph permissions/scopes, and apply Conditional Access and PIM where appropriate. Then ensure the agent’s CST and WPC are narrower than the underlying identity grants, so the agent can only exercise a reviewed subset of capabilities."
    },
    {
      "q": "What artifacts should I retain for audit after an MCP incident?",
      "a": "Retain the proof bundle for the affected jobs, including gateway receipts, the CST scope hash, and the referenced WPC hash. That lets you show what policy was in force and what model calls occurred, even if you later rotate credentials."
    }
  ],
  "sources": [
    {
      "title": "OWASP MCP Top 10",
      "uri": "https://owasp.org/www-project-mcp-top-10/"
    },
    {
      "title": "Security Best Practices - Model Context Protocol",
      "uri": "https://modelcontextprotocol.io/docs/tutorials/security/security_best_practices"
    },
    {
      "title": "Enhancing GitHub Copilot agent mode with MCP - GitHub Enterprise Cloud Docs",
      "uri": "https://docs.github.com/en/enterprise-cloud@latest/copilot/tutorials/enhance-agent-mode-with-mcp"
    },
    {
      "title": "Security Copilot Model Context Protocol",
      "uri": "https://learn.microsoft.com/en-us/copilot/security/developer/mcp-overview"
    },
    {
      "title": "What is Model Context Protocol (MCP)? A guide - Google Cloud",
      "uri": "https://cloud.google.com/discover/what-is-model-context-protocol"
    },
    {
      "title": "What Is MCP? A Simple Guide to Model Context Protocol for ...",
      "uri": "https://admin.salesforce.com/blog/2025/what-is-mcp-a-simple-guide-to-model-context-protocol-for-salesforce-admins"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:46:17.131Z",
  "indexable": true
}