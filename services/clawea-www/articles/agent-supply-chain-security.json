{
  "slug": "agent-supply-chain-security",
  "title": "Agent Supply Chain Security (Skills, Plugins, MCP) | Claw EA",
  "category": "pillars",
  "html": "<h2>Direct Answer</h2>\n<p>Agent supply chain security is about making skills, plugins, and MCP servers behave like production dependencies: pinned, permissioned, and auditable. In OpenClaw, prompts and skills are easy to change, but the risk lives in executable tools and extensions, so you need a permissioned execution layer backed by policy-as-code, not prompt-only rules.</p>\n<p>Claw EA adds an enforcement and proof layer around OpenClaw: a WPC (Work Policy Contract) defines what is allowed, a CST (scoped token) limits what the runtime can call, clawproxy emits gateway receipts for model calls, and each job can produce a proof bundle for later verification.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Inventory what can execute. Split inputs into three buckets: (1) skills (docs and guidance), (2) plugins/extensions (code that runs), and (3) MCP servers (local or remote tool providers via MCP server).</p>\n    <p>Treat skills as changeable text and treat plugins and MCP servers as code dependencies that can exfiltrate data or expand tool reach.</p>\n  </li>\n  <li>\n    <p>Set a baseline OpenClaw safety posture. Run OpenClaw’s security audit regularly and treat any “open room + elevated tools” finding as a release blocker for enterprise environments.</p>\n    <p>Confirm sandbox mode and tool policy are explicit, not inherited defaults, and ensure plugins are not implicitly enabled without an allowlist.</p>\n  </li>\n  <li>\n    <p>Define a WPC for your agent job class. Put concrete constraints in the WPC: allowed tool families, model routing expectations, and any required redaction posture.</p>\n    <p>Store the signed WPC in the WPC registry and use hash addressing so you can pin exactly what policy was used for any run.</p>\n  </li>\n  <li>\n    <p>Issue a CST for the run and pin the policy hash when needed. The CST (from clawscope) carries a scope hash and can include optional policy hash pinning so the runtime cannot swap policies mid-flight.</p>\n    <p>Use job-scoped CST binding to reduce replay risk if a token leaks or is copied between runs.</p>\n  </li>\n  <li>\n    <p>Route model calls through clawproxy. Configure the OpenClaw provider so model traffic goes through clawproxy, which emits gateway receipts for model calls.</p>\n    <p>If you use OpenRouter via fal, route it through clawproxy so receipts cover the model call boundary you actually depend on.</p>\n  </li>\n  <li>\n    <p>Lock down plugin and MCP permissions with policy-as-code. Prompt-only controls fail because a compromised plugin or MCP server can ignore instructions and directly call tools; you need machine-enforced allow/deny and sandbox boundaries.</p>\n    <p>As a rule: permissions come from the WPC and OpenClaw tool policy, not from what a skill says is “allowed”.</p>\n  </li>\n  <li>\n    <p>Produce and store proof. For each job, emit a proof bundle that includes gateway receipts and binding metadata, then store or publish a Trust Pulse for audit viewing when appropriate.</p>\n    <p>Make proof retention a deployment decision: keep full bundles for incident response, and keep lightweight indices for routine compliance checks.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Supply chain issues in agent systems rarely look like classic package compromise only. They also show up as tool surface drift, silent permission creep, and context misbinding where the model or tool thinks it is operating under one policy while execution actually happens under another.</p>\n<p>The table below focuses on skills, plugins, and MCP servers because they are where “helpful” updates can become executable behavior changes.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Malicious plugin update</td>\n      <td>A plugin release adds hidden network calls or expands tool invocation patterns. The agent still “looks normal” in chat while behavior changes under the hood.</td>\n      <td>Pin plugin versions in deployment and require a WPC that explicitly limits tool families. Use sandboxing for tool execution to reduce host access, and keep an allowlist for enabled extensions.</td>\n    </tr>\n    <tr>\n      <td>MCP server dependency tampering</td>\n      <td>An MCP server (or its dependencies) changes protocol semantics or tool outputs, leading to unsafe actions or data leakage.</td>\n      <td>Treat MCP servers as code: deploy from controlled artifacts, restrict which tools are exposed, and require policy-as-code enforcement. Track MCP-related supply chain risks using OWASP MCP guidance.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection into “skill” content</td>\n      <td>A skill or retrieved doc includes instructions that cause the model to request dangerous tools or bypass normal review patterns.</td>\n      <td>Do not encode permissions in skills. Enforce tool allow/deny in OpenClaw tool policy plus a WPC, and ensure dangerous tools remain unavailable even if the model requests them.</td>\n    </tr>\n    <tr>\n      <td>Policy swap or config drift</td>\n      <td>A run starts under one intended policy but ends up executing with looser tool settings after a config change, restart, or operator mistake.</td>\n      <td>Use a WPC hash address and optional policy hash pinning in the CST so the execution context is bound to the expected policy artifact.</td>\n    </tr>\n    <tr>\n      <td>Token replay across jobs</td>\n      <td>A leaked token is reused to perform actions outside the original run context.</td>\n      <td>Use marketplace anti-replay binding with job-scoped CST binding, and rotate CSTs per job rather than per environment.</td>\n    </tr>\n    <tr>\n      <td>Unintended host execution</td>\n      <td>Sandbox is disabled or “elevated” execution is enabled, turning a tool call into host-level file or process access.</td>\n      <td>Use OpenClaw sandbox mode intentionally and audit elevated usage. Require a WPC that forbids elevated tools for high-risk channels and enforce a minimal tool profile.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the intent: a single policy artifact (WPC) defines the job’s allowed capabilities, and the CST is pinned to that policy hash. Keep the policy small, explicit, and stable enough that a reviewer can reason about it.</p>\n\n<pre>\n{\n  \"wpc_ref\": \"wpc:sha256:BASE64URL_HASH\",\n  \"job\": {\n    \"id\": \"job_2026_02_11_001\",\n    \"purpose\": \"triage support tickets and draft replies\"\n  },\n  \"execution\": {\n    \"sandbox_required\": true,\n    \"tools\": {\n      \"allow\": [\"read\", \"write\", \"http\", \"ticketing.lookup\"],\n      \"deny\": [\"exec\", \"process\", \"browser.control\", \"secrets.dump\"]\n    },\n    \"models\": {\n      \"route_via\": \"clawproxy\",\n      \"provider\": \"openrouter_via_fal\"\n    }\n  },\n  \"auth\": {\n    \"cst\": {\n      \"scope_hash\": \"BASE64URL_SCOPE_HASH\",\n      \"policy_hash_pinning\": \"wpc:sha256:BASE64URL_HASH\",\n      \"job_scoped_binding\": true\n    }\n  },\n  \"audit\": {\n    \"require_gateway_receipts\": true,\n    \"emit_proof_bundle\": true\n  }\n}\n</pre>\n\n<p>Prompt-only rules cannot guarantee enforcement when a plugin, MCP server, or tool wrapper is compromised. Policy-as-code is evaluated by the execution layer, so the same run either can or cannot call a tool regardless of what the model is persuaded to do.</p>\n\n<h2>What proof do you get?</h2>\n<p>For model calls routed through clawproxy, you get gateway receipts that are signed and can be verified later. These receipts are designed to let you answer operational questions like: which model endpoint was called, under which job context, and whether the call was made under the expected policy constraints.</p>\n<p>Claw EA can package receipts and related metadata into a proof bundle per job. Proof bundles are what you hand to internal audit, incident response, or a customer security review, and they can be stored or surfaced as a Trust Pulse for viewing.</p>\n<p>In practice, teams use proof in three ways: (1) spot checks during rollout, (2) post-incident reconstruction when a plugin or MCP server behaved unexpectedly, and (3) change control evidence when updating tool permissions. If you need additional guarantees like transparency log inclusion proofs, that is planned and should be treated as a separate rollout item.</p>\n\n<h2>Rollback posture</h2>\n<p>Supply chain safety depends on having a rollback that is fast and evidence-backed. The goal is to revert to a known-good policy and tool surface quickly, then use proof to determine whether any runs occurred under the bad state.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Plugin or extension update causes unexpected behavior</td>\n      <td>Revert to last pinned plugin artifact and reapply the previous tool allowlist. If needed, tighten the WPC to remove the affected tool family until you complete review.</td>\n      <td>Proof bundle timelines plus gateway receipts show when behavior changed and which model calls happened during the suspect window.</td>\n    </tr>\n    <tr>\n      <td>MCP server shows suspicious outputs or tool expansion</td>\n      <td>Disable the MCP server in deployment and remove its tools from allowlists. Re-run OpenClaw security audit to catch implicit plugin enablement.</td>\n      <td>Gateway receipts confirm whether model calls continued; internal logs plus proof bundle metadata help correlate which sessions invoked affected tools.</td>\n    </tr>\n    <tr>\n      <td>Policy drift or wrong config pushed</td>\n      <td>Pin the CST to the intended WPC hash for subsequent runs and revert configs to the last known-good policy file. Treat any run without the expected policy hash as non-compliant.</td>\n      <td>WPC hash addressing plus CST policy hash pinning make it straightforward to identify which jobs used the wrong policy.</td>\n    </tr>\n    <tr>\n      <td>Suspected CST leakage</td>\n      <td>Rotate CSTs per job, invalidate the suspect run context, and rely on job-scoped CST binding to reduce replay. Consider reducing TTL and scoping further for high-risk jobs.</td>\n      <td>Receipts and proof bundles provide a bounded view of what actions were performed with the token during its validity window.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>What is the difference between skills, plugins, and MCP servers?</h3>\n<p>Skills are guidance text that gets injected into an agent’s context; they should not be trusted as enforcement. Plugins and MCP servers expose executable capabilities, so treat them like dependencies with explicit permissions and review.</p>\n\n<h3>Why is prompt-only safety not enough for supply chain security?</h3>\n<p>Because supply chain compromise lives below the prompt: a plugin or MCP server can execute code or call tools regardless of instructions. Policy-as-code places the decision in the execution layer, so the action is blocked even if the model is manipulated.</p>\n\n<h3>How do WPC and CST work together during a run?</h3>\n<p>The WPC is the signed, hash-addressed policy artifact that defines what is allowed. The CST is the scoped token that carries the scope hash and can optionally pin the policy hash, binding the run to the intended policy.</p>\n\n<h3>What do gateway receipts actually cover?</h3>\n<p>Gateway receipts cover model calls routed through clawproxy. They are useful for verifying what calls occurred and for building a proof bundle that can be independently checked later.</p>\n\n<h3>Can I use this with an existing MCP setup?</h3>\n<p>Yes, typically via MCP server deployment controls plus routing model calls through clawproxy for receipting. If you need deeper enforcement at the MCP layer, that is usually an enterprise buildout based on how your MCP servers are hosted and authenticated.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (security audit and common footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://owasp.org/www-project-mcp-top-10/2025/MCP04-2025%E2%80%93Software-Supply-Chain-Attacks&Dependency-Tampering\">OWASP MCP04: Software Supply Chain Attacks &amp; Dependency Tampering</a></li>\n  <li><a href=\"https://owasp.org/www-project-mcp-top-10/\">OWASP MCP Top 10</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/developer/ai/intro-agents-mcp\">Microsoft Learn: Build Agents using Model Context Protocol on Azure</a></li>\n</ul>",
  "description": "Agent supply chain security is about making skills, plugins, and MCP servers behave like production dependencies: pinned, permissioned, and auditable. In OpenClaw, prompts and skills are easy to change, but the risk live",
  "faqs": [
    {
      "q": "What is the difference between skills, plugins, and MCP servers?",
      "a": "Skills are guidance text that gets injected into an agent’s context; they should not be trusted as enforcement. Plugins and MCP servers expose executable capabilities, so treat them like dependencies with explicit permissions and review."
    },
    {
      "q": "Why is prompt-only safety not enough for supply chain security?",
      "a": "Because supply chain compromise lives below the prompt: a plugin or MCP server can execute code or call tools regardless of instructions. Policy-as-code places the decision in the execution layer, so the action is blocked even if the model is manipulated."
    },
    {
      "q": "How do WPC and CST work together during a run?",
      "a": "The WPC is the signed, hash-addressed policy artifact that defines what is allowed. The CST is the scoped token that carries the scope hash and can optionally pin the policy hash, binding the run to the intended policy."
    },
    {
      "q": "What do gateway receipts actually cover?",
      "a": "Gateway receipts cover model calls routed through clawproxy. They are useful for verifying what calls occurred and for building a proof bundle that can be independently checked later."
    },
    {
      "q": "Can I use this with an existing MCP setup?",
      "a": "Yes, typically via MCP server deployment controls plus routing model calls through clawproxy for receipting. If you need deeper enforcement at the MCP layer, that is usually an enterprise buildout based on how your MCP servers are hosted and authenticated."
    }
  ],
  "sources": [
    {
      "title": "OWASP MCP Top 10",
      "uri": "https://owasp.org/www-project-mcp-top-10/"
    },
    {
      "title": "Software Supply Chain Attacks & Dependency Tampering",
      "uri": "https://owasp.org/www-project-mcp-top-10/2025/MCP04-2025%E2%80%93Software-Supply-Chain-Attacks&Dependency-Tampering"
    },
    {
      "title": "OWASP/www-project-mcp-top-10 - GitHub",
      "uri": "https://github.com/OWASP/www-project-mcp-top-10"
    },
    {
      "title": "MCP Lite - A Simplified Approach to Model Context Protocol ...",
      "uri": "https://github.com/modelcontextprotocol/modelcontextprotocol/discussions/1158"
    },
    {
      "title": "Build Agents using Model Context Protocol on Azure",
      "uri": "https://learn.microsoft.com/en-us/azure/developer/ai/intro-agents-mcp"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:43:17.808Z",
  "indexable": true
}