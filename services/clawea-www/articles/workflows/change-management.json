{
  "slug": "workflows/change-management",
  "title": "Change management ticketing and approvals | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<p>For change management, you want an agent workflow where the agent can draft and simulate, but cannot approve or close a change unless a permissioned execution policy allows it. Claw EA runs OpenClaw as the baseline agent runtime, then binds high-risk actions to a Work Policy Contract (WPC) and a CST so approvals are enforced by the execution layer, not by prompt instructions.</p>\n<p>This matters because prompt-only controls fail under prompt injection and tool misuse. Policy-as-code gives you a signed, hash-addressed policy artifact that the runtime and proxy can verify before any irreversible change action is attempted.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Define the change boundaries and label irreversible actions.</strong> Treat “approve change” and “close change request” as high risk, and require a separate path from “draft”, “simulate”, or “comment”. Keep “read-only ticket context” and “write actions” as distinct tools or tool modes.</p>\n    <p>In OpenClaw, keep the agent’s tool policy tight so it can only call the minimum tools needed for drafting and evidence gathering. Use sandboxed tool execution where practical to limit local blast radius.</p>\n  </li>\n  <li>\n    <p><strong>Publish a WPC that encodes who can do what, and when step-up is required.</strong> Store the WPC in the WPC registry, then configure your execution path to fetch and verify the WPC by its hash before running an approval or closure tool call.</p>\n    <p>Make “simulate-first” mandatory for any execution plan that would modify production configuration or ticket state. If simulation cannot be performed, fail closed and require an explicit exception in a new WPC revision.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the job with scope hash and optional policy hash pinning.</strong> Use clawscope to mint a CST that is job-scoped and bound to the specific WPC hash for this run. This prevents a “valid token, wrong policy” scenario and supports marketplace anti-replay binding (job-scoped CST binding).</p>\n    <p>Keep CST TTL short for approvals and closures. If your identity layer is Microsoft Entra ID, you can gate the human approval step with Conditional Access and PIM, while still using the CST to gate machine execution.</p>\n  </li>\n  <li>\n    <p><strong>Route all model calls through clawproxy and require receipts.</strong> For runs that can lead to a ticket transition or a production change, require gateway receipts for model calls emitted by clawproxy. Treat missing receipts as a verification failure for the run.</p>\n    <p>If you use OpenRouter via fal, route it through clawproxy so the receipt stream is consistent across models. This is how you later prove what the model saw and what it returned, within the limits of the receipt schema.</p>\n  </li>\n  <li>\n    <p><strong>Enforce two-person rule and step-up approvals at the tool boundary.</strong> The agent can prepare a change plan, gather evidence, and draft the approval request, but the “approve” and “close” tools should require two distinct human approvers. Implement the approvals step via official API or via an MCP server, depending on your ticketing system and control plane.</p>\n    <p>Operationally, require one approver from the service owner group and one from the platform or security group. Record who approved, what was approved, and which WPC hash governed the action.</p>\n  </li>\n  <li>\n    <p><strong>Run simulate-first, then execute under the same WPC.</strong> The agent runs a dry-run that produces artifacts: expected diffs, validation output, and rollback steps. Only after the approvals are collected does the execution step run, and only if the WPC permits the specific change type and target environment.</p>\n    <p>This prevents the common failure mode where “approval” is granted for a plan, but “execution” happens with a different plan. The execution layer checks that the approved plan fingerprint matches what is being applied.</p>\n  </li>\n  <li>\n    <p><strong>Emit a proof bundle and store it for audit.</strong> Package the gateway receipts, policy hash, CST scope hash metadata, and run identifiers into a proof bundle. Store the resulting artifact in Trust Pulse so auditors can review what happened without rehydrating the whole runtime.</p>\n    <p>For ticket closure, require that the proof bundle exists and that the closure reason includes its identifier. That gives you a hard link between the ticket state and the execution evidence.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection in ticket comments</td>\n      <td>The agent is tricked into calling “approve” or “close”, or into expanding its tool usage beyond intent.</td>\n      <td>Tool boundary enforcement with WPC-gated actions, plus OpenClaw tool policy and sandboxing. Prompt text can influence planning, but cannot bypass the WPC and CST checks.</td>\n    </tr>\n    <tr>\n      <td>Single-user rubber stamping</td>\n      <td>A single operator approves and closes changes quickly, eliminating separation of duties.</td>\n      <td>Two-person rule in policy-as-code, enforced at execution time. Step-up approvals require two distinct identities before the irreversible tools unlock.</td>\n    </tr>\n    <tr>\n      <td>Replay of a prior approval token</td>\n      <td>An attacker reuses an approval artifact or token to approve a different change later.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) and short-lived CST issuance. The CST is tied to a job and optionally pinned to a WPC hash.</td>\n    </tr>\n    <tr>\n      <td>Drift between approved plan and executed action</td>\n      <td>The plan reviewed by humans differs from what was actually executed due to last-minute edits or model variability.</td>\n      <td>Forced simulate-first with plan fingerprinting, plus WPC rules that require the execution step to reference the same plan hash. Missing match fails closed.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable model activity after incident</td>\n      <td>You cannot reconstruct which model calls influenced the approval request or change execution.</td>\n      <td>Gateway receipts for model calls via clawproxy, bundled into a proof bundle and retained as an audit artifact in Trust Pulse.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact, JSON-like sketch of what you encode in a WPC for change approvals. The goal is to make “approve” and “close” impossible unless the policy is verified and the approvals are present, even if the prompt tries to override it.</p>\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"change_mgmt_prod_approval\",\n  \"policy_hash\": \"b64u:... (served by clawcontrols)\",\n  \"enforcement\": {\n    \"fail_closed\": true,\n    \"require_gateway_receipts\": true,\n    \"require_proof_bundle\": true\n  },\n  \"token_requirements\": {\n    \"require_cst\": true,\n    \"cst_scope_hash\": \"b64u:...\",\n    \"optional_policy_hash_pinning\": true,\n    \"job_scoped_binding\": true\n  },\n  \"tools\": {\n    \"ticket.read\": { \"allowed\": true },\n    \"ticket.comment\": { \"allowed\": true },\n    \"change.simulate\": { \"allowed\": true, \"required_before\": [\"change.execute\", \"ticket.approve\", \"ticket.close\"] },\n    \"ticket.approve\": {\n      \"allowed\": true,\n      \"step_up_approvals\": 2,\n      \"two_person_rule\": true,\n      \"approver_constraints\": [\"service_owner\", \"platform_security\"]\n    },\n    \"ticket.close\": {\n      \"allowed\": true,\n      \"step_up_approvals\": 2,\n      \"two_person_rule\": true,\n      \"requires_proof_bundle_reference\": true\n    },\n    \"change.execute\": {\n      \"allowed\": true,\n      \"requires_plan_fingerprint_match\": true\n    }\n  }\n}\n</pre>\n<p>In practice, you keep the approver identities and group membership checks in your enterprise identity system. If you are using Microsoft Entra ID, map approver roles to groups and use PIM and Conditional Access for step-up, then let the WPC decide whether the tool call can proceed.</p>\n\n<h2>What proof do you get?</h2>\n<p>Every model call routed through clawproxy produces gateway receipts, which are signed receipts emitted by clawproxy for model calls. Those receipts are what you point to when someone asks, “What did the model see and what did it output before the approval request was generated?”</p>\n<p>At the end of the run, Claw EA produces a proof bundle, which is a harness artifact bundling receipts and related metadata for audit and verification. The proof bundle includes the WPC hash reference, CST-related binding metadata, and run identifiers so you can correlate the ticket, the plan, and the execution evidence.</p>\n<p>For retention and review, store the proof bundle in Trust Pulse as a marketplace-stored artifact for audit/viewing. In change management terms, this becomes the attachment you can reference from the ticket and from post-incident reviews.</p>\n\n<h2>Rollback posture</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Approval granted incorrectly</td>\n      <td>Revoke the CST, then require a new job-scoped CST and a new WPC-governed approval cycle. Treat the prior approval as invalid for future runs.</td>\n      <td>Proof bundle showing the original WPC hash, approver identities (as recorded by your approval system), and the gateway receipts for the decision support.</td>\n    </tr>\n    <tr>\n      <td>Execution diverged from the plan</td>\n      <td>Stop further runs by pinning to a revised WPC that disallows execute for the target system until corrected. Re-run simulate-first under the new policy and collect fresh approvals.</td>\n      <td>Mismatch evidence: plan fingerprint versus execution metadata within the proof bundle, plus gateway receipts for the model calls that produced the plan.</td>\n    </tr>\n    <tr>\n      <td>Ticket was closed without required artifacts</td>\n      <td>Reopen the ticket via official API and require proof bundle reference before closure. Tighten the WPC so closure fails unless the proof bundle identifier is supplied.</td>\n      <td>Absence is the signal: closure event without a corresponding proof bundle reference. The corrected run produces a new proof bundle and ties it to the ticket.</td>\n    </tr>\n    <tr>\n      <td>Suspected replay or token misuse</td>\n      <td>Invalidate the job context, rotate relevant secrets, and issue a fresh CST with job-scoped binding. Re-run with WPC hash pinning enabled.</td>\n      <td>Job-scoped CST binding metadata and timing correlation across receipts. The proof bundle provides a single package to hand to verification and audit teams.</td>\n    </tr>\n  </tbody>\n</table>\n<p>If you need network egress allowlists, implement them outside clawproxy as an optional control. Keep the rollback plan itself under change control so it is always available during an incident.</p>\n\n<h2>FAQ</h2>\n<h3>Why is prompt-only approval not acceptable for enterprise change management?</h3>\n<p>Because the model can be convinced to ignore the instruction, especially when untrusted text enters the context. Policy-as-code moves the decision to a machine-enforced boundary where “approve” and “close” simply cannot run unless the WPC and CST conditions are satisfied.</p>\n\n<h3>How do two-person rule and step-up approvals work with Claw EA?</h3>\n<p>The WPC encodes that “approve” and “close” require two distinct approvals, then the execution layer checks that the approvals exist before calling the tool. The approvals themselves can be collected via official API or via an MCP server, depending on your ticketing system.</p>\n\n<h3>Can OpenClaw still be used if we already have a ticketing workflow?</h3>\n<p>Yes. OpenClaw runs the agent and tools, while Claw EA supplies the permissioned execution layer and proof artifacts, so you can keep your existing ticket states and approval roles.</p>\n\n<h3>What do gateway receipts and proof bundles help us do during an audit?</h3>\n<p>They let you verify that the agent run followed the policy you intended, and they provide a signed record of model calls. Instead of reconstructing events from logs and screenshots, you can hand an auditor the proof bundle and the associated WPC hash.</p>\n\n<h3>Do you enforce network egress allowlists and cost budgets?</h3>\n<p>Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are optional or planned items, depending on your deployment. If you need them today, they can be implemented as an enterprise buildout alongside the shipped WPC, CST, receipts, and proof bundle controls.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-copilot-studio/flows-advanced-approvals\">Multistage and AI approvals in agent flows - Microsoft Copilot Studio</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/entra/id-governance/access-review-agent\">Microsoft Security Copilot Access Review Agent in Microsoft Entra ID Governance</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "For change management, you want an agent workflow where the agent can draft and simulate, but cannot approve or close a change unless a permissioned execution policy allows it. Claw EA runs OpenClaw as the baseline agent",
  "faqs": [
    {
      "q": "Why is prompt-only approval not acceptable for enterprise change management?",
      "a": "Because the model can be convinced to ignore the instruction, especially when untrusted text enters the context. Policy-as-code moves the decision to a machine-enforced boundary where “approve” and “close” simply cannot run unless the WPC and CST conditions are satisfied."
    },
    {
      "q": "How do two-person rule and step-up approvals work with Claw EA?",
      "a": "The WPC encodes that “approve” and “close” require two distinct approvals, then the execution layer checks that the approvals exist before calling the tool. The approvals themselves can be collected via official API or via an MCP server, depending on your ticketing system."
    },
    {
      "q": "Can OpenClaw still be used if we already have a ticketing workflow?",
      "a": "Yes. OpenClaw runs the agent and tools, while Claw EA supplies the permissioned execution layer and proof artifacts, so you can keep your existing ticket states and approval roles."
    },
    {
      "q": "What do gateway receipts and proof bundles help us do during an audit?",
      "a": "They let you verify that the agent run followed the policy you intended, and they provide a signed record of model calls. Instead of reconstructing events from logs and screenshots, you can hand an auditor the proof bundle and the associated WPC hash."
    },
    {
      "q": "Do you enforce network egress allowlists and cost budgets?",
      "a": "Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are optional or planned items, depending on your deployment. If you need them today, they can be implemented as an enterprise buildout alongside the shipped WPC, CST, receipts, and proof bundle controls."
    }
  ],
  "sources": [
    {
      "title": "Microsoft Security Copilot Access Review Agent in Microsoft Entra - Microsoft Entra ID Governance",
      "uri": "https://learn.microsoft.com/en-us/entra/id-governance/access-review-agent"
    },
    {
      "title": "Microsoft Security Copilot Access Review Agent in Microsoft Entra",
      "uri": "https://learn.microsoft.com/en-us/entra/security-copilot/access-review-agent"
    },
    {
      "title": "Design secure generative AI application workflows with Amazon Verified Permissions and Amazon Bedrock Agents | Amazon Web Services",
      "uri": "https://aws.amazon.com/blogs/machine-learning/design-secure-generative-ai-application-workflows-with-amazon-verified-permissions-and-amazon-bedrock-agents"
    },
    {
      "title": "A 5-Step Playbook to Tackle ALM for AI Agents and Apps - Salesforce",
      "uri": "https://www.salesforce.com/blog/agent-and-application-lifecycle-management/"
    },
    {
      "title": "Latest access control security enhancements for AI Agents and Skill Kit [Updated Zurich Patch 4]",
      "uri": "https://www.servicenow.com/community/now-assist-articles/latest-access-control-security-enhancements-for-ai-agents-and/ta-p/3374036"
    },
    {
      "title": "Multistage and AI approvals in agent flows - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/flows-advanced-approvals"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:35:12.198Z",
  "indexable": true
}