{
  "slug": "workflows/release-notes-to-customers",
  "title": "Release notes and customer notifications with approvals | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<h2>Direct Answer</h2>\n<p>Use OpenClaw as the baseline agent runtime to draft release notes and prepare customer notifications, but make the publish and send actions permissioned by policy-as-code. In Claw EA, that permissioning is expressed as a WPC and enforced using CST plus gateway receipts and proof bundles, so you can prove what was proposed, who approved it, and what was actually sent.</p>\n<p>Prompt-only controls fail because the same prompt that says “ask for approval” can be overridden by injected content or a tool error path. A WPC makes the execution layer fail-closed: the agent can draft freely, but it cannot publish release notes or email customers unless the policy conditions and approval requirements are satisfied.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the workflow boundary: “Draft is reversible, publish is irreversible.” Treat “publish release notes” and “email customers” as high-risk actions that must be gated behind explicit approvals and an output policy.</p>\n    <p>Decide which surfaces you will use (for example: your docs site CMS, a status page, and an email provider), and plan to integrate via official API or via an MCP server.</p>\n  </li>\n  <li>\n    <p>Create a WPC for the release workflow and register it. The WPC should specify which tools are allowed for drafting, which tool(s) are allowed for publishing, and what approval steps must occur before publish or send.</p>\n    <p>Keep the WPC narrow: allow read-only access to release artifacts (tickets, commits, changelog files), and block any tool that can mutate production content until approvals clear.</p>\n  </li>\n  <li>\n    <p>Issue a CST for the job from clawscope, scoped to the minimum set of actions. Pin the CST to the WPC (policy hash pinning) so the token cannot be replayed under a different policy.</p>\n    <p>Use job-scoped CST binding to reduce replay risk across runs, especially for “send” actions.</p>\n  </li>\n  <li>\n    <p>Run the drafting phase in OpenClaw with sandboxing enabled for tools. Drafting can call models and summarize diffs, but it should not have the capability to publish or send yet.</p>\n    <p>As part of drafting, require the agent to produce a “candidate artifact” that is structured: audience, version, change list, known issues, and a customer-facing email body.</p>\n  </li>\n  <li>\n    <p>Apply DLP and redaction rules before anything leaves the drafting boundary. Enforce redaction on secrets, internal hostnames, customer identifiers, and security-sensitive details that should not be disclosed in release notes.</p>\n    <p>If your environment uses Microsoft controls, align the human approval step with your existing process (for example via a flow that uses Entra ID identity and Conditional Access), implemented via official API or enterprise buildout.</p>\n  </li>\n  <li>\n    <p>Perform step-up approvals (human-in-the-loop). The approver should see a diff view of the proposed release note and the exact customer notification content, plus the policy summary that explains what will happen when approved.</p>\n    <p>On approval, re-issue or elevate the CST for a short TTL, still pinned to the same WPC, and allow only the publish and send tools needed for this one run.</p>\n  </li>\n  <li>\n    <p>Execute the publish and send phase through clawproxy so model calls and key execution metadata generate gateway receipts. Store the proof bundle and, if needed for external sharing, write a Trust Pulse artifact for audit/viewing.</p>\n    <p>After completion, revoke or let the CST expire, and run a post-run check that the published content hash matches the approved artifact hash.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (operational)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection via release artifact text</td>\n      <td>The agent is tricked into skipping approvals or adding hidden content to the customer email.</td>\n      <td>Policy-as-code gates tool execution: WPC denies publish and send until approvals are present. Draft output must pass an output policy and redaction checks before an approval can be requested.</td>\n    </tr>\n    <tr>\n      <td>Credential misuse</td>\n      <td>A long-lived token is reused to publish outside the intended job window.</td>\n      <td>Use CST with short TTL and job-scoped CST binding. Pin CST to the WPC hash so the token cannot be repurposed under a different policy.</td>\n    </tr>\n    <tr>\n      <td>Over-broad tool access in the agent runtime</td>\n      <td>The agent can access filesystem, shell, or admin APIs while drafting, increasing blast radius.</td>\n      <td>Use OpenClaw sandboxing and tool policy to keep drafting tools read-only and isolated. Avoid elevated execution for this workflow unless you can justify it and keep it off by default.</td>\n    </tr>\n    <tr>\n      <td>Data leakage in release notes</td>\n      <td>PII, secrets, internal URLs, or incident details leak into public release notes.</td>\n      <td>DLP and redaction rules are enforced before approvals and again before publish. Require a “public-safe” checklist in the approval UI and block publish on any unresolved redaction findings.</td>\n    </tr>\n    <tr>\n      <td>Repudiation after a bad send</td>\n      <td>Teams cannot prove what the model saw, what was approved, and what content was sent.</td>\n      <td>Route model calls through clawproxy to emit gateway receipts. Package receipts, policy hash, CST scope hash, and run metadata into a proof bundle for later verification.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact, JSON-like sketch of a WPC that separates drafting from irreversible actions. The key idea is that the agent may draft, but publishing and sending require step-up approvals plus output policy checks, enforced at execution time rather than requested in a prompt.</p>\n\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"release-notes-to-customers\",\n  \"risk\": {\n    \"irreversible_actions\": [\"publish_release_notes\", \"email_customers\"],\n    \"step_up_approval_required\": true\n  },\n  \"token_constraints\": {\n    \"require_cst\": true,\n    \"require_scope_hash\": true,\n    \"policy_hash_pinning\": \"required\",\n    \"job_scoped_binding\": \"required\"\n  },\n  \"tools\": {\n    \"draft_phase\": {\n      \"allow\": [\"read_repo\", \"read_tickets\", \"model_call\", \"render_markdown\"],\n      \"deny\": [\"publish_release_notes\", \"email_customers\", \"admin_api\"]\n    },\n    \"publish_phase\": {\n      \"allow\": [\"publish_release_notes\", \"email_customers\"],\n      \"conditions\": [\n        {\"type\": \"approval\", \"role\": \"release_manager\", \"min_approvers\": 1},\n        {\"type\": \"approval\", \"role\": \"security_or_comms\", \"min_approvers\": 1},\n        {\"type\": \"output_policy\", \"must_pass\": [\"dlp_redaction\", \"no_secrets\", \"no_internal_hosts\"]},\n        {\"type\": \"artifact_hash_match\", \"approved_hash_required\": true}\n      ]\n    }\n  },\n  \"logging\": {\n    \"require_gateway_receipts_for_model_calls\": true,\n    \"proof_bundle_required\": true\n  }\n}\n</pre>\n\n<h2>What proof do you get?</h2>\n<p>For every model call routed through clawproxy, you get gateway receipts that can be checked later to confirm the call happened under the expected policy constraints. These receipts are signed, and they bind to the job context so they are meaningful in an audit.</p>\n<p>At the end of the run, Claw EA produces a proof bundle that packages gateway receipts plus related metadata like the WPC hash, CST scope hash, and run identifiers. If you need a human-friendly view for auditors or internal review, you can store and view the run as a Trust Pulse artifact.</p>\n<p>This matters operationally when a customer reports “you announced X” or “you emailed the wrong segment.” Instead of reconstructing from logs and chat transcripts, you verify the proof bundle and compare the approved artifact hash to the published content hash.</p>\n\n<h2>Rollback posture</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence you should retain</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Draft release notes</td>\n      <td>Discard or replace the draft; no external impact.</td>\n      <td>Draft artifact hashes and approval denials (if any), plus proof bundle if models were used.</td>\n    </tr>\n    <tr>\n      <td>Publish release notes</td>\n      <td>Publish a corrected revision and link to an errata section; avoid silent edits if your policy requires transparency.</td>\n      <td>Approved artifact hash, published artifact hash, timestamps, and the proof bundle showing the publish was gated by approvals.</td>\n    </tr>\n    <tr>\n      <td>Email customers</td>\n      <td>Send a correction email with clear subject prefix and an internal incident record; do not attempt recalls unless your mail system guarantees it.</td>\n      <td>Recipient selection criteria snapshot, the exact sent body hash, approval record, and proof bundle capturing the final generation step.</td>\n    </tr>\n    <tr>\n      <td>Token or policy misconfiguration discovered mid-run</td>\n      <td>Revoke CST immediately, stop the job, rotate any exposed credentials, and re-run under a tightened WPC.</td>\n      <td>CST issuance details, WPC hash, and receipts showing what actions did and did not occur before revocation.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Optional: egress allowlists enforced outside clawproxy can be implemented if you need network-level containment for publishing tools. Treat this as a separate control plane decision because it is environment-specific.</p>\n\n<h2>FAQ</h2>\n<h3>Why isn’t “ask for approval in the prompt” enough?</h3>\n<p>Because prompts are not a control boundary: they can be overwritten by injected content, tool outputs, or a simple “ignore previous instructions” attack. A WPC makes approval a machine-enforced precondition to the publish and send tools, so the run fails closed.</p>\n\n<h3>Where do approvals live in this workflow?</h3>\n<p>Approvals are referenced as conditions in the WPC and are checked before enabling irreversible tools. The approval system itself can be wired in via official API or via MCP server, and it should record approver identity and the hash of the approved artifact.</p>\n\n<h3>How do CST and WPC relate to each other?</h3>\n<p>CST is the scoped token issued by clawscope; it carries scope constraints for the job. The CST can be pinned to a WPC hash so a token issued for “release-notes-to-customers” cannot be reused to run under a different policy.</p>\n\n<h3>What exactly do gateway receipts prove?</h3>\n<p>Gateway receipts are signed receipts emitted by clawproxy for model calls, so you can verify the model calls that occurred in the run. Combined with a proof bundle, they support audits like “did a model generate the final email body after approval” and “which policy was in force.”</p>\n\n<h3>Can this workflow integrate with Microsoft identity and governance?</h3>\n<p>Yes, but treat it as an integration decision: you can align approvals and access with Entra ID and Conditional Access, and implement checks via official API. The key is to keep irreversible actions behind step-up approvals and short-lived CST, regardless of the identity provider.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization\">Governance and security for AI agents across the organization (Microsoft Cloud Adoption Framework)</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-copilot-studio/flows-advanced-approvals\">Multistage and AI approvals in agent flows (Microsoft Copilot Studio)</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Use OpenClaw as the baseline agent runtime to draft release notes and prepare customer notifications, but make the publish and send actions permissioned by policy-as-code. In Claw EA, that permissioning is expressed as a",
  "faqs": [
    {
      "q": "Why isn’t “ask for approval in the prompt” enough?",
      "a": "Because prompts are not a control boundary: they can be overwritten by injected content, tool outputs, or a simple “ignore previous instructions” attack. A WPC makes approval a machine-enforced precondition to the publish and send tools, so the run fails closed."
    },
    {
      "q": "Where do approvals live in this workflow?",
      "a": "Approvals are referenced as conditions in the WPC and are checked before enabling irreversible tools. The approval system itself can be wired in via official API or via MCP server, and it should record approver identity and the hash of the approved artifact."
    },
    {
      "q": "How do CST and WPC relate to each other?",
      "a": "CST is the scoped token issued by clawscope; it carries scope constraints for the job. The CST can be pinned to a WPC hash so a token issued for “release-notes-to-customers” cannot be reused to run under a different policy."
    },
    {
      "q": "What exactly do gateway receipts prove?",
      "a": "Gateway receipts are signed receipts emitted by clawproxy for model calls, so you can verify the model calls that occurred in the run. Combined with a proof bundle, they support audits like “did a model generate the final email body after approval” and “which policy was in force.”"
    },
    {
      "q": "Can this workflow integrate with Microsoft identity and governance?",
      "a": "Yes, but treat it as an integration decision: you can align approvals and access with Entra ID and Conditional Access, and implement checks via official API. The key is to keep irreversible actions behind step-up approvals and short-lived CST, regardless of the identity provider."
    }
  ],
  "sources": [
    {
      "title": "Multistage and AI approvals in agent flows - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/flows-advanced-approvals"
    },
    {
      "title": "Governance and security for AI agents across the organization",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization"
    },
    {
      "title": "Release Notes for Microsoft 365 Copilot",
      "uri": "https://learn.microsoft.com/en-us/copilot/microsoft-365/release-notes"
    },
    {
      "title": "Microsoft Security Copilot Access Review Agent in Microsoft Entra - Microsoft Entra ID Governance",
      "uri": "https://learn.microsoft.com/en-us/entra/id-governance/access-review-agent"
    },
    {
      "title": "Overview of Microsoft Agent 365",
      "uri": "https://learn.microsoft.com/en-us/microsoft-agent-365/overview"
    },
    {
      "title": "Protect Agent Workflows with Easy Auth - Azure Logic Apps",
      "uri": "https://learn.microsoft.com/en-us/azure/logic-apps/set-up-authentication-agent-workflows"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:48:51.043Z",
  "indexable": true
}