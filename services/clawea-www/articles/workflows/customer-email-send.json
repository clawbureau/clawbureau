{
  "slug": "workflows/customer-email-send",
  "title": "Customer communications with DLP and approvals | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<h2>Direct Answer</h2>\n<p>This workflow lets an OpenClaw agent draft and send customer emails only when DLP checks pass and a human approves the final payload. Claw EA makes the execution permissioned with policy-as-code so the agent cannot bypass controls using prompt tricks or tool misuse.</p>\n<p>The core mechanism is a WPC (Work Policy Contract) that constrains which tools can run, what data can appear in outbound content, and when step-up approvals are required. Each model call routed through clawproxy produces gateway receipts, which are packaged into a proof bundle for later verification and audit.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this when an agent is allowed to communicate with customers but you want strong controls on outbound email and attachments. The intent is to make “drafting” cheap and reversible, and make “sending” gated and provable.</p>\n\n<ol>\n  <li>\n    <p><strong>Define a WPC for customer communications.</strong> Encode allowed tools (draft, classify, redact, prepare email), deny direct send by default, and require approval for any irreversible action. Store the signed, hash-addressed WPC in the WPC registry served by clawcontrols.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the job, pinned to the policy.</strong> Use clawscope to mint a CST (scoped token) with a scope hash matching the workflow’s privileges, and optionally pin the WPC policy hash. Bind the CST to the job to prevent replay across runs.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent in a sandboxed tool environment.</strong> In OpenClaw, enable sandboxing for tool execution so file and process access are reduced during drafting and analysis. Keep “send email” out of the default tool profile, and expose it only via a gated tool that enforces approvals.</p>\n  </li>\n  <li>\n    <p><strong>Draft with DLP and redaction in the loop.</strong> The agent generates a draft, then runs DLP classification and redaction rules over the outgoing body, subject, recipients, and attachment names. If the content includes restricted patterns, the policy should force redaction or block the send path.</p>\n  </li>\n  <li>\n    <p><strong>Step-up approval before send.</strong> Route the prepared “send request” to a human reviewer with a minimal approval UI that shows recipients, subject, body diff, and attachment hashes. Require explicit approval for external recipients, attachments, refunds/credits language, or any exception to the default output policy.</p>\n  </li>\n  <li>\n    <p><strong>Send via official API, constrained by policy.</strong> If you send through Microsoft, do it via the official API using Microsoft Entra ID and Microsoft Graph permissions/scopes that match the minimum needed. Apply Conditional Access and, if appropriate, PIM for the sending identity so the agent cannot silently gain broad mailbox access.</p>\n  </li>\n  <li>\n    <p><strong>Collect evidence and publish the run artifact.</strong> Route model calls through clawproxy to emit gateway receipts and bundle them with job metadata into a proof bundle. Store the proof bundle and optionally publish a Trust Pulse artifact for audit viewing and internal review.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Outbound customer email is high risk because it is hard to undo and easy to abuse for data exfiltration. Treat “send” and “share attachment” as privileged operations that should fail closed when policy checks are missing.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection causes unauthorized send</td>\n      <td>The agent is coerced to email sensitive data or contact unintended recipients.</td>\n      <td>Policy-as-code in a WPC denies direct send, requires step-up approval, and enforces recipient allow rules and output redaction.</td>\n    </tr>\n    <tr>\n      <td>Data exfiltration via attachments</td>\n      <td>The agent attaches internal files or exports data into a PDF and sends it out.</td>\n      <td>DLP rules block or redact attachment names and content; policy can require “no attachments” unless explicitly approved with hashes shown to reviewer.</td>\n    </tr>\n    <tr>\n      <td>Scope creep from broad email permissions</td>\n      <td>A compromised agent token can send as any mailbox or read unrelated mailboxes.</td>\n      <td>Use a CST with a narrow scope hash; for Microsoft, minimize Microsoft Graph permissions/scopes and constrain identity with Entra ID, Conditional Access, and optionally PIM.</td>\n    </tr>\n    <tr>\n      <td>Replay of an approved action</td>\n      <td>A previously approved send request is reused to send again or to new recipients.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding, plus approval objects bound to job id and policy hash.</td>\n    </tr>\n    <tr>\n      <td>Audit gap after an incident</td>\n      <td>You cannot prove what the model saw, produced, or which policy was enforced.</td>\n      <td>Gateway receipts from clawproxy plus a proof bundle that records policy hash, token scope hash, timestamps, and model routing details.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact, JSON-like sketch of what teams typically encode into a WPC for customer email. The point is to make “send email” conditional on concrete checks and approvals, not on the agent’s own self-report.</p>\n\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"workflow\": \"customer-email-send\",\n  \"tools\": {\n    \"allow\": [\"draft_email\", \"dlp_scan\", \"redact\", \"prepare_send_request\"],\n    \"deny\": [\"send_email_direct\", \"share_attachment_direct\"]\n  },\n  \"output_policy\": {\n    \"recipient_rules\": {\n      \"allow_domains\": [\"customer.com\", \"subsidiary.example\"],\n      \"block_free_mail\": true\n    },\n    \"dlp\": {\n      \"block_patterns\": [\"\\\\b\\\\d{3}-\\\\d{2}-\\\\d{4}\\\\b\", \"API_KEY_\", \"BEGIN PRIVATE KEY\"],\n      \"redact_patterns\": [\"\\\\b\\\\d{16}\\\\b\", \"\\\\b\\\\d{3}-\\\\d{2}-\\\\d{4}\\\\b\"]\n    },\n    \"attachments\": {\n      \"default\": \"deny\",\n      \"allow_if\": [\"approved\", \"hash_listed_in_approval\"]\n    }\n  },\n  \"approvals\": {\n    \"required_for\": [\"send_email\", \"any_attachment\", \"external_recipient\", \"policy_exception\"],\n    \"approver_group\": \"customer-comms-approvers\",\n    \"approval_payload_must_include\": [\"to\", \"cc\", \"bcc\", \"subject\", \"body\", \"attachment_hashes\"]\n  },\n  \"token_constraints\": {\n    \"require_cst_scope_hash\": true,\n    \"optional_policy_hash_pinning\": true,\n    \"job_scoped_binding\": true\n  },\n  \"model_routing\": {\n    \"proxy\": \"clawproxy\",\n    \"require_gateway_receipts\": true\n  }\n}\n</pre>\n\n<p>Prompt-only controls fail because the same model that generates the email is also the component you are asking to “behave.” A WPC makes the decision external, machine-checked, and consistent across sessions and model changes.</p>\n\n<h2>What proof do you get?</h2>\n<p>For every model call routed through clawproxy, you get gateway receipts that record the call under the proxy’s signing and policy enforcement context. Those receipts make it possible to verify what was called, when it was called, and which job-bound CST was used.</p>\n<p>Claw EA packages gateway receipts plus policy identifiers and run metadata into a proof bundle. The proof bundle is the artifact you hand to security, compliance, or an incident responder to validate that the send path required approval and that the run used the intended WPC.</p>\n<p>If you need a shareable audit view, store the run as a Trust Pulse artifact. This gives reviewers a stable place to inspect what was produced and what was enforced, without relying on mutable application logs.</p>\n\n<h2>Rollback posture</h2>\n<p>Email sending is not fully reversible, so rollback needs to focus on preventing additional sends and proving the blast radius. Treat “disable future capability” as the primary rollback, and use evidence to drive customer comms and internal remediation.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Approval granted but send not executed yet</td>\n      <td>Invalidate the job by revoking or expiring the CST; require a fresh approval under a new job id.</td>\n      <td>Proof bundle shows the last approved payload and the absence of any send execution receipt.</td>\n    </tr>\n    <tr>\n      <td>Email sent to wrong recipient</td>\n      <td>Stop further sends by tightening the WPC recipient rules and re-issuing a narrower CST scope hash; escalate as an incident.</td>\n      <td>Gateway receipts identify the run, job binding, and the generated content that led to send approval.</td>\n    </tr>\n    <tr>\n      <td>Sensitive data appears in draft output</td>\n      <td>Update DLP redact/block patterns in the WPC and force redaction; retrain reviewers to reject exceptions.</td>\n      <td>Proof bundle ties the output to a specific WPC hash so you can prove which rule set was active.</td>\n    </tr>\n    <tr>\n      <td>Suspected token misuse</td>\n      <td>Revoke CSTs and rotate the sending identity; in Microsoft environments, review Entra ID sign-in logs and Conditional Access outcomes.</td>\n      <td>Job-scoped CST binding plus receipts help differentiate replay attempts from legitimate runs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is policy-as-code required instead of a careful system prompt?</h3>\n<p>A prompt is advice to the same component that is generating the risky action. A WPC is a signed artifact enforced outside the model, so “send email” can fail closed when DLP or approvals are missing.</p>\n\n<h3>Can this work with Microsoft 365 mailboxes?</h3>\n<p>Yes, typically via the official API using Microsoft Entra ID and Microsoft Graph permissions/scopes sized to the minimum required. If you need a custom connector surface, do it via an MCP server or an enterprise buildout, and keep the “send” tool gated behind approvals.</p>\n\n<h3>What exactly is approved by the human?</h3>\n<p>Approve the final payload that will be sent: recipients, subject, body, and attachment hashes. Approval should be bound to the job id and the WPC hash so it cannot be reused under different policy or scope.</p>\n\n<h3>How do you prevent replays of a previously approved send?</h3>\n<p>Use marketplace anti-replay binding with a job-scoped CST binding, and require approvals that are only valid for that job. If a request is replayed outside the job context, it should fail policy checks.</p>\n\n<h3>What models can be used for drafting?</h3>\n<p>Claw EA can route model calls through clawproxy and produce gateway receipts regardless of provider, and OpenRouter via fal is supported when routed through clawproxy. The key is that drafting can vary, but the send path remains permissioned and audited.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-copilot-studio/admin-data-loss-prevention\">Configure data policies for agents (DLP) - Microsoft Copilot Studio</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-copilot-studio/flows-advanced-approvals\">Multistage and AI approvals in agent flows - Microsoft Copilot Studio</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/purview/ai-agents\">Use Microsoft Purview to manage data security &amp; compliance for AI agents</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "This workflow lets an OpenClaw agent draft and send customer emails only when DLP checks pass and a human approves the final payload. Claw EA makes the execution permissioned with policy-as-code so the agent cannot bypas",
  "faqs": [
    {
      "q": "Why is policy-as-code required instead of a careful system prompt?",
      "a": "A prompt is advice to the same component that is generating the risky action. A WPC is a signed artifact enforced outside the model, so “send email” can fail closed when DLP or approvals are missing."
    },
    {
      "q": "Can this work with Microsoft 365 mailboxes?",
      "a": "Yes, typically via the official API using Microsoft Entra ID and Microsoft Graph permissions/scopes sized to the minimum required. If you need a custom connector surface, do it via an MCP server or an enterprise buildout, and keep the “send” tool gated behind approvals."
    },
    {
      "q": "What exactly is approved by the human?",
      "a": "Approve the final payload that will be sent: recipients, subject, body, and attachment hashes. Approval should be bound to the job id and the WPC hash so it cannot be reused under different policy or scope."
    },
    {
      "q": "How do you prevent replays of a previously approved send?",
      "a": "Use marketplace anti-replay binding with a job-scoped CST binding, and require approvals that are only valid for that job. If a request is replayed outside the job context, it should fail policy checks."
    },
    {
      "q": "What models can be used for drafting?",
      "a": "Claw EA can route model calls through clawproxy and produce gateway receipts regardless of provider, and OpenRouter via fal is supported when routed through clawproxy. The key is that drafting can vary, but the send path remains permissioned and audited."
    }
  ],
  "sources": [
    {
      "title": "Considerations for DSPM for AI to manage data security and ...",
      "uri": "https://learn.microsoft.com/en-us/purview/dspm-for-ai-considerations"
    },
    {
      "title": "Configure data policies for agents - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/admin-data-loss-prevention"
    },
    {
      "title": "Data loss prevention example - Require user authentication in agents - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/dlp-example-3"
    },
    {
      "title": "Multistage and AI approvals in agent flows - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/flows-advanced-approvals"
    },
    {
      "title": "Use Microsoft Purview to manage data security & compliance for AI agents",
      "uri": "https://learn.microsoft.com/en-us/purview/ai-agents"
    },
    {
      "title": "Use Microsoft Purview to manage data security & compliance for Microsoft 365 Copilot & Microsoft 365 Copilot Chat",
      "uri": "https://learn.microsoft.com/en-us/purview/ai-m365-copilot"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:39:14.423Z",
  "indexable": true
}