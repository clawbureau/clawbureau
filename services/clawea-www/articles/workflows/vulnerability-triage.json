{
  "slug": "workflows/vulnerability-triage",
  "title": "Vulnerability triage and patch coordination | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<p>For vulnerability triage and patch coordination, you want an agent that can read evidence, propose a patch plan, and execute only the minimal, permissioned actions needed to remediate. In Claw EA, OpenClaw is the baseline agent runtime, and Claw Bureau adds policy-as-code constraints and verifiable run artifacts so patch actions are auditable and reversible.</p>\n<p>Prompt-only guardrails fail when the agent hits ambiguous instructions or untrusted input. A permissioned execution layer uses a WPC and CST to enforce tool allow/deny lists, step-up approvals, and a forced dry-run before any irreversible action like applying patches, restarting services, or opening an incident.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Define the job boundary and policy.</strong> Create a WPC that describes what “triage” means versus “remediation,” and split them into separate phases with different tool permissions. Keep patching and restarts in a gated phase that requires approval.</p>\n    <p>Store the WPC in the WPC registry so it is signed and hash-addressed, and so the runtime can fetch and verify it before execution.</p>\n  </li>\n  <li>\n    <p><strong>Issue a job-scoped CST and pin the policy hash.</strong> Use a CST (issued by clawscope) that binds scope to this specific vulnerability ticket or change request. Enable optional policy hash pinning so the CST is only valid when the runtime is using the exact WPC you approved.</p>\n    <p>This prevents token reuse across unrelated incidents and makes “same token, different job” replays fail in the marketplace anti-replay binding model.</p>\n  </li>\n  <li>\n    <p><strong>Run evidence collection in a sandboxed, read-first mode.</strong> Configure OpenClaw tool policy so the agent can fetch advisories, read repo files, and query your scanners via official API or via an MCP server. Keep writes off until the plan is reviewed.</p>\n    <p>In OpenClaw, prefer Docker sandboxing for tool execution and a tight tool profile that excludes patch and restart tools during triage.</p>\n  </li>\n  <li>\n    <p><strong>Force “simulate-first” for every risky change.</strong> Require a dry-run output such as “plan,” “diff,” or “what would change,” depending on the tool and environment. Treat “apply patches,” “restart services,” and “open incident” as irreversible actions that cannot be executed until a dry-run artifact is attached to the change request.</p>\n    <p>If your patch mechanism does not support dry-run natively, implement a simulate step that produces deterministic outputs (for example, computed package upgrades, affected services, and rollback commands) before any write.</p>\n  </li>\n  <li>\n    <p><strong>Step-up approval before remediation.</strong> Require a human approver to confirm the patch plan, maintenance window, and blast radius. If you use Microsoft identity, this is typically done with Entra ID group membership checks and a step-up workflow that can be backed by Conditional Access and PIM for just-in-time eligibility.</p>\n    <p>Claw EA treats the approval result as an input that changes which tools are allowed, rather than as a prompt instruction that can be ignored.</p>\n  </li>\n  <li>\n    <p><strong>Execute remediation through clawproxy and keep receipts.</strong> Route model calls through clawproxy so you get gateway receipts for the reasoning and tool selection steps that led to the patch. If you use OpenRouter via fal, keep it routed through clawproxy so the same receipt mechanism applies.</p>\n    <p>After execution, emit a proof bundle that includes receipts and the job metadata needed for audit and later verification.</p>\n  </li>\n  <li>\n    <p><strong>Close out with a rollback-ready record.</strong> The agent should produce a rollback checklist, including pre-change snapshots, version pinning, and restart order. Store the proof bundle and, if applicable for your program, publish the audit view as a Trust Pulse for later review.</p>\n    <p>Any gaps, like missing pre-change snapshots, should fail the workflow closed and return to approval rather than “proceed anyway.”</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Vulnerability response is a high-pressure workflow where unsafe defaults show up: untrusted CVE text, copy-pasted commands, and “just restart it” actions. The goal is not perfect security, but consistent containment and verifiable decisions.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection via advisory text, issue comments, or pasted logs</td>\n      <td>The agent is convinced to run extra commands, exfiltrate secrets, or widen permissions “temporarily.”</td>\n      <td>Permissioned tool policy in OpenClaw plus WPC-enforced allow/deny lists; keep write tools denied in triage; require approvals to transition phases.</td>\n    </tr>\n    <tr>\n      <td>Credential overreach and lateral movement</td>\n      <td>A token that can patch one service ends up being used to touch others or a wider environment.</td>\n      <td>Job-scoped CST with scope hash and optional policy hash pinning; keep credentials short-lived and scoped to the minimum API permissions.</td>\n    </tr>\n    <tr>\n      <td>Unsafe patch application</td>\n      <td>The agent applies a patch that breaks dependencies, restarts the wrong service, or changes infra outside the ticket.</td>\n      <td>Forced dry-run and explicit “apply” gate; separate triage versus remediation tools; sandbox tool execution when possible.</td>\n    </tr>\n    <tr>\n      <td>Replay of a previously approved run</td>\n      <td>An attacker reuses an old approval or token to execute a similar action later.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding; approvals tied to job metadata and policy hash.</td>\n    </tr>\n    <tr>\n      <td>Audit gaps after an incident</td>\n      <td>You cannot prove what model calls were made, what policy applied, or whether steps were followed.</td>\n      <td>Gateway receipts for model calls and proof bundles for the job; store and review via Trust Pulse when needed.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows a two-phase WPC: triage is read-only, remediation is gated and requires approval plus simulate-first. The policy is enforced at execution time, not negotiated in the prompt.</p>\n<pre>{\n  \"wpc_version\": \"1\",\n  \"job\": {\n    \"name\": \"vuln-triage-and-patch\",\n    \"risk_notes\": [\"apply patches\", \"restart services\", \"open incident\"]\n  },\n  \"token_requirements\": {\n    \"cst_scope_hash_required\": true,\n    \"policy_hash_pinning\": \"required\"\n  },\n  \"phases\": [\n    {\n      \"name\": \"triage\",\n      \"tools\": {\n        \"allow\": [\"read_repo\", \"search_code\", \"fetch_advisory\", \"query_scanner_api\"],\n        \"deny\": [\"apply_patch\", \"write_repo\", \"restart_service\", \"open_incident\"]\n      },\n      \"sandbox\": { \"mode\": \"all\", \"workspaceAccess\": \"ro\" }\n    },\n    {\n      \"name\": \"remediation\",\n      \"requires\": {\n        \"step_up_approval\": true,\n        \"dry_run_first\": true\n      },\n      \"tools\": {\n        \"allow\": [\"generate_patch_diff\", \"apply_patch\", \"run_tests\", \"restart_service\", \"open_incident\"],\n        \"deny\": [\"shell_unrestricted\", \"exfiltrate_data\"]\n      },\n      \"guards\": {\n        \"simulate_first\": {\n          \"required_tools\": [\"apply_patch\", \"restart_service\", \"open_incident\"],\n          \"evidence_artifact\": \"dry_run_report\"\n        }\n      }\n    }\n  ],\n  \"model_calls\": {\n    \"must_route_via\": [\"clawproxy\"],\n    \"receipts\": \"required\"\n  }\n}</pre>\n<p>If you need environment-specific enforcement like egress allowlists outside clawproxy, that can be implemented, but treat it as an optional control and validate it in your own infrastructure layer.</p>\n\n<h2>What proof do you get?</h2>\n<p>Every model call routed through clawproxy emits gateway receipts that can be checked later. The receipts let you verify that the run used the expected proxy path and that the recorded call metadata matches what was approved.</p>\n<p>At the end of the job, Claw EA produces a proof bundle that packages the gateway receipts and related run metadata for audit and verification. This is the artifact you hand to security engineering, compliance, or incident review to show what was done, under which WPC, and under which CST.</p>\n<p>For cross-team visibility, you can store and view the audit artifact as a Trust Pulse. Use this when you need an immutable viewing surface for postmortems or when sharing evidence with reviewers who should not have direct access to your execution environment.</p>\n\n<h2>Rollback posture</h2>\n<p>Vulnerability remediation fails in predictable ways: package upgrades cascade, restarts fan out, and mitigations become permanent “temporary” changes. Your workflow should produce rollback steps as first-class outputs, and it should prefer actions that are easy to revert.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Apply patches</td>\n      <td>Pin versions, keep a pre-change manifest, and prepare a downgrade or redeploy plan. Require a dry-run report that lists exact versions and files touched.</td>\n      <td>Proof bundle includes the dry-run artifact reference and gateway receipts showing the “apply” step followed an approved simulate-first.</td>\n    </tr>\n    <tr>\n      <td>Restart services</td>\n      <td>Define restart order, health checks, and an automatic abort condition when error budgets trip. Prefer rolling restarts and keep a “stop after N% unhealthy” rule.</td>\n      <td>Receipts show the decision path for restart scope; the job record includes the approved service list and timestamps.</td>\n    </tr>\n    <tr>\n      <td>Open incident</td>\n      <td>Make incident creation idempotent per job, and require linking to the originating ticket. If opened in error, close with a documented reason and retain evidence.</td>\n      <td>Proof bundle ties the action to the job-scoped CST binding; reviewers can confirm it was the authorized run.</td>\n    </tr>\n    <tr>\n      <td>Repository changes for mitigations</td>\n      <td>Use small commits, feature flags, and revert-friendly diffs. Require tests in the remediation phase before merge.</td>\n      <td>Dry-run output includes the proposed diff; receipts show when writes were enabled and that step-up approval preceded it.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Automatic cost budget enforcement can be implemented as a planned control, but you should not rely on it as the primary brake for risky operational actions. Keep the primary brakes in policy and approvals.</p>\n\n<h2>FAQ</h2>\n<h3>Why not just tell the agent “do not patch without approval” in the prompt?</h3>\n<p>Because prompt instructions are not an enforcement boundary. When the agent encounters conflicting text or an injection, prompt-only controls degrade into “best effort,” while policy-as-code keeps tools unavailable until the phase transition is approved.</p>\n\n<h3>How does OpenClaw help with containment during triage?</h3>\n<p>OpenClaw provides sandboxing for tool execution and explicit tool policy, so you can run triage in a constrained environment and keep write tools denied. You can also inspect effective sandbox and tool settings to ensure the runtime matches your intended configuration.</p>\n\n<h3>What do WPC and CST change operationally for a patch run?</h3>\n<p>A WPC defines the allowed actions and gates as a signed policy artifact, and a CST is the job-scoped credential used by the runtime to call services under that policy. With optional policy hash pinning, the CST is only valid for the exact policy you reviewed.</p>\n\n<h3>Can this workflow talk to Microsoft security tools?</h3>\n<p>Yes, via official API, typically using Microsoft Graph permissions/scopes aligned to least privilege. If you use Entra ID, you can combine group checks with Conditional Access and PIM to enforce who can approve remediation steps.</p>\n\n<h3>What is the minimal artifact set to keep for audit?</h3>\n<p>Keep the WPC hash, the job-scoped CST metadata (not the raw token), gateway receipts from clawproxy, and the final proof bundle. That set is usually sufficient to reconstruct what the agent was allowed to do and what it actually did.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://genai.owasp.org/resource/securing-agentic-applications-guide-1-0/\">OWASP: Securing Agentic Applications Guide 1.0</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/copilot/security/agents-overview\">Microsoft Learn: Microsoft Security Copilot agents overview</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "For vulnerability triage and patch coordination, you want an agent that can read evidence, propose a patch plan, and execute only the minimal, permissioned actions needed to remediate. In Claw EA, OpenClaw is the baselin",
  "faqs": [
    {
      "q": "Why not just tell the agent “do not patch without approval” in the prompt?",
      "a": "Because prompt instructions are not an enforcement boundary. When the agent encounters conflicting text or an injection, prompt-only controls degrade into “best effort,” while policy-as-code keeps tools unavailable until the phase transition is approved."
    },
    {
      "q": "How does OpenClaw help with containment during triage?",
      "a": "OpenClaw provides sandboxing for tool execution and explicit tool policy, so you can run triage in a constrained environment and keep write tools denied. You can also inspect effective sandbox and tool settings to ensure the runtime matches your intended configuration."
    },
    {
      "q": "What do WPC and CST change operationally for a patch run?",
      "a": "A WPC defines the allowed actions and gates as a signed policy artifact, and a CST is the job-scoped credential used by the runtime to call services under that policy. With optional policy hash pinning, the CST is only valid for the exact policy you reviewed."
    },
    {
      "q": "Can this workflow talk to Microsoft security tools?",
      "a": "Yes, via official API, typically using Microsoft Graph permissions/scopes aligned to least privilege. If you use Entra ID, you can combine group checks with Conditional Access and PIM to enforce who can approve remediation steps."
    },
    {
      "q": "What is the minimal artifact set to keep for audit?",
      "a": "Keep the WPC hash, the job-scoped CST metadata (not the raw token), gateway receipts from clawproxy, and the final proof bundle. That set is usually sufficient to reconstruct what the agent was allowed to do and what it actually did."
    }
  ],
  "sources": [
    {
      "title": "Securing Agentic Applications Guide 1.0",
      "uri": "https://genai.owasp.org/resource/securing-agentic-applications-guide-1-0/"
    },
    {
      "title": "Microsoft Security Copilot agents overview",
      "uri": "https://learn.microsoft.com/en-us/copilot/security/agents-overview"
    },
    {
      "title": "Security Copilot agent development planning guide",
      "uri": "https://learn.microsoft.com/en-us/copilot/security/developer/planning-guide"
    },
    {
      "title": "Securing Agentic AI: The Agentic AI Security Scoping Matrix",
      "uri": "https://aws.amazon.com/ai/security/agentic-ai-scoping-matrix/"
    },
    {
      "title": "Next '25: Driving secure innovation with AI, Google Unified Security",
      "uri": "https://cloud.google.com/blog/products/identity-security/driving-secure-innovation-with-ai-google-unified-security-next25"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:55:05.533Z",
  "indexable": true
}