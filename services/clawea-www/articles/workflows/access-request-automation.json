{
  "slug": "workflows/access-request-automation",
  "title": "Access requests and entitlement changes | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<h2>Direct Answer</h2>\n<p>Access requests and entitlement changes are safe to automate only when the execution layer is permissioned, not prompt-only. In Claw EA, an OpenClaw agent can assemble evidence and propose changes, but the actual grant, group membership change, or privileged role activation is gated by policy-as-code and explicit approvals.</p>\n<p>The practical pattern is: the agent prepares a change plan, a two-person approval is collected, then a tightly scoped CST (issued by clawscope) allows exactly one change via official API, with gateway receipts (from clawproxy) and a proof bundle generated for audit.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Define the “allowed change surface” in a WPC.</strong> Treat grant access, change group membership, and issue privileged roles as high risk. Encode which resource types are in-scope (for example Entra ID group membership only, no role assignments) and which request attributes must be present (ticket id, manager id, business justification).</p>\n    <p>Store the WPC in the WPC registry and reference it by hash for every run, so the agent cannot silently drift policy mid-flight.</p>\n  </li>\n  <li>\n    <p><strong>Lock down the OpenClaw runtime to match the workflow.</strong> Run the agent with tool allowlists and sandboxing enabled so “investigation tools” (read-only directory, internal docs search, ticket lookup via MCP server) are available, while “mutation tools” are absent until approval is granted.</p>\n    <p>Operationally, you want the agent to be able to draft a plan in a sandbox, and only later receive the minimum capability to execute one specific change.</p>\n  </li>\n  <li>\n    <p><strong>Collect request evidence and normalize it.</strong> The agent pulls the access request from your intake system (via official API or via MCP server), verifies identity attributes, and enumerates the intended entitlement delta. For Microsoft, this means resolving the Entra ID object ids for user, group, and optionally checking whether PIM is required instead of a direct permanent assignment.</p>\n    <p>At this stage the agent should only produce a “change intent” record, not execute any entitlement mutation.</p>\n  </li>\n  <li>\n    <p><strong>Perform step-up approvals with a two-person rule.</strong> Require an approver pair that matches your governance model (for example manager plus system owner, or security plus app owner). The agent posts a summary, but humans approve the exact delta: who, what, how long, and why.</p>\n    <p>Record approver identities and timestamps as part of the job metadata that will be bound into the run’s proof bundle.</p>\n  </li>\n  <li>\n    <p><strong>Issue a job-scoped CST and pin it to the WPC hash.</strong> After approvals, mint a CST (issued by clawscope) whose scope hash matches the single approved action, and optionally pin the policy hash to the WPC used for the decision. Use job-scoped binding to prevent replay of the token in a different job context.</p>\n    <p>This is the core difference versus prompt-only gating: the permission is a machine-checked artifact, not a suggestion in text.</p>\n  </li>\n  <li>\n    <p><strong>Execute the change via official API, routed through clawproxy.</strong> The agent calls Microsoft Graph (or your IAM API) with only the permissions required for the one operation, and the model calls are routed through clawproxy so gateway receipts are emitted for verification. Keep the mutation step minimal: one API call, then immediate read-back to confirm state.</p>\n    <p>If the change involves elevated access, prefer time-bound activation via PIM where your process allows it, and treat it as a separate WPC profile with stricter approval requirements.</p>\n  </li>\n  <li>\n    <p><strong>Close the loop and publish evidence.</strong> Generate a proof bundle containing the gateway receipts and job metadata, then store the artifact for audit. Optionally publish a Trust Pulse so reviewers can view what policy was used, what was approved, and what was executed without re-running the job.</p>\n    <p>Operational outcome: you can answer “who approved what” and “what executed under which policy hash” without trusting the agent’s narrative.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection causes unauthorized entitlement grants</td>\n      <td>The agent is coerced into adding a user to a sensitive group or assigning a role outside the request.</td>\n      <td>WPC constrains allowed targets and operations; mutation requires a CST pinned to the WPC hash and bounded to the job.</td>\n    </tr>\n    <tr>\n      <td>Approval spoofing or “rubber stamp” risk</td>\n      <td>An attacker tries to get a single approver to accept a vague request, or an approver misses hidden scope changes.</td>\n      <td>Two-person rule plus structured change intent: approvers sign off on an explicit delta (object ids, duration, and justification).</td>\n    </tr>\n    <tr>\n      <td>Token replay</td>\n      <td>A captured token is reused later to perform an additional grant.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding; keep CST TTL short and scope to a single operation.</td>\n    </tr>\n    <tr>\n      <td>Over-broad API permissions</td>\n      <td>The automation identity has Graph permissions that allow broader changes than intended.</td>\n      <td>Enforce least privilege at the IAM layer (Graph permissions and Conditional Access policies); in Claw EA, keep the CST scope narrow even if the backend app registration is broader.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable model behavior during the decision</td>\n      <td>You cannot prove which model calls influenced the plan and recommendation.</td>\n      <td>Route model traffic through clawproxy to obtain gateway receipts, then bundle them into a proof bundle for audit.</td>\n    </tr>\n    <tr>\n      <td>Host escape or tool overreach inside the agent runtime</td>\n      <td>The agent uses local shell or filesystem access to exfiltrate secrets or modify configs.</td>\n      <td>Use OpenClaw sandboxing and strict tool allowlists; keep secrets isolated so the investigation phase cannot read mutation credentials.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a JSON-like sketch of a WPC that forces step-up approvals, a two-person rule, secrets isolation, and narrow execution. The intent is to make “what is allowed” machine-checkable, and to ensure the agent cannot escalate itself by rewriting prompts.</p>\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"workflow\": \"access_request_automation\",\n  \"risk_class\": \"high\",\n  \"irreversible_actions\": [\n    \"grant_access\",\n    \"change_group_membership\",\n    \"issue_privileged_roles\"\n  ],\n  \"approvals\": {\n    \"step_up_required\": true,\n    \"two_person_rule\": true,\n    \"required_approver_roles\": [\"manager\", \"resource_owner\"],\n    \"approval_payload_must_include\": [\n      \"request_id\",\n      \"target_user_object_id\",\n      \"target_resource_object_id\",\n      \"action\",\n      \"duration_minutes\",\n      \"justification\"\n    ]\n  },\n  \"execution\": {\n    \"secrets_isolation\": {\n      \"investigation_phase_can_read_secrets\": false,\n      \"mutation_phase_secret_refs\": [\"entra_graph_mutator_credential\"]\n    },\n    \"allowed_operations\": [\n      {\n        \"system\": \"entra_id\",\n        \"action\": \"add_member_to_group\",\n        \"constraints\": {\n          \"allowed_group_object_ids\": [\"<groupA>\", \"<groupB>\"],\n          \"max_duration_minutes\": 480\n        }\n      }\n    ],\n    \"token_requirements\": {\n      \"require_cst\": true,\n      \"cst_scope_hash_must_match\": true,\n      \"optional_policy_hash_pinning\": true,\n      \"job_scoped_binding\": true\n    }\n  },\n  \"audit\": {\n    \"require_gateway_receipts\": true,\n    \"emit_proof_bundle\": true\n  }\n}\n</pre>\n<p>In practice, the WPC is signed and hash-addressed, fetched and verified by the runtime via the WPC registry. The approval payload becomes part of the job record so the CST issuance can be tied to exactly what was approved.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get gateway receipts for model calls emitted by clawproxy. These receipts let you verify that model traffic for the job was routed through the gateway and was not later rewritten in logs.</p>\n<p>You also get a proof bundle that binds together the receipts and run metadata (job id, WPC hash, CST scope hash, and approval references). If you need a shareable audit view, you can store the artifact as a Trust Pulse for later review.</p>\n<p>This evidence is useful for incident response because it separates three questions: what policy was in force (WPC hash), what permission was granted (CST scope hash), and what model calls occurred (gateway receipts). It also supports fail-closed review: runs without the expected artifacts are treated as non-compliant.</p>\n\n<h2>Rollback posture</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to require before rollback</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Add user to Entra ID group</td>\n      <td>Remove user from group via official API; confirm membership state by read-back.</td>\n      <td>Proof bundle with WPC hash and approval payload that authorized the membership add, plus the resulting membership confirmation step.</td>\n    </tr>\n    <tr>\n      <td>Grant app entitlement (application-specific)</td>\n      <td>Revoke entitlement via official API; if the app does not support clean revocation, disable the account as a temporary containment step.</td>\n      <td>Proof bundle plus the app-side entitlement identifier that was modified, so rollback targets the exact record.</td>\n    </tr>\n    <tr>\n      <td>Privileged role activation or assignment</td>\n      <td>If activated through PIM, remove or expire the activation and confirm effective role. If assigned permanently, revoke the assignment and rotate any credentials impacted by the exposure window.</td>\n      <td>Approval record showing step-up approvals and duration, plus proof bundle binding the job to the executed change.</td>\n    </tr>\n    <tr>\n      <td>Policy mistake (WPC too permissive)</td>\n      <td>Update WPC, rotate to a new hash, and require policy hash pinning for future runs so old policies cannot be used silently.</td>\n      <td>List of jobs that referenced the old WPC hash so you can assess and remediate any changes made under that policy.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Rollback for entitlement changes is operationally different from rollback for software deploys: the “undo” action is itself high risk. Treat rollback as a separate, permissioned workflow with its own WPC and approvals, especially for privileged roles.</p>\n\n<h2>FAQ</h2>\n<h3>Why is prompt-only approval not sufficient for access changes?</h3>\n<p>Because prompts are not enforceable. A permissioned execution layer makes the entitlement mutation depend on a CST and a WPC hash, which are machine-checked artifacts rather than text instructions the agent can ignore.</p>\n\n<h3>How does Claw EA prevent an approved token from being reused later?</h3>\n<p>Use job-scoped CST binding to make replay in a different job context fail. Keep the CST scope narrow and TTL short so even within the same job it is hard to stretch beyond the approved action.</p>\n\n<h3>Can this work with Microsoft Entra ID and Microsoft Graph?</h3>\n<p>Yes, using Microsoft Graph via official API, with the automation identity constrained by Graph permissions and your Conditional Access policies. Claw EA adds policy-as-code (WPC) and token scoping (CST) so the agent cannot exceed the approved change, even if the request text is manipulated.</p>\n\n<h3>What do auditors actually review after an incident?</h3>\n<p>They review the WPC hash used for the run, the approval payload for the two-person rule, and the proof bundle containing gateway receipts for model calls. This gives a concrete chain from policy to permission to execution, rather than a narrative summary.</p>\n\n<h3>Do I need to sandbox the agent if I already restrict API permissions?</h3>\n<p>Yes, because the agent runtime can still expose local secrets and tooling that are unrelated to Graph permissions. OpenClaw sandboxing and tool policy reduce the chance that a single prompt injection turns into host-level access or credential leakage.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/entra/id-governance/identity-governance-overview\">Microsoft Entra ID Governance overview</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/entra/id-governance/access-review-agent\">Microsoft Entra Access Review Agent documentation</a></li>\n  <li><a href=\"https://aws.amazon.com/ai/security/agentic-ai-scoping-matrix/\">AWS Agentic AI Security Scoping Matrix</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Access requests and entitlement changes are safe to automate only when the execution layer is permissioned, not prompt-only. In Claw EA, an OpenClaw agent can assemble evidence and propose changes, but the actual grant, ",
  "faqs": [
    {
      "q": "Why is prompt-only approval not sufficient for access changes?",
      "a": "Because prompts are not enforceable. A permissioned execution layer makes the entitlement mutation depend on a CST and a WPC hash, which are machine-checked artifacts rather than text instructions the agent can ignore."
    },
    {
      "q": "How does Claw EA prevent an approved token from being reused later?",
      "a": "Use job-scoped CST binding to make replay in a different job context fail. Keep the CST scope narrow and TTL short so even within the same job it is hard to stretch beyond the approved action."
    },
    {
      "q": "Can this work with Microsoft Entra ID and Microsoft Graph?",
      "a": "Yes, using Microsoft Graph via official API, with the automation identity constrained by Graph permissions and your Conditional Access policies. Claw EA adds policy-as-code (WPC) and token scoping (CST) so the agent cannot exceed the approved change, even if the request text is manipulated."
    },
    {
      "q": "What do auditors actually review after an incident?",
      "a": "They review the WPC hash used for the run, the approval payload for the two-person rule, and the proof bundle containing gateway receipts for model calls. This gives a concrete chain from policy to permission to execution, rather than a narrative summary."
    },
    {
      "q": "Do I need to sandbox the agent if I already restrict API permissions?",
      "a": "Yes, because the agent runtime can still expose local secrets and tooling that are unrelated to Graph permissions. OpenClaw sandboxing and tool policy reduce the chance that a single prompt injection turns into host-level access or credential leakage."
    }
  ],
  "sources": [
    {
      "title": "Microsoft Entra Ignite 2025: Key Announcements and Updates",
      "uri": "https://learn.microsoft.com/en-us/entra/fundamentals/whats-new-ignite-2025"
    },
    {
      "title": "Microsoft Security Copilot Access Review Agent in Microsoft Entra - Microsoft Entra ID Governance",
      "uri": "https://learn.microsoft.com/en-us/entra/id-governance/access-review-agent"
    },
    {
      "title": "Securing Agentic AI: The Agentic AI Security Scoping Matrix",
      "uri": "https://aws.amazon.com/ai/security/agentic-ai-scoping-matrix/"
    },
    {
      "title": "What Are Agentic Workflows?",
      "uri": "https://www.salesforce.com/agentforce/agentic-workflows/"
    },
    {
      "title": "Microsoft Security Copilot Access Review Agent in Microsoft Entra",
      "uri": "https://learn.microsoft.com/en-us/entra/security-copilot/access-review-agent"
    },
    {
      "title": "Microsoft Entra ID Governance",
      "uri": "https://learn.microsoft.com/en-us/entra/id-governance/identity-governance-overview"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:33:00.936Z",
  "indexable": true
}