{
  "slug": "workflows/data-exfiltration-prevention",
  "title": "Prevent agent exfiltration in tool runs | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<h2>Direct Answer</h2>\n<p>To prevent agent exfiltration during tool runs, you need permissioned execution that is enforced by the runtime, not a prompt instruction that can be bypassed. In Claw EA, run OpenClaw as the baseline agent runtime, then bind every job to a WPC and a CST so the agent can only use the tools, files, and outbound paths that the policy allows.</p>\n<p>When model traffic is routed through clawproxy, you also get Gateway receipts for model calls and a proof bundle you can verify later. This makes exfiltration attempts easier to detect and easier to prove after the fact, especially for webhook and changefeed style workflows where replay and idempotency bugs are common.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Classify tool outputs as reversible vs irreversible.</strong> Treat uploads, outbound webhooks, and any cross-boundary send as high risk. Decide upfront which tools are allowed to emit network requests, and which can only write to a local workspace.</p>\n  </li>\n  <li>\n    <p><strong>Define a WPC that enumerates tool permissions, file scopes, and outbound destinations.</strong> Use a minimal allowlist, then widen it intentionally when you see real failures. Store the WPC as a signed, hash-addressed artifact and reference it by hash in your run configuration.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the job and pin it to the WPC hash.</strong> The CST is issued by clawscope and should include a scope hash that matches your intended permissions. Use job-scoped CST binding to reduce replay risk, so a token from one job cannot be reused to perform the same webhook send in another job.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy and require Gateway receipts.</strong> This is the easiest place to get verifiable evidence of what the model was asked and what it returned. If you use OpenRouter via fal, route it through clawproxy so every model call emits receipts.</p>\n  </li>\n  <li>\n    <p><strong>Enforce file path read and write scopes inside the tool runner.</strong> In OpenClaw, prefer sandboxed tool execution and mount only the minimum workspace paths as read-only or read-write. Keep secrets and credentials outside the mounted workspace, and treat any tool that can read arbitrary paths as a privileged capability.</p>\n  </li>\n  <li>\n    <p><strong>Implement DLP and redaction at two points: logs and outbound payloads.</strong> Configure OpenClaw logging redaction so tool logs do not spill secrets, and add explicit payload filters in your outbound tools (webhook sender, HTTP client, file uploader). This is where you enforce “no raw document text”, “no credential-like strings”, and “only these fields may leave”.</p>\n  </li>\n  <li>\n    <p><strong>Harden webhooks and changefeeds with idempotency and replay controls.</strong> Require idempotency keys on outbound webhook sends, store a dedupe record for a bounded time window, and refuse replays that do not match the expected job id and policy hash. Sign webhook payloads (HMAC or asymmetric) and verify responses strictly, since webhook destinations are a common exfil channel disguised as normal integration traffic.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Exfiltration in tool runs usually looks like a normal integration. The attacker goal is to get the agent to copy sensitive data into an outbound request, a file upload, or a durable changefeed record that an external system later exports.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection triggers an “innocent” tool to send secrets</td>\n      <td>The agent is instructed to include credentials or document text in a webhook payload or HTTP request.</td>\n      <td>Permissioned execution via WPC tool allowlists plus outbound payload DLP and schema checks; do not rely on “never send secrets” prompt text.</td>\n    </tr>\n    <tr>\n      <td>Over-broad filesystem access</td>\n      <td>A tool reads <code>~/.ssh</code>, cloud creds, or other host files and then stages them for upload.</td>\n      <td>Sandboxed tool execution, minimal bind mounts, and explicit file path read scopes; deny “read all” tools unless they are isolated and reviewed.</td>\n    </tr>\n    <tr>\n      <td>Webhook replay and idempotency gaps</td>\n      <td>An attacker repeats a previously valid send, or forces double-sends that leak more data over time.</td>\n      <td>Job-scoped CST binding to reduce cross-job replay, plus idempotency keys and dedupe storage at the webhook tool layer.</td>\n    </tr>\n    <tr>\n      <td>Changefeed as a covert channel</td>\n      <td>The agent writes sensitive fields into a record stream that later syncs to external systems.</td>\n      <td>WPC field-level constraints for write tools (allowed fields, max payload size), and outbound redaction before commits.</td>\n    </tr>\n    <tr>\n      <td>Model output laundering</td>\n      <td>Sensitive content appears in the model output and is forwarded by tooling without validation.</td>\n      <td>Require outbound tools to re-validate and redact payloads even if the model produced them; attach receipts so you can correlate output to send attempts.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>The goal of policy-as-code is to make the execution layer fail closed even when the agent is manipulated. A prompt can be overridden by a single malicious message, but a WPC can be verified and enforced consistently for every tool call.</p>\n<p>Below is a compact, JSON-like example of a WPC-style policy shape you can use in your organization. Treat it as a template: your WPC should specify the exact tool IDs you run in OpenClaw, the file scopes the sandbox can mount, and the only outbound destinations that can receive data.</p>\n\n<pre>{\n  \"policy_name\": \"no-exfiltration-tool-run\",\n  \"version\": 1,\n\n  \"tools\": {\n    \"allow\": [\n      \"fs.read_scoped\",\n      \"fs.write_scoped\",\n      \"webhook.send_scoped\",\n      \"http.fetch_scoped\"\n    ],\n    \"deny\": [\n      \"fs.read_all\",\n      \"shell.exec_host\",\n      \"uploader.send_unscoped\"\n    ]\n  },\n\n  \"filesystem\": {\n    \"read_paths\": [\n      \"/workspace/input/\",\n      \"/workspace/context/\"\n    ],\n    \"write_paths\": [\n      \"/workspace/output/\",\n      \"/workspace/tmp/\"\n    ],\n    \"deny_paths\": [\n      \"/home/\",\n      \"/root/\",\n      \"/etc/\",\n      \"/proc/\",\n      \"/var/run/docker.sock\"\n    ]\n  },\n\n  \"egress\": {\n    \"domain_allowlist\": [\n      \"hooks.example.com\",\n      \"api.example.com\"\n    ],\n    \"ip_allowlist\": [\n      \"203.0.113.10/32\"\n    ],\n    \"notes\": \"Egress allowlists are typically enforced at the network layer. This can be implemented outside clawproxy (optional) and should be treated as required for high-risk tools.\"\n  },\n\n  \"dlp\": {\n    \"redact_patterns\": [\n      \"AKIA[0-9A-Z]{16}\",\n      \"-----BEGIN PRIVATE KEY-----\",\n      \"(?i)password\\\\s*[:=]\"\n    ],\n    \"max_outbound_bytes\": 8192,\n    \"allowed_outbound_fields\": [\n      \"event_type\",\n      \"record_id\",\n      \"status\",\n      \"summary\"\n    ]\n  },\n\n  \"webhooks\": {\n    \"require_idempotency_key\": true,\n    \"idempotency_ttl_seconds\": 86400,\n    \"require_payload_signature\": true\n  }\n}</pre>\n\n<h2>What proof do you get?</h2>\n<p>When model calls are routed through clawproxy, each call yields Gateway receipts that can be verified later. These receipts are the backbone for post-incident questions like “which model response led to the outbound send?” and “did the model output contain the secret, or did the tool add it?”.</p>\n<p>For an operational audit trail, package the receipts into a proof bundle together with run metadata you control, such as the WPC hash, the CST scope hash, tool invocation summaries, and hashes of produced artifacts. Store or publish the resulting artifact to Trust Pulse when you need a durable review surface for internal audit or external verification.</p>\n\n<h2>Rollback posture</h2>\n<p>Exfiltration controls should assume some actions cannot be undone. The rollback plan is therefore about making irreversible sends hard to execute, easy to detect, and attributable to a specific job configuration.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Outbound webhook send with sensitive payload</td>\n      <td>Disable the webhook tool in the WPC, rotate destination secrets, and invalidate job CST issuance for that workflow until reviewed.</td>\n      <td>Proof bundle containing the WPC hash, CST scope hash, and correlated Gateway receipts around the decision point.</td>\n    </tr>\n    <tr>\n      <td>File upload to external system</td>\n      <td>Remove upload capability from the policy, revoke external credentials, and request deletion via official API if the vendor supports it.</td>\n      <td>Artifact hashes recorded in the proof bundle, plus tool invocation logs you attach for chain-of-custody.</td>\n    </tr>\n    <tr>\n      <td>Changefeed write of sensitive fields</td>\n      <td>Stop the writer tool, run a compensating scrub job via official API, and tighten field allowlists to only non-sensitive fields.</td>\n      <td>Proof bundle metadata showing which tool wrote, with timestamps aligned to Gateway receipts for the triggering model output.</td>\n    </tr>\n    <tr>\n      <td>Over-broad filesystem mount discovered after the fact</td>\n      <td>Reconfigure sandbox mounts to minimal scopes, rotate any secrets that were accessible, and re-run the OpenClaw security audit.</td>\n      <td>Configuration diffs plus a new proof bundle for the remediated run; keep the prior bundle for incident review.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is prompt-only “do not exfiltrate data” not sufficient?</h3>\n<p>Because prompts are not an enforcement boundary. A single injected instruction can cause the agent to call a tool with real side effects, so the execution layer must be permissioned using policy-as-code that the runtime can fail closed on.</p>\n\n<h3>How do WPC and CST reduce webhook replay risk?</h3>\n<p>A WPC defines what is allowed, and a CST can be pinned to the WPC hash so the job can only act under that policy. With job-scoped CST binding, a captured token is less useful outside the original job context, which helps reduce cross-job replay.</p>\n\n<h3>Where should egress allowlists be enforced?</h3>\n<p>For high assurance, enforce egress allowlists at the network layer close to the sandbox or runner. Egress allowlists enforced outside clawproxy are optional and can be implemented, but for exfiltration prevention they should be treated as mandatory for outbound tools.</p>\n\n<h3>How do I make webhooks idempotent in an agent workflow?</h3>\n<p>Require an idempotency key per outbound send, persist a dedupe record for a fixed TTL, and reject duplicates even if the model retries. Bind the idempotency key format to job identifiers so a copied key cannot be replayed in a different run.</p>\n\n<h3>What should I audit after changing tool permissions?</h3>\n<p>Run the OpenClaw security audit and confirm the effective sandbox and tool policy configuration, not just the intended config. Then run a canary job and review the proof bundle to ensure the WPC hash and CST scope hash match what you expect.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-copilot-studio/external-security-provider\">Enable external threat detection and protection for Copilot Studio custom agents (preview)</a></li>\n  <li><a href=\"https://docs.aws.amazon.com/prescriptive-guidance/latest/agentic-ai-patterns/introduction.html\">Agentic AI patterns and workflows on AWS</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "To prevent agent exfiltration during tool runs, you need permissioned execution that is enforced by the runtime, not a prompt instruction that can be bypassed. In Claw EA, run OpenClaw as the baseline agent runtime, then",
  "faqs": [
    {
      "q": "Why is prompt-only “do not exfiltrate data” not sufficient?",
      "a": "Because prompts are not an enforcement boundary. A single injected instruction can cause the agent to call a tool with real side effects, so the execution layer must be permissioned using policy-as-code that the runtime can fail closed on."
    },
    {
      "q": "How do WPC and CST reduce webhook replay risk?",
      "a": "A WPC defines what is allowed, and a CST can be pinned to the WPC hash so the job can only act under that policy. With job-scoped CST binding, a captured token is less useful outside the original job context, which helps reduce cross-job replay."
    },
    {
      "q": "Where should egress allowlists be enforced?",
      "a": "For high assurance, enforce egress allowlists at the network layer close to the sandbox or runner. Egress allowlists enforced outside clawproxy are optional and can be implemented, but for exfiltration prevention they should be treated as mandatory for outbound tools."
    },
    {
      "q": "How do I make webhooks idempotent in an agent workflow?",
      "a": "Require an idempotency key per outbound send, persist a dedupe record for a fixed TTL, and reject duplicates even if the model retries. Bind the idempotency key format to job identifiers so a copied key cannot be replayed in a different run."
    },
    {
      "q": "What should I audit after changing tool permissions?",
      "a": "Run the OpenClaw security audit and confirm the effective sandbox and tool policy configuration, not just the intended config. Then run a canary job and review the proof bundle to ensure the WPC hash and CST scope hash match what you expect."
    }
  ],
  "sources": [
    {
      "title": "Enable external threat detection and protection for Copilot Studio custom agents (preview) - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/external-security-provider"
    },
    {
      "title": "Agentic AI patterns and workflows on AWS",
      "uri": "https://docs.aws.amazon.com/prescriptive-guidance/latest/agentic-ai-patterns/introduction.html"
    },
    {
      "title": "Agent Engine Threat Detection overview",
      "uri": "https://cloud.google.com/security-command-center/docs/agent-engine-threat-detection-overview"
    },
    {
      "title": "Data Cloud Governance: Protecting Your Data in the Agentic Landscape",
      "uri": "https://admin.salesforce.com/blog/2025/data-cloud-governance-protecting-your-data-agentforce"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:40:20.374Z",
  "indexable": true
}