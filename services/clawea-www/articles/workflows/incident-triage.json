{
  "slug": "workflows/incident-triage",
  "title": "Incident triage and response coordination | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<p>Incident triage and response coordination works best when the agent runtime is constrained by machine-enforced policy, not by “please be careful” prompt text. In Claw EA, OpenClaw is the baseline agent runtime, and Claw Bureau adds permissioned execution with WPCs, CSTs, gateway receipts, and proof bundles so you can prove what happened and safely roll it back.</p>\n<p>The operational goal is simple: let an agent gather evidence and draft actions quickly, but require explicit policy and step-up approvals for irreversible moves like disable access, block egress, rotate keys, or declare incident. You end each run with verifiable artifacts that can be reviewed after the fact without trusting the agent’s narrative.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>This runbook assumes you already have an incident channel and an on-call rotation. It also assumes your agent can reach your systems via official API, via MCP server, or via an enterprise buildout.</p>\n\n<ol>\n  <li>\n    <p><strong>Create a case and select an incident WPC.</strong> Treat the WPC as the “what is allowed” contract for this specific incident severity and environment. The WPC is fetched and verified via the WPC registry, and its hash becomes the anchor for the run.</p>\n    <p>Do not start with a broad “security engineer” prompt and full tool access. Start with a narrow WPC that permits read-only evidence collection and drafting, then escalate in controlled steps.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the job, pinned to the case scope.</strong> Mint a CST (issued by clawscope) that is job-scoped and bound to the incident identifiers you care about, such as case ID and environment. Use CST scope hash and optional policy hash pinning so the token is only valid for the intended policy.</p>\n    <p>This makes token reuse harder across cases, and it reduces the chance that a copied token can be replayed in a different context.</p>\n  </li>\n  <li>\n    <p><strong>Start OpenClaw in “triage mode” with tool allow/deny lists.</strong> Configure OpenClaw tool policy to allow only evidence collection tools (logs, ticket read, alert read, query tools) and deny any tool that can mutate production by default. If you use sandboxing, keep tool execution inside the sandbox unless an explicitly approved step requires elevated execution.</p>\n    <p>OpenClaw’s separation of sandbox, tool policy, and elevated execution matters during incidents because “read data” and “change system state” need different controls.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy and collect gateway receipts.</strong> Configure the model provider path so model calls are proxied and receipted, for example OpenRouter via fal routed through clawproxy. Each model call yields gateway receipts that can later be verified independently of your chat transcript.</p>\n    <p>This step is what turns “the agent said it did X” into “here are the signed receipts for the model interactions that produced the recommendation.”</p>\n  </li>\n  <li>\n    <p><strong>Evidence sweep: gather, normalize, and summarize.</strong> Have the agent pull the minimum needed telemetry: alert details, recent deployments, auth events, network anomalies, and key asset inventory. Keep write actions disabled, and require the agent to cite specific evidence objects (IDs, timestamps, query links) in its summary.</p>\n    <p>If you use Microsoft security data, collect it via official API with appropriate Microsoft Graph permissions/scopes, and prefer temporary elevation through PIM where applicable. Conditional Access can be used to restrict where the human approver can authenticate from, but do not rely on it as the only control.</p>\n  </li>\n  <li>\n    <p><strong>Step-up approvals for irreversible actions.</strong> When the agent proposes an action like disable access, block egress, rotate keys, or declare incident, it must pause and request a human approval with a clearly stated blast radius and rollback plan. On approval, re-issue a new CST or switch to a stricter WPC variant that explicitly allows only the requested action and nothing else.</p>\n    <p>This is the core difference between prompt-only guardrails and permissioned execution: the enforcement is in the execution layer, not in the agent’s self-restraint.</p>\n  </li>\n  <li>\n    <p><strong>Close the loop: produce a proof bundle and publish for review.</strong> At the end of the run, package gateway receipts and run metadata into a proof bundle. Store the proof bundle in Trust Pulse so responders and auditors can review what policy was in force, what the agent asked the model, and what actions were approved.</p>\n    <p>In post-incident review, you should be able to answer “what did we allow?” and “what did we do?” without reconstructing intent from chat logs.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Incident response is adversarial by default, and the agent’s inputs are often hostile: alert text, ticket comments, pasted terminal output, and user-provided artifacts. Design the workflow so the agent can read widely but act narrowly, and so approvals are visible and attributable.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection from incident artifacts</td>\n      <td>An attacker hides instructions in logs or tickets to trick the agent into disabling access or rotating keys.</td>\n      <td>WPC tool allow/deny lists default to read-only; irreversible tools require step-up approval and a policy change before execution.</td>\n    </tr>\n    <tr>\n      <td>Tool escalation to host execution</td>\n      <td>The agent finds a path to run elevated commands and touches host files or secrets during triage.</td>\n      <td>OpenClaw sandboxing for tool execution, deny elevated tools by default, and isolate “elevated” into a separate approved step.</td>\n    </tr>\n    <tr>\n      <td>Token replay across incidents</td>\n      <td>A CST copied from one case is reused to run actions in another case or environment.</td>\n      <td>Marketplace anti-replay binding with job-scoped CST binding, plus CST scope hash and optional policy hash pinning.</td>\n    </tr>\n    <tr>\n      <td>Disputed “who approved what”</td>\n      <td>After the incident, no one can prove whether a human approved a high-risk action or if it was improvised.</td>\n      <td>Step-up approvals are treated as explicit gates; store decision metadata alongside the proof bundle and WPC hash.</td>\n    </tr>\n    <tr>\n      <td>Model call integrity disputes</td>\n      <td>Someone claims the agent never asked the model to do a certain analysis, or that outputs were edited.</td>\n      <td>Gateway receipts from clawproxy for model calls, packaged into a proof bundle for verification and review.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a simplified, JSON-like sketch of an incident triage WPC. The point is that the enforcement lives in policy and tokens, not in the prompt.</p>\n\n<pre>\n{\n  \"wpc\": {\n    \"name\": \"incident-triage-sev2\",\n    \"mode\": \"triage\",\n    \"tools\": {\n      \"allow\": [\n        \"tickets.read\",\n        \"alerts.read\",\n        \"logs.query\",\n        \"inventory.read\",\n        \"evidence.export\"\n      ],\n      \"deny\": [\n        \"access.disable\",\n        \"network.block_egress\",\n        \"keys.rotate\",\n        \"incident.declare\"\n      ]\n    },\n    \"approvals\": {\n      \"step_up_required_for\": [\n        \"access.disable\",\n        \"network.block_egress\",\n        \"keys.rotate\",\n        \"incident.declare\"\n      ],\n      \"approver_group\": \"oncall-incident-command\"\n    },\n    \"kill_switch\": {\n      \"on_trigger\": \"deny_all_mutations\",\n      \"note\": \"Emergency stop if behavior deviates or scope is unclear.\"\n    }\n  },\n  \"cst\": {\n    \"issued_by\": \"clawscope\",\n    \"scope_hash\": \"job:INC-24817:prod\",\n    \"policy_hash_pinning\": \"optional\",\n    \"bind\": {\n      \"case_id\": \"INC-24817\",\n      \"environment\": \"prod\",\n      \"job_scoped\": true\n    }\n  }\n}\n</pre>\n\n<p>In practice, you keep “triage” and “containment” as separate WPCs. Moving from one to the other is a deliberate act, not an emergent behavior from a longer prompt.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get gateway receipts for model calls, emitted by clawproxy, which let you verify that specific model interactions occurred under a specific CST and policy context. Those receipts are assembled into a proof bundle, which ties together the run metadata, policy hash references, and receipt envelopes for audit and verification.</p>\n<p>For coordination work, the proof bundle is the handoff artifact. It supports a clean separation between “fast iteration” during triage and “slow certainty” during review, because the reviewer can check the WPC used, the CST scope hash, and the set of receipted model calls that drove recommendations.</p>\n<p>When you need a durable place to store and view the run’s evidence package, publish the proof bundle to Trust Pulse. This is useful for post-incident review, compliance sampling, and internal dispute resolution about what was permitted and what actually happened.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback in incident response is mostly about avoiding irreversible actions until you have sufficient evidence. When you must do irreversible work, you make the rollback plan explicit and you capture evidence that the right policy and approvals were in force.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Disable access</td>\n      <td>Prefer temporary disable with an expiry; document which identities were impacted and why. Re-enable only after confirming containment criteria.</td>\n      <td>WPC that explicitly allowed the action, step-up approval record, and the proof bundle for the run that proposed and executed it.</td>\n    </tr>\n    <tr>\n      <td>Block egress</td>\n      <td>Start with the narrowest scope (service or subnet), time-box the block, and keep an exception path for critical dependencies.</td>\n      <td>Approval gate metadata plus the policy change that moved from triage to containment permissions.</td>\n    </tr>\n    <tr>\n      <td>Rotate keys</td>\n      <td>Stage new keys first, validate consumers, then revoke old keys. Keep a documented backout window if service stability is at risk.</td>\n      <td>Proof bundle showing the recommendation chain, plus explicit human approval before mutation tools were enabled.</td>\n    </tr>\n    <tr>\n      <td>Declare incident</td>\n      <td>Use a reversible “suspected incident” state if your process supports it; upgrade severity only after validation. Keep stakeholder comms templated and consistent.</td>\n      <td>WPC and approval log showing the declaration was intentional, not triggered by untrusted inputs.</td>\n    </tr>\n    <tr>\n      <td>Emergency stop (kill switch)</td>\n      <td>Revoke the CST and switch to a deny-all-mutations WPC variant. Restart in read-only mode to preserve evidence gathering without further changes.</td>\n      <td>CST revocation event plus the WPC hash for the emergency posture attached to the incident record.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why isn’t a carefully written prompt enough for incident response?</h3>\n<p>Because incident artifacts are untrusted input, and the agent is incentivized to “be helpful” under pressure. Permissioned execution puts the guardrails in enforceable policy (WPC plus CST constraints), so the agent cannot perform irreversible actions unless the execution layer allows it.</p>\n\n<h3>What is the minimum set of controls you recommend for triage?</h3>\n<p>Start with tool allow/deny lists, sandboxed tool execution where feasible, and step-up approvals for disable access, block egress, rotate keys, and declare incident. Add a kill switch that can immediately revoke the CST and force a deny-all-mutations posture.</p>\n\n<h3>How do gateway receipts and proof bundles help in a post-incident review?</h3>\n<p>They let reviewers verify model calls and policy context without trusting a chat transcript or a human summary. The proof bundle becomes the audit anchor: which WPC was in force, which CST scope hash was used, and which model interactions were receipted.</p>\n\n<h3>Can this workflow operate in a Microsoft environment?</h3>\n<p>Yes, but treat Microsoft Graph access as a privileged integration and scope it tightly. Use Entra ID controls like PIM for time-bound elevation and Conditional Access for approver sign-in constraints, and collect data via official API with explicit permissions/scopes.</p>\n\n<h3>What should we do if the agent starts behaving unexpectedly mid-incident?</h3>\n<p>Trigger the kill switch: revoke the CST and move to a deny-all-mutations WPC posture. Restart the run in read-only mode so you can continue evidence collection while you inspect the proof bundle for what the agent was attempting.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit guidance and common footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns\">Microsoft Learn: AI agent orchestration patterns (Azure Architecture Center)</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Incident triage and response coordination works best when the agent runtime is constrained by machine-enforced policy, not by “please be careful” prompt text. In Claw EA, OpenClaw is the baseline agent runtime, and Claw ",
  "faqs": [
    {
      "q": "Why isn’t a carefully written prompt enough for incident response?",
      "a": "Because incident artifacts are untrusted input, and the agent is incentivized to “be helpful” under pressure. Permissioned execution puts the guardrails in enforceable policy (WPC plus CST constraints), so the agent cannot perform irreversible actions unless the execution layer allows it."
    },
    {
      "q": "What is the minimum set of controls you recommend for triage?",
      "a": "Start with tool allow/deny lists, sandboxed tool execution where feasible, and step-up approvals for disable access, block egress, rotate keys, and declare incident. Add a kill switch that can immediately revoke the CST and force a deny-all-mutations posture."
    },
    {
      "q": "How do gateway receipts and proof bundles help in a post-incident review?",
      "a": "They let reviewers verify model calls and policy context without trusting a chat transcript or a human summary. The proof bundle becomes the audit anchor: which WPC was in force, which CST scope hash was used, and which model interactions were receipted."
    },
    {
      "q": "Can this workflow operate in a Microsoft environment?",
      "a": "Yes, but treat Microsoft Graph access as a privileged integration and scope it tightly. Use Entra ID controls like PIM for time-bound elevation and Conditional Access for approver sign-in constraints, and collect data via official API with explicit permissions/scopes."
    },
    {
      "q": "What should we do if the agent starts behaving unexpectedly mid-incident?",
      "a": "Trigger the kill switch: revoke the CST and move to a deny-all-mutations WPC posture. Restart the run in read-only mode so you can continue evidence collection while you inspect the proof bundle for what the agent was attempting."
    }
  ],
  "sources": [
    {
      "title": "AI Agent Orchestration Patterns - Azure Architecture Center",
      "uri": "https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns"
    },
    {
      "title": "Security Copilot agent development planning guide",
      "uri": "https://learn.microsoft.com/en-us/copilot/security/developer/planning-guide"
    },
    {
      "title": "AWS Security Incident Response now provides agentic AI-powered investigation - AWS",
      "uri": "https://aws.amazon.com/about-aws/whats-new/2025/11/aws-security-incident-response-agentic-ai-powered-investigation"
    },
    {
      "title": "Use Triage Agent to investigate alerts",
      "uri": "https://docs.cloud.google.com/chronicle/docs/secops/triage-agent"
    },
    {
      "title": "The dawn of agentic AI in security operations at RSAC 2025",
      "uri": "https://cloud.google.com/blog/products/identity-security/the-dawn-of-agentic-ai-in-security-operations-at-rsac-2025"
    },
    {
      "title": "How Agentforce Enabled Incident Response Automation",
      "uri": "https://engineering.salesforce.com/how-agentforce-enabled-incident-response-automation-to-cut-common-resolution-time-by-70-80/"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:41:27.151Z",
  "indexable": true
}