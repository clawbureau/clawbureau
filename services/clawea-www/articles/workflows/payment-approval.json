{
  "slug": "workflows/payment-approval",
  "title": "Payment and invoice approvals | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<p>For payment and invoice approvals, treat the agent as an untrusted operator: it can prepare evidence and drafts, but it must not be able to send payments, approve invoices, or update payout destinations without machine-enforced gates. In Claw EA, you run the workflow on the OpenClaw baseline agent runtime, then enforce permissions with a WPC and job-scoped CST so the execution layer fails closed even if prompts are manipulated.</p>\n<p>Prompt-only controls are not enough because prompts can be overridden by user input, injected invoice text, or tool output. Policy-as-code is how you force “dry-run only”, “two-person rule”, and “step-up approvals” at the tool and token boundary, with gateway receipts and a proof bundle to verify what actually happened.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Define the irreversible actions and split the workflow.</strong> Make “send payment”, “approve invoice”, and “update payout destination” separate steps from “collect invoice”, “match PO”, and “draft payment batch”. Keep irreversible actions behind explicit approval gates.</p>\n  </li>\n  <li>\n    <p><strong>Write a WPC for payment approval work.</strong> Store a WPC = Work Policy Contract in the WPC registry (served by clawcontrols). Include: forced dry-run for payment tools, two-person rule, required approver roles, and caps for amount and vendor risk tier.</p>\n  </li>\n  <li>\n    <p><strong>Issue a job-scoped CST for the run.</strong> Create a CST = scoped token (issued by clawscope) that is bound to the specific job and pinned to the WPC hash when you want strict policy immutability. This ensures a token minted for “draft-only” cannot later be replayed for “send payment” in another run.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent in a sandboxed tool environment.</strong> In OpenClaw, enable sandboxing for tool execution so file and process access is constrained. Keep elevated execution off for payment workflows unless you can justify it and you have compensating controls.</p>\n  </li>\n  <li>\n    <p><strong>Force a dry-run phase and produce an approval packet.</strong> The agent generates a payment proposal: invoice metadata, matching results, exception notes, and a signed “intent” summary that includes vendor, amount, currency, and destination reference. The proposal is immutable input to the approval step (hash it and include the hash in the approval request).</p>\n  </li>\n  <li>\n    <p><strong>Collect step-up approvals with a two-person rule.</strong> Route the approval to two distinct humans (for example AP manager plus controller). If you use Microsoft tooling, implement the approval workflow via official API and enforce identities with Entra ID, plus Conditional Access and PIM where appropriate for approver roles.</p>\n  </li>\n  <li>\n    <p><strong>Execute payment only after approvals re-issue a new CST.</strong> After both approvals, mint a new CST with a narrower TTL and a higher-risk scope that allows only the exact payment action for the exact proposal hash. The agent executes the single irreversible step and then the token expires.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Payment workflows fail when a model can directly reach payment rails or when it can change what humans think they approved. The controls below are operational and should be testable with red-team prompts and injected invoice content.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (what you enforce)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection via invoice text or email thread</td>\n      <td>The agent is convinced to skip checks, change amounts, or “approve now”.</td>\n      <td>WPC denies irreversible tools by default and forces dry-run. Approvals are required inputs, not optional instructions, and CST scopes prevent payment without the approval-bound token.</td>\n    </tr>\n    <tr>\n      <td>Payout destination manipulation</td>\n      <td>The agent updates bank details or swaps destination IDs before payment.</td>\n      <td>WPC blocks “update payout destination” entirely or requires a separate step-up approval and a separate CST. Approval packet includes destination reference and hash so changes are detectable.</td>\n    </tr>\n    <tr>\n      <td>Approval spoofing or ambiguous assent</td>\n      <td>A single person approval is treated as enough, or a chat message is mistaken for approval.</td>\n      <td>Two-person rule in WPC plus explicit approver identities (Entra ID) and a required approval object that binds to the proposal hash. No “free-form text means approved”.</td>\n    </tr>\n    <tr>\n      <td>Tool overreach from broad credentials</td>\n      <td>The agent can do more than intended if it obtains a powerful credential or token.</td>\n      <td>CST minted per job with minimal scope and short TTL. Optional policy hash pinning ensures the token is only valid under the specific WPC hash.</td>\n    </tr>\n    <tr>\n      <td>Replay of a previously valid payment token</td>\n      <td>A captured token is used to send another payment later.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) and short TTL. Require proposal-hash binding in the WPC so the token is useless for any other payload.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable model behavior after an incident</td>\n      <td>You cannot prove what prompts and model calls caused the payment.</td>\n      <td>All model calls routed through clawproxy produce gateway receipts. The run emits a proof bundle for audit and verification, and can be stored as a Trust Pulse artifact for viewing.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a compact JSON-like example of the intent you encode in a WPC. Your real WPC will include your internal role names, risk tiers, and the exact tool names exposed in your OpenClaw deployment.</p>\n\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"workflow\": \"payment_and_invoice_approval\",\n  \"risk\": \"high\",\n  \"irreversible_actions\": [\n    \"send_payment\",\n    \"approve_invoice\",\n    \"update_payout_destination\"\n  ],\n  \"defaults\": {\n    \"mode\": \"dry_run_only\",\n    \"require_evidence_packet\": true\n  },\n  \"approvals\": {\n    \"step_up_required_for\": [\"send_payment\", \"approve_invoice\", \"update_payout_destination\"],\n    \"two_person_rule\": true,\n    \"approver_identities\": {\n      \"provider\": \"EntraID\",\n      \"roles_allowed\": [\"AP_Manager\", \"Controller\"]\n    },\n    \"binding\": {\n      \"must_match_proposal_hash\": true\n    }\n  },\n  \"token_constraints\": {\n    \"require_cst\": true,\n    \"cst_ttl_seconds_max\": 900,\n    \"require_job_scoped_binding\": true,\n    \"optional_policy_hash_pinning\": true\n  },\n  \"limits\": {\n    \"max_amount_per_payment\": 25000,\n    \"max_payments_per_run\": 20,\n    \"token_cost_budget\": {\n      \"model_calls_max\": 200\n    }\n  },\n  \"model_routing\": {\n    \"require_clawproxy_receipts\": true\n  }\n}\n</pre>\n\n<p>Why this must be enforced as policy-as-code: if an attacker can influence the prompt, they can influence the agent’s “intent”. A WPC gives you a signed, hash-addressed policy artifact that tools and proxies can verify, so execution is permissioned even when the model output is adversarial.</p>\n\n<h2>What proof do you get?</h2>\n<p>Every model call routed through clawproxy yields gateway receipts that can be verified later. Receipts let you answer: which model was called, when, under which CST scope hash, and under which policy hash pinning (when enabled).</p>\n<p>Each run emits a proof bundle that packages the gateway receipts plus run metadata, including the job binding needed to detect replay. For audit and review workflows, the proof bundle can be stored as a Trust Pulse artifact so reviewers can view what was executed and what controls were in force.</p>\n\n<h2>Rollback posture</h2>\n<p>Payments are not safely “rollbackable” in the same sense as database writes, so your rollback posture should focus on fail-closed execution, fast containment, and evidence preservation. Use dry-run by default and only mint “execute” CST after approvals, so the most common failure mode is “no payment sent”.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Invoice review and matching</td>\n      <td>Discard drafts and rerun under a stricter WPC. Keep the original proposal hash to compare deltas.</td>\n      <td>Proof bundle with gateway receipts showing the model calls used for extraction and matching.</td>\n    </tr>\n    <tr>\n      <td>Approval collection</td>\n      <td>Invalidate pending approvals and require re-approval if any proposal field changes (amount, vendor, destination reference).</td>\n      <td>Approval packet bound to proposal hash, plus proof bundle metadata tying the run to job-scoped CST binding.</td>\n    </tr>\n    <tr>\n      <td>Send payment</td>\n      <td>Containment: revoke or let execute-token TTL expire, freeze further runs, then use the payment provider’s reversal or recall process if available.</td>\n      <td>Gateway receipts for model calls leading to the execution step, plus the proof bundle proving which WPC and CST were used.</td>\n    </tr>\n    <tr>\n      <td>Update payout destination</td>\n      <td>Revert to last known good destination via official API, then require a separate two-person approval for any future destination changes.</td>\n      <td>Proof bundle showing the request sequence, including the policy gates that required step-up approval.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Can the agent ever be allowed to send payments directly?</h3>\n<p>Only if you treat “send payment” as a separate, approval-bound capability and mint a dedicated CST for that single action. In practice, most teams keep default mode as dry-run and require step-up approvals for any irreversible call.</p>\n\n<h3>Why is prompt-only approval logic unsafe for invoice approvals?</h3>\n<p>Because the prompt is not a control boundary. Invoice PDFs, vendor emails, and chat users can inject instructions that override the intended procedure, while policy-as-code is verified by the execution layer (WPC plus CST constraints) and can fail closed.</p>\n\n<h3>How do you implement the two-person rule in Microsoft environments?</h3>\n<p>Use Entra ID identities for approvers and implement the approval capture via official API in your workflow system. Apply Conditional Access and PIM to reduce the chance that a compromised account can satisfy both approvals.</p>\n\n<h3>What should be included in the approval packet?</h3>\n<p>At minimum: vendor identity, invoice ID, amount and currency, destination reference, supporting documents, and an exceptions list. Hash the packet and require the hash match at execution so the agent cannot switch details after approval.</p>\n\n<h3>What proof is available if finance disputes a payment later?</h3>\n<p>You can provide the proof bundle for the run, including gateway receipts emitted by clawproxy for the model calls. This gives a verifiable record of policy context (WPC hash) and token context (CST scope hash) that governed the execution.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/microsoft-copilot-studio/flows-advanced-approvals\">Multistage and AI approvals in agent flows (Microsoft Copilot Studio)</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "For payment and invoice approvals, treat the agent as an untrusted operator: it can prepare evidence and drafts, but it must not be able to send payments, approve invoices, or update payout destinations without machine-e",
  "faqs": [
    {
      "q": "Can the agent ever be allowed to send payments directly?",
      "a": "Only if you treat “send payment” as a separate, approval-bound capability and mint a dedicated CST for that single action. In practice, most teams keep default mode as dry-run and require step-up approvals for any irreversible call."
    },
    {
      "q": "Why is prompt-only approval logic unsafe for invoice approvals?",
      "a": "Because the prompt is not a control boundary. Invoice PDFs, vendor emails, and chat users can inject instructions that override the intended procedure, while policy-as-code is verified by the execution layer (WPC plus CST constraints) and can fail closed."
    },
    {
      "q": "How do you implement the two-person rule in Microsoft environments?",
      "a": "Use Entra ID identities for approvers and implement the approval capture via official API in your workflow system. Apply Conditional Access and PIM to reduce the chance that a compromised account can satisfy both approvals."
    },
    {
      "q": "What should be included in the approval packet?",
      "a": "At minimum: vendor identity, invoice ID, amount and currency, destination reference, supporting documents, and an exceptions list. Hash the packet and require the hash match at execution so the agent cannot switch details after approval."
    },
    {
      "q": "What proof is available if finance disputes a payment later?",
      "a": "You can provide the proof bundle for the run, including gateway receipts emitted by clawproxy for the model calls. This gives a verifiable record of policy context (WPC hash) and token context (CST scope hash) that governed the execution."
    }
  ],
  "sources": [
    {
      "title": "Multistage and AI approvals in agent flows - Microsoft Copilot Studio",
      "uri": "https://learn.microsoft.com/en-us/microsoft-copilot-studio/flows-advanced-approvals"
    },
    {
      "title": "Agentic Payments: The Next Evolution in ...",
      "uri": "https://aws.amazon.com/blogs/industries/agentic-payments-the-next-evolution-in-the-payments-value-chain/"
    },
    {
      "title": "AI agent-driven browser automation for enterprise workflow ... - AWS",
      "uri": "https://aws.amazon.com/blogs/machine-learning/ai-agent-driven-browser-automation-for-enterprise-workflow-management/"
    },
    {
      "title": "Powering AI commerce with the new Agent Payments Protocol (AP2)",
      "uri": "https://cloud.google.com/blog/products/ai-machine-learning/announcing-agents-to-payments-ap2-protocol"
    },
    {
      "title": "The Enterprise AI Agent Era: Why Trust, Security, and ...",
      "uri": "https://www.salesforce.com/blog/unified-trust-security-governance-for-agentic-solutions/"
    },
    {
      "title": "Your Complete Guide to AI Agent Testing - Salesforce",
      "uri": "https://www.salesforce.com/agentforce/ai-agents/security/"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:44:09.501Z",
  "indexable": true
}