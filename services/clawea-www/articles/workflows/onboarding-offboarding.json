{
  "slug": "workflows/onboarding-offboarding",
  "title": "Employee onboarding/offboarding automation | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<h2>Direct Answer</h2>\n<p>Employee onboarding and offboarding automation is high impact because it touches identity, access, and licensing. In Claw EA, you run the workflow as an OpenClaw baseline agent runtime job, but you do not rely on “the prompt” to keep it safe.</p>\n<p>Instead, you permission the execution layer with a WPC (Work Policy Contract) and issue a CST (scoped token) per job, so actions like creating accounts, disabling accounts, and assigning licenses are gated by policy, approvals, and verifiable receipts.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the onboarding and offboarding action surface, and mark irreversible actions as high risk. At minimum treat “create account,” “disable account,” and “assign licenses” as high risk, even if they are routine.</p>\n    <p>Decide what must be done via Microsoft Graph (via official API) and what can be done via internal systems (often via an MCP server or an enterprise buildout).</p>\n  </li>\n  <li>\n    <p>Create a WPC that describes the allowed tools, allowed Graph permission scopes, and approval requirements. Store the signed, hash-addressed policy in the WPC registry (served by clawcontrols) and reference it by its policy hash.</p>\n    <p>This makes “what the agent is allowed to do” machine-checkable and stable, even if prompts or skills change.</p>\n  </li>\n  <li>\n    <p>Issue a CST (from clawscope) that is scoped to this workflow and pinned to the WPC hash. Bind the CST to the job to prevent replay across runs (marketplace anti-replay binding).</p>\n    <p>Use short TTLs and per-run tokens so a leaked token is less useful and older runs cannot be re-executed later.</p>\n  </li>\n  <li>\n    <p>Configure OpenClaw tool policy and sandboxing for the job. Keep tools minimal, prefer sandboxed execution for any file or process tooling, and avoid host-elevated tools unless you have an explicit need.</p>\n    <p>Run the OpenClaw security audit regularly as part of the workflow’s operational checklist, especially after config changes.</p>\n  </li>\n  <li>\n    <p>Implement step-up approvals and the two-person rule for high risk actions. Practically, this means the agent can prepare a plan and a “pending change set,” but a second approver must confirm before execution proceeds.</p>\n    <p>If you already use Conditional Access and PIM in Microsoft Entra, align approvals with your existing operational pattern, for example requiring a privileged operator approval before license assignment or account disable.</p>\n  </li>\n  <li>\n    <p>Isolate secrets and credentials. Keep Microsoft Graph credentials and any internal system credentials out of prompts and skill text, and only make them available at execution time to the specific tool that needs them.</p>\n    <p>Pair this with CST scoping so the job can call only the allowed proxy and policy services, not arbitrary endpoints.</p>\n  </li>\n  <li>\n    <p>Route model traffic through clawproxy to obtain gateway receipts, then produce a proof bundle at the end of the run. Store or attach the proof bundle to the ticketing or HR case record, and optionally publish a Trust Pulse for audit viewing.</p>\n    <p>This gives you a concrete artifact for “what was asked, what was executed, and under which policy,” without relying on ad hoc logs.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Onboarding and offboarding workflows fail in predictable ways: overbroad permissions, ambiguous approvals, and tool access that exceeds intent. The goal is to keep the agent useful while making unsafe paths fail closed.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection triggers unauthorized identity changes</td>\n      <td>An email, chat, or ticket includes text that tricks the agent into disabling the wrong user or changing a privileged group.</td>\n      <td>WPC tool and action allowlists, step-up approvals for high risk actions, and two-person rule before commit.</td>\n    </tr>\n    <tr>\n      <td>Overbroad Microsoft Graph permissions or role scope</td>\n      <td>The workflow token can edit more users or groups than intended, turning a single mistake into org-wide impact.</td>\n      <td>WPC declares allowed Graph scopes and limits target selectors; CST is pinned to the WPC hash and issued per job.</td>\n    </tr>\n    <tr>\n      <td>Credential leakage into logs or prompts</td>\n      <td>Secrets appear in model context, transcripts, or tool output, and then spread to downstream systems.</td>\n      <td>Secrets isolation at execution time; OpenClaw logging redaction hygiene; keep credentials out of skill text and prompts.</td>\n    </tr>\n    <tr>\n      <td>Replay of a prior “disable account” run</td>\n      <td>An attacker reuses old authorization material to re-run offboarding actions or execute them out of window.</td>\n      <td>Job-scoped CST binding (anti-replay) and short TTLs; require fresh approvals per run.</td>\n    </tr>\n    <tr>\n      <td>Unverifiable model actions during incident review</td>\n      <td>You cannot prove what the model call contained, which model was used, or whether the proxy enforced policy.</td>\n      <td>Gateway receipts from clawproxy and proof bundles for verification and post-incident reconstruction.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a sketch of what a WPC-driven onboarding/offboarding policy can look like. The point is to make the “allowed actions” and “approval gates” explicit, rather than hoping the agent follows instructions in a prompt.</p>\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"workflow\": \"employee_onboarding_offboarding\",\n  \"risk_classes\": {\n    \"high\": [\n      \"create_account\",\n      \"disable_account\",\n      \"assign_license\"\n    ]\n  },\n  \"approvals\": {\n    \"step_up_required_for\": [\"high\"],\n    \"two_person_rule_for\": [\"high\"],\n    \"approval_evidence\": [\"ticket_id\", \"approver_1\", \"approver_2\", \"timestamp\"]\n  },\n  \"identity_targets\": {\n    \"allowed_tenants\": [\"TENANT_ID_PLACEHOLDER\"],\n    \"allowed_user_match\": [\"hr_employee_id\", \"userPrincipalName\"],\n    \"deny_if_ambiguous_match\": true\n  },\n  \"graph_policy\": {\n    \"via\": \"official_api\",\n    \"allowed_scopes\": [\n      \"User.ReadWrite.All\",\n      \"GroupMember.ReadWrite.All\"\n    ],\n    \"deny_operations\": [\n      \"roleAssignment.write\",\n      \"directoryRole.activate\"\n    ]\n  },\n  \"execution\": {\n    \"openclaw_tool_profile\": \"onboarding_minimal\",\n    \"sandbox\": \"on\",\n    \"elevated_tools\": \"deny\"\n  },\n  \"attestation\": {\n    \"require_gateway_receipts\": true,\n    \"require_proof_bundle\": true\n  }\n}</pre>\n<p>In practice, you align this with Microsoft Entra controls, including Conditional Access and PIM for privileged operations. If your environment requires additional gates like manager verification or HRIS reconciliation, that is typically handled via an MCP server or enterprise buildout tied into your existing system of record.</p>\n\n<h2>What proof do you get?</h2>\n<p>Each run can produce gateway receipts for model calls, emitted by clawproxy. These receipts are designed for verification so you can later show that model traffic flowed through the proxy path you control, under the CST and the pinned WPC hash.</p>\n<p>At the end of the run, Claw EA can assemble a proof bundle that packages the receipts and related metadata needed for audit and verification. If you use OpenRouter via fal routed through clawproxy, the model call receipts still come from the same controlled gateway path.</p>\n<p>For audit workflows, the proof bundle can be stored as a Trust Pulse artifact for viewing. This helps answer operational questions like “who approved the disable,” “which policy version was active,” and “what model interactions occurred,” without depending on a single mutable log stream.</p>\n\n<h2>Rollback posture</h2>\n<p>Identity workflows have asymmetric rollback: some changes are reversible, others are not, and some are only reversible within a time window. Your rollback plan should be part of the WPC and the runbook, not an afterthought during an incident.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Create account</td>\n      <td>Disable the new account, remove group memberships, revoke sessions, and open a ticket for follow-up identity review.</td>\n      <td>Proof bundle showing the create request plan, approvals, and the gateway receipts for model calls used to generate the change set.</td>\n    </tr>\n    <tr>\n      <td>Assign licenses</td>\n      <td>Remove licenses, verify mailbox and data retention implications, then document impact in the ticket.</td>\n      <td>WPC hash for the run and approval evidence captured before commit, plus receipts confirming the controlled execution path.</td>\n    </tr>\n    <tr>\n      <td>Disable account</td>\n      <td>Re-enable only with step-up approvals, then force password reset or session revocation based on your incident posture.</td>\n      <td>Two-person approval record tied to the job-scoped CST binding, to show the disable could not be replayed outside the run.</td>\n    </tr>\n    <tr>\n      <td>Group membership changes</td>\n      <td>Restore from last-known-good membership snapshot, then verify app access and Conditional Access behavior.</td>\n      <td>Run artifact trail: policy hash pinning, receipts, and the recorded target selectors used for the change.</td>\n    </tr>\n  </tbody>\n</table>\n<p>For stronger rollback, many teams add a “dry-run then commit” pattern, where the agent produces a proposed diff and waits for approvals. That pattern maps cleanly to step-up approvals and the two-person rule, without granting the agent authority to commit irreversible actions by itself.</p>\n\n<h2>FAQ</h2>\n<h3>Why is permissioned execution better than prompt-only controls?</h3>\n<p>Prompts can be overwritten by input text, tool output, or a model mistake. A WPC makes allowed actions and required approvals enforceable by the execution layer, so the system fails closed when the agent tries to go out of bounds.</p>\n\n<h3>How does this interact with Microsoft Entra ID and Microsoft Graph permissions?</h3>\n<p>You typically execute identity actions via official API using Microsoft Graph, with scopes limited to what the workflow needs. The WPC documents and constrains those scopes, and approvals are required before high risk operations like account disable or license assignment.</p>\n\n<h3>What enforces the two-person rule in practice?</h3>\n<p>The agent can prepare a change set and request approvals, but execution is blocked until two distinct approvers are recorded for the specific job. This is most reliable when approvals are tied to your ticketing workflow and verified before commit.</p>\n\n<h3>What stops someone from replaying an offboarding run later?</h3>\n<p>CSTs are issued per job and can be bound to the job to prevent replay. Combined with short TTLs and policy hash pinning, older authorization material does not remain valid for new runs.</p>\n\n<h3>What do auditors get at the end of the workflow?</h3>\n<p>You can provide gateway receipts for model calls and a proof bundle that packages receipts with run metadata. If you use Trust Pulse, you can store the artifact for later viewing during audits or incident review.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/graph/identity-network-access-overview\">Microsoft Entra identity and network access APIs in Microsoft Graph</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/entra/id-governance/tutorial-onboard-custom-workflow-portal\">Automate employee onboarding tasks with Lifecycle workflows (Microsoft Entra ID Governance)</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Employee onboarding and offboarding automation is high impact because it touches identity, access, and licensing. In Claw EA, you run the workflow as an OpenClaw baseline agent runtime job, but you do not rely on “the pr",
  "faqs": [
    {
      "q": "Why is permissioned execution better than prompt-only controls?",
      "a": "Prompts can be overwritten by input text, tool output, or a model mistake. A WPC makes allowed actions and required approvals enforceable by the execution layer, so the system fails closed when the agent tries to go out of bounds."
    },
    {
      "q": "How does this interact with Microsoft Entra ID and Microsoft Graph permissions?",
      "a": "You typically execute identity actions via official API using Microsoft Graph, with scopes limited to what the workflow needs. The WPC documents and constrains those scopes, and approvals are required before high risk operations like account disable or license assignment."
    },
    {
      "q": "What enforces the two-person rule in practice?",
      "a": "The agent can prepare a change set and request approvals, but execution is blocked until two distinct approvers are recorded for the specific job. This is most reliable when approvals are tied to your ticketing workflow and verified before commit."
    },
    {
      "q": "What stops someone from replaying an offboarding run later?",
      "a": "CSTs are issued per job and can be bound to the job to prevent replay. Combined with short TTLs and policy hash pinning, older authorization material does not remain valid for new runs."
    },
    {
      "q": "What do auditors get at the end of the workflow?",
      "a": "You can provide gateway receipts for model calls and a proof bundle that packages receipts with run metadata. If you use Trust Pulse, you can store the artifact for later viewing during audits or incident review."
    }
  ],
  "sources": [
    {
      "title": "Microsoft Agent 365 documentation",
      "uri": "https://learn.microsoft.com/en-us/microsoft-agent-365/"
    },
    {
      "title": "Microsoft Entra Identity and Network Access Management APIs on ...",
      "uri": "https://learn.microsoft.com/en-us/graph/identity-network-access-overview"
    },
    {
      "title": "Build smarter and faster with Power Platform - Microsoft Developer",
      "uri": "https://developer.microsoft.com/en-us/power-platform"
    },
    {
      "title": "Agentforce for Employees | Salesforce AP",
      "uri": "https://www.salesforce.com/ap/agentforce/agentforce-for-employees/"
    },
    {
      "title": "What Are Agentic Workflows?",
      "uri": "https://www.salesforce.com/agentforce/agentic-workflows/"
    },
    {
      "title": "Automate employee onboarding tasks before their first day of work with the Microsoft Entra admin center - Microsoft Entra ID Governance",
      "uri": "https://learn.microsoft.com/en-us/entra/id-governance/tutorial-onboard-custom-workflow-portal"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:43:19.611Z",
  "indexable": true
}