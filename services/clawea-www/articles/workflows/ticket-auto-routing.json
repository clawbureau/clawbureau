{
  "slug": "workflows/ticket-auto-routing",
  "title": "Support ticket classification and routing | Secure Agent Workflow | Claw EA",
  "category": "workflows",
  "html": "<p>Support ticket classification and routing is safe to automate when the agent runs under permissioned execution, not prompt-only instructions. In Claw EA, you run an OpenClaw agent with a WPC that constrains what it can read, what it can write, and which routing actions require approval.</p>\n<p>This workflow classifies the ticket, proposes a route, and only applies irreversible actions (assign, change priority, notify customers) when the policy allows it and the run is auditable via gateway receipts and a proof bundle.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Define the routing surface area.</strong> Decide what the agent is allowed to do without a human: read ticket text, redact, label, and recommend a queue. Treat assign, priority changes, and outbound notifications as high risk and default them to “propose only”.</p>\n    <p>Integrate your ticket system and chat or email intake via official API or via MCP server, then keep the agent’s tool list minimal.</p>\n  </li>\n  <li>\n    <p><strong>Publish a WPC and pin it for the job.</strong> Create a WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols) that encodes the allowed tools, redaction requirements, and whether “apply route” is permitted. Pin the policy hash so the job fails closed if the runtime is presented with a different policy.</p>\n    <p>This is the key difference from prompt-only controls: the policy is checked by the execution and proxy layers, not “suggested” to the model.</p>\n  </li>\n  <li>\n    <p><strong>Issue a job-scoped CST.</strong> Request a CST = scoped token (issued by clawscope) for this single routing job, scoped to the minimum set of actions (for example: read ticket, write labels, create internal note). Use optional policy hash pinning in the CST so the token cannot be reused under a different WPC.</p>\n    <p>This reduces blast radius if an agent session is prompt-injected or a token leaks.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy.</strong> Configure the OpenClaw provider so model traffic goes through clawproxy (for example OpenRouter via fal routed through clawproxy). clawproxy emits Gateway receipts = signed receipts emitted by clawproxy for model calls.</p>\n    <p>Receipts let you later prove which model was called, when, and under which job and policy constraints, without relying on application logs alone.</p>\n  </li>\n  <li>\n    <p><strong>Enforce redaction and DLP before classification.</strong> Run an intake step that strips secrets and sensitive identifiers from the text that will be sent to the model. Keep raw content in your ticket system, but only pass a redacted view into the LLM step.</p>\n    <p>Make redaction a policy requirement, not a best-effort instruction.</p>\n  </li>\n  <li>\n    <p><strong>Apply rate limits and concurrency limits.</strong> Set per-queue throughput limits (for example: max tickets per minute) and a strict concurrency cap (for example: max in-flight tickets per agent). If a spike arrives, the workflow should degrade to “classify only” and stop routing changes.</p>\n    <p>Cost budget enforcement can be implemented, but do not assume it is present unless you add it as an enterprise buildout.</p>\n  </li>\n  <li>\n    <p><strong>Two-phase commit for irreversible actions.</strong> Phase 1: classify and propose route, priority, and notification template in an internal note. Phase 2: a separate tool call applies the changes only if the WPC permits it, the CST scope includes it, and your control plane records the approval decision.</p>\n    <p>This is how you keep “notify customer” from becoming an accidental or injected action.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>This workflow is mostly about controlling where untrusted text can steer the system. Ticket bodies frequently contain prompt injection, credential strings, and social engineering attempts that try to trigger routing changes or customer outreach.</p>\n<p>The table below lists common failure modes and the concrete control that should stop them.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection inside ticket text</td>\n      <td>Ticket content instructs the agent to reassign VIP accounts, escalate priority, or message customers.</td>\n      <td>WPC forbids direct “apply” tools by default; two-phase commit; CST scoped to propose-only for most runs.</td>\n    </tr>\n    <tr>\n      <td>Data leakage to the model</td>\n      <td>Secrets, tokens, or personal data are sent to the LLM during classification.</td>\n      <td>Policy-required redaction step and DLP rules; send only a redacted “model_view” field to the model.</td>\n    </tr>\n    <tr>\n      <td>Tool overreach</td>\n      <td>Agent uses broad API permissions to query unrelated tickets, customers, or internal docs.</td>\n      <td>Minimal tool allowlist in OpenClaw plus WPC tool constraints; CST contains only the job’s read and write scopes.</td>\n    </tr>\n    <tr>\n      <td>Replay of an old authorization</td>\n      <td>A previously valid token is reused to apply routing on new tickets.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) so the token is bound to this job context.</td>\n    </tr>\n    <tr>\n      <td>Unbounded throughput</td>\n      <td>A backlog spike or loop causes thousands of tickets to be processed, amplifying mistakes.</td>\n      <td>Rate limits and concurrency limits; fail closed to “classify only” when thresholds are hit.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>Prompt-only routing rules fail because they are optional to the model. A WPC makes the constraints enforceable by the execution and proxy layers, so “do not notify customers” is not merely advice.</p>\n<p>Below is a compact JSON-like sketch of a ticket routing WPC. Treat it as a shape example; your exact fields depend on your internal policy compiler and tool naming.</p>\n\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"workflow\": \"ticket_auto_routing\",\n  \"tools\": {\n    \"allow\": [\"tickets.read\", \"tickets.add_label\", \"tickets.add_internal_note\"],\n    \"deny\": [\"tickets.notify_customer\", \"tickets.set_priority\", \"tickets.assign\"]\n  },\n  \"outputs\": {\n    \"mode\": \"propose_only\",\n    \"required_fields\": [\"category\", \"confidence\", \"recommended_queue\", \"rationale\"],\n    \"redaction\": {\n      \"required\": true,\n      \"dlp_rules\": [\n        {\"type\": \"secret\", \"pattern\": \"api_key_like\"},\n        {\"type\": \"pii\", \"pattern\": \"email\"},\n        {\"type\": \"pii\", \"pattern\": \"phone\"}\n      ],\n      \"max_chars_sent_to_model\": 6000\n    }\n  },\n  \"limits\": {\n    \"rate_limit_per_minute\": 60,\n    \"max_concurrency\": 5,\n    \"max_model_calls_per_ticket\": 3\n  },\n  \"high_risk_actions\": {\n    \"requires_approval\": [\"tickets.assign\", \"tickets.set_priority\", \"tickets.notify_customer\"]\n  }\n}\n</pre>\n\n<p>If you later decide to allow auto-assign for a single queue, do it by changing the WPC and re-pinning the policy hash for that job. Do not “just update the prompt” and hope the agent complies.</p>\n\n<h2>What proof do you get?</h2>\n<p>Every model call routed through clawproxy produces Gateway receipts. Those receipts are assembled into a Proof bundle = harness artifact bundling receipts and related metadata for audit/verification.</p>\n<p>Operationally, this gives you evidence that a specific ticket classification was generated under a specific WPC hash and a job-scoped CST. If you store the resulting artifact in Trust Pulse, reviewers get a stable object for audit and viewing without asking engineers to reconstruct logs.</p>\n\n<ul>\n  <li>\n    <p><strong>Gateway receipts:</strong> show the model call inputs and outputs in a verifiable envelope, plus binding metadata (job context, token scope hash, optional policy hash pinning).</p>\n  </li>\n  <li>\n    <p><strong>Proof bundle:</strong> packages receipts plus run metadata (tool decisions, timestamps, and identifiers you choose to include) so verification can be automated later.</p>\n  </li>\n  <li>\n    <p><strong>Anti-replay binding:</strong> reduces the chance that a valid CST from one run can be used to mutate tickets in a different run.</p>\n  </li>\n</ul>\n\n<h2>Rollback posture</h2>\n<p>Rollback for ticket routing is mostly about preventing further writes, then repairing the small set of wrong writes you already made. Design the workflow so the agent can keep classifying while routing mutations are paused.</p>\n<p>Use the table below as a concrete “what to do at 2 AM” checklist.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop all irreversible writes</td>\n      <td>Switch to a WPC that denies assign, priority change, and customer notification; issue new CSTs pinned to that policy hash.</td>\n      <td>New proof bundles show the deny policy hash; old proof bundles identify when the last write was allowed.</td>\n    </tr>\n    <tr>\n      <td>Quarantine a bad classifier version</td>\n      <td>Disable the routing “apply” phase, keep “propose only”, and require approval for affected categories.</td>\n      <td>Gateway receipts show the exact model outputs and confidence that triggered proposals.</td>\n    </tr>\n    <tr>\n      <td>Undo wrong assignments</td>\n      <td>Run a repair job that reads a bounded set of affected tickets and restores prior owner and priority via official API, with strict limits.</td>\n      <td>Repair run produces its own proof bundle; compare ticket diffs to receipts for traceability.</td>\n    </tr>\n    <tr>\n      <td>Contain data exposure risk</td>\n      <td>Increase redaction strictness (for example reduce max_chars_sent_to_model), and block categories that tend to include secrets until rules are updated.</td>\n      <td>Proof bundles show the redaction configuration used per run, and receipts show what was actually sent.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Can I let the agent auto-assign tickets without human approval?</h3>\n<p>Yes, but do it per queue and per action in the WPC, not as a global behavior. Start with “propose only”, then allow “tickets.assign” only where misroutes are low risk and easy to reverse.</p>\n\n<h3>Why is policy-as-code necessary if the prompt already says “do not notify customers”?</h3>\n<p>Because the prompt is not an enforcement boundary. A WPC plus CST scoping makes “notify customer” impossible unless the execution layer authorizes the tool call.</p>\n\n<h3>How do I integrate with ServiceNow, Zendesk, or Jira Service Management?</h3>\n<p>Use the vendor’s official API or an MCP server, and keep the tool surface minimal. If you need deeper controls like custom field mappings and idempotent repair jobs, that is typically an enterprise buildout.</p>\n\n<h3>What should I log for audits without storing full customer text?</h3>\n<p>Prefer proof bundles with redacted model inputs and include hashes or ticket IDs that let you correlate back to your system of record. Gateway receipts give you verifiable call metadata without requiring you to keep verbose, sensitive transcripts everywhere.</p>\n\n<h3>Does sandboxing replace WPC and CST controls?</h3>\n<p>No. Sandboxing reduces blast radius for tool execution, but it does not define business permissions like “can reassign a ticket”. Use sandboxing and tool policy in OpenClaw, then use WPC and CST for permissioned execution and verifiable runs.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/copilot/security/developer/planning-guide\">Security Copilot agent development planning guide</a></li>\n</ul>\n\n<div class=\"cta-banner\" data-cta=\"bofu-endcap\">\n  <h2>Ready to put this workflow into production?</h2>\n  <p>Get a scoped deployment plan with Work Policy Contracts, approval gates, and cryptographic proof bundles for your team.</p>\n  <a href=\"/contact\" class=\"cta-btn cta-btn-lg\" data-cta=\"bofu-talk-to-sales\">Talk to Sales</a>\n  <a href=\"/trust\" class=\"cta-btn cta-btn-outline cta-btn-lg\" style=\"margin-left:.75rem\" data-cta=\"bofu-trust-layer\">Review Trust Layer</a>\n</div>\n",
  "description": "Support ticket classification and routing is safe to automate when the agent runs under permissioned execution, not prompt-only instructions. In Claw EA, you run an OpenClaw agent with a WPC that constrains what it can r",
  "faqs": [
    {
      "q": "Can I let the agent auto-assign tickets without human approval?",
      "a": "Yes, but do it per queue and per action in the WPC, not as a global behavior. Start with “propose only”, then allow “tickets.assign” only where misroutes are low risk and easy to reverse."
    },
    {
      "q": "Why is policy-as-code necessary if the prompt already says “do not notify customers”?",
      "a": "Because the prompt is not an enforcement boundary. A WPC plus CST scoping makes “notify customer” impossible unless the execution layer authorizes the tool call."
    },
    {
      "q": "How do I integrate with ServiceNow, Zendesk, or Jira Service Management?",
      "a": "Use the vendor’s official API or an MCP server, and keep the tool surface minimal. If you need deeper controls like custom field mappings and idempotent repair jobs, that is typically an enterprise buildout."
    },
    {
      "q": "What should I log for audits without storing full customer text?",
      "a": "Prefer proof bundles with redacted model inputs and include hashes or ticket IDs that let you correlate back to your system of record. Gateway receipts give you verifiable call metadata without requiring you to keep verbose, sensitive transcripts everywhere."
    },
    {
      "q": "Does sandboxing replace WPC and CST controls?",
      "a": "No. Sandboxing reduces blast radius for tool execution, but it does not define business permissions like “can reassign a ticket”. Use sandboxing and tool policy in OpenClaw, then use WPC and CST for permissioned execution and verifiable runs."
    }
  ],
  "sources": [
    {
      "title": "Security Copilot agent development planning guide",
      "uri": "https://learn.microsoft.com/en-us/copilot/security/developer/planning-guide"
    },
    {
      "title": "AWS Marketplace: Lyzr Customer Service Agents Hub - Amazon.com",
      "uri": "https://aws.amazon.com/marketplace/pp/prodview-q7w4dz3wlms2i"
    },
    {
      "title": "AI agents in enterprises: Best practices with Amazon Bedrock ...",
      "uri": "https://aws.amazon.com/blogs/machine-learning/ai-agents-in-enterprises-best-practices-with-amazon-bedrock-agentcore/"
    },
    {
      "title": "What Are Agentic Workflows?",
      "uri": "https://www.salesforce.com/agentforce/agentic-workflows/"
    },
    {
      "title": "Al Ticketing: What It Is, Benefits, and Examples | Salesforce",
      "uri": "https://www.salesforce.com/service/ai/ticketing/"
    },
    {
      "title": "AI Agent Use Cases in the Enterprise - SAP",
      "uri": "https://www.sap.com/sea/resources/ai-agents-use-cases"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:51:51.186Z",
  "indexable": true
}