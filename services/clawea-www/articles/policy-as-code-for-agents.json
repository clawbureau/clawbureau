{
  "slug": "policy-as-code-for-agents",
  "title": "Policy-as-Code for Agents (Permissioned Execution) | Claw EA",
  "category": "pillars",
  "html": "<h2>Direct Answer</h2>\n<p>Policy-as-code for agents means the execution layer enforces permissions the same way your APIs do: explicit, versioned rules that decide what the agent may do, with which credentials, and under what conditions. In Claw EA, you express those rules as a WPC (Work Policy Contract) and bind them to runtime access using a CST (scoped token), so an OpenClaw agent cannot exceed its approved authority even if a prompt tries to push it.</p>\n<p>Prompt-only controls are advisory and easy to bypass through prompt injection, tool ambiguity, or configuration drift. Permissioned execution makes approvals durable: the policy is signed, hash-addressed, fetched and verified at runtime, and its enforcement is evidenced through gateway receipts and proof bundles.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the job boundary and approval surface. Decide what the agent is allowed to change (read-only vs write), where it is allowed to act (systems and environments), and what “completion” means so you can stop the run on policy failure.</p>\n    <p>Keep the initial boundary narrow: one business purpose, one environment, and a minimal set of tools.</p>\n  </li>\n  <li>\n    <p>Write a WPC (Work Policy Contract) that is concrete enough to be enforced. Include tool allow/deny intent, model/provider constraints where you have them, and any required human approval gates (for example, “writes require ticket id”).</p>\n    <p>Store and serve the WPC from clawcontrols, using the WPC hash as the stable identifier.</p>\n  </li>\n  <li>\n    <p>Issue a CST (scoped token) from clawscope for the specific job. Bind the CST to a scope hash that matches the WPC intent, and optionally pin the policy hash so the runtime must use that exact WPC version.</p>\n    <p>Use short TTLs and job scoping so a captured token cannot be replayed across jobs.</p>\n  </li>\n  <li>\n    <p>Route model traffic through clawproxy so model calls are receipted. This yields gateway receipts for each model request and response, allowing you to prove what model was invoked and under which authorization context.</p>\n    <p>If you use OpenRouter via fal, route it through clawproxy so the same receipt and verification flow applies.</p>\n  </li>\n  <li>\n    <p>Configure OpenClaw with a strict tool policy and sandbox defaults, then map the WPC into the agent’s effective tool availability. OpenClaw already separates sandboxing, tool policy, and elevated execution; keep elevated execution off unless you have an explicit reason and a separate approval.</p>\n    <p>Run OpenClaw’s own security audit regularly to catch common footguns (permissions, exposed gateway surfaces, and over-broad tool exposure).</p>\n  </li>\n  <li>\n    <p>Run the job and fail closed on policy mismatches. At start, fetch the WPC by hash and verify it; on each sensitive action, ensure the CST scope hash and any pinned policy hash still match the effective policy.</p>\n    <p>On mismatch, stop the run and preserve the evidence bundle rather than trying to “fix forward” mid-flight.</p>\n  </li>\n  <li>\n    <p>Export a proof bundle and publish it to Trust Pulse if you need centralized review. The proof bundle aggregates gateway receipts and related metadata so verification and audit can happen after the fact without trusting the operator’s narrative.</p>\n    <p>Use this bundle in incident review, change management, or to justify approvals that were granted.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Permissioned execution is mainly about preventing an agent from gaining capability through conversation, indirect instructions, or drift. The table below lists concrete failure modes we see in enterprise agent deployments and the control that should carry the load.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (permissioned execution)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection into a tool-enabled agent</td>\n      <td>The agent is convinced to run a higher-impact tool sequence (exfiltrate files, alter configs, send messages) because the prompt “sounds authorized”.</td>\n      <td>WPC defines allowed tools and preconditions; OpenClaw tool policy enforces the local boundary; CST scope hash ensures the runtime cannot silently widen permissions for convenience.</td>\n    </tr>\n    <tr>\n      <td>Scope creep across iterations</td>\n      <td>A “temporary” permission becomes permanent as teams add scopes to make failures go away, until the agent has broad privileges.</td>\n      <td>Approvals result in a new WPC hash; CST can pin the policy hash; review diff is done on policy artifacts, not on prompts or chat logs.</td>\n    </tr>\n    <tr>\n      <td>Model call repudiation</td>\n      <td>After an incident, you cannot prove which model produced an instruction, what was sent, or whether the transcript was edited.</td>\n      <td>Gateway receipts from clawproxy provide signed evidence for model calls; proof bundles package receipts for verification and retention workflows.</td>\n    </tr>\n    <tr>\n      <td>Replay of credentials across jobs</td>\n      <td>A token from one run is reused to execute a different run with different intent.</td>\n      <td>Marketplace anti-replay binding using job-scoped CST binding; keep TTL short and require fresh CST issuance per run.</td>\n    </tr>\n    <tr>\n      <td>Sandbox escape by configuration</td>\n      <td>Tools that should run in a container run on the host due to “elevated” escape hatches or permissive binds.</td>\n      <td>OpenClaw sandbox settings plus tool policy separation; express “no elevated” and “no dangerous binds” in your WPC and enforce locally in the OpenClaw config review process.</td>\n    </tr>\n    <tr>\n      <td>Plugin/tool sprawl</td>\n      <td>New extensions appear on disk or in config and become callable without a formal approval.</td>\n      <td>Enforce explicit allowlists in OpenClaw tool profiles; treat any tool surface change as a WPC change requiring approval and new policy hash.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Some controls sit outside the proxy layer. For example, egress allowlists enforced outside clawproxy can be implemented as an optional layer if you need deterministic outbound restrictions per environment.</p>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the shape of a permissioned execution policy you can operationalize. In practice, you publish the signed artifact as a WPC in clawcontrols and bind it to a job CST from clawscope so enforcement is not dependent on the prompt.</p>\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"agent-change-reviewer\",\n  \"purpose\": \"Review a PR and propose edits; no direct deploys\",\n  \"constraints\": {\n    \"tool_policy\": {\n      \"allow\": [\"read\", \"search\", \"repo.diff\", \"repo.comment\"],\n      \"deny\":  [\"exec\", \"shell\", \"repo.merge\", \"deploy.*\"]\n    },\n    \"sandbox\": {\n      \"required\": true,\n      \"workspaceAccess\": \"ro\",\n      \"elevated_exec\": \"deny\"\n    },\n    \"approvals\": [\n      {\n        \"when\": \"tool == 'repo.comment' && content.contains('SECURITY:')\",\n        \"require\": \"human_approval\"\n      }\n    ],\n    \"model_calls\": {\n      \"route_via\": \"clawproxy\",\n      \"receipts_required\": true\n    }\n  },\n  \"binding\": {\n    \"cst_scope_hash_required\": true,\n    \"optional_policy_hash_pinning\": true\n  }\n}\n</pre>\n<p>Two operational rules matter here. First, the agent only receives a CST whose scope matches the policy intent, so it cannot “ask for more permissions” mid-run without a new approval and a new token.</p>\n<p>Second, the model calls are required to be routed through clawproxy so you can later validate what happened using gateway receipts and a proof bundle.</p>\n\n<h2>What proof do you get?</h2>\n<p>You get signed gateway receipts emitted by clawproxy for each model call that is routed through it. Receipts are the primary evidence for model invocation details and are designed to be verified later rather than trusted implicitly.</p>\n<p>You also get a proof bundle, which is a harness artifact bundling receipts and related metadata for audit and verification. This is what you hand to a reviewer, an auditor, or your own incident process so they can validate the run without relying on screenshots or edited transcripts.</p>\n<p>If you publish to Trust Pulse, you have a marketplace-stored artifact for audit/viewing. Use that when multiple teams need consistent access to the same evidence set, or when you want a stable reference in a ticket.</p>\n<p>What this does not do by itself is prevent all data egress or enforce a spend ceiling. Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are optional or planned layers, depending on your environment and change-control requirements.</p>\n\n<h2>Rollback posture</h2>\n<p>Permissioned execution should include a rollback posture that is simple and testable. The goal is to be able to stop work, revoke authority, and produce evidence within minutes, without debating what the agent “meant” in the chat.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to retain</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Policy mistake discovered (WPC too permissive)</td>\n      <td>Issue a new WPC and require policy hash pinning for new runs; do not reuse the old WPC hash.</td>\n      <td>Old and new WPC hashes, approval record, proof bundle from the run that revealed the gap.</td>\n    </tr>\n    <tr>\n      <td>Token leak suspected</td>\n      <td>Revoke the CST at clawscope and rotate job credentials; restart the job with a fresh CST bound to the job.</td>\n      <td>CST issuance metadata, revocation event, proof bundle up to the stop point.</td>\n    </tr>\n    <tr>\n      <td>Unapproved tool invocation attempt</td>\n      <td>Fail closed and stop the agent session; widen policy only after review and new WPC hash.</td>\n      <td>Gateway receipts showing the attempted model call and the denial path, plus the effective tool policy snapshot.</td>\n    </tr>\n    <tr>\n      <td>Model provider dispute or audit request</td>\n      <td>Re-run the verification flow on the proof bundle and provide the receipts; do not rely on chat logs alone.</td>\n      <td>Proof bundle, gateway receipts, and verification output used internally for the decision.</td>\n    </tr>\n  </tbody>\n</table>\n<p>Operationally, rollback should be rehearsed. Treat “revoke CST, stop job, export proof bundle” as the agent equivalent of “disable key, stop deploy, preserve logs”.</p>\n\n<h2>FAQ</h2>\n<h3>Why is prompt-only control not enough for enterprise agents?</h3>\n<p>Prompts are not an enforcement boundary. A prompt can be overridden by new instructions, hidden content, or tool outputs, while permissioned execution uses WPC and CST constraints that the runtime checks regardless of what the agent says.</p>\n\n<h3>How do approvals work in a policy-as-code workflow?</h3>\n<p>Approvals should produce a new WPC version with a new hash, not just an updated prompt. You then issue a job-specific CST whose scope hash matches the approved WPC, and optionally pin the policy hash so the job cannot drift.</p>\n\n<h3>Where does OpenClaw fit if Claw EA is enforcing policy?</h3>\n<p>OpenClaw is the baseline agent runtime where tools execute and where local sandbox and tool policy are applied. Claw EA adds portable policy artifacts (WPC), scoped authorization (CST), and verifiable evidence (gateway receipts and proof bundles) so the run can be governed and audited consistently.</p>\n\n<h3>What do gateway receipts prove, and what do they not prove?</h3>\n<p>Gateway receipts prove details about model calls that went through clawproxy and were receipted, and they support later verification. They do not magically prove what happened in systems the agent touched unless those actions are also mediated and logged by your tools or environment.</p>\n\n<h3>Can I enforce outbound network allowlists or cost budgets with this?</h3>\n<p>Egress allowlists enforced outside clawproxy can be implemented as an optional layer, depending on where you can enforce network controls in your environment. Automatic cost budget enforcement is planned, so today you should implement spend limits via your provider controls and internal guardrails.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://owasp.org/www-project-mcp-top-10/2025/MCP02-2025%E2%80%93Privilege-Escalation-via-Scope-Creep\">OWASP MCP02:2025 Privilege Escalation via Scope Creep</a></li>\n  <li><a href=\"https://openpolicyagent.org/docs\">Open Policy Agent (OPA) Documentation</a></li>\n</ul>",
  "description": "Policy-as-code for agents means the execution layer enforces permissions the same way your APIs do: explicit, versioned rules that decide what the agent may do, with which credentials, and under what conditions. In Claw ",
  "faqs": [
    {
      "q": "Why is prompt-only control not enough for enterprise agents?",
      "a": "Prompts are not an enforcement boundary. A prompt can be overridden by new instructions, hidden content, or tool outputs, while permissioned execution uses WPC and CST constraints that the runtime checks regardless of what the agent says."
    },
    {
      "q": "How do approvals work in a policy-as-code workflow?",
      "a": "Approvals should produce a new WPC version with a new hash, not just an updated prompt. You then issue a job-specific CST whose scope hash matches the approved WPC, and optionally pin the policy hash so the job cannot drift."
    },
    {
      "q": "Where does OpenClaw fit if Claw EA is enforcing policy?",
      "a": "OpenClaw is the baseline agent runtime where tools execute and where local sandbox and tool policy are applied. Claw EA adds portable policy artifacts (WPC), scoped authorization (CST), and verifiable evidence (gateway receipts and proof bundles) so the run can be governed and audited consistently."
    },
    {
      "q": "What do gateway receipts prove, and what do they not prove?",
      "a": "Gateway receipts prove details about model calls that went through clawproxy and were receipted, and they support later verification. They do not magically prove what happened in systems the agent touched unless those actions are also mediated and logged by your tools or environment."
    },
    {
      "q": "Can I enforce outbound network allowlists or cost budgets with this?",
      "a": "Egress allowlists enforced outside clawproxy can be implemented as an optional layer, depending on where you can enforce network controls in your environment. Automatic cost budget enforcement is planned, so today you should implement spend limits via your provider controls and internal guardrails."
    }
  ],
  "sources": [
    {
      "title": "MCP02:2025 - Privilege Escalation via Scope Creep",
      "uri": "https://owasp.org/www-project-mcp-top-10/2025/MCP02-2025%E2%80%93Privilege-Escalation-via-Scope-Creep"
    },
    {
      "title": "Open Policy Agent (OPA)",
      "uri": "https://openpolicyagent.org/docs"
    },
    {
      "title": "Manage AWS Organizations policies as code by using AWS ...",
      "uri": "https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/manage-organizations-policies-as-code.html"
    },
    {
      "title": "Amazon Bedrock AgentCore Policy: Control Agent-to-Tool Interactions",
      "uri": "https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/policy.html"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:47:16.136Z",
  "indexable": true
}