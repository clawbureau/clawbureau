{
  "slug": "events",
  "title": "Event-native Agents (Triggers) | Claw EA",
  "category": "hubs",
  "html": "<h2>Direct Answer</h2>\n<p>Event-native agents are agents that run because an external system emitted an event: a webhook, a changefeed item, or a subscription notification. Claw EA makes these runs permissioned and auditable using OpenClaw as the baseline agent runtime, plus policy artifacts and receipts that survive incident review.</p>\n<p>Prompt-only controls fail in event pipelines because the attacker controls inputs and timing. You need policy-as-code that binds who can trigger a run, what tools can execute, and what model calls are allowed, enforced under a Work Policy Contract (WPC) and verified via gateway receipts and proof bundles.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this runbook when you are wiring webhooks or change notifications into an agent and you need idempotency, replay resistance, and audit evidence. The goal is a fail-closed path from inbound event to tool execution.</p>\n<ol>\n  <li>\n    <p><strong>Define the trigger boundary and idempotency key.</strong> Pick a stable key per event (for example: vendor event id, change sequence, or a hash of canonicalized payload plus source). Store the key in your job state so retries do not re-run side effects.</p>\n  </li>\n  <li>\n    <p><strong>Write a WPC for this trigger class.</strong> In the WPC, constrain allowed tools, allowed model/provider routing, and required input fields you will validate before any tool runs. Keep the WPC small and hash-addressed so it can be pinned and reviewed.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the trigger runner.</strong> The runner that receives events should get a CST (issued by clawscope) that is job-scoped and optionally pins a specific WPC hash. If the CST is stolen, the scope and job binding limit replay usefulness.</p>\n  </li>\n  <li>\n    <p><strong>Verify the event signature and normalize payloads before the agent sees them.</strong> Validate vendor signatures, timestamps, and required headers at the perimeter, then canonicalize the payload into a minimal “event context” object. Pass only the normalized context into OpenClaw, not raw headers and not arbitrary JSON.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent through clawproxy for model calls.</strong> Route model traffic through clawproxy so each model call yields gateway receipts. Keep tool execution inside OpenClaw’s tool policy and sandboxing settings so “what ran where” is inspectable.</p>\n  </li>\n  <li>\n    <p><strong>Emit a proof bundle and retain it with the job record.</strong> After completion, bundle the gateway receipts plus run metadata into a proof bundle. Use the proof bundle as your audit handle for later verification and escalation.</p>\n  </li>\n</ol>\n<p><strong>Getting started checklist:</strong> pick an idempotency key, write one WPC per trigger type, scope one CST per job, route model calls via clawproxy, and require a proof bundle for every completion.</p>\n\n<h2>Threat model</h2>\n<p>Event inputs are untrusted even when they originate from a trusted vendor. The main risk is that “a valid event” becomes “arbitrary remote control” when prompt content flows into tools without policy enforcement.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control in Claw EA</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Webhook replay and duplicate delivery</td>\n      <td>Vendor retries or attacker replays a captured request; you re-run side effects (emails, tickets, transfers).</td>\n      <td>Idempotency key stored per job plus marketplace anti-replay binding using job-scoped CST binding.</td>\n    </tr>\n    <tr>\n      <td>Signature bypass or weak validation</td>\n      <td>Attacker sends forged events to trigger privileged actions.</td>\n      <td>Perimeter verification plus WPC-required fields and fail-closed execution if validation artifacts are missing.</td>\n    </tr>\n    <tr>\n      <td>Prompt injection via event payload</td>\n      <td>Event text tricks the agent into calling tools outside intended workflow.</td>\n      <td>Permissioned execution under a WPC, not prompt-only, plus OpenClaw tool policy and sandboxing to limit blast radius.</td>\n    </tr>\n    <tr>\n      <td>Overbroad tokens shared across trigger types</td>\n      <td>A token intended for “read-only triage” gets reused for “write to production,” enabling lateral movement.</td>\n      <td>CST scope hash and optional policy hash pinning so each trigger runner is constrained to an explicit WPC.</td>\n    </tr>\n    <tr>\n      <td>Model-call repudiation</td>\n      <td>You cannot prove which model was called, what inputs were sent, or whether the agent used an unapproved route.</td>\n      <td>Gateway receipts emitted by clawproxy for model calls, included in a proof bundle for verification.</td>\n    </tr>\n    <tr>\n      <td>Subscription drift (changefeed gaps)</td>\n      <td>Your change notification subscription expires or loses state; you miss events and silently stop enforcing controls.</td>\n      <td>Operational runbook: subscription lifecycle checks plus job records that require proof bundles for completion and alert on missing runs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><strong>Microsoft Graph change notifications (specific pitfall):</strong> treat each notification as a trigger to fetch the authoritative resource via official API, then decide actions based on that fetched state. Keep Graph permissions/scopes minimal (for example, read scopes for triage paths) and use Entra ID Conditional Access and PIM for operator access to the app registration and secrets.</p>\n\n<h2>Policy-as-code example</h2>\n<p>This is a sketch of what you want the policy to express for an event-native run. The important part is that the policy is machine-checked and pinned (WPC), rather than buried in prompts or tribal knowledge.</p>\n\n<pre>{\n  \"wpc_ref\": \"wpc:sha256:<policy_hash>\",\n  \"trigger\": {\n    \"type\": \"webhook|changefeed|graph_change_notification\",\n    \"required_headers\": [\"signature\", \"timestamp\"],\n    \"idempotency\": { \"key\": \"event_id\", \"ttl_seconds\": 86400 }\n  },\n  \"execution\": {\n    \"tools_profile\": \"event-triage\",\n    \"tools_allow\": [\"read\", \"search\", \"http_fetch_via_official_api\"],\n    \"tools_deny\": [\"shell\", \"write_files\", \"payments\", \"admin_actions\"],\n    \"sandbox\": { \"mode\": \"all\", \"workspace_access\": \"ro\" }\n  },\n  \"model_routing\": {\n    \"via\": \"clawproxy\",\n    \"provider\": \"openrouter_via_fal\",\n    \"require_gateway_receipts\": true\n  },\n  \"token\": {\n    \"cst\": {\n      \"scope_hash\": \"<scope_hash>\",\n      \"pin_wpc_hash\": \"<policy_hash>\",\n      \"job_bound\": true\n    }\n  }\n}</pre>\n\n<p>If you later need to widen access, do it by issuing a new WPC and updating the pinned hash. That creates an explicit change record rather than a silent behavior change.</p>\n\n<h2>What proof do you get?</h2>\n<p>For every agent run, you can retain verifiable artifacts instead of screenshots and best-effort logs. This is how you answer “what executed” and “under which constraints” when a webhook run creates an incident.</p>\n<ul>\n  <li>\n    <p><strong>Gateway receipts:</strong> signed receipts emitted by clawproxy for model calls. They let you audit which model calls occurred during the run and tie those calls to a specific job context.</p>\n  </li>\n  <li>\n    <p><strong>Proof bundle:</strong> a harness artifact bundling receipts and related metadata for audit/verification. Store it alongside the job record and use it for later review or verification workflows.</p>\n  </li>\n  <li>\n    <p><strong>WPC reference:</strong> the Work Policy Contract (WPC) hash that governed the run, fetched and verified from the WPC registry. This matters because the same event payload under a different WPC can be allowed or denied.</p>\n  </li>\n  <li>\n    <p><strong>Trust Pulse (optional):</strong> a marketplace-stored artifact for audit/viewing. Use it when you need to share a run’s evidence with a separate review group without giving them runtime access.</p>\n  </li>\n</ul>\n\n<h2>Rollback posture</h2>\n<p>Event systems retry, reorder, and duplicate. Your rollback posture should assume a run can partially succeed, then be retried later with the same event id.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop new triggers immediately</td>\n      <td>Rotate or revoke the CST for the trigger runner; runs fail closed while you investigate.</td>\n      <td>Token issuance and revocation records (operational), plus absence of new proof bundles for blocked jobs.</td>\n    </tr>\n    <tr>\n      <td>Freeze tool side effects</td>\n      <td>Update to a tighter WPC that denies write tools; pin the new WPC hash for subsequent jobs.</td>\n      <td>WPC hash change plus proof bundles showing denied tool attempts or altered tool availability.</td>\n    </tr>\n    <tr>\n      <td>Re-run deterministically</td>\n      <td>Reprocess from a stored event context using the same idempotency key; only missing steps execute.</td>\n      <td>Job record keyed by idempotency plus proof bundles per attempt (each with gateway receipts).</td>\n    </tr>\n    <tr>\n      <td>Post-incident verification</td>\n      <td>Verify proof bundles and compare to expected WPC and CST scope hash.</td>\n      <td>Proof bundle contents: gateway receipts, WPC reference, CST binding metadata.</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are optional and can be implemented as an enterprise buildout if you need stronger containment during rollback windows.</p>\n\n<h2>FAQ</h2>\n\n<h3>How do you handle idempotency for webhooks and changefeeds?</h3>\n<p>Pick an idempotency key that is stable across retries, then persist it per job before any side effect. Treat “already processed” as success, and store enough state to continue partial workflows without repeating writes.</p>\n\n<h3>Why is policy-as-code required instead of prompt instructions?</h3>\n<p>Event payloads are attacker-controlled inputs, so prompt-only guardrails can be overwritten by injected content. A WPC makes the execution layer permissioned: tools, routing, and token scopes are enforced even when the prompt is hostile.</p>\n\n<h3>What is the minimum Claw Bureau setup for trigger security?</h3>\n<p>Use a WPC to define what the run is allowed to do, a CST (issued by clawscope) to bind the runner to that policy, and route model calls via clawproxy to get gateway receipts. Then store the proof bundle per run so you can audit and verify after the fact.</p>\n\n<h3>How do Microsoft Graph change notifications fit into this model?</h3>\n<p>Use the notification only as a trigger to fetch the authoritative object via official API, then apply your WPC-governed workflow. Keep Graph permissions/scopes minimal, and manage the app and credentials under Entra ID controls like Conditional Access and PIM.</p>\n\n<h3>Can we prove which model the agent actually called?</h3>\n<p>You can prove the model call path that went through clawproxy using gateway receipts, then package them into a proof bundle. If a run bypasses the proxy, you will not have those receipts, which is why proxy routing should be required for event-native workloads.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://aws.amazon.com/blogs/compute/sending-and-receiving-webhooks-on-aws-innovate-with-event-notifications\">Sending and receiving webhooks on AWS: Innovate with event notifications</a></li>\n</ul>",
  "description": "Event-native agents are agents that run because an external system emitted an event: a webhook, a changefeed item, or a subscription notification. Claw EA makes these runs permissioned and auditable using OpenClaw as the",
  "faqs": [
    {
      "q": "How do you handle idempotency for webhooks and changefeeds?",
      "a": "Pick an idempotency key that is stable across retries, then persist it per job before any side effect. Treat “already processed” as success, and store enough state to continue partial workflows without repeating writes."
    },
    {
      "q": "Why is policy-as-code required instead of prompt instructions?",
      "a": "Event payloads are attacker-controlled inputs, so prompt-only guardrails can be overwritten by injected content. A WPC makes the execution layer permissioned: tools, routing, and token scopes are enforced even when the prompt is hostile."
    },
    {
      "q": "What is the minimum Claw Bureau setup for trigger security?",
      "a": "Use a WPC to define what the run is allowed to do, a CST (issued by clawscope) to bind the runner to that policy, and route model calls via clawproxy to get gateway receipts. Then store the proof bundle per run so you can audit and verify after the fact."
    },
    {
      "q": "How do Microsoft Graph change notifications fit into this model?",
      "a": "Use the notification only as a trigger to fetch the authoritative object via official API, then apply your WPC-governed workflow. Keep Graph permissions/scopes minimal, and manage the app and credentials under Entra ID controls like Conditional Access and PIM."
    },
    {
      "q": "Can we prove which model the agent actually called?",
      "a": "You can prove the model call path that went through clawproxy using gateway receipts, then package them into a proof bundle. If a run bypasses the proxy, you will not have those receipts, which is why proxy routing should be required for event-native workloads."
    }
  ],
  "sources": [
    {
      "title": "Agents API · Cloudflare Agents docs",
      "uri": "https://developers.cloudflare.com/agents/api-reference/agents-api"
    },
    {
      "title": "Sending and receiving webhooks on AWS: Innovate with event notifications | Amazon Web Services",
      "uri": "https://aws.amazon.com/blogs/compute/sending-and-receiving-webhooks-on-aws-innovate-with-event-notifications"
    },
    {
      "title": "Create event-driven architectures with Eventarc",
      "uri": "https://cloud.google.com/firestore/docs/eventarc"
    },
    {
      "title": "Webhooks",
      "uri": "https://developers.google.com/business-communications/rcs-business-messaging/guides/integrate/webhooks"
    },
    {
      "title": "Integrate Agents with Platform Events",
      "uri": "https://developer.salesforce.com/blogs/2025/07/integrate-agents-with-platform-events"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:56:17.864Z",
  "indexable": true
}