{
  "slug": "verify/proof-bundle",
  "title": "How to Verify a Proof Bundle | Claw EA",
  "category": "verify",
  "html": "<p>To verify a Proof bundle, you check that every cryptographic envelope validates and that the bundle’s bindings are consistent: the Work Policy Contract (WPC), the CST = scoped token, and the Gateway receipts all point at the same job identity and the same policy hash. Then you fail closed if anything is missing, unsigned, unverifiable, or not bound to the expected scope.</p>\n<p>OpenClaw is the baseline agent runtime, but prompt text alone is not a permission boundary. You need a permissioned execution layer enforced by policy-as-code so the runtime can prove what was allowed, what was called, and what cannot be replayed outside the original job.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Collect the Proof bundle and the verification inputs you expect to be true. At minimum: expected WPC policy hash (or an allowlist of acceptable hashes), the expected job identifier (if your pipeline assigns one), and the public keys or key-discovery references used to validate signatures.</p>\n    <p>If your workflow stores artifacts in Trust Pulse, pull the exact artifact you intend to verify and record its storage identifier for traceability.</p>\n  </li>\n  <li>\n    <p>Verify the WPC first, before looking at model traffic. The WPC = Work Policy Contract is a signed, hash-addressed policy artifact served by clawcontrols, so verification is: signature valid, hash matches the address, and the policy content matches what you intended to authorize.</p>\n    <p>Fail closed if the bundle references a WPC you cannot fetch and verify, or if it references multiple policies when you expect exactly one.</p>\n  </li>\n  <li>\n    <p>Verify the CST claims and bindings. A CST = scoped token is issued by clawscope; you should validate its signature, validate its scope hash, and confirm optional policy hash pinning when your job requires a specific WPC.</p>\n    <p>Then confirm the job-scoped binding is present when applicable, so a CST captured from one job cannot be replayed in another context.</p>\n  </li>\n  <li>\n    <p>Verify Gateway receipts for each model call. Gateway receipts are signed receipts emitted by clawproxy for model calls, so verification is: signature valid, receipt fields parse correctly, and each receipt binds to the same job identity and expected scope/policy references.</p>\n    <p>Fail closed if any model call in the run lacks a receipt when your policy requires full receipting coverage.</p>\n  </li>\n  <li>\n    <p>Check bundle integrity and cross-linking. A Proof bundle should be internally consistent: referenced receipt hashes exist, metadata hashes match their referenced payloads, and timestamps and nonces do not indicate copying or splicing from another run.</p>\n    <p>Do not accept “mostly valid” bundles for audit or incident response. Partial validity is a common way to launder unreceipted calls or inject an out-of-policy receipt set.</p>\n  </li>\n  <li>\n    <p>Confirm runtime posture constraints were actually enforceable. Prompt instructions like “do not exfiltrate secrets” do not prevent tool calls, network egress, or host execution; policy-as-code does because it can be checked and enforced by the runtime and proxy layer.</p>\n    <p>If the agent ran with elevated host execution or broad tool access, treat the proof as limited to what receipts can cover, not as a blanket safety guarantee.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Proof verification is about resisting realistic failures: replay, splicing, partial logging, and “policy drift” between what was approved and what was executed. The table below lists common failure modes and what a fail-closed verifier should do.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (what to verify)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Receipt replay across jobs</td>\n      <td>An attacker copies valid Gateway receipts from a prior run to make a new run look compliant.</td>\n      <td>Enforce marketplace anti-replay binding (job-scoped CST binding) and require receipts to bind to the same job identity and CST scope hash.</td>\n    </tr>\n    <tr>\n      <td>Policy drift (prompt-only “policy”)</td>\n      <td>The prompt claims restrictions, but the runtime or tools were not actually constrained.</td>\n      <td>Require a verified WPC and validate optional policy hash pinning in the CST when your workflow requires a specific policy.</td>\n    </tr>\n    <tr>\n      <td>Bundle splicing</td>\n      <td>A bundle mixes receipts and metadata from multiple runs to hide an out-of-policy call.</td>\n      <td>Verify internal hash linking across the Proof bundle and require a single, consistent job identity and policy reference set.</td>\n    </tr>\n    <tr>\n      <td>Partial coverage</td>\n      <td>Some model calls are receipted, but others bypass clawproxy and are missing receipts.</td>\n      <td>Fail closed on missing Gateway receipts when policy demands full coverage, and treat the verified subset as a partial attestation only.</td>\n    </tr>\n    <tr>\n      <td>Key substitution</td>\n      <td>A verifier accepts attacker-controlled signing keys.</td>\n      <td>Pin trusted key sources and rotate keys via controlled processes. Reject unknown issuers and unexpected key IDs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the shape of an enforceable policy artifact and how you bind execution to it. The important point is not the exact schema, but that the WPC is signed and hash-addressed, and the CST can pin to that policy hash so the job cannot silently switch rules.</p>\n\n<pre>\n{\n  \"wpc_ref\": {\n    \"policy_hash_b64u\": \"u6J...your_expected_policy_hash...\"\n  },\n  \"execution\": {\n    \"runtime\": \"openclaw\",\n    \"require_gateway_receipts\": true,\n    \"models\": [\n      { \"provider\": \"openrouter_via_fal\", \"allow\": true }\n    ]\n  },\n  \"auth\": {\n    \"cst\": {\n      \"require_scope_hash\": true,\n      \"pin_policy_hash\": \"u6J...your_expected_policy_hash...\"\n    }\n  },\n  \"audit\": {\n    \"require_proof_bundle\": true,\n    \"store_to_trust_pulse\": true\n  }\n}\n</pre>\n\n<p>Why this matters operationally: if you only instruct the agent in the prompt, you cannot later prove the instruction was enforced. With a WPC plus CST pinning, you can reject runs that do not match the approved policy hash.</p>\n\n<h2>What proof do you get?</h2>\n<p>A Proof bundle is the harness artifact bundling receipts and related metadata for audit/verification. In practice, you should expect: a reference to the WPC (by hash), a record of the CST scope or its hash, and a set of Gateway receipts for model calls emitted by clawproxy.</p>\n\n<p>What is signed: the WPC is signed; the CST is signed (issued by clawscope); Gateway receipts are signed by clawproxy. What is hashed: the WPC is hash-addressed; the bundle should include hashes linking receipts and metadata so tampering is detectable.</p>\n\n<p>What is replayable if you do it wrong: receipts and tokens can be copied if they are not bound to a job identity and policy hash. That is why you verify job-scoped CST binding and (when required) policy hash pinning, then reject bundles that cannot prove those bindings.</p>\n\n<p>A minimal “shape” to look for during review is below. Treat it as an inspection checklist, not a wire contract.</p>\n\n<pre>\n{\n  \"bundle\": {\n    \"job_id\": \"job_2026_02_11_001\",\n    \"wpc_policy_hash_b64u\": \"u6J...policy...\",\n    \"cst_scope_hash\": \"sH...scope...\",\n    \"receipts\": [\n      {\n        \"receipt_id\": \"rcpt_01\",\n        \"provider\": \"openrouter_via_fal\",\n        \"request_hash\": \"h_req_...\",\n        \"response_hash\": \"h_resp_...\",\n        \"signature\": \"sig_...\"\n      }\n    ]\n  }\n}\n</pre>\n\n<h2>Rollback posture</h2>\n<p>Verification should drive rollback actions that are easy to execute and easy to evidence. If you cannot prove a run is within policy, treat it as untrusted and roll forward by re-running under a stricter WPC, rather than trying to “patch” an unverifiable bundle.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence you should retain</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Bundle fails WPC verification</td>\n      <td>Block acceptance, fetch WPC again from clawcontrols, and require a re-run with the correct WPC hash.</td>\n      <td>Failed verification report, expected policy hash, and the retrieved WPC used for comparison.</td>\n    </tr>\n    <tr>\n      <td>Bundle fails CST binding checks</td>\n      <td>Revoke the CST via official API (clawscope) and issue a new CST with the correct scope hash and optional policy hash pinning.</td>\n      <td>Revocation record, new CST issuance record, and the verifier output showing the mismatch.</td>\n    </tr>\n    <tr>\n      <td>Missing Gateway receipts</td>\n      <td>Treat as partial attestation; re-run with all model traffic routed through clawproxy so every call produces receipts.</td>\n      <td>List of missing receipt slots, run configuration showing proxy routing, and the new bundle with full coverage.</td>\n    </tr>\n    <tr>\n      <td>Suspected replay or splicing</td>\n      <td>Invalidate the run, require a fresh job identity, and enforce job-scoped CST binding for the next execution.</td>\n      <td>Comparison notes across job IDs, receipt IDs, and timestamps that indicate reuse.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Can I verify a Proof bundle offline?</h3>\n<p>Yes, if you already have the needed public keys or key-discovery material cached and you have the WPC content that the bundle references. The workflow is similar to offline verification patterns used for software attestations: download the bundle while online, then verify signatures and hashes offline.</p>\n\n<h3>Why is prompt-only policy not enough?</h3>\n<p>Because prompts do not constrain tools, network calls, or host execution, and they cannot produce enforceable, testable proofs. Policy-as-code works because the WPC can be verified, the CST can pin to the WPC hash, and Gateway receipts can prove what model calls actually happened.</p>\n\n<h3>What does “fail closed” mean in practice?</h3>\n<p>If any required signature, hash link, policy reference, or binding is missing or invalid, you do not accept the bundle as verified. You either treat it as a partial artifact (explicitly labeled) or require a re-run under a verified WPC with receipted traffic.</p>\n\n<h3>Do Gateway receipts prove what tools did on the machine?</h3>\n<p>No, Gateway receipts cover model calls routed through clawproxy. For tool execution risks, rely on the OpenClaw controls (sandbox, tool policy, elevated mode) and treat the Proof bundle as proof of model-call behavior and policy bindings, not as a complete host activity log.</p>\n\n<h3>Where should we store verified bundles?</h3>\n<p>Store the original Proof bundle plus the verifier output in an append-only location your audit team controls. If you use Trust Pulse, store the artifact there for consistent viewing and later review, and keep your internal case metadata alongside it.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://docs.github.com/en/actions/how-tos/secure-your-work/use-artifact-attestations/verify-attestations-offline\">GitHub Docs: Verifying attestations offline</a></li>\n  <li><a href=\"https://pages.nist.gov/800-63-4/sp800-63c.html\">NIST SP 800-63C: Digital Identity Guidelines (Federation and Assertions)</a></li>\n</ul>",
  "description": "To verify a Proof bundle, you check that every cryptographic envelope validates and that the bundle’s bindings are consistent: the Work Policy Contract (WPC), the CST = scoped token, and the Gateway receipts all point at",
  "faqs": [
    {
      "q": "Can I verify a Proof bundle offline?",
      "a": "Yes, if you already have the needed public keys or key-discovery material cached and you have the WPC content that the bundle references. The workflow is similar to offline verification patterns used for software attestations: download the bundle while online, then verify signatures and hashes offline."
    },
    {
      "q": "Why is prompt-only policy not enough?",
      "a": "Because prompts do not constrain tools, network calls, or host execution, and they cannot produce enforceable, testable proofs. Policy-as-code works because the WPC can be verified, the CST can pin to the WPC hash, and Gateway receipts can prove what model calls actually happened."
    },
    {
      "q": "What does “fail closed” mean in practice?",
      "a": "If any required signature, hash link, policy reference, or binding is missing or invalid, you do not accept the bundle as verified. You either treat it as a partial artifact (explicitly labeled) or require a re-run under a verified WPC with receipted traffic."
    },
    {
      "q": "Do Gateway receipts prove what tools did on the machine?",
      "a": "No, Gateway receipts cover model calls routed through clawproxy. For tool execution risks, rely on the OpenClaw controls (sandbox, tool policy, elevated mode) and treat the Proof bundle as proof of model-call behavior and policy bindings, not as a complete host activity log."
    },
    {
      "q": "Where should we store verified bundles?",
      "a": "Store the original Proof bundle plus the verifier output in an append-only location your audit team controls. If you use Trust Pulse, store the artifact there for consistent viewing and later review, and keep your internal case metadata alongside it."
    }
  ],
  "sources": [
    {
      "title": "NIST Special Publication 800-63C",
      "uri": "https://pages.nist.gov/800-63-4/sp800-63c.html"
    },
    {
      "title": "Verifying attestations offline - GitHub Docs",
      "uri": "https://docs.github.com/en/actions/how-tos/secure-your-work/use-artifact-attestations/verify-attestations-offline"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:32:02.859Z",
  "indexable": true
}