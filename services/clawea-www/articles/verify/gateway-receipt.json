{
  "slug": "verify/gateway-receipt",
  "title": "How to Verify a Gateway Receipt | Claw EA",
  "category": "verify",
  "html": "<h2>Direct Answer</h2>\n<p>To verify a Gateway receipt, you check that (1) the receipt signature is valid for clawproxy’s public key, and (2) the receipt is cryptographically bound to the exact request context you expected: the model request/response hashes, the CST scope hash, and (optionally) a pinned WPC hash.</p>\n<p>In Claw EA, the receipt is strongest when it is carried inside a proof bundle, because the bundle captures the job context and makes replay and “receipt swapping” easier to detect during audit.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Collect inputs.</strong> Get the Gateway receipt (or a proof bundle containing it), plus the expected job metadata from your control plane: job id, agent/session identifiers, the CST you issued for the run, and the WPC hash you intended to enforce.</p>\n    <p>If you run OpenClaw as the baseline agent runtime, also capture the OpenClaw run identifiers you use to correlate model calls to a job (for example, session key and agent name from your own orchestration layer).</p>\n  </li>\n  <li>\n    <p><strong>Fetch the policy you claim you ran under.</strong> Resolve the WPC by its hash from the WPC registry, then verify it is correctly signed and the hash matches what you pinned.</p>\n    <p>This step is what makes “permissioned execution” concrete: the run is constrained by a signed artifact, not by a prompt that the model can ignore.</p>\n  </li>\n  <li>\n    <p><strong>Verify the CST binding.</strong> Inspect the CST (issued by clawscope) and confirm the scope hash matches the expected scope for this job. If you are using optional policy hash pinning, confirm the CST claims include the intended WPC hash and that it matches the fetched WPC.</p>\n    <p>Reject if the CST is expired, revoked, not job-scoped (if your deployment requires job scoping), or missing the expected pin.</p>\n  </li>\n  <li>\n    <p><strong>Verify the receipt signature (fail closed).</strong> Validate the receipt signature using clawproxy’s public key material (for example, via a pinned key or an approved key distribution mechanism in your environment).</p>\n    <p>Reject if the signature is invalid, the receipt format is unexpected, or required fields are missing. Do not “best-effort” accept partial receipts.</p>\n  </li>\n  <li>\n    <p><strong>Verify receipt bindings: what is signed and what is hashed.</strong> Compute hashes over the canonicalized request and response bodies (or the referenced content hashes) and compare to the receipt’s hash fields.</p>\n    <p>Also compare the receipt’s CST scope hash and any WPC hash fields against the CST and WPC you verified earlier.</p>\n  </li>\n  <li>\n    <p><strong>Check anti-replay and job scoping.</strong> Confirm the receipt is bound to the job-scoped CST (marketplace anti-replay binding) and that the job id and nonce-like fields (if present in your bundle schema) are consistent across the bundle.</p>\n    <p>Reject if the same receipt id appears in multiple jobs, or if a receipt from another job can be “attached” without detection.</p>\n  </li>\n  <li>\n    <p><strong>Store verification results with evidence.</strong> Persist the receipt, verification decision, and key metadata (policy hash, scope hash, model/provider identifiers, timestamps) as an immutable audit record.</p>\n    <p>If you use Trust Pulse, publish the artifact for reviewers; otherwise store internally with the proof bundle.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>A Gateway receipt is designed to make model-call evidence portable and checkable after the fact. Verification should assume the agent, the model, and any upstream prompt content can be hostile, and should treat receipts as untrusted until proven valid.</p>\n<p>Prompt-only control is insufficient because the model can be instructed to ignore constraints, fabricate logs, or omit actions. Policy-as-code via WPC and CST makes the execution layer permissioned and verifiable even when prompts are adversarial.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Receipt forgery</td>\n      <td>An attacker fabricates a “receipt-like” JSON to claim a model call occurred.</td>\n      <td>Verify clawproxy signature and reject if the signing key is not trusted for your environment.</td>\n    </tr>\n    <tr>\n      <td>Receipt swapping</td>\n      <td>A valid receipt from another run is attached to this job to “prove” compliant behavior.</td>\n      <td>Verify binding to the job-scoped CST and the expected CST scope hash; prefer validation in a proof bundle.</td>\n    </tr>\n    <tr>\n      <td>Policy bypass via prompt</td>\n      <td>The model is instructed to ignore rules and call tools or models outside intended constraints.</td>\n      <td>Use a WPC and require CST policy hash pinning (optional) so receipts must match the intended policy hash.</td>\n    </tr>\n    <tr>\n      <td>Partial logging</td>\n      <td>Only some calls are shown, hiding unsafe outputs or data exfiltration attempts.</td>\n      <td>Require receipts for every model call routed through clawproxy; audit for gaps per session/job.</td>\n    </tr>\n    <tr>\n      <td>Key confusion / wrong verifier key</td>\n      <td>A verifier uses the wrong public key and accepts receipts from an unapproved proxy.</td>\n      <td>Pin allowed signer keys per environment and rotate keys with an explicit approval workflow.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example shows the shape you want to bind into a WPC and optionally pin into the CST. Keep it minimal and deterministic so you can verify the exact same bytes (or canonical form) across systems.</p>\n<p>It is intentionally “JSON-like” and omits endpoints. In practice, the WPC is a signed, hash-addressed artifact served by clawcontrols.</p>\n\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"policy\": {\n    \"job\": {\n      \"purpose\": \"customer_support_triage\",\n      \"data_class\": \"internal\"\n    },\n    \"model_routing\": {\n      \"require_gateway_receipts\": true,\n      \"allowed_provider\": [\"openrouter_via_fal\"],\n      \"allowed_models\": [\"exact-model-id-here\"]\n    },\n    \"tool_policy\": {\n      \"allow\": [\"read\", \"write\", \"http\"],\n      \"deny\": [\"exec\", \"browser_control\"]\n    }\n  },\n  \"verification\": {\n    \"require_cst_scope_hash\": true,\n    \"pin_wpc_hash_in_cst\": true\n  }\n}\n</pre>\n\n<h2>What proof do you get?</h2>\n<p>Gateway receipts are signed receipts emitted by clawproxy for model calls. They are intended to be checked independently from the agent and independently from any prompt transcript.</p>\n<p>A proof bundle packages one or more receipts plus metadata needed for audit and verification. It is the unit you should store and hand to reviewers, because it reduces ambiguity about “which run” a receipt belongs to.</p>\n\n<p>A minimal receipt and bundle shape looks like this (illustrative fields only). The important part is that the signature covers the binding fields, and that you can recompute the referenced hashes.</p>\n\n<pre>\n{\n  \"proof_bundle\": {\n    \"bundle_id\": \"bnd_...\",\n    \"job_id\": \"job_...\",\n    \"cst_scope_hash\": \"h_scope_...\",\n    \"wpc_hash\": \"h_wpc_...\",\n    \"receipts\": [\n      {\n        \"receipt_id\": \"rcpt_...\",\n        \"issuer\": \"clawproxy\",\n        \"issued_at\": \"2026-02-11T12:34:56Z\",\n        \"provider\": \"openrouter_via_fal\",\n        \"model\": \"exact-model-id-here\",\n        \"request_hash\": \"h_req_...\",\n        \"response_hash\": \"h_resp_...\",\n        \"binding\": {\n          \"job_id\": \"job_...\",\n          \"cst_scope_hash\": \"h_scope_...\",\n          \"wpc_hash\": \"h_wpc_...\"\n        },\n        \"signature\": \"sig_...\"\n      }\n    ]\n  }\n}\n</pre>\n\n<p>What is signed: the binding fields (job id, scope hash, optional WPC hash), the request and response hashes, and issuer metadata. What is hashed: the request payload and response payload (or their canonical encodings) so you can detect any edit after issuance.</p>\n<p>What is replayable: a receipt can be copied as bytes, but it should fail verification for a different job when you enforce job-scoped CST binding and compare bundle metadata to your expected job context.</p>\n\n<h2>Rollback posture</h2>\n<p>Receipt verification should degrade safely. If verification fails, your system should behave as if the model call is untrusted, even if the content looks plausible.</p>\n<p>Rollbacks are operational decisions. Keep them tied to evidence you can show later, ideally by attaching the failed receipt and verifier output to the same case ticket.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Receipt signature fails</td>\n      <td>Quarantine the run output; block downstream automation; require re-run under a fresh CST.</td>\n      <td>Receipt bytes, signer key id used, signature verification error, timestamp.</td>\n    </tr>\n    <tr>\n      <td>Scope hash mismatch</td>\n      <td>Treat as cross-job contamination; invalidate the job; rotate job-scoped CST issuance path.</td>\n      <td>Expected CST scope hash, observed scope hash in receipt/bundle, job id mapping.</td>\n    </tr>\n    <tr>\n      <td>WPC pin mismatch (when required)</td>\n      <td>Stop processing and re-run only after re-issuing CST with the correct WPC hash pin.</td>\n      <td>WPC hash from clawcontrols, CST claims showing pinned hash, receipt binding fields.</td>\n    </tr>\n    <tr>\n      <td>Hash mismatch for request/response</td>\n      <td>Assume tampering or serialization mismatch; store raw payloads and canonicalization rules; re-run verification with agreed canonical form.</td>\n      <td>Computed hashes, canonicalization method/version, raw payload digests, receipt hashes.</td>\n    </tr>\n    <tr>\n      <td>Missing receipts for some calls</td>\n      <td>Fail the job audit; require all model calls to route through clawproxy; review OpenClaw provider configuration.</td>\n      <td>Expected call count vs receipts count, session timeline, proof bundle contents.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Can I verify a Gateway receipt without a proof bundle?</h3>\n<p>Yes, if you have the receipt bytes, the correct public key for clawproxy, and the expected context (job id, CST scope hash, and any pinned WPC hash). In practice, teams use proof bundles because they reduce “missing context” failures and make audits easier.</p>\n\n<h3>Why do I need policy-as-code instead of putting rules in the prompt?</h3>\n<p>A prompt is not a permission boundary. A WPC is a signed artifact, and a CST can optionally pin that policy hash, so the execution layer can reject runs that do not match the intended constraints even if the model was instructed otherwise.</p>\n\n<h3>What should I treat as the source of truth: the transcript or the receipt?</h3>\n<p>For “did a specific model call happen with specific inputs and outputs,” the receipt is the evidence object because it is signed and hash-bound. Transcripts can still be useful, but they are easier to edit and harder to bind to a specific call.</p>\n\n<h3>What are common verification pitfalls?</h3>\n<p>The most common are: using the wrong signer key, skipping canonicalization rules when recomputing hashes, and failing to enforce job scoping so a receipt can be moved between jobs. Another pitfall is accepting “receipt-like” logs from the agent instead of verifying the clawproxy signature.</p>\n\n<h3>How does this relate to OpenClaw security controls?</h3>\n<p>OpenClaw controls what tools can run and where they run (sandbox vs host), but that does not automatically produce third-party verifiable evidence of model calls. Gateway receipts and proof bundles complement OpenClaw by providing audit artifacts for the model gateway path.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf\">NIST CSRC: Implementation Guidance for FIPS 140-2 (PDF)</a></li>\n</ul>",
  "description": "To verify a Gateway receipt, you check that (1) the receipt signature is valid for clawproxy’s public key, and (2) the receipt is cryptographically bound to the exact request context you expected: the model request/respo",
  "faqs": [
    {
      "q": "Can I verify a Gateway receipt without a proof bundle?",
      "a": "Yes, if you have the receipt bytes, the correct public key for clawproxy, and the expected context (job id, CST scope hash, and any pinned WPC hash). In practice, teams use proof bundles because they reduce “missing context” failures and make audits easier."
    },
    {
      "q": "Why do I need policy-as-code instead of putting rules in the prompt?",
      "a": "A prompt is not a permission boundary. A WPC is a signed artifact, and a CST can optionally pin that policy hash, so the execution layer can reject runs that do not match the intended constraints even if the model was instructed otherwise."
    },
    {
      "q": "What should I treat as the source of truth: the transcript or the receipt?",
      "a": "For “did a specific model call happen with specific inputs and outputs,” the receipt is the evidence object because it is signed and hash-bound. Transcripts can still be useful, but they are easier to edit and harder to bind to a specific call."
    },
    {
      "q": "What are common verification pitfalls?",
      "a": "The most common are: using the wrong signer key, skipping canonicalization rules when recomputing hashes, and failing to enforce job scoping so a receipt can be moved between jobs. Another pitfall is accepting “receipt-like” logs from the agent instead of verifying the clawproxy signature."
    },
    {
      "q": "How does this relate to OpenClaw security controls?",
      "a": "OpenClaw controls what tools can run and where they run (sandbox vs host), but that does not automatically produce third-party verifiable evidence of model calls. Gateway receipts and proof bundles complement OpenClaw by providing audit artifacts for the model gateway path."
    }
  ],
  "sources": [
    {
      "title": "[PDF] Implementation Guidance for FIPS 140-2 - NIST - CSRC",
      "uri": "https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:31:08.083Z",
  "indexable": true
}