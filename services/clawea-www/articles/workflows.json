{
  "slug": "workflows",
  "title": "Enterprise Agent Workflows (Safe by Policy) | Claw EA",
  "category": "hubs",
  "html": "<h2>Direct Answer</h2>\n<p>Enterprise agent workflows fail when “safety” lives only in prompts. Claw EA treats execution as a permissioned system: a Work Policy Contract (WPC) is the machine-enforced contract, a CST is the scoped token that binds a job to that policy, and model calls produce gateway receipts for later verification.</p>\n<p>OpenClaw is the baseline agent runtime: it already has tool allow/deny profiles and optional Docker sandboxing, which you can pair with Claw Bureau primitives to get auditable, repeatable workflows. The goal is not to make agents smarter, it is to make their actions bounded, attributable, and reversible.</p>\n<p>This hub covers the operational building blocks for “enterprise agent workflows” where security teams can answer: what was allowed, what actually happened, and what you can roll back quickly.</p>\n\n<p><strong>Workflow taxonomy (what teams usually standardize):</strong></p>\n<ul>\n  <li><strong>Production deploy with tool sandboxing:</strong> Run OpenClaw tools in Docker to reduce filesystem and process blast radius.</li>\n  <li><strong>Permissioned tool access:</strong> Convert “agent can do X” into a WPC that can be fetched and verified before execution.</li>\n  <li><strong>Model access control with receipts:</strong> Route model traffic through clawproxy so each call yields gateway receipts.</li>\n  <li><strong>Job-scoped identity:</strong> Issue a CST per job, with a scope hash and optional policy hash pinning to prevent policy drift.</li>\n  <li><strong>Secrets and credentials hygiene:</strong> Keep secrets out of prompts and logs; scope what the runtime can read.</li>\n  <li><strong>High-risk action approvals:</strong> Add a human gate for actions like payments or user provisioning (can be implemented).</li>\n  <li><strong>Audit and verification:</strong> Package gateway receipts into a proof bundle and store/share via Trust Pulse.</li>\n  <li><strong>Incident response and rollback:</strong> Revoke CSTs, revert to a known-good WPC hash, and tighten OpenClaw tool policy.</li>\n</ul>\n\n<p><strong>How to get started checklist:</strong></p>\n<ul>\n  <li>Pick one workflow and define “allowed tools, allowed model route, allowed data boundaries.”</li>\n  <li>Write and publish a WPC in clawcontrols and keep the hash in your change record.</li>\n  <li>Issue a CST from clawscope per job, with policy hash pinning where appropriate.</li>\n  <li>Run OpenClaw with tight tool policy and sandboxing, and route model calls through clawproxy.</li>\n  <li>Require proof bundles for promotion to production and store them in Trust Pulse.</li>\n</ul>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p><strong>Define the workflow boundary.</strong> Write down the exact tools the agent may use (read/write/exec/browser) and what “done” means. If the workflow touches Microsoft systems, define the Microsoft Graph permissions/scopes you expect the integration to use, and gate access through Entra ID and Conditional Access where applicable (via official API or enterprise buildout).</p>\n  </li>\n  <li>\n    <p><strong>Create a WPC for the job type.</strong> Put tool allow/deny, model routing requirements, and any required human gates into the WPC, then publish it to clawcontrols. Treat the WPC hash as the immutable identifier, and reference that hash in your deployment and ticketing flow.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST bound to the job.</strong> Use clawscope to mint a CST with a scope hash that matches the job’s permitted actions, and optionally pin the WPC hash in the token claims. Use short TTLs for interactive workflows, and mint new CSTs for retries rather than reusing old ones.</p>\n  </li>\n  <li>\n    <p><strong>Configure OpenClaw defensively.</strong> Use OpenClaw tool policy (profiles plus allow/deny) to match the WPC intent, and enable Docker sandboxing for tools when possible. Run <code>openclaw security audit</code> regularly to catch configuration footguns around auth exposure, tool blast radius, and filesystem permissions.</p>\n  </li>\n  <li>\n    <p><strong>Route model traffic through clawproxy.</strong> Ensure the OpenClaw provider path sends model calls through clawproxy so you get gateway receipts for each call. If you use OpenRouter via fal, route that through clawproxy as well so the same receipt semantics apply.</p>\n  </li>\n  <li>\n    <p><strong>Collect and verify the proof bundle.</strong> At the end of the run, export the proof bundle that includes gateway receipts plus job metadata, then verify it in your audit workflow. Store the resulting artifact in Trust Pulse for later viewing and cross-team review.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection triggers dangerous tools</td>\n      <td>The model tries to turn untrusted content into file writes, shell exec, or browser actions.</td>\n      <td>OpenClaw tool policy allow/deny plus Docker sandboxing; WPC defines permitted tools and denies “escape hatch” behaviors by default.</td>\n    </tr>\n    <tr>\n      <td>Policy drift between staging and prod</td>\n      <td>A run uses broader permissions than the reviewer intended because configs changed.</td>\n      <td>WPC is hash-addressed; CST can optionally pin the policy hash so the job fails closed if the policy is not the expected one.</td>\n    </tr>\n    <tr>\n      <td>Token replay across jobs</td>\n      <td>An attacker reuses a token from one job to run another job or re-run the same job later.</td>\n      <td>Marketplace anti-replay binding with job-scoped CST binding; keep CST TTLs short and issue per-job tokens.</td>\n    </tr>\n    <tr>\n      <td>Unreceipted model calls</td>\n      <td>A component calls a model directly, bypassing auditability, and you cannot prove what was asked or returned.</td>\n      <td>Route model calls through clawproxy to generate gateway receipts; treat “no receipts” as an invalid production run.</td>\n    </tr>\n    <tr>\n      <td>Sandbox boundary pierced by mounts or elevated exec</td>\n      <td>Accidental bind mounts or elevated execution expose host filesystem or control surfaces.</td>\n      <td>Prefer read-only mounts; avoid elevated execution unless explicitly justified; use OpenClaw sandbox explain and security audit to spot risky settings.</td>\n    </tr>\n    <tr>\n      <td>Over-permissioned Microsoft access</td>\n      <td>An agent gets broad Graph scopes and can read or modify more than intended.</td>\n      <td>Minimize Microsoft Graph permissions/scopes; use Entra ID Conditional Access and PIM where applicable; keep these permissions out of prompts and enforce via official API or enterprise buildout.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is an illustrative, JSON-like WPC shape to show how teams encode execution permissions. The point is determinism: reviewers can diff it, operators can pin it by hash, and jobs can fail closed if the contract is not the one you approved.</p>\n\n<pre>{\n  \"wpc_version\": \"v1\",\n  \"purpose\": \"Invoice triage and draft response\",\n  \"tool_policy\": {\n    \"allow\": [\"read\", \"write\", \"http\", \"browser\"],\n    \"deny\": [\"exec\", \"process\", \"elevated\"]\n  },\n  \"sandbox_expectations\": {\n    \"tools_run_in_sandbox\": true,\n    \"workspace_access\": \"ro\"\n  },\n  \"model_route\": {\n    \"require_clawproxy\": true,\n    \"allowed\": [\"OpenRouter_via_fal\"]\n  },\n  \"token_requirements\": {\n    \"cst_ttl_seconds_max\": 1800,\n    \"require_scope_hash\": true,\n    \"policy_hash_pinning\": \"optional\"\n  },\n  \"approvals\": {\n    \"required_for\": [\"external_send\", \"user_provisioning\"],\n    \"status\": \"can be implemented\"\n  },\n  \"audit\": {\n    \"require_gateway_receipts\": true,\n    \"require_proof_bundle\": true\n  }\n}</pre>\n\n<p>In practice you also map this to OpenClaw configuration: tool profiles, allow/deny lists, and sandbox mode. The WPC is the contract; OpenClaw settings are the local enforcement layer that should match it.</p>\n\n<h2>What proof do you get?</h2>\n<p>For production workflows, “logs” are not enough because they are easy to miss, redact incorrectly, or tamper with after an incident. Claw EA focuses on proof you can verify independently and attach to a ticket, incident, or audit package.</p>\n<ul>\n  <li><strong>Gateway receipts:</strong> signed receipts emitted by clawproxy for model calls, so you can prove which calls were made through the approved gateway.</li>\n  <li><strong>Proof bundle:</strong> a harness artifact bundling receipts and related metadata for audit and verification, including policy identifiers and job context needed for review.</li>\n  <li><strong>CST binding signals:</strong> evidence that the run used the intended CST (scoped token) and respected job-scoped anti-replay binding.</li>\n  <li><strong>Trust Pulse:</strong> marketplace-stored artifact storage/viewer to share proof bundles with auditors and stakeholders without emailing attachments around.</li>\n</ul>\n\n<h2>Rollback posture</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to check</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop an in-flight workflow</td>\n      <td>Revoke the CST in clawscope and require a fresh CST for retries.</td>\n      <td>Token revocation record plus proof bundle showing which calls completed before revocation.</td>\n    </tr>\n    <tr>\n      <td>Undo a permission expansion</td>\n      <td>Revert to a prior WPC hash and re-issue CSTs with policy hash pinning to that hash.</td>\n      <td>WPC hash history in your change record; proof bundles for runs before and after the revert.</td>\n    </tr>\n    <tr>\n      <td>Contain tool abuse</td>\n      <td>Tighten OpenClaw tool allow/deny and increase sandboxing scope (for example, sandbox all sessions).</td>\n      <td>OpenClaw security audit output and sandbox explain output for the affected agent sessions.</td>\n    </tr>\n    <tr>\n      <td>Contain model-route bypass</td>\n      <td>Require clawproxy routing for production runs and reject runs without gateway receipts.</td>\n      <td>Presence of gateway receipts in the proof bundle; absence is a policy violation.</td>\n    </tr>\n    <tr>\n      <td>Clamp network exposure</td>\n      <td>Reduce inbound surfaces and tighten OpenClaw channel policies; egress allowlists can be implemented outside clawproxy (optional).</td>\n      <td>Updated OpenClaw security audit results; WPC revision notes describing the new boundary.</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Automatic cost budget enforcement is planned in some deployments, but you should not rely on it as your primary safety boundary today. Make “what can run” and “what must be receipted” the default controls, then add budgets as a secondary guardrail when available.</p>\n\n<h2>FAQ</h2>\n\n<h3>Why is policy-as-code required instead of just prompting the agent to behave?</h3>\n<p>Prompts are not a permission system because they do not constrain tool availability, token scope, or network routes. A WPC plus CST makes the boundary machine-checkable, and it gives you a stable artifact you can review, diff, and pin by hash.</p>\n\n<h3>How does this relate to OpenClaw’s tool policy and sandboxing?</h3>\n<p>OpenClaw enforces the local boundary: which tools exist and whether tool execution runs on the host or in Docker. Claw EA adds remote authorization and audit primitives so the same workflow can be repeated across environments with verifiable receipts.</p>\n\n<h3>What do I require for a workflow to be considered “production”?</h3>\n<p>At minimum: a published WPC, a per-job CST with scope hash, and model calls routed through clawproxy so you get gateway receipts. Then require a proof bundle for every run and store it in Trust Pulse for review.</p>\n\n<h3>Can we integrate with Microsoft systems like Entra ID and Microsoft Graph?</h3>\n<p>Yes, typically via official API or via MCP server, with an enterprise buildout when you need strict controls. Keep Graph permissions/scopes minimal, and use Entra ID controls like Conditional Access and PIM where applicable.</p>\n\n<h3>What if we need strict egress control or hard spend caps?</h3>\n<p>Egress allowlists enforced outside clawproxy are optional and can be implemented, depending on your environment. Automatic cost budget enforcement is planned, so treat it as an add-on rather than a core safety mechanism today.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/build-secure-process\">Process to build agents across your organization - Microsoft Learn</a></li>\n  <li><a href=\"https://aws.amazon.com/blogs/machine-learning/ai-agents-in-enterprises-best-practices-with-amazon-bedrock-agentcore/\">AI agents in enterprises: Best practices with Amazon Bedrock AgentCore</a></li>\n</ul>",
  "description": "Enterprise agent workflows fail when “safety” lives only in prompts. Claw EA treats execution as a permissioned system: a Work Policy Contract (WPC) is the machine-enforced contract, a CST is the scoped token that binds ",
  "faqs": [
    {
      "q": "Why is policy-as-code required instead of just prompting the agent to behave?",
      "a": "Prompts are not a permission system because they do not constrain tool availability, token scope, or network routes. A WPC plus CST makes the boundary machine-checkable, and it gives you a stable artifact you can review, diff, and pin by hash."
    },
    {
      "q": "How does this relate to OpenClaw’s tool policy and sandboxing?",
      "a": "OpenClaw enforces the local boundary: which tools exist and whether tool execution runs on the host or in Docker. Claw EA adds remote authorization and audit primitives so the same workflow can be repeated across environments with verifiable receipts."
    },
    {
      "q": "What do I require for a workflow to be considered “production”?",
      "a": "At minimum: a published WPC, a per-job CST with scope hash, and model calls routed through clawproxy so you get gateway receipts. Then require a proof bundle for every run and store it in Trust Pulse for review."
    },
    {
      "q": "Can we integrate with Microsoft systems like Entra ID and Microsoft Graph?",
      "a": "Yes, typically via official API or via MCP server, with an enterprise buildout when you need strict controls. Keep Graph permissions/scopes minimal, and use Entra ID controls like Conditional Access and PIM where applicable."
    },
    {
      "q": "What if we need strict egress control or hard spend caps?",
      "a": "Egress allowlists enforced outside clawproxy are optional and can be implemented, depending on your environment. Automatic cost budget enforcement is planned, so treat it as an add-on rather than a core safety mechanism today."
    }
  ],
  "sources": [
    {
      "title": "Process to build agents across your organization - Microsoft Learn",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/build-secure-process"
    },
    {
      "title": "AI agents in enterprises: Best practices with Amazon Bedrock ...",
      "uri": "https://aws.amazon.com/blogs/machine-learning/ai-agents-in-enterprises-best-practices-with-amazon-bedrock-agentcore/"
    },
    {
      "title": "The Enterprise AI Agent Era: Why Trust, Security, and Governance ...",
      "uri": "https://www.salesforce.com/blog/unified-trust-security-governance-for-agentic-solutions/"
    },
    {
      "title": "What Are Agentic Workflows?",
      "uri": "https://www.salesforce.com/agentforce/agentic-workflows/"
    },
    {
      "title": "AI Agents Use Cases in the Enterprise - SAP",
      "uri": "https://www.sap.com/resources/ai-agents-use-cases"
    },
    {
      "title": "AI Agents - ServiceNow",
      "uri": "https://www.servicenow.com/products/ai-agents.html"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:04:46.815Z",
  "indexable": true
}