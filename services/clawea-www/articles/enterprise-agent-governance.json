{
  "slug": "enterprise-agent-governance",
  "title": "Enterprise Agent Governance (Policy, Approvals, Budgets) | Claw EA",
  "category": "pillars",
  "html": "<h2>Direct Answer</h2>\n<p>Enterprise agent governance is permissioned execution: every tool call and every model call runs under a machine-enforced policy, with approvals and scope limits that cannot be bypassed by a clever prompt.</p>\n<p>Claw EA uses OpenClaw as the baseline agent runtime, then adds Claw Bureau primitives so runs are tied to a WPC, authorized by a CST, and evidenced by gateway receipts and a proof bundle you can verify later.</p>\n\n<h2>Step-by-step runbook</h2>\n<ol>\n  <li>\n    <p>Define the work boundary as policy, not instructions. Start by listing allowed tools, allowed model providers, maximum session TTL, and what must be redacted in logs.</p>\n    <p>Keep this in a WPC so the runtime can fetch and verify the signed policy artifact instead of trusting a prompt.</p>\n  </li>\n  <li>\n    <p>Publish the WPC and treat it like an immutable release. Your deployment process should reference the WPC hash, not “latest,” so you can prove which policy governed a run.</p>\n    <p>Claw EA expects WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols).</p>\n  </li>\n  <li>\n    <p>Issue a CST per job or per run, scoped to that WPC. Pin the policy hash in the CST when you want fail-closed behavior: the run cannot proceed if the policy changes.</p>\n    <p>CST = scoped token (issued by clawscope).</p>\n  </li>\n  <li>\n    <p>Route all model traffic through clawproxy. This ensures every model call emits gateway receipts and is enforceable against the WPC and CST scope.</p>\n    <p>If you use OpenRouter via fal, route it through clawproxy so receipts are produced for each model request.</p>\n  </li>\n  <li>\n    <p>Wire approvals to the execution boundary, not to chat. Approvals should gate the issuance of a CST (or the upgrade to a higher-privilege CST), because the token is what tools and providers actually honor.</p>\n    <p>If you need Microsoft-native approval workflows, integrate approval decisions via official API and map them to CST issuance rules.</p>\n  </li>\n  <li>\n    <p>Run OpenClaw with explicit tool policy and sandboxing aligned to the WPC. Use OpenClaw tool allow/deny profiles and Docker sandboxing so prompt injection cannot silently turn into host execution.</p>\n    <p>Run OpenClaw’s security audit regularly to catch common “footguns” like open inbound policies or risky logging settings.</p>\n  </li>\n  <li>\n    <p>Collect proof bundles per run and store the verification artifact. A proof bundle ties together gateway receipts, the policy hash, and job-scoped bindings so you can audit who authorized what and what actually happened.</p>\n    <p>Optionally store the resulting artifact as a Trust Pulse for later viewing and review.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Prompt-only controls fail because they are advisory text inside the same channel the attacker can influence. Governance needs enforcement at the execution layer: tokens, policy fetch/verify, tool allowlists, and receipted model traffic.</p>\n<p>The table below shows concrete failure modes and the controls you should put in place in Claw EA deployments.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (operational)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection causes unauthorized tool use</td>\n      <td>An agent is convinced to run a tool sequence that reads files, exfiltrates data, or modifies systems.</td>\n      <td>Enforce tool policy in OpenClaw and bind the run to a WPC; require a CST that scopes tool categories and denies elevation by default.</td>\n    </tr>\n    <tr>\n      <td>Policy drift between approval and execution</td>\n      <td>A run is approved under “Policy A,” but executes under a modified “Policy B” after a config change.</td>\n      <td>Pin the WPC hash in the CST; at runtime, fetch/verify the WPC and fail closed if hashes do not match.</td>\n    </tr>\n    <tr>\n      <td>Replay of a previously approved credential</td>\n      <td>A captured token is reused to start a new job with the same privileges.</td>\n      <td>Use marketplace anti-replay binding with job-scoped CST binding so a CST cannot be replayed across jobs.</td>\n    </tr>\n    <tr>\n      <td>Unverified model calls (shadow egress)</td>\n      <td>Some model calls bypass your proxy, so you cannot prove what was sent or received.</td>\n      <td>Route model traffic through clawproxy so gateway receipts are emitted for model calls; restrict provider configuration to the proxied path.</td>\n    </tr>\n    <tr>\n      <td>Sandbox escape via “elevated” execution</td>\n      <td>A sandboxed agent uses a host escape hatch, intentionally or by misconfiguration, and runs on the host.</td>\n      <td>In OpenClaw, treat “elevated” as a break-glass path; require a higher-privilege CST for any workflow that enables it and keep it off in default profiles.</td>\n    </tr>\n    <tr>\n      <td>Budget overruns from long-running sessions</td>\n      <td>Costs grow because sessions run longer than intended or loop on retries.</td>\n      <td>Enforce tight TTLs in CST and session constraints in your WPC. Automatic cost budget enforcement is planned; today, implement usage caps via your provider billing controls and internal run limits.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This example illustrates the difference between “instructions” and “enforcement.” The policy is a WPC that is verified at runtime, and the CST pins the policy hash so the agent cannot switch policies mid-run.</p>\n<p>Use this as a template for what you want to be explicit about: allowed tools, sandbox requirements, model routing, and approval gates for privilege upgrades.</p>\n\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"policy\": {\n    \"job_class\": \"enterprise_agent_run\",\n    \"tool_policy\": {\n      \"allow\": [\"read\", \"write\", \"http\", \"process\"],\n      \"deny\": [\"exec_host\", \"docker_socket\", \"filesystem_mount_rw_outside_workspace\"],\n      \"require_sandbox\": true\n    },\n    \"model_policy\": {\n      \"require_proxy\": \"clawproxy\",\n      \"allowed_routes\": [\"openrouter_via_fal\"],\n      \"receipt_required\": true\n    },\n    \"approvals\": [\n      { \"action\": \"enable_elevated\", \"require\": \"human_approval\" },\n      { \"action\": \"access_production_data\", \"require\": \"human_approval\" }\n    ],\n    \"session_limits\": {\n      \"max_ttl_seconds\": 3600\n    },\n    \"audit\": {\n      \"emit_gateway_receipts\": true,\n      \"bundle_proof\": true\n    }\n  },\n  \"cst_requirements\": {\n    \"policy_hash_pinned\": true,\n    \"job_scoped_binding\": true\n  }\n}\n</pre>\n\n<h2>What proof do you get?</h2>\n<p>Governance is only credible if you can verify what ran, under which policy, and what the model saw. Claw EA produces evidence at the execution boundary, not just application logs.</p>\n<p>For model calls, clawproxy emits gateway receipts. These receipts are signed and can be bundled to prove that a given prompt and response pair flowed through the governed proxy path.</p>\n<p>For each run, Claw EA can produce a proof bundle. A proof bundle is a harness artifact bundling receipts and related metadata for audit/verification, including the WPC reference and the CST scope hash so you can connect “approved scope” to “observed behavior.”</p>\n<p>For anti-replay, Claw EA supports marketplace anti-replay binding via job-scoped CST binding. In practice, this means a CST intended for one job cannot be reused to start another job with the same authority.</p>\n<p>For storage and review workflows, you can store a Trust Pulse. Trust Pulse is a marketplace-stored artifact for audit/viewing, useful when you need to share a run record with security, compliance, or an external auditor without granting them access to the runtime.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback is part of governance because agents change behavior as tools, models, and policies change. Your goal is to revert privilege and stop execution quickly, then preserve evidence for review.</p>\n<p>The table below summarizes safe rollback actions and the evidence you should expect to retain.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Revoke the active CST</td>\n      <td>Fail closed for new calls that require authorization; the agent cannot continue privileged actions.</td>\n      <td>Token issuance and revocation events, plus proof bundle linkage to the CST scope hash.</td>\n    </tr>\n    <tr>\n      <td>Rotate to a more restrictive WPC</td>\n      <td>New runs must fetch/verify a stricter WPC; existing pinned runs continue to enforce the pinned hash or fail closed if mismatched.</td>\n      <td>WPC hash history and the WPC reference embedded in the proof bundle.</td>\n    </tr>\n    <tr>\n      <td>Disable elevated execution in OpenClaw config</td>\n      <td>Tool execution stays inside Docker sandbox where configured; host escape hatch is removed.</td>\n      <td>OpenClaw config diff plus the run’s receipts showing tool usage did not include elevated paths.</td>\n    </tr>\n    <tr>\n      <td>Force model routing through clawproxy only</td>\n      <td>Blocks unreceipted model calls; any bypass becomes a deployment failure rather than a silent gap.</td>\n      <td>Gateway receipts coverage for model calls and proof bundle completeness checks.</td>\n    </tr>\n    <tr>\n      <td>Emergency stop for a job class</td>\n      <td>Issue no new CSTs for that job class and require re-approval for re-enable.</td>\n      <td>Audit trail for issuance decisions, plus historical proof bundles for already-completed runs.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is permissioned execution better than “system prompt governance”?</h3>\n<p>System prompts are editable text inside the same channel an attacker can influence, and they do not stop a tool call from happening. Permissioned execution uses a WPC and CST so the runtime can refuse actions, even if the prompt asks for them.</p>\n\n<h3>Where do approvals live in this model?</h3>\n<p>Approvals should gate authority, not conversation. In practice, an approval triggers issuance of a CST (or an upgraded CST) that is scoped to a WPC hash, and tools/providers only accept actions covered by that token.</p>\n\n<h3>How do budgets work today?</h3>\n<p>Automatic cost budget enforcement is planned. Today you can implement budgets operationally by constraining TTL and scope in the CST and WPC, and by applying provider-side usage limits and monitoring on the billing account.</p>\n\n<h3>Can this align with Microsoft Entra ID governance?</h3>\n<p>Yes, as an integration pattern: use Entra ID identities and your existing approval processes (for example via PIM or other governance workflows) to decide when a CST can be issued. The mapping is “human decision in Entra governed workflow” to “token issuance policy,” implemented via official API or enterprise buildout.</p>\n\n<h3>What do I show an auditor after an incident?</h3>\n<p>Provide the proof bundle for the run, including gateway receipts for model calls, the WPC hash reference, and the CST scope hash binding. If you stored the artifact as a Trust Pulse, you can share that viewing record without exposing the runtime.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization\">Governance and security for AI agents across the organization (Microsoft Learn)</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/entra/agent-id/identity-professional/security-for-ai\">Security for AI agents with Microsoft Entra Agent ID (Microsoft Learn)</a></li>\n</ul>",
  "description": "Enterprise agent governance is permissioned execution: every tool call and every model call runs under a machine-enforced policy, with approvals and scope limits that cannot be bypassed by a clever prompt.",
  "faqs": [
    {
      "q": "Why is permissioned execution better than “system prompt governance”?",
      "a": "System prompts are editable text inside the same channel an attacker can influence, and they do not stop a tool call from happening. Permissioned execution uses a WPC and CST so the runtime can refuse actions, even if the prompt asks for them."
    },
    {
      "q": "Where do approvals live in this model?",
      "a": "Approvals should gate authority, not conversation. In practice, an approval triggers issuance of a CST (or an upgraded CST) that is scoped to a WPC hash, and tools/providers only accept actions covered by that token."
    },
    {
      "q": "How do budgets work today?",
      "a": "Automatic cost budget enforcement is planned. Today you can implement budgets operationally by constraining TTL and scope in the CST and WPC, and by applying provider-side usage limits and monitoring on the billing account."
    },
    {
      "q": "Can this align with Microsoft Entra ID governance?",
      "a": "Yes, as an integration pattern: use Entra ID identities and your existing approval processes (for example via PIM or other governance workflows) to decide when a CST can be issued. The mapping is “human decision in Entra governed workflow” to “token issuance policy,” implemented via official API or enterprise buildout."
    },
    {
      "q": "What do I show an auditor after an incident?",
      "a": "Provide the proof bundle for the run, including gateway receipts for model calls, the WPC hash reference, and the CST scope hash binding. If you stored the artifact as a Trust Pulse, you can share that viewing record without exposing the runtime."
    }
  ],
  "sources": [
    {
      "title": "Agent management for enterprises",
      "uri": "https://docs.github.com/en/copilot/concepts/agents/enterprise-management"
    },
    {
      "title": "Governance and security for AI agents across the organization",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization"
    },
    {
      "title": "Microsoft 365 Copilot agents governance visual guide",
      "uri": "https://learn.microsoft.com/en-us/copilot/microsoft-365/agent-essentials/m365-agents-visual-map"
    },
    {
      "title": "Security for AI agents with Microsoft Entra Agent ID",
      "uri": "https://learn.microsoft.com/en-us/entra/agent-id/identity-professional/security-for-ai"
    },
    {
      "title": "Manage Copilot agents in the Microsoft 365 admin center",
      "uri": "https://learn.microsoft.com/en-us/microsoft-365/admin/manage/manage-copilot-agents-integrated-apps?view=o365-worldwide"
    },
    {
      "title": "Microsoft Security Copilot Access Review Agent in Microsoft Entra - Microsoft Entra ID Governance",
      "uri": "https://learn.microsoft.com/en-us/entra/id-governance/access-review-agent"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:44:09.623Z",
  "indexable": true
}