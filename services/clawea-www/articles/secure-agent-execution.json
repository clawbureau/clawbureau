{
  "slug": "secure-agent-execution",
  "title": "Secure Agent Execution (Permissioned Runtime) | Claw EA",
  "category": "pillars",
  "html": "<p>Secure agent execution means the agent can only act through a permissioned runtime that enforces machine-checkable rules, not just “be careful” instructions in a prompt. OpenClaw is a strong baseline agent runtime, and Claw EA layers policy binding, scoped authorization, and verifiable receipts so you can prove what the agent was allowed to do and what it actually did.</p>\n<p>Prompt-only controls fail because an attacker can steer the model around them, or a benign mistake can still trigger an unsafe tool call. A permissioned execution layer uses policy-as-code plus fail-closed verification so the agent cannot exceed the allowed tool surface, token scope, or policy hash.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>Use this runbook when you want enterprise AI agents that can run jobs with auditable boundaries and predictable rollback. The steps assume OpenClaw runs the agent and Claw Bureau primitives provide the enforcement and evidence.</p>\n\n<ol>\n  <li>\n    <p><strong>Start with a minimal OpenClaw tool surface.</strong> Enable sandboxing for tool execution where possible, and explicitly set tool allow and deny rules per agent. Run the built-in OpenClaw security audit regularly, especially after config changes or when exposing new inbound channels.</p>\n  </li>\n  <li>\n    <p><strong>Write a WPC and publish it.</strong> A WPC = Work Policy Contract (signed, hash-addressed policy artifact; served by clawcontrols). Treat the WPC hash as a release artifact: reviewed, change-controlled, and referenced by job configuration.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the job and pin policy if needed.</strong> A CST = scoped token (issued by clawscope). Use a job-scoped CST and, when you need strict change control, pin the policy hash so the runtime fails closed if the policy changes.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy for receipts.</strong> Gateway receipts are signed receipts emitted by clawproxy for model calls, giving you verifiable evidence of what was sent to and returned by the model. If you use OpenRouter via fal, route that traffic through clawproxy so the same receipt mechanism applies.</p>\n  </li>\n  <li>\n    <p><strong>Execute jobs under the permissioned runtime.</strong> Enforce tool policy in OpenClaw (what tools exist) and sandboxing (where tools run), then bind remote calls to the CST and WPC constraints. Avoid “prompt grants” like “you may access production” without a corresponding policy rule and scoped token.</p>\n  </li>\n  <li>\n    <p><strong>Collect a proof bundle and verify it.</strong> A proof bundle is a harness artifact bundling receipts and related metadata for audit/verification. Store the bundle per job and verify it during incident review, vendor review, or deployment promotion gates.</p>\n  </li>\n  <li>\n    <p><strong>Operationalize change and incident controls.</strong> Rotate CST issuance policies, keep WPC changes in a controlled pipeline, and review OpenClaw sandbox and bind mounts as part of every change window. If you need enterprise identity alignment (for example, Entra ID user and app identity), integrate via official API or an MCP server and keep Graph permissions minimal and explicit.</p>\n  </li>\n</ol>\n\n<h2>Threat model</h2>\n<p>Enterprise AI agents fail in predictable ways: prompt injection, excessive tool permissions, leaked tokens, and silent drift in configuration. Secure execution is about forcing those failures to become blocked requests with evidence, not “best effort” behavior.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control (fail-closed when possible)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt injection triggers high-impact tools</td>\n      <td>The model is persuaded to run shell, write files, or call external systems beyond the intended workflow.</td>\n      <td>OpenClaw tool policy allowlists and sandboxing reduce blast radius; WPC defines what is allowed; CST scope constrains what remote services accept even if the model asks.</td>\n    </tr>\n    <tr>\n      <td>Misconfigured inbound access (open rooms, weak auth)</td>\n      <td>Untrusted users can trigger the agent and drive it toward unsafe tool calls or data exposure.</td>\n      <td>Use OpenClaw security audit to catch common footguns; require allowlists and mention gates where appropriate; keep high-risk agents off public channels.</td>\n    </tr>\n    <tr>\n      <td>Token leakage or over-broad scopes</td>\n      <td>A leaked token becomes a standing capability that can be reused to call tools or model providers.</td>\n      <td>Issue job-scoped CST; keep TTL short; use scope hashes and optional policy hash pinning so tokens cannot be reused outside the intended policy context.</td>\n    </tr>\n    <tr>\n      <td>Replay of a prior “approved” job</td>\n      <td>An attacker replays a previously valid request pattern to get the same effect again.</td>\n      <td>Marketplace anti-replay binding (job-scoped CST binding) prevents reuse across jobs; store proof bundles per job so you can detect duplicates and drift.</td>\n    </tr>\n    <tr>\n      <td>Sandbox pierced by unsafe mounts or elevated exec</td>\n      <td>A containerized tool gains host-level control via bind mounts, sensitive directories, or elevated tool escape hatches.</td>\n      <td>Prefer workspaceAccess=none/ro, avoid docker.sock mounts, and tightly gate elevated tools; use OpenClaw “sandbox explain” and configuration reviews to validate effective policy.</td>\n    </tr>\n    <tr>\n      <td>Disputed model calls and “who said what?”</td>\n      <td>You cannot prove what prompt or response led to an action, or whether content was altered in transit.</td>\n      <td>Route model calls via clawproxy to obtain gateway receipts; package them into a proof bundle for later verification and audit.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>A permissioned runtime needs rules the system can enforce without trusting the model’s intentions. In practice, that means a WPC that the runtime can fetch and verify by hash, plus a CST whose scope and optional policy hash pinning match the job.</p>\n\n<p>The snippet below is JSON-like and intentionally compact. It shows a policy that limits tool categories, blocks elevated execution, and requires model calls to be receipted through clawproxy.</p>\n\n<pre>\n{\n  \"wpc_version\": \"v1\",\n  \"policy_hash\": \"b64u:... (hash-addressed)\",\n  \"job\": {\n    \"id\": \"job-2026-02-11-001\",\n    \"anti_replay\": { \"bind_job_scoped_cst\": true }\n  },\n  \"tools\": {\n    \"allow\": [\"read\", \"write:workspace\", \"http:approved_hosts\"],\n    \"deny\": [\"exec\", \"process\", \"docker_socket\", \"browser:host_control\"],\n    \"elevated\": { \"enabled\": false }\n  },\n  \"models\": {\n    \"require_gateway_receipts\": true,\n    \"route_via\": [\"clawproxy\"],\n    \"providers\": [\"openrouter_via_fal\"]\n  },\n  \"tokens\": {\n    \"require_cst\": true,\n    \"cst_scope_hash\": \"b64u:...\",\n    \"pin_wpc_hash\": true\n  }\n}\n</pre>\n\n<h2>What proof do you get?</h2>\n<p>For every model call routed through clawproxy, you get gateway receipts: signed receipts emitted by clawproxy for model calls. These receipts are designed to be verifiable artifacts you can tie back to a job run, the active CST constraints, and the policy hash you intended.</p>\n<p>Claw EA packages receipts and related job metadata into a proof bundle. The proof bundle is what you archive, hand to internal audit, attach to a change ticket, or use in post-incident review to validate what happened without relying on ad hoc logs.</p>\n<p>When you need a durable place to store and view audit artifacts, you can store the result as a Trust Pulse artifact for audit/viewing. Retention is an operational decision: many teams keep proof bundles for the same duration as CI logs for low-risk jobs, and longer for production-impacting automations.</p>\n\n<h2>Rollback posture</h2>\n<p>Rollback for agents is not just “turn it off.” You want a small set of deterministic levers that stop execution safely, prevent repeats, and preserve evidence for triage.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence to capture</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Stop new work immediately</td>\n      <td>Revoke or expire the CST for the job so calls fail closed at the boundary.</td>\n      <td>CST issuance and revocation records; job id and timestamps.</td>\n    </tr>\n    <tr>\n      <td>Freeze permissions at last known-good</td>\n      <td>Pin the policy hash to the previous reviewed WPC and reject runs with newer hashes until reviewed.</td>\n      <td>WPC hash used per job; diff of policy artifacts in your change system.</td>\n    </tr>\n    <tr>\n      <td>Reduce local blast radius</td>\n      <td>Disable elevated tools and tighten OpenClaw tool allowlists and sandbox mounts, then re-run “security audit” and “sandbox explain.”</td>\n      <td>OpenClaw audit output, effective sandbox configuration, and updated tool policy state.</td>\n    </tr>\n    <tr>\n      <td>Dispute or investigate a specific run</td>\n      <td>Quarantine the proof bundle and verify receipts to confirm the exact model calls that occurred.</td>\n      <td>Proof bundle, gateway receipts, and verification results from your review process.</td>\n    </tr>\n    <tr>\n      <td>Prevent replay and “same job again”</td>\n      <td>Require job-scoped CST binding for future runs of that workflow and rotate any long-lived credentials used by tools.</td>\n      <td>Job scoping configuration, rotated secret references, and a record of scope changes.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is prompt-only safety not enough?</h3>\n<p>A prompt is not an enforcement point. If the model is manipulated or simply makes a mistake, it can still call tools unless the runtime blocks the call based on policy-as-code and scoped authorization.</p>\n\n<h3>How do WPC and CST work together in a permissioned runtime?</h3>\n<p>The WPC defines what is allowed in a portable, signed, hash-addressed artifact. The CST is the job’s scoped token, and its scope hash and optional policy hash pinning ensure the job cannot quietly run under different permissions.</p>\n\n<h3>What do gateway receipts cover, and what do they not cover?</h3>\n<p>Gateway receipts cover model calls routed through clawproxy, including verifiable evidence that a specific request and response occurred under the proxy boundary. They do not automatically prove what happened inside third-party systems your tools call, unless those systems provide their own verifiable logs via official API or an MCP server.</p>\n\n<h3>How does this relate to Microsoft enterprise controls like Entra ID and Conditional Access?</h3>\n<p>Use Entra ID for identity, apply least-privilege Microsoft Graph permissions/scopes for any agent-operated app registration, and rely on Conditional Access and PIM to limit standing access. Claw EA focuses on execution constraints and verifiable evidence; identity integration can be implemented via official API as part of an enterprise buildout.</p>\n\n<h3>Can we enforce network egress allowlists and cost budgets?</h3>\n<p>Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are optional or planned capabilities. If you need them now, they can be implemented with existing network controls and job orchestration policies, while still using WPC, CST, receipts, and proof bundles for auditable execution.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (security audit and common footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandboxing.md\">OpenClaw: Sandboxing</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization\">Microsoft Cloud Adoption Framework: Governance and security for AI agents across the organization</a></li>\n  <li><a href=\"https://learn.microsoft.com/en-us/security/security-for-ai/agent-365-security\">Microsoft Learn: Secure AI agents at scale using Microsoft Agent 365</a></li>\n  <li><a href=\"https://aws.amazon.com/blogs/security/the-agentic-ai-security-scoping-matrix-a-framework-for-securing-autonomous-ai-systems/\">AWS Security Blog: The Agentic AI Security Scoping Matrix</a></li>\n</ul>",
  "description": "Secure agent execution means the agent can only act through a permissioned runtime that enforces machine-checkable rules, not just “be careful” instructions in a prompt. OpenClaw is a strong baseline agent runtime, and C",
  "faqs": [
    {
      "q": "Why is prompt-only safety not enough?",
      "a": "A prompt is not an enforcement point. If the model is manipulated or simply makes a mistake, it can still call tools unless the runtime blocks the call based on policy-as-code and scoped authorization."
    },
    {
      "q": "How do WPC and CST work together in a permissioned runtime?",
      "a": "The WPC defines what is allowed in a portable, signed, hash-addressed artifact. The CST is the job’s scoped token, and its scope hash and optional policy hash pinning ensure the job cannot quietly run under different permissions."
    },
    {
      "q": "What do gateway receipts cover, and what do they not cover?",
      "a": "Gateway receipts cover model calls routed through clawproxy, including verifiable evidence that a specific request and response occurred under the proxy boundary. They do not automatically prove what happened inside third-party systems your tools call, unless those systems provide their own verifiable logs via official API or an MCP server."
    },
    {
      "q": "How does this relate to Microsoft enterprise controls like Entra ID and Conditional Access?",
      "a": "Use Entra ID for identity, apply least-privilege Microsoft Graph permissions/scopes for any agent-operated app registration, and rely on Conditional Access and PIM to limit standing access. Claw EA focuses on execution constraints and verifiable evidence; identity integration can be implemented via official API as part of an enterprise buildout."
    },
    {
      "q": "Can we enforce network egress allowlists and cost budgets?",
      "a": "Egress allowlists enforced outside clawproxy and automatic cost budget enforcement are optional or planned capabilities. If you need them now, they can be implemented with existing network controls and job orchestration policies, while still using WPC, CST, receipts, and proof bundles for auditable execution."
    }
  ],
  "sources": [
    {
      "title": "Secure AI agents at scale using Microsoft Agent 365",
      "uri": "https://learn.microsoft.com/en-us/security/security-for-ai/agent-365-security"
    },
    {
      "title": "Governance and security for AI agents across the organization",
      "uri": "https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ai-agents/governance-security-across-organization"
    },
    {
      "title": "Jentic: Enterprise Platform for Safe and Governed AI Agent Execution",
      "uri": "https://aws.amazon.com/marketplace/pp/prodview-x7gvzjtotpbog"
    },
    {
      "title": "The Agentic AI Security Scoping Matrix: A framework for ... - AWS",
      "uri": "https://aws.amazon.com/blogs/security/the-agentic-ai-security-scoping-matrix-a-framework-for-securing-autonomous-ai-systems/"
    },
    {
      "title": "Agent Factory Recap: Securing AI Agents in Production",
      "uri": "https://cloud.google.com/blog/topics/developers-practitioners/agent-factory-recap-securing-ai-agents-in-production"
    },
    {
      "title": "How Agentforce Runs Secure AI Agents at 11 Million Calls Per Day",
      "uri": "https://engineering.salesforce.com/how-agentforce-runs-secure-ai-agents-at-11-million-calls-per-day/"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T10:49:42.413Z",
  "indexable": true
}