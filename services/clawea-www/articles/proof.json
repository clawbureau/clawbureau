{
  "slug": "proof",
  "title": "Proof and Attestation for Agents | Claw EA",
  "category": "hubs",
  "html": "<p>Claw EA gives you verifiable proof about what an agent did by binding execution to a permissioned policy artifact and emitting cryptographic receipts for model calls. Instead of trusting a prompt transcript, you verify a Proof bundle that includes Gateway receipts from clawproxy and policy binding via a WPC and CST.</p>\n<p>OpenClaw is the baseline agent runtime, and Claw EA layers proof and authorization on top so audits can be replayed deterministically. The goal is operational: you can answer who authorized the run, which policy was in force, what model traffic occurred, and whether the same token could be replayed for a different job.</p>\n\n<h2>Step-by-step runbook</h2>\n<p>This runbook is the smallest path to “cryptographic receipts plus proof bundle verification” in an OpenClaw-based deployment. It assumes you already run OpenClaw with a tool policy and sandbox settings appropriate to your environment.</p>\n\n<ol>\n  <li>\n    <p><strong>Define the allowed work as policy-as-code.</strong> Write a WPC that constrains what the agent is allowed to do (tools, models, data handling, and any required human approvals). Prompt instructions are not a control surface because a prompt can be overwritten; the execution layer must be permissioned so the harness can fail closed when constraints are violated.</p>\n  </li>\n  <li>\n    <p><strong>Publish the WPC.</strong> Store the WPC in the WPC registry so it is signed and hash-addressed, and so clients can fetch and verify it consistently. In Claw EA, treat the WPC hash as the stable reference your auditors and incident responders will use.</p>\n  </li>\n  <li>\n    <p><strong>Issue a CST for the job.</strong> Mint a CST (scoped token) from clawscope that is job-scoped and includes a scope hash, with optional policy hash pinning to the WPC you expect. Keep CST TTL short and do not reuse it across environments.</p>\n  </li>\n  <li>\n    <p><strong>Route model calls through clawproxy.</strong> Configure your OpenClaw provider to send model traffic through clawproxy so each model call yields Gateway receipts. If you use OpenRouter via fal, keep it routed through clawproxy so receipt emission stays consistent across providers.</p>\n  </li>\n  <li>\n    <p><strong>Run the agent and capture the Proof bundle.</strong> When the job completes, collect the Proof bundle as the canonical “audit pack” for that run. Treat the bundle as immutable evidence: store it in your artifact system and optionally publish it to Trust Pulse for viewing.</p>\n  </li>\n  <li>\n    <p><strong>Verify before you trust.</strong> Verification should check WPC signature validity, CST scope hash alignment, and the integrity and signature chain of the Gateway receipts inside the Proof bundle. Your pipeline should fail closed: if any binding is missing or mismatched, the run is “unproven” even if logs exist.</p>\n  </li>\n</ol>\n\n<p><strong>How to get started checklist:</strong> pick one agent, one WPC, one job-scoped CST, and require that all model traffic goes through clawproxy. Store every Proof bundle next to the job output, and require verification before downstream systems accept the output (for example, before applying a patch or sending customer email).</p>\n\n<p><strong>Taxonomy of proof and attestation topics:</strong> Gateway receipts (signed per-call evidence), Proof bundles (run-level audit pack), WPC binding (policy identity and constraints), CST binding (who and what is authorized), anti-replay binding (job-scoped CST cannot be reused), verification gates (fail-closed checks before accepting results), Trust Pulse (artifact storage and viewer), and sandbox/tool policy alignment (matching OpenClaw local controls with remote proof expectations).</p>\n\n<h2>Threat model</h2>\n<p>Agent proof fails in predictable ways: missing bindings, token reuse, policy drift, and unproxied model traffic. Treat proof as a security control only when the verification path is automated and blocks unsafe promotion.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Threat</th>\n      <th>What happens</th>\n      <th>Control in Claw EA</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Prompt-only “policy” is bypassed</td>\n      <td>Injection or tool output changes the agent’s instructions and it performs actions outside intent.</td>\n      <td>Use a WPC as policy-as-code and enforce it via verification and token binding, not via prompt text.</td>\n    </tr>\n    <tr>\n      <td>Unproxied model calls</td>\n      <td>Some calls bypass clawproxy so there are no Gateway receipts, leaving gaps in evidence.</td>\n      <td>Route model traffic through clawproxy and verify that receipts cover the required model activity for the job.</td>\n    </tr>\n    <tr>\n      <td>Replay of credentials or job tokens</td>\n      <td>A CST is reused for a different job to “borrow” authorization scope.</td>\n      <td>Marketplace anti-replay binding with job-scoped CST binding, plus short TTL and optional WPC hash pinning.</td>\n    </tr>\n    <tr>\n      <td>Policy drift between run and audit</td>\n      <td>The “current” policy differs from the policy that was in force, so an audit cannot establish what was permitted.</td>\n      <td>WPC is hash-addressed; verification uses the referenced WPC hash, not a mutable policy name.</td>\n    </tr>\n    <tr>\n      <td>Receipt tampering or partial log export</td>\n      <td>Logs are edited to remove risky actions or to fabricate calls.</td>\n      <td>Gateway receipts are signed by clawproxy and bundled into a Proof bundle; verification rejects altered receipts.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Policy-as-code example</h2>\n<p>This is a minimal, JSON-like sketch of what teams typically put into a WPC to make proof meaningful. The exact fields vary by enterprise buildout, but the pattern is stable: bind identity, scope, allowed models, and tool blast radius to a signed, hash-addressed contract.</p>\n\n<pre>\n{\n  \"wpc_version\": \"1\",\n  \"policy_name\": \"agent-prod-change-window\",\n  \"allow\": {\n    \"models\": [\n      { \"provider\": \"openrouter_via_fal\", \"route\": \"via_clawproxy\", \"model\": \"approved-list\" }\n    ],\n    \"tools\": {\n      \"openclaw\": {\n        \"sandbox_mode\": \"all\",\n        \"tool_profile\": \"prod-safe\",\n        \"deny\": [\"exec_elevated\", \"write:/etc/*\", \"network:raw\"]\n      }\n    }\n  },\n  \"require\": {\n    \"cst\": {\n      \"job_scoped\": true,\n      \"scope_hash\": \"required\",\n      \"policy_hash_pinning\": \"optional\"\n    },\n    \"proof\": {\n      \"gateway_receipts\": \"required\",\n      \"proof_bundle\": \"required\"\n    }\n  },\n  \"handling\": {\n    \"logging\": { \"redact_sensitive\": \"tools\" },\n    \"retention_days\": 90\n  }\n}\n</pre>\n\n<p>The key point is that the WPC is not advice to the model. It is an externally verifiable constraint that your execution and verification pipeline can enforce even when the agent is confused, manipulated, or simply wrong.</p>\n\n<h2>What proof do you get?</h2>\n<p>At the call level, you get Gateway receipts emitted by clawproxy for model calls. These receipts let you prove that a specific request and response flowed through the gateway under a specific authorization context, rather than being manually copied into logs after the fact.</p>\n<p>At the run level, you get a Proof bundle that bundles receipts and related metadata for audit and verification. The Proof bundle is designed to be stored alongside job outputs so reviewers can verify: (1) which WPC was in force, (2) that the CST scope hash matches the intended authorization, and (3) that the set of Gateway receipts is intact and signed.</p>\n<p>For sharing and review, you can store and view artifacts in Trust Pulse. Treat Trust Pulse as the place to look at what was proven, while your internal pipeline still performs independent verification before promoting results to production systems.</p>\n\n<h2>Rollback posture</h2>\n<p>Proof helps most when rollback is planned and practiced. Your rollback plan should map actions to safe reversal steps and to the evidence you will require before and after the rollback.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Safe rollback</th>\n      <th>Evidence you should require</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Agent-generated code change</td>\n      <td>Revert commit, re-run tests, and block auto-merge until a verified Proof bundle exists for the change-producing run.</td>\n      <td>Proof bundle with complete Gateway receipts; WPC hash matches the approved change window policy.</td>\n    </tr>\n    <tr>\n      <td>Outbound communication (email, ticket update)</td>\n      <td>Send correction via the official API and disable the tool path until policy review is complete.</td>\n      <td>Proof bundle showing which tool was invoked and under which CST; receipts show the model context used to draft content.</td>\n    </tr>\n    <tr>\n      <td>Credential or secret exposure suspicion</td>\n      <td>Rotate secrets, revoke tokens, and quarantine the agent configuration until verification passes on a clean rerun.</td>\n      <td>WPC confirms redaction expectations; Proof bundle supports incident review of what the model saw and what was emitted.</td>\n    </tr>\n    <tr>\n      <td>Unexpected model provider usage</td>\n      <td>Disable the provider route and re-run with a pinned, approved model route.</td>\n      <td>Gateway receipts show the actual route used (for example, OpenRouter via fal routed through clawproxy) and support drift detection.</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2>FAQ</h2>\n\n<h3>Why is prompt-only governance not sufficient for agent proof?</h3>\n<p>A prompt is mutable at runtime and can be overridden by tool output, user messages, or injection. A WPC is policy-as-code that is signed, hash-addressed, and enforced and verified outside the model, so you can fail closed when constraints are not met.</p>\n\n<h3>What is the difference between Gateway receipts and a Proof bundle?</h3>\n<p>Gateway receipts are per model call and are emitted by clawproxy for verification. A Proof bundle is the run-level harness artifact that packages the receipts and metadata needed to audit and verify the job end to end.</p>\n\n<h3>How do CSTs prevent token reuse across jobs?</h3>\n<p>A CST is issued by clawscope and can be job-scoped with a scope hash, with optional policy hash pinning to a specific WPC. Claw EA also supports marketplace anti-replay binding (job-scoped CST binding) so a token is harder to reuse outside the intended job context.</p>\n\n<h3>Does this replace OpenClaw sandboxing and tool policy?</h3>\n<p>No. OpenClaw sandboxing and tool policy are local safety boundaries, and you should still run <code>openclaw security audit</code> regularly and keep tool allowlists tight.</p>\n\n<h3>What if I need to prove non-model actions like filesystem writes or API calls?</h3>\n<p>Start by proving model traffic with Gateway receipts and Proof bundles, and treat tool execution evidence as an enterprise buildout based on your environment and toolchain. In practice, teams bind “dangerous” side effects to explicit approvals and require proof verification before promotion.</p>\n\n<h2>Sources</h2>\n<ul>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/security/index.md\">OpenClaw Gateway Security (audit + footguns)</a></li>\n  <li><a href=\"https://github.com/openclaw/openclaw/blob/5d4f42016f3afdbd5218843648d3ea594541dedc/docs/gateway/sandbox-vs-tool-policy-vs-elevated.md\">OpenClaw: Sandbox vs Tool Policy vs Elevated</a></li>\n  <li><a href=\"https://cli.github.com/manual/gh_attestation_verify\">GitHub CLI Manual: gh attestation verify</a></li>\n</ul>",
  "description": "Claw EA gives you verifiable proof about what an agent did by binding execution to a permissioned policy artifact and emitting cryptographic receipts for model calls. Instead of trusting a prompt transcript, you verify a",
  "faqs": [
    {
      "q": "Why is prompt-only governance not sufficient for agent proof?",
      "a": "A prompt is mutable at runtime and can be overridden by tool output, user messages, or injection. A WPC is policy-as-code that is signed, hash-addressed, and enforced and verified outside the model, so you can fail closed when constraints are not met."
    },
    {
      "q": "What is the difference between Gateway receipts and a Proof bundle?",
      "a": "Gateway receipts are per model call and are emitted by clawproxy for verification. A Proof bundle is the run-level harness artifact that packages the receipts and metadata needed to audit and verify the job end to end."
    },
    {
      "q": "How do CSTs prevent token reuse across jobs?",
      "a": "A CST is issued by clawscope and can be job-scoped with a scope hash, with optional policy hash pinning to a specific WPC. Claw EA also supports marketplace anti-replay binding (job-scoped CST binding) so a token is harder to reuse outside the intended job context."
    },
    {
      "q": "Does this replace OpenClaw sandboxing and tool policy?",
      "a": "No. OpenClaw sandboxing and tool policy are local safety boundaries, and you should still run openclaw security audit regularly and keep tool allowlists tight."
    },
    {
      "q": "What if I need to prove non-model actions like filesystem writes or API calls?",
      "a": "Start by proving model traffic with Gateway receipts and Proof bundles, and treat tool execution evidence as an enterprise buildout based on your environment and toolchain. In practice, teams bind “dangerous” side effects to explicit approvals and require proof verification before promotion."
    }
  ],
  "sources": [
    {
      "title": "6cc0f4a8240307a7343de5db1260fb36",
      "uri": "https://gist.github.com/martindale/6cc0f4a8240307a7343de5db1260fb36"
    },
    {
      "title": "GitHub CLI",
      "uri": "https://cli.github.com/manual/gh_attestation_verify"
    }
  ],
  "model": "candidate-01",
  "generatedAt": "2026-02-11T11:01:25.208Z",
  "indexable": true
}