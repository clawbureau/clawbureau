/**
 * clawea-www ‚Äî Programmatic SEO site for clawea.com
 *
 * Serves 10k+ pages from R2-stored articles generated by Gemini.
 * Full SEO: JSON-LD, FAQ schema, OG tags, sitemap, robots.txt,
 * internal linking mesh, breadcrumbs, canonical URLs.
 *
 * Routes:
 *   GET /                        ‚Üí homepage
 *
 *   Core permissioned-execution taxonomy:
 *   GET /policy-as-code-for-agents
 *   GET /secure-agent-execution
 *   GET /agent-proof-and-attestation
 *   GET /agent-audit-and-replay
 *   GET /agent-supply-chain-security
 *   GET /event-native-agents
 *   GET /mcp-security
 *
 *   Families:
 *   GET /controls/*              ‚Üí control pages
 *   GET /tools/*                 ‚Üí enterprise tool pages
 *   GET /channels/*              ‚Üí channel control plane pages
 *   GET /workflows/*             ‚Üí workflow recipes (workflow ‚Üí tool ‚Üí channel)
 *   GET /policy/*                ‚Üí policy artifacts and validation
 *   GET /proof/*                 ‚Üí proof pages
 *   GET /verify/*                ‚Üí verification pages
 *   GET /audit/*                 ‚Üí audit/replay pages
 *   GET /mcp/*                   ‚Üí MCP security and server governance
 *   GET /supply-chain/*          ‚Üí extension supply chain security
 *   GET /events/*                ‚Üí event-native trigger patterns
 *   GET /compliance/*            ‚Üí compliance mappings and evidence
 *   GET /guides/*                ‚Üí implementation guides
 *   GET /glossary/*              ‚Üí glossary entries
 *   GET /vs/*, /compare/*, /for/* ‚Üí comparisons and role-based pages
 *
 *   Static pages:
 *   GET /pricing, /contact, /about, /trust, /secure-workers, /consulting
 *
 *   System endpoints:
 *   GET /sitemap.xml, /robots.txt, /health
 *   GET /<INDEXNOW_KEY>.txt
 *   POST /api/indexnow, /api/google-index, /api/index-urls
 *   POST /api/events (public conversion telemetry)
 *   POST /api/events/summary (token-protected weekly summary)
 *
 * Dynamic article routing:
 * - Any non-static route attempts to load articles/<slug>.json from R2.
 */

import { layout } from "./layout";
import {
  faqSchema,
  howToSchema,
  serviceSchema,
  canonical,
  definedTermSchema,
  techArticleSchema,
  productSchema,
  type PageMeta,
} from "./seo";
import { trustPage, secureWorkersPage, consultingPage, aboutPage } from "./pages/static";

interface Env {
  ARTICLES: R2Bucket;
  SITE_URL: string;
  ENVIRONMENT: string;

  // Indexing automation
  INDEXNOW_KEY?: string;
  INDEX_AUTOMATION_TOKEN?: string;
  GOOGLE_INDEXING_SERVICE_ACCOUNT_JSON?: string;
  INDEXNOW_MAX_ATTEMPTS?: string;
  INDEXNOW_RETRY_BASE_MS?: string;
  INDEXNOW_RETRY_MAX_MS?: string;
}

interface Article {
  slug: string;
  title: string;
  category: string;
  html: string;
  description: string;
  faqs: { q: string; a: string }[];
  /** v2 structured how-to support (optional, used when present) */
  howToTitle?: string;
  howToSteps?: Array<{ name: string; text: string }>;
  sources: { title: string; uri: string }[];
  model: string;
  generatedAt: string;
  /** Plan A: only index selected pages initially. */
  indexable?: boolean;
}

interface ManifestEntry {
  title: string;
  category: string;
  description: string;
  indexable?: boolean;
}

interface SearchResult {
  slug: string;
  title: string;
  description: string;
  category: string;
  score: number;
}

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function json(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: { "content-type": "application/json", "access-control-allow-origin": "*" },
  });
}

function html(body: string, status = 200, cacheSeconds = 3600): Response {
  return new Response(body, {
    status,
    headers: {
      "content-type": "text/html;charset=utf-8",
      "cache-control": `public, max-age=${cacheSeconds}, s-maxage=${cacheSeconds * 24}`,
    },
  });
}

function apiHeaders(extra: HeadersInit = {}): Headers {
  const h = new Headers(extra);
  h.set("access-control-allow-origin", "*");
  h.set("access-control-allow-methods", "POST,OPTIONS");
  h.set("access-control-allow-headers", "content-type,authorization");
  h.set("cache-control", "no-store");
  return h;
}

function apiJson(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: apiHeaders({ "content-type": "application/json" }),
  });
}

function apiError(code: string, message: string, status = 400): Response {
  return apiJson({ ok: false, error: { code, message } }, status);
}

function getBearerToken(request: Request): string | null {
  const auth = request.headers.get("authorization") ?? "";
  const m = auth.match(/^Bearer\s+(.+)$/i);
  return m?.[1]?.trim() ?? null;
}

function checkAutomationAuth(request: Request, env: Env): Response | null {
  const secret = env.INDEX_AUTOMATION_TOKEN?.trim();
  if (!secret) {
    return apiError("INDEX_AUTOMATION_NOT_CONFIGURED", "Indexing automation token is not configured", 503);
  }

  const token = getBearerToken(request);
  if (!token || token !== secret) {
    return apiError("UNAUTHORIZED", "Missing or invalid bearer token", 401);
  }

  return null;
}

const INDEXABLE_HOSTS = new Set(["clawea.com", "www.clawea.com"]);

function normalizeIndexingUrl(input: string): string | null {
  try {
    const u = new URL(input);
    if (u.protocol !== "https:") return null;
    const host = u.hostname.toLowerCase();
    if (!INDEXABLE_HOSTS.has(host)) return null;

    u.hash = "";
    return u.toString();
  } catch {
    return null;
  }
}

function normalizeUrlList(input: unknown, maxUrls = 500): { accepted: string[]; rejected: string[] } {
  const accepted: string[] = [];
  const rejected: string[] = [];

  if (!Array.isArray(input)) {
    return { accepted, rejected: ["urls_must_be_array"] };
  }

  for (const raw of input) {
    if (accepted.length >= maxUrls) break;
    if (typeof raw !== "string") {
      rejected.push(String(raw));
      continue;
    }

    const normalized = normalizeIndexingUrl(raw.trim());
    if (!normalized) {
      rejected.push(raw);
      continue;
    }

    if (!accepted.includes(normalized)) accepted.push(normalized);
  }

  return { accepted, rejected };
}

type IndexNowAttempt = {
  attempt: number;
  status: number;
  ok: boolean;
  retryable: boolean;
  waitMs?: number;
};

type IndexNowResult = {
  ok: boolean;
  submitted: number;
  status: number;
  body?: unknown;
  error?: string;
  attempts: number;
  retried: number;
  retryableFailures: number;
  attemptLog: IndexNowAttempt[];
};

const RETRYABLE_HTTP_STATUS = new Set([429, 500, 502, 503, 504]);

function isRetryableStatus(status: number): boolean {
  return RETRYABLE_HTTP_STATUS.has(status);
}

function parseRetryAfterMs(value: string | null): number | null {
  if (!value) return null;

  const asNum = Number(value);
  if (Number.isFinite(asNum) && asNum >= 0) {
    return Math.floor(asNum * 1000);
  }

  const asDate = Date.parse(value);
  if (Number.isNaN(asDate)) return null;

  const delta = asDate - Date.now();
  return delta > 0 ? delta : 0;
}

function backoffMs(attempt: number, baseMs = 900, maxMs = 30000): number {
  const exp = Math.min(maxMs, baseMs * 2 ** Math.max(0, attempt - 1));
  const jitter = Math.floor(exp * 0.2 * Math.random());
  return Math.min(maxMs, exp + jitter);
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function submitIndexNow(urls: string[], env: Env): Promise<IndexNowResult> {
  const key = env.INDEXNOW_KEY?.trim();
  if (!key) {
    return {
      ok: false,
      submitted: 0,
      status: 503,
      error: "INDEXNOW_KEY_NOT_CONFIGURED",
      attempts: 0,
      retried: 0,
      retryableFailures: 0,
      attemptLog: [],
    };
  }

  const maxAttempts = Math.max(1, Number(env.INDEXNOW_MAX_ATTEMPTS ?? "4"));
  const baseBackoffMs = Math.max(250, Number(env.INDEXNOW_RETRY_BASE_MS ?? "900"));
  const maxBackoffMs = Math.max(baseBackoffMs, Number(env.INDEXNOW_RETRY_MAX_MS ?? "30000"));

  const payload = {
    host: "clawea.com",
    key,
    keyLocation: `https://clawea.com/${key}.txt`,
    urlList: urls,
  };

  const attemptLog: IndexNowAttempt[] = [];
  let retried = 0;
  let retryableFailures = 0;
  let lastBody: unknown = null;
  let lastStatus = 502;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const res = await fetch("https://api.indexnow.org/IndexNow", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(payload),
      });

      const raw = await res.text();
      let parsed: unknown = raw;
      try {
        parsed = raw ? JSON.parse(raw) : null;
      } catch {
        // keep raw text body
      }

      const retryable = isRetryableStatus(res.status);
      const nextAllowed = attempt < maxAttempts && retryable;

      let waitMs: number | undefined;
      if (nextAllowed) {
        const retryAfterMs = parseRetryAfterMs(res.headers.get("retry-after"));
        waitMs = retryAfterMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs);
      }

      attemptLog.push({
        attempt,
        status: res.status,
        ok: res.ok,
        retryable,
        waitMs,
      });

      lastBody = parsed;
      lastStatus = res.status;

      if (res.ok) {
        return {
          ok: true,
          submitted: urls.length,
          status: res.status,
          body: parsed,
          attempts: attempt,
          retried,
          retryableFailures,
          attemptLog,
        };
      }

      if (!nextAllowed) {
        return {
          ok: false,
          submitted: 0,
          status: res.status,
          body: parsed,
          error: "INDEXNOW_REQUEST_FAILED",
          attempts: attempt,
          retried,
          retryableFailures,
          attemptLog,
        };
      }

      retryableFailures += 1;
      retried += 1;
      await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
    } catch (err: any) {
      const nextAllowed = attempt < maxAttempts;
      const waitMs = nextAllowed ? backoffMs(attempt, baseBackoffMs, maxBackoffMs) : undefined;

      attemptLog.push({
        attempt,
        status: 0,
        ok: false,
        retryable: nextAllowed,
        waitMs,
      });

      lastBody = { message: String(err?.message ?? err) };
      lastStatus = 502;

      if (!nextAllowed) {
        return {
          ok: false,
          submitted: 0,
          status: 502,
          body: lastBody,
          error: "INDEXNOW_FETCH_FAILED",
          attempts: attempt,
          retried,
          retryableFailures,
          attemptLog,
        };
      }

      retryableFailures += 1;
      retried += 1;
      await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
    }
  }

  return {
    ok: false,
    submitted: 0,
    status: lastStatus,
    body: lastBody,
    error: "INDEXNOW_REQUEST_FAILED",
    attempts: attemptLog.length,
    retried,
    retryableFailures,
    attemptLog,
  };
}

type GoogleServiceAccount = {
  client_email: string;
  private_key: string;
  token_uri?: string;
};

type GoogleIndexResult = {
  ok: boolean;
  submitted: number;
  failed: number;
  status: number;
  details: Array<{ url: string; ok: boolean; status: number; body?: unknown }>;
  error?: string;
};

function b64Url(input: string | Uint8Array): string {
  const str =
    typeof input === "string"
      ? input
      : String.fromCharCode(...input);
  return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function pemToPkcs8Bytes(pem: string): Uint8Array {
  const b64 = pem
    .replace(/-----BEGIN PRIVATE KEY-----/g, "")
    .replace(/-----END PRIVATE KEY-----/g, "")
    .replace(/\s+/g, "");

  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
  return out;
}

async function buildGoogleAccessToken(env: Env): Promise<string> {
  const raw = env.GOOGLE_INDEXING_SERVICE_ACCOUNT_JSON?.trim();
  if (!raw) {
    throw new Error("GOOGLE_INDEXING_NOT_CONFIGURED");
  }

  let sa: GoogleServiceAccount;
  try {
    sa = JSON.parse(raw) as GoogleServiceAccount;
  } catch {
    throw new Error("GOOGLE_INDEXING_SERVICE_ACCOUNT_INVALID_JSON");
  }

  if (!sa.client_email || !sa.private_key) {
    throw new Error("GOOGLE_INDEXING_SERVICE_ACCOUNT_FIELDS_MISSING");
  }

  const tokenUri = sa.token_uri ?? "https://oauth2.googleapis.com/token";
  const iat = Math.floor(Date.now() / 1000);
  const exp = iat + 3600;

  const header = { alg: "RS256", typ: "JWT" };
  const claim = {
    iss: sa.client_email,
    scope: "https://www.googleapis.com/auth/indexing",
    aud: tokenUri,
    iat,
    exp,
  };

  const encodedHeader = b64Url(JSON.stringify(header));
  const encodedClaim = b64Url(JSON.stringify(claim));
  const signingInput = `${encodedHeader}.${encodedClaim}`;

  const key = await crypto.subtle.importKey(
    "pkcs8",
    pemToPkcs8Bytes(sa.private_key),
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"],
  );

  const sig = await crypto.subtle.sign(
    { name: "RSASSA-PKCS1-v1_5" },
    key,
    new TextEncoder().encode(signingInput),
  );

  const jwt = `${signingInput}.${b64Url(new Uint8Array(sig))}`;

  const tokenRes = await fetch(tokenUri, {
    method: "POST",
    headers: { "content-type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: jwt,
    }).toString(),
  });

  if (!tokenRes.ok) {
    const errBody = await tokenRes.text();
    throw new Error(`GOOGLE_OAUTH_FAILED:${tokenRes.status}:${errBody.slice(0, 400)}`);
  }

  const tokenJson = await tokenRes.json<any>();
  const accessToken = tokenJson?.access_token;
  if (!accessToken || typeof accessToken !== "string") {
    throw new Error("GOOGLE_OAUTH_NO_ACCESS_TOKEN");
  }

  return accessToken;
}

async function submitGoogleIndexing(
  urls: string[],
  action: "URL_UPDATED" | "URL_DELETED",
  env: Env,
): Promise<GoogleIndexResult> {
  try {
    const accessToken = await buildGoogleAccessToken(env);

    const details: GoogleIndexResult["details"] = [];
    let submitted = 0;
    let failed = 0;

    for (const url of urls) {
      const res = await fetch("https://indexing.googleapis.com/v3/urlNotifications:publish", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          authorization: `Bearer ${accessToken}`,
        },
        body: JSON.stringify({
          url,
          type: action,
        }),
      });

      const raw = await res.text();
      let parsed: unknown = raw;
      try {
        parsed = raw ? JSON.parse(raw) : null;
      } catch {
        // leave as text
      }

      const ok = res.ok;
      if (ok) submitted += 1;
      else failed += 1;

      details.push({ url, ok, status: res.status, body: parsed });
    }

    return {
      ok: failed === 0,
      submitted,
      failed,
      status: failed === 0 ? 200 : 207,
      details,
    };
  } catch (err: any) {
    return {
      ok: false,
      submitted: 0,
      failed: urls.length,
      status: 503,
      details: [],
      error: String(err?.message ?? err),
    };
  }
}

async function loadArticle(env: Env, slug: string): Promise<Article | null> {
  const key = `articles/${slug}.json`;
  const obj = await env.ARTICLES.get(key);
  if (!obj) return null;
  const data = await obj.json<Article>();
  if ((data as any).error) return null;
  return data;
}

async function loadManifest(env: Env): Promise<Record<string, ManifestEntry>> {
  const obj = await env.ARTICLES.get("articles/_manifest.json");
  if (!obj) return {};
  try {
    const parsed = await obj.json<Record<string, ManifestEntry>>();
    return parsed && typeof parsed === "object" ? parsed : {};
  } catch {
    return {};
  }
}

function slugFromPath(pathname: string): string {
  return pathname.replace(/^\//, "").replace(/\/$/, "");
}

function normalizeSearchQuery(raw: string | null): string {
  return (raw ?? "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, " ")
    .slice(0, 120);
}

function searchManifest(manifest: Record<string, ManifestEntry>, query: string, limit = 30): SearchResult[] {
  if (!query) return [];
  const tokens = [...new Set(query.split(/[^a-z0-9]+/g).filter((t) => t.length >= 2))];
  const out: SearchResult[] = [];

  for (const [slug, entry] of Object.entries(manifest)) {
    if (!entry || typeof entry.title !== "string") continue;

    const title = entry.title.toLowerCase();
    const desc = (entry.description ?? "").toLowerCase();
    const slugText = slug.toLowerCase().replace(/\//g, " ");

    let score = 0;
    if (title.includes(query)) score += 120;
    if (slugText.includes(query)) score += 90;
    if (desc.includes(query)) score += 45;

    for (const t of tokens) {
      if (title.startsWith(t)) score += 25;
      if (title.includes(t)) score += 18;
      if (slugText.includes(t)) score += 15;
      if (desc.includes(t)) score += 8;
    }

    if (entry.indexable === true) score += 8;
    if (score <= 0) continue;

    out.push({
      slug,
      title: entry.title,
      description: entry.description,
      category: entry.category,
      score,
    });
  }

  return out
    .sort((a, b) => (b.score - a.score) || a.slug.localeCompare(b.slug, "en"))
    .slice(0, limit);
}

function previewText(input: string, max = 220): string {
  const cleaned = input.replace(/\s+/g, " ").trim();
  if (cleaned.length <= max) return cleaned;
  return `${cleaned.slice(0, max - 1)}‚Ä¶`;
}

function glossarySearchPage(query: string, results: SearchResult[]): string {
  const q = query.trim();
  const hasResults = results.length > 0;
  const body = hasResults
    ? `<div class="search-results">${results
        .map(
          (r) => `<a class="search-result-card" href="/${r.slug}">
            <div class="search-result-meta">
              <span class="badge badge-blue">${esc(r.category.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase()))}</span>
              <span class="search-pill">/${esc(r.slug)}</span>
            </div>
            <div class="search-result-title">${esc(r.title.replace(/ \| Claw EA$/, ""))}</div>
            <p class="search-result-desc">${esc(previewText(r.description, 240))}</p>
          </a>`,
        )
        .join("")}</div>`
    : `<div class="search-empty">
        No exact matches for <strong>${esc(q)}</strong>. Try a tool name (e.g. <em>Okta</em>), a control (e.g. <em>DLP</em>), or a workflow phrase (e.g. <em>approval gate</em>).
      </div>`;

  return layout({
    meta: {
      title: `Search: ${q} | Claw EA`,
      description: `Search Claw EA policy, workflow, tool, and glossary content for ‚Äú${q}‚Äù.`,
      path: "/glossary",
      canonicalPath: "/glossary",
      noindex: true,
      ogImageAlt: `Search results for ${q}`,
    },
    breadcrumbs: [
      { name: "Home", path: "/" },
      { name: "Glossary", path: "/glossary" },
      { name: `Search: ${q}`, path: "/glossary" },
    ],
    body: `
    <section class="section content-page">
      <div class="wrap">
        <h1>Search results</h1>
        <p class="search-summary">
          <span class="search-pill">Query: ${esc(q)}</span>
          <span>${results.length} result${results.length === 1 ? "" : "s"}</span>
        </p>
        <form class="card" role="search" action="/glossary" method="get" style="max-width:780px;padding:1rem 1.2rem;display:flex;gap:.6rem;align-items:center;flex-wrap:wrap">
          <label for="glossary-search-input" class="sr-only">Refine search query</label>
          <input id="glossary-search-input" type="search" name="q" value="${esc(q)}" placeholder="Search controls, workflows, tools..." style="flex:1;min-width:200px;border:1px solid var(--border);background:var(--surface-2);color:var(--text);padding:.6rem .75rem;border-radius:.6rem">
          <button type="submit" class="cta-btn" data-cta="glossary-search-submit">Search</button>
        </form>
        ${body}
      </div>
    </section>`,
  });
}

type TrackingEventType =
  | "cta_click"
  | "contact_intent_view"
  | "contact_email_click"
  | "contact_intent_submit";

type TrackingEvent = {
  eventType: TrackingEventType;
  page: string;
  href?: string;
  ctaId?: string;
  ts: string;
  source: string;
  attribution: Record<string, string>;
  context: {
    referrer?: string;
    country?: string;
    userAgent?: string;
    ipClassC?: string;
  };
};

const TRACKING_EVENT_TYPES = new Set<TrackingEventType>([
  "cta_click",
  "contact_intent_view",
  "contact_email_click",
  "contact_intent_submit",
]);

function clipString(input: unknown, maxLen: number): string | undefined {
  if (typeof input !== "string") return undefined;
  const v = input.trim();
  if (!v) return undefined;
  return v.slice(0, maxLen);
}

function normalizeAttribution(input: unknown): Record<string, string> {
  const src = typeof input === "object" && input !== null ? (input as Record<string, unknown>) : {};

  const allowedKeys = [
    "utm_source",
    "utm_medium",
    "utm_campaign",
    "utm_term",
    "utm_content",
    "gclid",
    "fbclid",
    "msclkid",
    "referrer_host",
    "landing_path",
    "source",
  ];

  const out: Record<string, string> = {};
  for (const key of allowedKeys) {
    const v = clipString(src[key], 160);
    if (v) out[key] = v;
  }

  return out;
}

function deriveSource(attribution: Record<string, string>): string {
  if (attribution.source) return attribution.source;
  if (attribution.utm_source) return `utm:${attribution.utm_source}`;
  if (attribution.referrer_host) return `ref:${attribution.referrer_host}`;
  return "direct";
}

function anonymizeIpClassC(ip: string | null): string | undefined {
  if (!ip) return undefined;
  const m = ip.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/);
  if (!m) return undefined;
  return `${m[1]}.${m[2]}.${m[3]}.x`;
}

async function ingestTrackingEvent(request: Request, env: Env): Promise<Response> {
  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  let body: any;
  try {
    body = await request.json<any>();
  } catch {
    return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
  }

  const eventTypeRaw = clipString(body?.eventType, 64);
  const eventType = eventTypeRaw && TRACKING_EVENT_TYPES.has(eventTypeRaw as TrackingEventType)
    ? (eventTypeRaw as TrackingEventType)
    : null;

  if (!eventType) {
    return apiError("EVENT_TYPE_INVALID", "eventType is missing or not allowed", 400);
  }

  const page = clipString(body?.page, 240) ?? "/";
  const ts = clipString(body?.ts, 80) ?? new Date().toISOString();
  const parsedTs = Number.isNaN(Date.parse(ts)) ? new Date().toISOString() : ts;

  const attribution = normalizeAttribution(body?.attribution);

  const event: TrackingEvent = {
    eventType,
    page,
    href: clipString(body?.href, 500),
    ctaId: clipString(body?.ctaId, 160),
    ts: parsedTs,
    source: deriveSource(attribution),
    attribution,
    context: {
      referrer: clipString(request.headers.get("referer"), 500),
      country: clipString(request.headers.get("cf-ipcountry"), 8),
      userAgent: clipString(request.headers.get("user-agent"), 180),
      ipClassC: anonymizeIpClassC(request.headers.get("cf-connecting-ip")),
    },
  };

  const day = event.ts.slice(0, 10);
  const random = typeof crypto.randomUUID === "function"
    ? crypto.randomUUID().slice(0, 8)
    : Math.random().toString(36).slice(2, 10);
  const key = `events/${day}/${event.ts.replace(/[:.]/g, "-")}-${random}.json`;

  await env.ARTICLES.put(key, JSON.stringify(event), {
    httpMetadata: { contentType: "application/json" },
  });

  return apiJson({ ok: true, eventId: key });
}

async function listTrackingEvents(env: Env, sinceMs: number): Promise<TrackingEvent[]> {
  const out: TrackingEvent[] = [];
  let cursor: string | undefined;

  while (true) {
    const listed = await env.ARTICLES.list({
      prefix: "events/",
      cursor,
      limit: 1000,
    });

    for (const obj of listed.objects) {
      const file = await env.ARTICLES.get(obj.key);
      if (!file) continue;

      try {
        const ev = await file.json<TrackingEvent>();
        const tsMs = Date.parse(ev.ts);
        if (Number.isNaN(tsMs) || tsMs < sinceMs) continue;
        if (!TRACKING_EVENT_TYPES.has(ev.eventType)) continue;
        out.push(ev);
      } catch {
        // ignore malformed rows
      }
    }

    if (!listed.truncated || !listed.cursor) break;
    cursor = listed.cursor;
  }

  return out;
}

function topCounts(map: Map<string, number>, limit = 10): Array<{ key: string; count: number }> {
  return [...map.entries()]
    .sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0], "en"))
    .slice(0, limit)
    .map(([key, count]) => ({ key, count }));
}

async function summarizeTrackingEvents(request: Request, env: Env): Promise<Response> {
  const authError = checkAutomationAuth(request, env);
  if (authError) return authError;

  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  let body: any = {};
  try {
    body = await request.json<any>();
  } catch {
    // allow empty JSON body
  }

  const daysRaw = Number(body?.days ?? 7);
  const days = Number.isFinite(daysRaw) ? Math.min(56, Math.max(1, Math.floor(daysRaw))) : 7;

  const sinceMs = Date.now() - (days * 24 * 60 * 60 * 1000);
  const events = await listTrackingEvents(env, sinceMs);

  const byType = new Map<string, number>();
  const bySource = new Map<string, number>();
  const byPage = new Map<string, number>();
  const byCta = new Map<string, number>();

  let contactIntentViews = 0;
  let contactIntentActions = 0;

  for (const ev of events) {
    byType.set(ev.eventType, (byType.get(ev.eventType) ?? 0) + 1);
    bySource.set(ev.source, (bySource.get(ev.source) ?? 0) + 1);
    byPage.set(ev.page, (byPage.get(ev.page) ?? 0) + 1);

    const ctaKey = ev.ctaId ?? ev.href ?? "unknown";
    if (ev.eventType === "cta_click" || ev.eventType === "contact_email_click") {
      byCta.set(ctaKey, (byCta.get(ctaKey) ?? 0) + 1);
    }

    if (ev.eventType === "contact_intent_view") contactIntentViews += 1;
    if (ev.eventType === "contact_email_click" || ev.eventType === "contact_intent_submit") {
      contactIntentActions += 1;
    }
  }

  const intentToActionRate = contactIntentViews > 0
    ? Number((contactIntentActions / contactIntentViews).toFixed(4))
    : 0;

  return apiJson({
    ok: true,
    days,
    generatedAt: new Date().toISOString(),
    totals: {
      events: events.length,
      contactIntentViews,
      contactIntentActions,
      intentToActionRate,
    },
    breakdown: {
      byType: topCounts(byType, 20),
      bySource: topCounts(bySource, 20),
      topPages: topCounts(byPage, 20),
      topCtas: topCounts(byCta, 20),
    },
  });
}

function breadcrumbsFromSlug(slug: string): { name: string; path: string }[] {
  const parts = slug.split("/");
  const crumbs = [{ name: "Home", path: "/" }];

  const labels: Record<string, string> = {
    // v2 taxonomy
    controls: "Controls",
    policy: "Policy",
    proof: "Proof",
    verify: "Verify",
    audit: "Audit",
    channels: "Channels",
    tools: "Tools",
    workflows: "Workflows",
    events: "Events",
    mcp: "MCP",
    "supply-chain": "Supply Chain",
    compliance: "Compliance",
    guides: "Guides",
    glossary: "Glossary",
    compare: "Compare",
    vs: "Vs",
    for: "For",

    // legacy (if old slugs exist in R2)
    deploy: "Deploy",
    integrations: "Integrations",
    "use-cases": "Use Cases",
    models: "Models",
    solutions: "Solutions",
    connect: "Connect",
    enterprise: "Enterprise",
  };

  let accum = "";
  for (const part of parts) {
    accum += "/" + part;
    crumbs.push({
      name: labels[part] ?? part.split("-").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(" "),
      path: accum,
    });
  }

  return crumbs;
}

// ‚îÄ‚îÄ Static Pages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function homePage(): string {
  return layout({
    meta: {
      title: "Claw EA | Enterprise AI Agents, Deployed and Verified",
      description: "Deploy managed AI agents for your enterprise. Every action cryptographically attested. Every model call receipted. Every output verifiable. Reliable, performant, scalable, flexible, secure.",
      path: "/",
    },
    body: `
    <section class="hero">
      <div class="wrap">
        <span class="badge badge-blue">Enterprise AI Infrastructure</span>
        <h1>AI Agents That Your Enterprise Can Actually Trust</h1>
        <p class="sub">Deploy verified AI agents across Slack, Teams, Discord, and 20+ channels. Every action attested. Every model call receipted. No vendor lock-in. Works with Claude, GPT, Gemini, Llama, and any model you choose.</p>
        <div class="actions">
          <a href="/contact" class="cta-btn cta-btn-lg">Talk to Sales</a>
          <a href="/pricing" class="cta-btn cta-btn-outline cta-btn-lg">View Plans</a>
        </div>
      </div>
    </section>

    <section class="section-sm" style="border-bottom:1px solid var(--border)">
      <div class="wrap stats">
        <div class="stat"><div class="num">20+</div><div class="label">Channel Integrations</div></div>
        <div class="stat"><div class="num">12+</div><div class="label">AI Models Supported</div></div>
        <div class="stat"><div class="num">100%</div><div class="label">Action Attestation</div></div>
        <div class="stat"><div class="num">&lt;200ms</div><div class="label">Receipt Overhead</div></div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Why Claw EA</span>
          <h2>Six Pillars of Enterprise AI Done Right</h2>
          <p>Built on OpenClaw, hardened for enterprise. Every design decision optimizes for these six properties.</p>
        </div>
        <div class="grid-3">
          <div class="card">
            <div class="icon">üõ°Ô∏è</div>
            <h3>Secure by Architecture</h3>
            <p>Hardware-isolated Cloudflare Sandboxes. Per-agent DID identities. Work Policy Contracts enforce egress, DLP, and approval gates before any agent runs.</p>
          </div>
          <div class="card">
            <div class="icon">‚ö°</div>
            <h3>Performant at the Edge</h3>
            <p>Cloudflare's global edge network. Smart model routing. Sleep/wake cycles that cut costs without sacrificing response time. Sub-200ms receipt overhead.</p>
          </div>
          <div class="card">
            <div class="icon">üìà</div>
            <h3>Scales to Thousands</h3>
            <p>Up to 9,999 agents per tenant. Multi-tenant isolation at the infrastructure level. Budget controls per agent, team, or org. Fleet management dashboard.</p>
          </div>
          <div class="card">
            <div class="icon">üîÑ</div>
            <h3>No Model Lock-in</h3>
            <p>Claude, GPT, Gemini, Llama, Mistral, DeepSeek, Qwen. Any model, any provider. BYOK (Bring Your Own Key) or managed. Switch models without code changes.</p>
          </div>
          <div class="card">
            <div class="icon">‚úÖ</div>
            <h3>Reliable Operations</h3>
            <p>Auto-restart on failure. Health checks every 5 minutes. Persistent R2 state survives sleep/wake. Cron-based monitoring with configurable retry limits.</p>
          </div>
          <div class="card">
            <div class="icon">üìã</div>
            <h3>Audit-Ready by Default</h3>
            <p>Cryptographic proof bundles for every run. Tamper-evident audit logs. SOC 2, HIPAA, GDPR, FedRAMP compatible. Export to any SIEM.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="section" style="background:var(--bg-alt)">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Permissioned Execution</span>
          <h2>Controls That Make Agents Safe to Run</h2>
          <p>Agents get cheap. Risk gets expensive. Claw EA is built around enforceable policy-as-code controls that prevent exfiltration and force approvals for irreversible actions.</p>
        </div>
        <div class="grid-4">
          ${[
            ["Egress Allowlist", "/controls/egress-allowlist", "Only approved domains and IPs."],
            ["DLP Redaction", "/controls/dlp-redaction", "Redact before data leaves the boundary."],
            ["Approval Gates", "/controls/approval-gates", "Step-up approvals for high-risk steps."],
            ["Two-person Rule", "/controls/two-person-rule", "Require two humans for irreversible actions."],
            ["Budgets", "/controls/budgets", "Token and cost budgets per workflow."],
            ["File Path Scopes", "/controls/file-path-scopes", "Restrict what can be read or written."],
            ["Kill Switch", "/controls/kill-switch", "Stop execution when policy is violated."],
            ["MCP Security", "/mcp/security-best-practices", "Use MCP without turning tools into exfiltration."],
          ]
            .map(([name, href, desc]) => `<a href="${href}" class="card card-link"><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Channels + Tools</span>
          <h2>Chat Control Plane Plus Enterprise Systems</h2>
          <p>Run agents where your team already works, and connect them to enterprise tools under strict policy and proof.</p>
        </div>
        <div class="grid-4">
          ${[
            ["Microsoft Teams", "/channels/microsoft-teams", "üü¶", "Approvals and control sessions."],
            ["Slack", "/channels/slack", "üí¨", "Fast control plane for teams."],
            ["Email", "/channels/email", "üìß", "High-risk outbound, policy-first."],
            ["Google Chat", "/channels/google-chat", "üü©", "Workspace-native control plane."],
            ["Entra ID", "/tools/entra-id", "üîê", "Identity and step-up approvals."],
            ["SharePoint", "/tools/sharepoint", "üìÑ", "Scoped document access."],
            ["GitHub", "/tools/github", "üêô", "Code changes with policy and proof."],
            ["Jira", "/tools/jira", "üìã", "Change control and ticket workflows."],
          ]
            .map(([name, href, icon, desc]) => `<a href="${href}" class="card card-link"><div class="icon">${icon}</div><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
        <p style="text-align:center;margin-top:2rem">
          <a href="/channels" style="color:var(--text-muted)">Browse channels</a>
          <span style="color:var(--text-muted)"> ¬∑ </span>
          <a href="/tools" style="color:var(--text-muted)">Browse tools</a>
        </p>
      </div>
    </section>

    <section class="section" style="background:var(--bg-alt)">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Pillars</span>
          <h2>Policy, Proof, and Supply Chain</h2>
          <p>Claw EA is built for permissioned execution you can audit, not generic "AI agents".</p>
        </div>
        <div class="grid-2">
          ${[
            ["Policy-as-Code", "/policy-as-code-for-agents", "Define what agents may do before they run."],
            ["Secure Execution", "/secure-agent-execution", "Sandboxing, tool policy, and secrets boundaries."],
            ["Proof and Attestation", "/agent-proof-and-attestation", "Receipts and proof bundles you can verify."],
            ["Audit and Replay", "/agent-audit-and-replay", "Evidence retention and replay posture."],
            ["Supply Chain Security", "/agent-supply-chain-security", "Signed skills and governance for extensions."],
            ["Event-native Agents", "/event-native-agents", "Webhooks and changefeeds, paired with policy."],
          ]
            .map(([name, href, desc]) => `<a href="${href}" class="card card-link"><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="cta-banner">
          <h2>Deploy Your First Enterprise AI Agent Today</h2>
          <p>Get a verified, attested AI agent running for your team in minutes. Start with Starter tier, scale to Enterprise.</p>
          <a href="/contact" class="cta-btn cta-btn-lg">Talk to Sales</a>
          <a href="/guides/first-30-days" class="cta-btn cta-btn-outline cta-btn-lg" style="margin-left:.75rem">Read the Guide</a>
        </div>
      </div>
    </section>`,
    schemas: [
      serviceSchema(
        "Claw EA - Enterprise AI Agent Platform",
        "Deploy managed, verified AI agents for enterprise. Cryptographic attestation, multi-model support, 20+ channel integrations.",
        "https://www.clawea.com",
      ),
    ],
  });
}

function pricingPage(): string {
  return layout({
    meta: {
      title: "Pricing | Claw EA Enterprise AI Agents",
      description: "Transparent pricing for enterprise AI agent infrastructure. Start free, scale to thousands. Starter, Team, Business, and Enterprise tiers.",
      path: "/pricing",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Pricing", path: "/pricing" }],
    body: `
    <section class="section content-page">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Pricing</span>
          <h2>Start Small, Scale Without Limits</h2>
          <p>Every tier includes full execution attestation, proof bundles, and audit logs.</p>
        </div>
        <div class="grid-4">
          <div class="price-card">
            <div class="tier">Starter</div>
            <div class="amount">$49</div>
            <div class="period">per month</div>
            <ul>
              <li>1 AI agent</li>
              <li>5 skills per agent</li>
              <li>All channels supported</li>
              <li>All models (BYOK)</li>
              <li>Execution attestation</li>
              <li>90-day audit log retention</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card">
            <div class="tier">Team</div>
            <div class="amount">$249</div>
            <div class="period">per month</div>
            <ul>
              <li>5 AI agents</li>
              <li>15 skills per agent</li>
              <li>All channels supported</li>
              <li>Model routing + failover</li>
              <li>Work Policy Contracts</li>
              <li>1-year audit log retention</li>
              <li>Budget controls</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card featured">
            <div class="tier" style="color:var(--accent)">Business</div>
            <div class="amount">$999</div>
            <div class="period">per month</div>
            <ul>
              <li>25 AI agents</li>
              <li>50 skills per agent</li>
              <li>Fleet management dashboard</li>
              <li>Multi-agent orchestration</li>
              <li>Custom agent templates</li>
              <li>3-year audit log retention</li>
              <li>SIEM integration</li>
              <li>Priority support</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card">
            <div class="tier">Enterprise</div>
            <div class="amount">Custom</div>
            <div class="period">contact sales</div>
            <ul>
              <li>Unlimited agents</li>
              <li>Unlimited skills</li>
              <li>Custom container limits</li>
              <li>Custom compliance mapping</li>
              <li>Dedicated support engineer</li>
              <li>7-year audit log retention</li>
              <li>BAA / DPA available</li>
              <li>On-prem option</li>
            </ul>
            <a href="/contact" class="cta-btn">Talk to Sales</a>
          </div>
        </div>
      </div>
    </section>`,
    schemas: [
      productSchema("Claw EA", "Enterprise AI Agent Platform", "https://www.clawea.com/pricing", [
        { price: "49", priceCurrency: "USD" },
        { price: "249", priceCurrency: "USD" },
        { price: "999", priceCurrency: "USD" },
      ]),
    ],
  });
}

function contactPage(): string {
  return layout({
    meta: {
      title: "Contact Sales | Claw EA Enterprise AI Agents",
      description: "Talk to our enterprise sales team about deploying verified AI agents for your organization.",
      path: "/contact",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Contact", path: "/contact" }],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:600px">
        <h1>Talk to Sales</h1>
        <p class="lead">Tell us about your AI agent needs. We typically respond within 4 hours during business days.</p>
        <div class="card" style="margin-top:2rem">
          <p style="text-align:center;padding:2rem">
            <strong>Email:</strong> <a href="mailto:enterprise@clawbureau.com">enterprise@clawbureau.com</a><br><br>
            <strong>Subject line:</strong> Claw EA inquiry from [Your Company]<br><br>
            Include: industry, team size, primary use case, and timeline.
          </p>
        </div>
      </div>
    </section>`,
  });
}

function notFoundPage(): string {
  return layout({
    meta: { title: "Page Not Found | Claw EA", description: "The page you're looking for doesn't exist.", path: "/404", noindex: true },
    body: `
    <section class="section content-page" style="text-align:center">
      <div class="wrap">
        <h1>404 - Page Not Found</h1>
        <p class="lead">The page you're looking for doesn't exist or has been moved.</p>
        <a href="/" class="cta-btn cta-btn-lg" style="margin-top:2rem">Back to Home</a>
      </div>
    </section>`,
  });
}

// ‚îÄ‚îÄ Article Page Renderer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function formatDateYmd(iso: string): string {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return iso;
  return d.toISOString().slice(0, 10);
}

function estimateReadMinutes(rawHtml: string, wordsPerMinute = 220): number {
  const words = rawHtml
    .replace(/<[^>]+>/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .split(" ")
    .filter(Boolean).length;

  if (words <= 0) return 1;
  return Math.max(1, Math.round(words / wordsPerMinute));
}

function toTitle(s: string): string {
  return s
    .split("-")
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(" ");
}

function uniqueLinks(items: Array<{ name: string; path: string }>): Array<{ name: string; path: string }> {
  const out: Array<{ name: string; path: string }> = [];
  const seen = new Set<string>();
  for (const i of items) {
    if (!i?.path || seen.has(i.path)) continue;
    seen.add(i.path);
    out.push(i);
  }
  return out;
}

function relatedLinksForArticle(article: Article): Array<{ name: string; path: string }> {
  const slugParts = article.slug.split("/").filter(Boolean);
  const family = slugParts[0] ?? "";

  const links: Array<{ name: string; path: string }> = [
    { name: "Policy-as-Code", path: "/policy-as-code-for-agents" },
    { name: "Secure Execution", path: "/secure-agent-execution" },
    { name: "Proof and Attestation", path: "/agent-proof-and-attestation" },
  ];

  if (family) {
    links.push({ name: `${toTitle(family)} hub`, path: `/${family}` });
  }

  // Family-specific helpers
  if (family === "workflows") {
    const toolSlug = slugParts[2];
    const channelSlug = slugParts[3];
    if (toolSlug) links.push({ name: `${toTitle(toolSlug)} tool page`, path: `/tools/${toolSlug}` });
    if (channelSlug) links.push({ name: `${toTitle(channelSlug)} channel page`, path: `/channels/${channelSlug}` });

    links.push({ name: "Approval gates", path: "/controls/approval-gates" });
    links.push({ name: "Two-person rule", path: "/controls/two-person-rule" });
    links.push({ name: "Budgets", path: "/controls/budgets" });
  }

  if (family === "tools") {
    const toolSlug = slugParts[1];
    if (toolSlug) links.push({ name: `${toTitle(toolSlug)} overview`, path: `/tools/${toolSlug}` });

    links.push({ name: "Egress allowlist", path: "/controls/egress-allowlist" });
    links.push({ name: "DLP and redaction", path: "/controls/dlp-redaction" });
    links.push({ name: "Secrets boundary", path: "/controls/secret-boundary" });
  }

  if (family === "channels") {
    const channelSlug = slugParts[1];
    if (channelSlug) links.push({ name: `${toTitle(channelSlug)} overview`, path: `/channels/${channelSlug}` });

    links.push({ name: "Tool allow/deny", path: "/controls/tool-allow-deny" });
    links.push({ name: "Approval gates", path: "/controls/approval-gates" });
    links.push({ name: "Kill switch", path: "/controls/kill-switch" });
  }

  if (family === "controls") {
    links.push({ name: "Controls hub", path: "/controls" });
    links.push({ name: "Policy artifacts", path: "/policy" });
  }

  // Remove self-link and dedupe
  const self = `/${article.slug}`;
  return uniqueLinks(links.filter((l) => l.path !== self)).slice(0, 8);
}

// ‚îÄ‚îÄ Article Processing Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/<[^>]+>/g, "")
    .replace(/&[^;]+;/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "");
}

interface TocEntry {
  id: string;
  text: string;
  depth: number;
}

/** Inject `id` attributes + anchor links into h2/h3 elements, extract TOC. */
function extractAndInjectHeadings(rawHtml: string): { html: string; toc: TocEntry[] } {
  const toc: TocEntry[] = [];
  const seen = new Set<string>();
  const processed = rawHtml.replace(
    /<(h[23])([^>]*)>([\s\S]*?)<\/\1>/gi,
    (_match, tag: string, attrs: string, content: string) => {
      if (attrs.includes(" id=")) return _match; // already has id
      const text = content.replace(/<[^>]+>/g, "").trim();
      let id = slugify(text);
      if (!id) return _match;
      if (seen.has(id)) id += "-" + seen.size;
      seen.add(id);
      const depth = tag.toLowerCase() === "h2" ? 2 : 3;
      toc.push({ id, text, depth });
      return `<${tag}${attrs} id="${id}">${content}<a href="#${id}" class="heading-anchor" aria-hidden="true">#</a></${tag}>`;
    },
  );
  return { html: processed, toc };
}

/** Render a sticky sidebar Table of Contents from extracted headings. */
function renderToc(toc: TocEntry[]): string {
  if (toc.length < 3) return "";
  const items = toc
    .map((e) => `<li class="depth-${e.depth}"><a href="#${e.id}">${esc(e.text)}</a></li>`)
    .join("");
  return `
  <aside class="toc" aria-label="Table of contents">
    <details open>
      <summary>On this page</summary>
      <nav><ol>${items}</ol></nav>
    </details>
  </aside>`;
}

/** Wrap bare <table> elements in a responsive scroll container. */
function wrapTables(rawHtml: string): string {
  return rawHtml
    .replace(/<table\b/g, '<div class="table-wrap" role="region" tabindex="0"><table')
    .replace(/<\/table>/g, "</table></div>");
}

function articlePage(article: Article): string {
  const breadcrumbs = breadcrumbsFromSlug(article.slug);
  const schemas: string[] = [];

  const url = canonical(`/${article.slug}`);
  const headline = article.title.replace(/ \| Claw EA$/, "");

  if (article.faqs.length > 0) {
    schemas.push(faqSchema(article.faqs));
  }

  if (article.howToSteps && article.howToSteps.length > 0) {
    schemas.push(
      howToSchema(
        { title: article.howToTitle ?? headline, steps: article.howToSteps },
        url,
      ),
    );
  }

  if (article.category === "glossary") {
    schemas.push(definedTermSchema(headline, article.description, url));
  } else {
    schemas.push(
      techArticleSchema({
        headline,
        description: article.description,
        url,
        datePublished: article.generatedAt,
        dateModified: article.generatedAt,
        section: article.category,
      }),
    );
  }

  const updated = formatDateYmd(article.generatedAt);
  const readMinutes = estimateReadMinutes(article.html);
  const slugParts = article.slug.split("/").filter(Boolean);

  // Process article body: inject heading IDs, extract TOC, wrap tables
  const { html: processedHtml, toc } = extractAndInjectHeadings(article.html);
  const bodyHtml = wrapTables(processedHtml);
  const tocHtml = renderToc(toc);

  // Key takeaways module (uses article description as summary)
  const takeawaysHtml = article.description
    ? `<div class="takeaways"><div class="takeaways-title">&#9672; Key takeaway</div><p>${esc(article.description)}</p></div>`
    : "";

  // Related content with card styling
  const related = relatedLinksForArticle(article);
  const relatedHtml = related.length
    ? `<div class="related"><h3>Related</h3><div class="related-grid">${related
        .map((l) => `<a href="${l.path}" class="related-card"><span class="related-label">${esc(l.name)}</span></a>`)
        .join("")}</div></div>`
    : "";

  const categoryLabel = article.category
    .replace(/-/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase());

  const familySlug = slugParts.length > 1 ? slugParts[0] : null;
  const familyLinkHtml = familySlug
    ? `<a href="/${familySlug}" class="meta-chip meta-chip-link" role="listitem">${esc(toTitle(familySlug))} hub</a>`
    : "";

  return layout({
    meta: {
      title: article.title,
      description: article.description,
      path: `/${article.slug}`,
      ogType: "article",
      ogImageAlt: `${headline} | Claw EA`,
      articleSection: categoryLabel,
      publishedTime: article.generatedAt,
      modifiedTime: article.generatedAt,
      // Plan A: fail-closed. Only explicitly indexable pages should be indexed.
      noindex: article.indexable !== true,
    },
    breadcrumbs,
    schemas,
    body: `
    <section class="section content-page">
      <div class="wrap">
        <span class="badge badge-blue">${categoryLabel}</span>
        <h1>${esc(headline)}</h1>
        <p class="article-meta">Evidence is linked in Sources when available.</p>
        <div class="article-meta-strip" role="list" aria-label="Article metadata">
          <span class="meta-chip" role="listitem">Updated <time datetime="${esc(article.generatedAt)}">${updated}</time></span>
          <span class="meta-chip" role="listitem">${readMinutes} min read</span>
          <span class="meta-chip" role="listitem">${esc(categoryLabel)}</span>
          ${familyLinkHtml}
        </div>
        ${takeawaysHtml}
        <div class="article-layout">
          ${tocHtml}
          <div class="article-main">
            <div class="article-body">${bodyHtml}</div>
            ${relatedHtml}
          </div>
        </div>
      </div>
    </section>`,
  });
}

function esc(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ‚îÄ‚îÄ Router ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname.replace(/\/+$/, "") || "/";

    // ‚îÄ‚îÄ IndexNow key file ‚îÄ‚îÄ
    if ((request.method === "GET" || request.method === "HEAD") && env.INDEXNOW_KEY && path === `/${env.INDEXNOW_KEY}.txt`) {
      return new Response(request.method === "HEAD" ? null : `${env.INDEXNOW_KEY}\n`, {
        headers: {
          "content-type": "text/plain;charset=utf-8",
          "cache-control": "public, max-age=86400",
        },
      });
    }

    // ‚îÄ‚îÄ API routes (indexing automation + conversion telemetry) ‚îÄ‚îÄ
    if (path.startsWith("/api/")) {
      if (request.method === "OPTIONS") {
        return new Response(null, { status: 204, headers: apiHeaders() });
      }

      // Public conversion instrumentation endpoint (no bearer token)
      if (path === "/api/events") {
        return await ingestTrackingEvent(request, env);
      }

      // Protected telemetry summary endpoint
      if (path === "/api/events/summary") {
        return await summarizeTrackingEvents(request, env);
      }

      const authError = checkAutomationAuth(request, env);
      if (authError) return authError;

      if (request.method !== "POST") {
        return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
      }

      let body: any;
      try {
        body = await request.json<any>();
      } catch {
        return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
      }

      const { accepted, rejected } = normalizeUrlList(body?.urls, 500);
      if (accepted.length === 0) {
        return apiError("URLS_INVALID", "No valid clawea.com URLs were provided", 400);
      }

      if (path === "/api/indexnow") {
        const result = await submitIndexNow(accepted, env);
        return apiJson({
          ok: result.ok,
          engine: "indexnow",
          submitted: result.submitted,
          requested: accepted.length,
          rejected,
          status: result.status,
          attempts: result.attempts,
          retried: result.retried,
          retryableFailures: result.retryableFailures,
          attemptLog: result.attemptLog,
          body: result.body,
          error: result.error,
        }, result.ok ? 200 : 502);
      }

      if (path === "/api/google-index") {
        const action = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const result = await submitGoogleIndexing(accepted, action, env);
        return apiJson({
          ok: result.ok,
          engine: "google",
          action,
          submitted: result.submitted,
          failed: result.failed,
          requested: accepted.length,
          rejected,
          status: result.status,
          details: result.details,
          error: result.error,
        }, result.ok ? 200 : result.status);
      }

      if (path === "/api/index-urls") {
        const action = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const enginesRaw = body?.engines;
        const enginesInput = Array.isArray(enginesRaw)
          ? enginesRaw.map((x) => String(x).toLowerCase())
          : [String(enginesRaw ?? "all").toLowerCase()];

        const useAll = enginesInput.includes("all");
        const useIndexNow = useAll || enginesInput.includes("indexnow");
        const useGoogle = useAll || enginesInput.includes("google");

        if (!useIndexNow && !useGoogle) {
          return apiError("ENGINES_INVALID", "engines must include indexnow, google, or all", 400);
        }

        const out: Record<string, unknown> = {
          ok: true,
          requested: accepted.length,
          rejected,
          action,
          engines: enginesInput,
        };

        if (useIndexNow) {
          const r = await submitIndexNow(accepted, env);
          out.indexnow = {
            ok: r.ok,
            submitted: r.submitted,
            status: r.status,
            attempts: r.attempts,
            retried: r.retried,
            retryableFailures: r.retryableFailures,
            attemptLog: r.attemptLog,
            body: r.body,
            error: r.error,
          };
          if (!r.ok) out.ok = false;
        }

        if (useGoogle) {
          const r = await submitGoogleIndexing(accepted, action, env);
          out.google = {
            ok: r.ok,
            submitted: r.submitted,
            failed: r.failed,
            status: r.status,
            details: r.details,
            error: r.error,
          };
          if (!r.ok) out.ok = false;
        }

        return apiJson(out, out.ok ? 200 : 207);
      }

      return apiError("NOT_FOUND", "Unknown API route", 404);
    }

    // ‚îÄ‚îÄ Static routes ‚îÄ‚îÄ
    if (path === "/health") return json({ ok: true, service: "clawea-www", ts: new Date().toISOString() });
    if (path === "/") return html(homePage(), 200, 7200);
    if (path === "/pricing") return html(pricingPage());
    if (path === "/contact") return html(contactPage());
    if (path === "/trust") return html(trustPage());
    if (path === "/secure-workers") return html(secureWorkersPage());
    if (path === "/consulting") return html(consultingPage());
    if (path === "/about") return html(aboutPage());

    if (path === "/glossary") {
      const q = normalizeSearchQuery(url.searchParams.get("q"));
      if (q) {
        const manifest = await loadManifest(env);
        const results = searchManifest(manifest, q, 32);
        return html(glossarySearchPage(q, results), 200, 300);
      }
    }

    // ‚îÄ‚îÄ Robots.txt ‚îÄ‚îÄ
    if (path === "/robots.txt") {
      return new Response(
        `User-agent: *\nAllow: /\nDisallow: /api/\nDisallow: /v1/\n\nSitemap: https://www.clawea.com/sitemap.xml\n`,
        { headers: { "content-type": "text/plain", "cache-control": "public, max-age=86400" } },
      );
    }

    // ‚îÄ‚îÄ Sitemap ‚îÄ‚îÄ
    if (path === "/sitemap.xml") {
      return await serveSitemap(env);
    }

    // ‚îÄ‚îÄ Dynamic article routes ‚îÄ‚îÄ
    const slug = slugFromPath(path);
    const article = await loadArticle(env, slug);
    if (article) {
      return html(articlePage(article), 200, 3600);
    }

    // ‚îÄ‚îÄ 404 ‚îÄ‚îÄ
    return html(notFoundPage(), 404);
  },
} satisfies ExportedHandler<Env>;

// ‚îÄ‚îÄ Sitemap Generator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function serveSitemap(env: Env): Promise<Response> {
  // Load sitemap index from R2
  // Core sitemap only (Plan A)
  const obj = await env.ARTICLES.get("articles/_sitemap_core.json");
  const staticPages = [
    { slug: "", priority: "1.0" },
    { slug: "trust", priority: "0.8" },
    { slug: "secure-workers", priority: "0.8" },
    { slug: "consulting", priority: "0.8" },
    { slug: "pricing", priority: "0.8" },
    { slug: "contact", priority: "0.7" },
    { slug: "about", priority: "0.6" },
  ];

  let entries = staticPages.map((p) => `  <url><loc>https://www.clawea.com/${p.slug}</loc><priority>${p.priority}</priority><changefreq>weekly</changefreq></url>`);

  if (obj) {
    const articles = await obj.json<{ slug: string; category: string }[]>();
    for (const a of articles) {
      const pri =
        a.category === "pillars" || a.category === "hubs" ? "0.8"
          : a.category === "guides" ? "0.7"
            : ["controls", "policy", "proof", "verify", "audit"].includes(a.category) ? "0.7"
              : [
                  "workflows",
                  "tools",
                  "channels",
                  "mcp",
                  "supply-chain",
                  "compliance",
                  "compare",
                  "roles",
                ].includes(a.category) ? "0.6"
                : a.category === "glossary" ? "0.5"
                  : "0.5";
      entries.push(`  <url><loc>https://www.clawea.com/${a.slug}</loc><priority>${pri}</priority><changefreq>monthly</changefreq></url>`);
    }
  }

  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${entries.join("\n")}
</urlset>`;

  return new Response(xml, {
    headers: { "content-type": "application/xml", "cache-control": "public, max-age=3600" },
  });
}
