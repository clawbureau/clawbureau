/**
 * clawea-www — Programmatic SEO site for clawea.com
 *
 * Serves 10k+ pages from R2-stored articles generated by Gemini.
 * Full SEO: JSON-LD, FAQ schema, OG tags, sitemap, robots.txt,
 * internal linking mesh, breadcrumbs, canonical URLs.
 *
 * Routes:
 *   GET /                        → homepage
 *
 *   Core permissioned-execution taxonomy:
 *   GET /policy-as-code-for-agents
 *   GET /secure-agent-execution
 *   GET /agent-proof-and-attestation
 *   GET /agent-audit-and-replay
 *   GET /agent-supply-chain-security
 *   GET /event-native-agents
 *   GET /mcp-security
 *
 *   Families:
 *   GET /controls/*              → control pages
 *   GET /tools/*                 → enterprise tool pages
 *   GET /channels/*              → channel control plane pages
 *   GET /workflows/*             → workflow recipes (workflow → tool → channel)
 *   GET /policy/*                → policy artifacts and validation
 *   GET /proof/*                 → proof pages
 *   GET /verify/*                → verification pages
 *   GET /audit/*                 → audit/replay pages
 *   GET /mcp/*                   → MCP security and server governance
 *   GET /supply-chain/*          → extension supply chain security
 *   GET /events/*                → event-native trigger patterns
 *   GET /compliance/*            → compliance mappings and evidence
 *   GET /guides/*                → implementation guides
 *   GET /glossary/*              → glossary entries
 *   GET /vs/*, /compare/*, /for/* → comparisons and role-based pages
 *
 *   Static pages:
 *   GET /pricing, /assessment, /assessment/result, /contact, /about, /trust, /secure-workers, /consulting, /sources
 *
 *   System endpoints:
 *   GET /sitemap.xml, /robots.txt, /llms.txt, /health
 *   GET /<INDEXNOW_KEY>.txt
 *   GET /api/search?q=...
 *   GET /api/experiments/config, /api/experiments/assignment, /api/experiments/winners (winners is token-protected)
 *   POST /api/leads/submit
 *   GET /api/leads/status, /api/leads/export (token-protected)
 *   POST /api/indexnow, /api/google-index, /api/index-urls
 *   GET /api/index-queue/status
 *   POST /api/index-queue/enqueue, /api/index-queue/replay
 *   POST /api/events (public conversion telemetry)
 *   POST /api/events/summary (token-protected weekly summary)
 *
 * Dynamic article routing:
 * - Any non-static route attempts to load articles/<slug>.json from R2.
 */

import { layout } from "./layout";
import {
  faqSchema,
  howToSchema,
  serviceSchema,
  canonical,
  definedTermSchema,
  techArticleSchema,
  productSchema,
  type PageMeta,
} from "./seo";
import { trustPage, secureWorkersPage, consultingPage, aboutPage } from "./pages/static";

interface Env {
  ARTICLES: R2Bucket;
  SITE_URL: string;
  ENVIRONMENT: string;

  // Demand capture data + jobs
  DB: D1Database;
  VARIANT_CONFIG: KVNamespace;
  LEAD_JOBS: Queue;

  // Indexing automation
  INDEXNOW_KEY?: string;
  INDEX_AUTOMATION_TOKEN?: string;
  LEADS_API_TOKEN?: string;
  GOOGLE_INDEXING_SERVICE_ACCOUNT_JSON?: string;
  INDEXNOW_MAX_ATTEMPTS?: string;
  INDEXNOW_RETRY_BASE_MS?: string;
  INDEXNOW_RETRY_MAX_MS?: string;
  GOOGLE_INDEX_MAX_ATTEMPTS?: string;
  GOOGLE_INDEX_RETRY_BASE_MS?: string;
  GOOGLE_INDEX_RETRY_MAX_MS?: string;

  // Durable indexing queue
  INDEX_QUEUE_ENABLED?: string;
  INDEX_QUEUE_MAX_ENTRIES_PER_RUN?: string;
  INDEX_QUEUE_INDEXNOW_MAX_ATTEMPTS?: string;
  INDEX_QUEUE_GOOGLE_MAX_ATTEMPTS?: string;
  INDEX_QUEUE_RETRY_BASE_MS?: string;
  INDEX_QUEUE_RETRY_MAX_MS?: string;

  // Lead intake + Turnstile
  TURNSTILE_SECRET_KEY?: string;
  TURNSTILE_SITE_KEY?: string;
  TURNSTILE_REQUIRED?: string;
  LEAD_ID_HASH_SALT?: string;

  // Experiment routing
  EXPERIMENT_SEED?: string;
  EXPERIMENT_CONFIG_KEY?: string;
}

interface Article {
  slug: string;
  title: string;
  category: string;
  html: string;
  description: string;
  faqs: { q: string; a: string }[];
  /** v2 structured how-to support (optional, used when present) */
  howToTitle?: string;
  howToSteps?: Array<{ name: string; text: string }>;
  sources: { title: string; uri: string }[];
  model: string;
  generatedAt: string;
  /** Plan A: only index selected pages initially. */
  indexable?: boolean;
}

interface ManifestEntry {
  title: string;
  category: string;
  description: string;
  indexable?: boolean;
}

type SearchDocumentKind = "article" | "static";

interface SearchDocument {
  path: string;
  title: string;
  description: string;
  category: string;
  kind: SearchDocumentKind;
}

interface SearchResult extends SearchDocument {
  score: number;
}

type LeadLifecycleStatus =
  | "new"
  | "enriched"
  | "qualified"
  | "contacted"
  | "closed"
  | "rejected";

interface LeadSubmissionPayload {
  fullName?: string;
  email?: string;
  company?: string;
  role?: string;
  teamSize?: string;
  timeline?: string;
  primaryUseCase?: string;
  intentNote?: string;
  assessment?: {
    readinessScore?: number;
    roiScore?: number;
    riskScore?: number;
    confidenceLabel?: string;
  };
  attribution?: Record<string, string>;
  firstTouch?: {
    ts?: string;
    path?: string;
    pageFamily?: string;
    source?: string;
  };
  page?: string;
  pageFamily?: string;
  turnstileToken?: string;
  idempotencyKey?: string;
}

interface LeadRow {
  lead_id: string;
  created_at: string;
  updated_at: string;
  last_seen_at: string;
  status: LeadLifecycleStatus;
  qualification_score: number;
  intent_score: number;
  risk_score: number;
  readiness_score: number;
  roi_score: number;
  dedupe_count: number;
  source: string;
  page: string;
  page_family: string;
  full_name: string;
  company: string;
  role: string;
  team_size: string;
  timeline: string;
  primary_use_case: string;
  email_hint: string;
}

interface ExperimentVariantConfig {
  seed: string;
  families: Record<string, {
    hero: string[];
    cta: string[];
  }>;
}

const DEFAULT_EXPERIMENT_CONFIG: ExperimentVariantConfig = {
  seed: "aeo-rev-005-default",
  families: {
    home: { hero: ["proof", "roi", "speed"], cta: ["proof", "roi", "speed"] },
    assessment: { hero: ["proof", "roi", "speed"], cta: ["proof", "roi", "speed"] },
    tools: { hero: ["proof", "risk"], cta: ["assessment", "sales"] },
    workflows: { hero: ["proof", "automation"], cta: ["assessment", "sales"] },
    contact: { hero: ["fast-path", "proof"], cta: ["submit", "assessment"] },
    pricing: { hero: ["roi", "proof"], cta: ["proof", "roi", "sales"] },
    sources: { hero: ["proof", "citation"], cta: ["assessment", "sales"] },
    root: { hero: ["proof", "roi"], cta: ["proof", "roi"] },
  },
};

// ── Helpers ───────────────────────────────────────────────────────

function json(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: { "content-type": "application/json", "access-control-allow-origin": "*" },
  });
}

function html(body: string, status = 200, cacheSeconds = 3600): Response {
  return new Response(body, {
    status,
    headers: {
      "content-type": "text/html;charset=utf-8",
      "cache-control": `public, max-age=${cacheSeconds}, s-maxage=${cacheSeconds * 24}`,
    },
  });
}

function apiHeaders(extra: HeadersInit = {}): Headers {
  const h = new Headers(extra);
  h.set("access-control-allow-origin", "*");
  h.set("access-control-allow-methods", "GET,POST,OPTIONS");
  h.set("access-control-allow-headers", "content-type,authorization");
  h.set("cache-control", "no-store");
  return h;
}

function apiJson(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: apiHeaders({ "content-type": "application/json" }),
  });
}

function apiError(code: string, message: string, status = 400): Response {
  return apiJson({ ok: false, error: { code, message } }, status);
}

function getBearerToken(request: Request): string | null {
  const auth = request.headers.get("authorization") ?? "";
  const m = auth.match(/^Bearer\s+(.+)$/i);
  return m?.[1]?.trim() ?? null;
}

function checkAutomationAuth(request: Request, env: Env): Response | null {
  const secret = env.INDEX_AUTOMATION_TOKEN?.trim();
  if (!secret) {
    return apiError("INDEX_AUTOMATION_NOT_CONFIGURED", "Indexing automation token is not configured", 503);
  }

  const token = getBearerToken(request);
  if (!token || token !== secret) {
    return apiError("UNAUTHORIZED", "Missing or invalid bearer token", 401);
  }

  return null;
}

function checkOpsAuth(request: Request, env: Env): Response | null {
  const secret = env.LEADS_API_TOKEN?.trim() || env.INDEX_AUTOMATION_TOKEN?.trim();
  if (!secret) {
    return apiError("OPS_AUTH_NOT_CONFIGURED", "Ops bearer token is not configured", 503);
  }

  const token = getBearerToken(request);
  if (!token || token !== secret) {
    return apiError("UNAUTHORIZED", "Missing or invalid bearer token", 401);
  }

  return null;
}

const INDEXABLE_HOSTS = new Set(["clawea.com", "www.clawea.com"]);

function normalizeIndexingUrl(input: string): string | null {
  try {
    const u = new URL(input);
    if (u.protocol !== "https:") return null;
    const host = u.hostname.toLowerCase();
    if (!INDEXABLE_HOSTS.has(host)) return null;

    u.hash = "";
    return u.toString();
  } catch {
    return null;
  }
}

function normalizeUrlList(input: unknown, maxUrls = 500): { accepted: string[]; rejected: string[] } {
  const accepted: string[] = [];
  const rejected: string[] = [];

  if (!Array.isArray(input)) {
    return { accepted, rejected: ["urls_must_be_array"] };
  }

  for (const raw of input) {
    if (accepted.length >= maxUrls) break;
    if (typeof raw !== "string") {
      rejected.push(String(raw));
      continue;
    }

    const normalized = normalizeIndexingUrl(raw.trim());
    if (!normalized) {
      rejected.push(raw);
      continue;
    }

    if (!accepted.includes(normalized)) accepted.push(normalized);
  }

  return { accepted, rejected };
}

type IndexNowAttempt = {
  attempt: number;
  status: number;
  ok: boolean;
  retryable: boolean;
  waitMs?: number;
};

type IndexNowResult = {
  ok: boolean;
  submitted: number;
  status: number;
  body?: unknown;
  error?: string;
  attempts: number;
  retried: number;
  retryableFailures: number;
  attemptLog: IndexNowAttempt[];
};

const RETRYABLE_HTTP_STATUS = new Set([429, 500, 502, 503, 504]);

function isRetryableStatus(status: number): boolean {
  return RETRYABLE_HTTP_STATUS.has(status);
}

function parseRetryAfterMs(value: string | null): number | null {
  if (!value) return null;

  const asNum = Number(value);
  if (Number.isFinite(asNum) && asNum >= 0) {
    return Math.floor(asNum * 1000);
  }

  const asDate = Date.parse(value);
  if (Number.isNaN(asDate)) return null;

  const delta = asDate - Date.now();
  return delta > 0 ? delta : 0;
}

function backoffMs(attempt: number, baseMs = 900, maxMs = 30000): number {
  const exp = Math.min(maxMs, baseMs * 2 ** Math.max(0, attempt - 1));
  const jitter = Math.floor(exp * 0.2 * Math.random());
  return Math.min(maxMs, exp + jitter);
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function submitIndexNow(urls: string[], env: Env): Promise<IndexNowResult> {
  const key = env.INDEXNOW_KEY?.trim();
  if (!key) {
    return {
      ok: false,
      submitted: 0,
      status: 503,
      error: "INDEXNOW_KEY_NOT_CONFIGURED",
      attempts: 0,
      retried: 0,
      retryableFailures: 0,
      attemptLog: [],
    };
  }

  const maxAttempts = Math.max(1, Number(env.INDEXNOW_MAX_ATTEMPTS ?? "4"));
  const baseBackoffMs = Math.max(250, Number(env.INDEXNOW_RETRY_BASE_MS ?? "900"));
  const maxBackoffMs = Math.max(baseBackoffMs, Number(env.INDEXNOW_RETRY_MAX_MS ?? "30000"));

  const payload = {
    host: "clawea.com",
    key,
    keyLocation: `https://clawea.com/${key}.txt`,
    urlList: urls,
  };

  const attemptLog: IndexNowAttempt[] = [];
  let retried = 0;
  let retryableFailures = 0;
  let lastBody: unknown = null;
  let lastStatus = 502;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const res = await fetch("https://api.indexnow.org/IndexNow", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(payload),
      });

      const raw = await res.text();
      let parsed: unknown = raw;
      try {
        parsed = raw ? JSON.parse(raw) : null;
      } catch {
        // keep raw text body
      }

      const retryable = isRetryableStatus(res.status);
      const nextAllowed = attempt < maxAttempts && retryable;

      let waitMs: number | undefined;
      if (nextAllowed) {
        const retryAfterMs = parseRetryAfterMs(res.headers.get("retry-after"));
        waitMs = retryAfterMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs);
      }

      attemptLog.push({
        attempt,
        status: res.status,
        ok: res.ok,
        retryable,
        waitMs,
      });

      lastBody = parsed;
      lastStatus = res.status;

      if (res.ok) {
        return {
          ok: true,
          submitted: urls.length,
          status: res.status,
          body: parsed,
          attempts: attempt,
          retried,
          retryableFailures,
          attemptLog,
        };
      }

      if (!nextAllowed) {
        return {
          ok: false,
          submitted: 0,
          status: res.status,
          body: parsed,
          error: "INDEXNOW_REQUEST_FAILED",
          attempts: attempt,
          retried,
          retryableFailures,
          attemptLog,
        };
      }

      retryableFailures += 1;
      retried += 1;
      await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
    } catch (err: any) {
      const nextAllowed = attempt < maxAttempts;
      const waitMs = nextAllowed ? backoffMs(attempt, baseBackoffMs, maxBackoffMs) : undefined;

      attemptLog.push({
        attempt,
        status: 0,
        ok: false,
        retryable: nextAllowed,
        waitMs,
      });

      lastBody = { message: String(err?.message ?? err) };
      lastStatus = 502;

      if (!nextAllowed) {
        return {
          ok: false,
          submitted: 0,
          status: 502,
          body: lastBody,
          error: "INDEXNOW_FETCH_FAILED",
          attempts: attempt,
          retried,
          retryableFailures,
          attemptLog,
        };
      }

      retryableFailures += 1;
      retried += 1;
      await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
    }
  }

  return {
    ok: false,
    submitted: 0,
    status: lastStatus,
    body: lastBody,
    error: "INDEXNOW_REQUEST_FAILED",
    attempts: attemptLog.length,
    retried,
    retryableFailures,
    attemptLog,
  };
}

type GoogleServiceAccount = {
  client_email: string;
  private_key: string;
  token_uri?: string;
};

type GoogleAttempt = {
  attempt: number;
  status: number;
  ok: boolean;
  retryable: boolean;
  waitMs?: number;
};

type GoogleIndexDetail = {
  url: string;
  ok: boolean;
  status: number;
  body?: unknown;
  attempts: number;
  retried: number;
  retryableFailures: number;
  attemptLog: GoogleAttempt[];
};

type GoogleIndexResult = {
  ok: boolean;
  submitted: number;
  failed: number;
  status: number;
  details: GoogleIndexDetail[];
  error?: string;
};

function b64Url(input: string | Uint8Array): string {
  const str =
    typeof input === "string"
      ? input
      : String.fromCharCode(...input);
  return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function pemToPkcs8Bytes(pem: string): Uint8Array {
  const b64 = pem
    .replace(/-----BEGIN PRIVATE KEY-----/g, "")
    .replace(/-----END PRIVATE KEY-----/g, "")
    .replace(/\s+/g, "");

  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
  return out;
}

async function buildGoogleAccessToken(env: Env): Promise<string> {
  const raw = env.GOOGLE_INDEXING_SERVICE_ACCOUNT_JSON?.trim();
  if (!raw) {
    throw new Error("GOOGLE_INDEXING_NOT_CONFIGURED");
  }

  let sa: GoogleServiceAccount;
  try {
    sa = JSON.parse(raw) as GoogleServiceAccount;
  } catch {
    throw new Error("GOOGLE_INDEXING_SERVICE_ACCOUNT_INVALID_JSON");
  }

  if (!sa.client_email || !sa.private_key) {
    throw new Error("GOOGLE_INDEXING_SERVICE_ACCOUNT_FIELDS_MISSING");
  }

  const tokenUri = sa.token_uri ?? "https://oauth2.googleapis.com/token";
  const iat = Math.floor(Date.now() / 1000);
  const exp = iat + 3600;

  const header = { alg: "RS256", typ: "JWT" };
  const claim = {
    iss: sa.client_email,
    scope: "https://www.googleapis.com/auth/indexing",
    aud: tokenUri,
    iat,
    exp,
  };

  const encodedHeader = b64Url(JSON.stringify(header));
  const encodedClaim = b64Url(JSON.stringify(claim));
  const signingInput = `${encodedHeader}.${encodedClaim}`;

  const key = await crypto.subtle.importKey(
    "pkcs8",
    pemToPkcs8Bytes(sa.private_key),
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"],
  );

  const sig = await crypto.subtle.sign(
    { name: "RSASSA-PKCS1-v1_5" },
    key,
    new TextEncoder().encode(signingInput),
  );

  const jwt = `${signingInput}.${b64Url(new Uint8Array(sig))}`;

  const tokenRes = await fetch(tokenUri, {
    method: "POST",
    headers: { "content-type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: jwt,
    }).toString(),
  });

  if (!tokenRes.ok) {
    const errBody = await tokenRes.text();
    throw new Error(`GOOGLE_OAUTH_FAILED:${tokenRes.status}:${errBody.slice(0, 400)}`);
  }

  const tokenJson = await tokenRes.json<any>();
  const accessToken = tokenJson?.access_token;
  if (!accessToken || typeof accessToken !== "string") {
    throw new Error("GOOGLE_OAUTH_NO_ACCESS_TOKEN");
  }

  return accessToken;
}

async function submitGoogleIndexing(
  urls: string[],
  action: "URL_UPDATED" | "URL_DELETED",
  env: Env,
): Promise<GoogleIndexResult> {
  try {
    const accessToken = await buildGoogleAccessToken(env);

    const details: GoogleIndexResult["details"] = [];
    let submitted = 0;
    let failed = 0;

    const maxAttempts = Math.max(1, Number(env.GOOGLE_INDEX_MAX_ATTEMPTS ?? "4"));
    const baseBackoffMs = Math.max(250, Number(env.GOOGLE_INDEX_RETRY_BASE_MS ?? "1200"));
    const maxBackoffMs = Math.max(baseBackoffMs, Number(env.GOOGLE_INDEX_RETRY_MAX_MS ?? "45000"));

    for (const url of urls) {
      const attemptLog: GoogleAttempt[] = [];
      let retried = 0;
      let retryableFailures = 0;
      let finalOk = false;
      let finalStatus = 503;
      let finalBody: unknown = null;

      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          const res = await fetch("https://indexing.googleapis.com/v3/urlNotifications:publish", {
            method: "POST",
            headers: {
              "content-type": "application/json",
              authorization: `Bearer ${accessToken}`,
            },
            body: JSON.stringify({
              url,
              type: action,
            }),
          });

          const raw = await res.text();
          let parsed: unknown = raw;
          try {
            parsed = raw ? JSON.parse(raw) : null;
          } catch {
            // leave as text
          }

          const retryable = isRetryableStatus(res.status);
          const shouldRetry = !res.ok && retryable && attempt < maxAttempts;
          const retryAfterMs = shouldRetry ? parseRetryAfterMs(res.headers.get("retry-after")) : null;
          const waitMs = shouldRetry ? (retryAfterMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs)) : undefined;

          attemptLog.push({
            attempt,
            status: res.status,
            ok: res.ok,
            retryable,
            waitMs,
          });

          finalOk = res.ok;
          finalStatus = res.status;
          finalBody = parsed;

          if (res.ok) break;
          if (!shouldRetry) break;

          retryableFailures += 1;
          retried += 1;
          await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
        } catch (err: any) {
          const shouldRetry = attempt < maxAttempts;
          const waitMs = shouldRetry ? backoffMs(attempt, baseBackoffMs, maxBackoffMs) : undefined;

          attemptLog.push({
            attempt,
            status: 0,
            ok: false,
            retryable: shouldRetry,
            waitMs,
          });

          finalOk = false;
          finalStatus = 503;
          finalBody = { message: String(err?.message ?? err) };

          if (!shouldRetry) break;

          retryableFailures += 1;
          retried += 1;
          await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
        }
      }

      if (finalOk) submitted += 1;
      else failed += 1;

      details.push({
        url,
        ok: finalOk,
        status: finalStatus,
        body: finalBody,
        attempts: attemptLog.length,
        retried,
        retryableFailures,
        attemptLog,
      });
    }

    return {
      ok: failed === 0,
      submitted,
      failed,
      status: failed === 0 ? 200 : 207,
      details,
    };
  } catch (err: any) {
    return {
      ok: false,
      submitted: 0,
      failed: urls.length,
      status: 503,
      details: [],
      error: String(err?.message ?? err),
    };
  }
}

// ── Durable Indexing Queue ──────────────────────────────────────

type IndexEngine = "indexnow" | "google";
type IndexAction = "URL_UPDATED" | "URL_DELETED";
type IndexQueueEngineStatus = "queued" | "retry" | "done" | "failed";

const INDEX_ENGINES: IndexEngine[] = ["indexnow", "google"];
const INDEX_QUEUE_KEY = "articles/_indexing_queue.v1.json";
const INDEX_QUEUE_SUMMARY_KEY = "articles/_indexing_queue_summary.json";

interface IndexQueueEngineState {
  status: IndexQueueEngineStatus;
  attempts: number;
  maxAttempts: number;
  nextAttemptAt?: string;
  lastStatus?: number;
  lastError?: string;
  lastProcessedAt?: string;
}

interface IndexQueueEntry {
  id: string;
  url: string;
  action: IndexAction;
  engines: Partial<Record<IndexEngine, IndexQueueEngineState>>;
  createdAt: string;
  updatedAt: string;
  source?: string;
}

interface IndexQueueState {
  version: 1;
  updatedAt: string;
  entries: Record<string, IndexQueueEntry>;
}

interface IndexQueueRunEngineResult {
  engine: IndexEngine;
  ok: boolean;
  status: number;
  retryable: boolean;
  attempts: number;
  maxAttempts: number;
  nextAttemptAt?: string;
  error?: string;
}

interface IndexQueueRunItem {
  id: string;
  url: string;
  action: IndexAction;
  engineResults: IndexQueueRunEngineResult[];
}

interface IndexQueueRunArtifact {
  runId: string;
  source: string;
  startedAt: string;
  finishedAt: string;
  processedEntries: number;
  processedEngines: number;
  succeeded: number;
  scheduledRetry: number;
  failed: number;
  clearedEntries: number;
  simulate429: boolean;
  items: IndexQueueRunItem[];
  queueAfter: ReturnType<typeof summarizeIndexQueue>;
}

interface QueueStatusSummary {
  totalEntries: number;
  byEngine: Record<IndexEngine, { queued: number; retry: number; done: number; failed: number }>;
  nextAttemptAt?: string;
}

interface EnqueueQueueOptions {
  urls: string[];
  action: IndexAction;
  engines: IndexEngine[];
  force?: boolean;
  source?: string;
}

interface ProcessQueueOptions {
  source: string;
  maxEntries?: number;
  simulate429?: boolean;
}

interface ProcessQueueResult {
  run: IndexQueueRunArtifact;
  artifactKey: string;
}

function envInt(raw: string | undefined, fallback: number, min = 1): number {
  const n = Number(raw);
  if (!Number.isFinite(n)) return fallback;
  return Math.max(min, Math.floor(n));
}

function queueEnabled(env: Env): boolean {
  return env.INDEX_QUEUE_ENABLED !== "0";
}

function queueMaxEntriesPerRun(env: Env): number {
  return envInt(env.INDEX_QUEUE_MAX_ENTRIES_PER_RUN, 40, 1);
}

function queueMaxAttemptsForEngine(env: Env, engine: IndexEngine): number {
  if (engine === "indexnow") {
    return envInt(env.INDEX_QUEUE_INDEXNOW_MAX_ATTEMPTS, 8, 1);
  }
  return envInt(env.INDEX_QUEUE_GOOGLE_MAX_ATTEMPTS, 6, 1);
}

function deterministicJitter(seed: string, limit: number): number {
  if (limit <= 0) return 0;
  let h = 2166136261;
  for (let i = 0; i < seed.length; i++) {
    h ^= seed.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return Math.abs(h) % Math.max(1, limit);
}

function queueBackoffMs(env: Env, seed: string, attempt: number): number {
  const baseMs = envInt(env.INDEX_QUEUE_RETRY_BASE_MS, 60_000, 250);
  const maxMs = envInt(env.INDEX_QUEUE_RETRY_MAX_MS, 3_600_000, baseMs);
  const exp = Math.min(maxMs, baseMs * 2 ** Math.max(0, attempt - 1));
  const jitter = deterministicJitter(`${seed}:${attempt}`, Math.floor(exp * 0.25));
  return Math.min(maxMs, exp + jitter);
}

function parseDueMs(iso: string | undefined): number {
  if (!iso) return 0;
  const ms = Date.parse(iso);
  return Number.isNaN(ms) ? 0 : ms;
}

function isPendingState(status: IndexQueueEngineStatus): boolean {
  return status === "queued" || status === "retry";
}

async function queueEntryId(url: string, action: IndexAction): Promise<string> {
  const input = new TextEncoder().encode(`${action}|${url}`);
  const digest = await crypto.subtle.digest("SHA-256", input);
  return b64Url(new Uint8Array(digest));
}

async function loadIndexQueue(env: Env): Promise<IndexQueueState> {
  const obj = await env.ARTICLES.get(INDEX_QUEUE_KEY);
  if (!obj) {
    return {
      version: 1,
      updatedAt: new Date().toISOString(),
      entries: {},
    };
  }

  try {
    const parsed = await obj.json<IndexQueueState>();
    if (!parsed || typeof parsed !== "object" || parsed.version !== 1 || typeof parsed.entries !== "object") {
      throw new Error("invalid_queue_shape");
    }

    return {
      version: 1,
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : new Date().toISOString(),
      entries: parsed.entries ?? {},
    };
  } catch {
    return {
      version: 1,
      updatedAt: new Date().toISOString(),
      entries: {},
    };
  }
}

async function saveIndexQueue(env: Env, state: IndexQueueState): Promise<void> {
  state.updatedAt = new Date().toISOString();
  await env.ARTICLES.put(INDEX_QUEUE_KEY, JSON.stringify(state, null, 2), {
    httpMetadata: { contentType: "application/json" },
  });
}

function summarizeIndexQueue(state: IndexQueueState): QueueStatusSummary {
  const byEngine: QueueStatusSummary["byEngine"] = {
    indexnow: { queued: 0, retry: 0, done: 0, failed: 0 },
    google: { queued: 0, retry: 0, done: 0, failed: 0 },
  };

  let nextAttemptMs = Number.POSITIVE_INFINITY;

  for (const entry of Object.values(state.entries)) {
    for (const engine of INDEX_ENGINES) {
      const s = entry.engines[engine];
      if (!s) continue;
      byEngine[engine][s.status] += 1;
      if (isPendingState(s.status)) {
        const due = parseDueMs(s.nextAttemptAt);
        if (due > 0 && due < nextAttemptMs) nextAttemptMs = due;
      }
    }
  }

  return {
    totalEntries: Object.keys(state.entries).length,
    byEngine,
    nextAttemptAt: Number.isFinite(nextAttemptMs) ? new Date(nextAttemptMs).toISOString() : undefined,
  };
}

function summarizeQueueForResponse(state: IndexQueueState) {
  const summary = summarizeIndexQueue(state);
  const pending = Object.values(state.entries)
    .filter((entry) =>
      INDEX_ENGINES.some((engine) => {
        const s = entry.engines[engine];
        return s && isPendingState(s.status);
      }),
    )
    .sort((a, b) => a.updatedAt.localeCompare(b.updatedAt, "en"))
    .slice(0, 25)
    .map((entry) => ({
      id: entry.id,
      url: entry.url,
      action: entry.action,
      engines: entry.engines,
      updatedAt: entry.updatedAt,
    }));

  return { summary, pending };
}

function parseIndexingEngines(input: unknown): IndexEngine[] {
  const raw = Array.isArray(input)
    ? input.map((x) => String(x).toLowerCase())
    : [String(input ?? "all").toLowerCase()];

  const useAll = raw.includes("all");
  const out: IndexEngine[] = [];
  if (useAll || raw.includes("indexnow")) out.push("indexnow");
  if (useAll || raw.includes("google")) out.push("google");
  return out;
}

async function enqueueIndexQueue(
  env: Env,
  options: EnqueueQueueOptions,
): Promise<{ created: number; updated: number; deduped: number; state: IndexQueueState; summary: ReturnType<typeof summarizeQueueForResponse> }> {
  const state = await loadIndexQueue(env);

  const nowIso = new Date().toISOString();
  let created = 0;
  let updated = 0;
  let deduped = 0;

  for (const url of options.urls) {
    const id = await queueEntryId(url, options.action);
    let entry = state.entries[id];
    const wasExisting = Boolean(entry);
    let changed = false;

    if (!entry) {
      entry = {
        id,
        url,
        action: options.action,
        engines: {},
        createdAt: nowIso,
        updatedAt: nowIso,
        source: options.source,
      };
      state.entries[id] = entry;
      created += 1;
      changed = true;
    }

    for (const engine of options.engines) {
      const maxAttempts = queueMaxAttemptsForEngine(env, engine);
      const existing = entry.engines[engine];

      if (!existing) {
        entry.engines[engine] = {
          status: "queued",
          attempts: 0,
          maxAttempts,
          nextAttemptAt: nowIso,
        };
        changed = true;
        continue;
      }

      if (options.force) {
        entry.engines[engine] = {
          status: "queued",
          attempts: 0,
          maxAttempts,
          nextAttemptAt: nowIso,
        };
        changed = true;
        continue;
      }

      existing.maxAttempts = maxAttempts;

      if (existing.status === "done") {
        deduped += 1;
        continue;
      }

      if (existing.status === "failed" && existing.attempts >= existing.maxAttempts) {
        deduped += 1;
        continue;
      }

      if (existing.status === "failed" || existing.status === "retry") {
        existing.status = "queued";
        existing.nextAttemptAt = nowIso;
        existing.lastError = undefined;
        changed = true;
        continue;
      }

      deduped += 1;
    }

    if (changed) {
      entry.updatedAt = nowIso;
      entry.source = options.source ?? entry.source;
      if (!entry.createdAt) entry.createdAt = nowIso;
      if (wasExisting) updated += 1;
    }
  }

  await saveIndexQueue(env, state);
  return {
    created,
    updated,
    deduped,
    state,
    summary: summarizeQueueForResponse(state),
  };
}

async function forceRequeueFailedEntries(env: Env): Promise<{ requeued: number; state: IndexQueueState }> {
  const state = await loadIndexQueue(env);
  const nowIso = new Date().toISOString();
  let requeued = 0;

  for (const entry of Object.values(state.entries)) {
    let changed = false;
    for (const engine of INDEX_ENGINES) {
      const s = entry.engines[engine];
      if (!s || s.status !== "failed") continue;
      s.status = "queued";
      s.nextAttemptAt = nowIso;
      s.lastError = undefined;
      changed = true;
      requeued += 1;
    }
    if (changed) entry.updatedAt = nowIso;
  }

  if (requeued > 0) await saveIndexQueue(env, state);
  return { requeued, state };
}

function googleFailureStatus(result: GoogleIndexResult, url: string): { status: number; retryable: boolean; error?: string } {
  const detail = result.details.find((d) => d.url === url) ?? result.details[0];
  if (detail) {
    return {
      status: detail.status,
      retryable: isRetryableStatus(detail.status),
      error: detail.ok ? undefined : "GOOGLE_INDEXING_REQUEST_FAILED",
    };
  }

  return {
    status: result.status,
    retryable: isRetryableStatus(result.status),
    error: result.error,
  };
}

async function processIndexQueue(env: Env, options: ProcessQueueOptions): Promise<ProcessQueueResult> {
  const startedAt = new Date().toISOString();
  const runId = startedAt.replace(/[:.]/g, "-");

  if (!queueEnabled(env)) {
    const disabledRun: IndexQueueRunArtifact = {
      runId,
      source: options.source,
      startedAt,
      finishedAt: new Date().toISOString(),
      processedEntries: 0,
      processedEngines: 0,
      succeeded: 0,
      scheduledRetry: 0,
      failed: 0,
      clearedEntries: 0,
      simulate429: Boolean(options.simulate429),
      items: [],
      queueAfter: {
        totalEntries: 0,
        byEngine: {
          indexnow: { queued: 0, retry: 0, done: 0, failed: 0 },
          google: { queued: 0, retry: 0, done: 0, failed: 0 },
        },
      },
    };

    const disabledKey = `articles/_indexing_runs/queue-${runId}.json`;
    await env.ARTICLES.put(disabledKey, JSON.stringify(disabledRun, null, 2), {
      httpMetadata: { contentType: "application/json" },
    });

    return { run: disabledRun, artifactKey: disabledKey };
  }

  const state = await loadIndexQueue(env);
  const maxEntries = Math.max(1, options.maxEntries ?? queueMaxEntriesPerRun(env));
  const nowMs = Date.now();

  const candidates = Object.values(state.entries)
    .map((entry) => {
      const dueEngines = INDEX_ENGINES.filter((engine) => {
        const s = entry.engines[engine];
        if (!s || !isPendingState(s.status)) return false;
        return parseDueMs(s.nextAttemptAt) <= nowMs;
      });
      return { entry, dueEngines };
    })
    .filter((x) => x.dueEngines.length > 0)
    .sort((a, b) => a.entry.updatedAt.localeCompare(b.entry.updatedAt, "en"))
    .slice(0, maxEntries);

  const items: IndexQueueRunItem[] = [];
  let succeeded = 0;
  let scheduledRetry = 0;
  let failed = 0;
  let clearedEntries = 0;

  for (const candidate of candidates) {
    const entry = candidate.entry;
    const engineResults: IndexQueueRunEngineResult[] = [];

    for (const engine of candidate.dueEngines) {
      const stateForEngine = entry.engines[engine];
      if (!stateForEngine) continue;

      stateForEngine.attempts += 1;
      stateForEngine.lastProcessedAt = new Date().toISOString();

      let ok = false;
      let status = 503;
      let retryable = false;
      let error: string | undefined;

      if (options.simulate429) {
        status = 429;
        retryable = true;
        error = "SIMULATED_429";
      } else if (engine === "indexnow") {
        const result = await submitIndexNow([entry.url], env);
        ok = result.ok;
        status = result.status;
        retryable = isRetryableStatus(result.status);
        error = result.error;
      } else {
        const result = await submitGoogleIndexing([entry.url], entry.action, env);
        ok = result.ok;
        const failure = googleFailureStatus(result, entry.url);
        status = ok ? 200 : failure.status;
        retryable = !ok && failure.retryable;
        error = ok ? undefined : (failure.error ?? result.error);
      }

      if (ok) {
        stateForEngine.status = "done";
        stateForEngine.nextAttemptAt = undefined;
        stateForEngine.lastStatus = status;
        stateForEngine.lastError = undefined;
        succeeded += 1;
      } else if (retryable && stateForEngine.attempts < stateForEngine.maxAttempts) {
        stateForEngine.status = "retry";
        const waitMs = queueBackoffMs(env, `${entry.id}:${engine}`, stateForEngine.attempts);
        stateForEngine.nextAttemptAt = new Date(Date.now() + waitMs).toISOString();
        stateForEngine.lastStatus = status;
        stateForEngine.lastError = error ?? "INDEXING_RETRY_SCHEDULED";
        scheduledRetry += 1;
      } else {
        stateForEngine.status = "failed";
        stateForEngine.nextAttemptAt = undefined;
        stateForEngine.lastStatus = status;
        stateForEngine.lastError = error ?? "INDEXING_FAILED";
        failed += 1;
      }

      engineResults.push({
        engine,
        ok,
        status,
        retryable,
        attempts: stateForEngine.attempts,
        maxAttempts: stateForEngine.maxAttempts,
        nextAttemptAt: stateForEngine.nextAttemptAt,
        error: stateForEngine.lastError,
      });
    }

    entry.updatedAt = new Date().toISOString();
    items.push({
      id: entry.id,
      url: entry.url,
      action: entry.action,
      engineResults,
    });

    const allDone = INDEX_ENGINES.every((engine) => {
      const s = entry.engines[engine];
      return !s || s.status === "done";
    });

    if (allDone) {
      delete state.entries[entry.id];
      clearedEntries += 1;
    }
  }

  await saveIndexQueue(env, state);

  const run: IndexQueueRunArtifact = {
    runId,
    source: options.source,
    startedAt,
    finishedAt: new Date().toISOString(),
    processedEntries: items.length,
    processedEngines: items.reduce((sum, item) => sum + item.engineResults.length, 0),
    succeeded,
    scheduledRetry,
    failed,
    clearedEntries,
    simulate429: Boolean(options.simulate429),
    items,
    queueAfter: summarizeIndexQueue(state),
  };

  const artifactKey = `articles/_indexing_runs/queue-${runId}.json`;
  await env.ARTICLES.put(artifactKey, JSON.stringify(run, null, 2), {
    httpMetadata: { contentType: "application/json" },
  });
  await env.ARTICLES.put(INDEX_QUEUE_SUMMARY_KEY, JSON.stringify(run, null, 2), {
    httpMetadata: { contentType: "application/json" },
  });

  return { run, artifactKey };
}

async function loadLastQueueRun(env: Env): Promise<IndexQueueRunArtifact | null> {
  const obj = await env.ARTICLES.get(INDEX_QUEUE_SUMMARY_KEY);
  if (!obj) return null;
  try {
    return await obj.json<IndexQueueRunArtifact>();
  } catch {
    return null;
  }
}

async function loadArticle(env: Env, slug: string): Promise<Article | null> {
  const key = `articles/${slug}.json`;
  const obj = await env.ARTICLES.get(key);
  if (!obj) return null;
  const data = await obj.json<Article>();
  if ((data as any).error) return null;
  return data;
}

async function loadManifest(env: Env): Promise<Record<string, ManifestEntry>> {
  const obj = await env.ARTICLES.get("articles/_manifest.json");
  if (!obj) return {};
  try {
    const parsed = await obj.json<Record<string, ManifestEntry>>();
    return parsed && typeof parsed === "object" ? parsed : {};
  } catch {
    return {};
  }
}

function slugFromPath(pathname: string): string {
  return pathname.replace(/^\//, "").replace(/\/$/, "");
}

function normalizeSearchQuery(raw: string | null): string {
  return (raw ?? "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, " ")
    .slice(0, 120);
}

function categoryLabel(category: string): string {
  return category.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
}

const STATIC_SEARCH_DOCS: SearchDocument[] = [
  {
    path: "/",
    title: "Claw EA | Enterprise AI Agents, Deployed and Verified",
    description: "Deploy managed AI agents for your enterprise with cryptographic attestation and policy controls.",
    category: "landing",
    kind: "static",
  },
  {
    path: "/pricing",
    title: "Pricing | Claw EA Enterprise AI Agents",
    description: "Pricing plans for enterprise AI agent infrastructure.",
    category: "pricing",
    kind: "static",
  },
  {
    path: "/assessment",
    title: "AI Readiness Assessment | Claw EA",
    description: "Two-minute assessment for enterprise AI readiness, expected ROI, and rollout risk posture.",
    category: "assessment",
    kind: "static",
  },
  {
    path: "/sources",
    title: "Citation Source Hub | Claw EA",
    description: "Citation routing hub for source-backed enterprise AI implementation pages.",
    category: "sources",
    kind: "static",
  },
  {
    path: "/contact",
    title: "Contact Sales | Claw EA Enterprise AI Agents",
    description: "Talk to Claw EA enterprise sales.",
    category: "contact",
    kind: "static",
  },
  {
    path: "/trust",
    title: "Trust Layer | Verified AI Agent Execution | Claw EA",
    description: "Cryptographic proof of AI agent actions.",
    category: "trust",
    kind: "static",
  },
  {
    path: "/secure-workers",
    title: "Secure AI Workers | Sandboxed Enterprise Agents | Claw EA",
    description: "Hardware-isolated secure AI workers with strict policy enforcement.",
    category: "trust",
    kind: "static",
  },
  {
    path: "/consulting",
    title: "Enterprise AI Consulting | Agent Strategy & Deployment | Claw EA",
    description: "Consulting services for deployment and governance of AI agent programs.",
    category: "consulting",
    kind: "static",
  },
  {
    path: "/about",
    title: "About Claw Bureau | Enterprise AI Trust Infrastructure",
    description: "About Claw Bureau and the trust infrastructure approach for enterprise AI.",
    category: "about",
    kind: "static",
  },
  {
    path: "/glossary",
    title: "Glossary | Claw EA",
    description: "Glossary of enterprise AI policy, proof, and control terms.",
    category: "glossary",
    kind: "static",
  },
];

function buildSearchCorpus(manifest: Record<string, ManifestEntry>): SearchDocument[] {
  const manifestDocs: SearchDocument[] = Object.entries(manifest)
    .filter(([, entry]) => Boolean(entry?.title))
    .map(([slug, entry]) => ({
      path: `/${slug}`,
      title: entry.title,
      description: entry.description,
      category: entry.category,
      kind: "article" as const,
    }));

  const map = new Map<string, SearchDocument>();
  for (const doc of [...manifestDocs, ...STATIC_SEARCH_DOCS]) {
    map.set(doc.path, doc);
  }
  return [...map.values()];
}

function searchCorpus(corpus: SearchDocument[], query: string, limit = 30): SearchResult[] {
  if (!query) return [];
  const tokens = [...new Set(query.split(/[^a-z0-9]+/g).filter((t) => t.length >= 2))];
  const out: SearchResult[] = [];

  for (const doc of corpus) {
    const title = doc.title.toLowerCase();
    const desc = (doc.description ?? "").toLowerCase();
    const pathText = doc.path.toLowerCase().replace(/\//g, " ");
    const categoryText = doc.category.toLowerCase();

    let score = 0;
    if (title.includes(query)) score += 120;
    if (pathText.includes(query)) score += 95;
    if (desc.includes(query)) score += 45;
    if (categoryText.includes(query)) score += 30;

    for (const t of tokens) {
      if (title.startsWith(t)) score += 25;
      if (title.includes(t)) score += 18;
      if (pathText.includes(t)) score += 15;
      if (desc.includes(t)) score += 8;
      if (categoryText.includes(t)) score += 6;
    }

    if (doc.kind === "article") score += 6;
    if (score <= 0) continue;

    out.push({ ...doc, score });
  }

  return out
    .sort((a, b) => (b.score - a.score) || a.path.localeCompare(b.path, "en"))
    .slice(0, limit);
}

function previewText(input: string, max = 220): string {
  const cleaned = input.replace(/\s+/g, " ").trim();
  if (cleaned.length <= max) return cleaned;
  return `${cleaned.slice(0, max - 1)}…`;
}

function glossarySearchPage(query: string, results: SearchResult[]): string {
  const q = query.trim();
  const hasResults = results.length > 0;
  const body = hasResults
    ? `<div class="search-results">${results
        .map(
          (r) => `<a class="search-result-card" href="${r.path}">
            <div class="search-result-meta">
              <span class="badge badge-blue">${esc(categoryLabel(r.category))}</span>
              <span class="search-pill">${esc(r.path)}</span>
            </div>
            <div class="search-result-title">${esc(r.title.replace(/ \| Claw EA$/, ""))}</div>
            <p class="search-result-desc">${esc(previewText(r.description, 240))}</p>
          </a>`,
        )
        .join("")}</div>`
    : `<div class="search-empty">
        No exact matches for <strong>${esc(q)}</strong>. Try a tool name (e.g. <em>okta</em>), a control (e.g. <em>dlp</em>), or a workflow phrase (e.g. <em>approval gate</em>).
      </div>`;

  return layout({
    meta: {
      title: `Search: ${q} | Claw EA`,
      description: `Search Claw EA policy, workflow, tool, and glossary content for “${q}”.`,
      path: "/glossary",
      canonicalPath: "/glossary",
      noindex: true,
      ogImageAlt: `Search results for ${q}`,
    },
    breadcrumbs: [
      { name: "Home", path: "/" },
      { name: "Glossary", path: "/glossary" },
      { name: `Search: ${q}`, path: "/glossary" },
    ],
    body: `
    <section class="section content-page">
      <div class="wrap">
        <h1>Search results</h1>
        <p class="search-summary">
          <span class="search-pill">Query: ${esc(q)}</span>
          <span>${results.length} result${results.length === 1 ? "" : "s"}</span>
        </p>
        <form class="card" role="search" action="/glossary" method="get" style="max-width:780px;padding:1rem 1.2rem;display:flex;gap:.6rem;align-items:center;flex-wrap:wrap">
          <label for="glossary-search-input" class="sr-only">Refine search query</label>
          <input id="glossary-search-input" type="search" name="q" value="${esc(q)}" placeholder="Search controls, workflows, tools..." style="flex:1;min-width:200px;border:1px solid var(--border);background:var(--surface-2);color:var(--text);padding:.6rem .75rem;border-radius:.6rem">
          <button type="submit" class="cta-btn" data-cta="glossary-search-submit">Search</button>
        </form>
        ${body}
      </div>
    </section>`,
  });
}

type TrackingEventType =
  | "cta_click"
  | "contact_intent_view"
  | "contact_email_click"
  | "contact_intent_submit"
  | "lead_submit"
  | "variant_assignment"
  | "search_query"
  | "search_result_click"
  | "search_clear";

type TrackingEvent = {
  eventType: TrackingEventType;
  page: string;
  pageFamily: string;
  href?: string;
  ctaId?: string;
  ctaVariant?: string;
  actionOutcome?: string;
  query?: string;
  resultCount?: number;
  targetPath?: string;
  variantId?: string;
  heroVariant?: string;
  visitorId?: string;
  ts: string;
  source: string;
  attribution: Record<string, string>;
  context: {
    referrer?: string;
    country?: string;
    userAgent?: string;
    ipClassC?: string;
  };
};

const TRACKING_EVENT_TYPES = new Set<TrackingEventType>([
  "cta_click",
  "contact_intent_view",
  "contact_email_click",
  "contact_intent_submit",
  "lead_submit",
  "variant_assignment",
  "search_query",
  "search_result_click",
  "search_clear",
]);

function clipString(input: unknown, maxLen: number): string | undefined {
  if (typeof input !== "string") return undefined;
  const v = input.trim();
  if (!v) return undefined;
  return v.slice(0, maxLen);
}

function pageFamilyFromPath(input: string | undefined): string {
  const path = (input ?? "/").trim();
  if (!path || path === "/") return "home";
  const parts = path.replace(/^\//, "").split("/").filter(Boolean);
  if (parts.length === 0) return "home";

  const known = new Set([
    "controls",
    "workflows",
    "tools",
    "channels",
    "policy",
    "proof",
    "verify",
    "audit",
    "mcp",
    "supply-chain",
    "events",
    "compliance",
    "guides",
    "glossary",
    "trust",
    "secure-workers",
    "consulting",
    "pricing",
    "contact",
    "assessment",
    "sources",
    "about",
  ]);

  const first = parts[0];
  if (known.has(first)) return first;
  return "root";
}

function normalizeResultCount(input: unknown): number | undefined {
  const n = Number(input);
  if (!Number.isFinite(n) || n < 0) return undefined;
  return Math.min(100_000, Math.floor(n));
}

function normalizeAttribution(input: unknown): Record<string, string> {
  const src = typeof input === "object" && input !== null ? (input as Record<string, unknown>) : {};

  const allowedKeys = [
    "utm_source",
    "utm_medium",
    "utm_campaign",
    "utm_term",
    "utm_content",
    "gclid",
    "fbclid",
    "msclkid",
    "referrer_host",
    "landing_path",
    "source",
    "first_touch_ts",
    "first_touch_path",
    "first_touch_page_family",
  ];

  const out: Record<string, string> = {};
  for (const key of allowedKeys) {
    const v = clipString(src[key], 160);
    if (v) out[key] = v;
  }

  return out;
}

function deriveSource(attribution: Record<string, string>): string {
  if (attribution.source) return attribution.source;
  if (attribution.utm_source) return `utm:${attribution.utm_source}`;
  if (attribution.referrer_host) return `ref:${attribution.referrer_host}`;
  return "direct";
}

function anonymizeIpClassC(ip: string | null): string | undefined {
  if (!ip) return undefined;
  const m = ip.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/);
  if (!m) return undefined;
  return `${m[1]}.${m[2]}.${m[3]}.x`;
}

async function ingestTrackingEvent(request: Request, env: Env): Promise<Response> {
  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  let body: any;
  try {
    body = await request.json<any>();
  } catch {
    return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
  }

  const eventTypeRaw = clipString(body?.eventType, 64);
  const eventType = eventTypeRaw && TRACKING_EVENT_TYPES.has(eventTypeRaw as TrackingEventType)
    ? (eventTypeRaw as TrackingEventType)
    : null;

  if (!eventType) {
    return apiError("EVENT_TYPE_INVALID", "eventType is missing or not allowed", 400);
  }

  const page = clipString(body?.page, 240) ?? "/";
  const pageFamily = clipString(body?.pageFamily, 80) ?? pageFamilyFromPath(page);
  const ts = clipString(body?.ts, 80) ?? new Date().toISOString();
  const parsedTs = Number.isNaN(Date.parse(ts)) ? new Date().toISOString() : ts;

  const attribution = normalizeAttribution(body?.attribution);

  const event: TrackingEvent = {
    eventType,
    page,
    pageFamily,
    href: clipString(body?.href, 500),
    ctaId: clipString(body?.ctaId, 160),
    ctaVariant: clipString(body?.ctaVariant, 120),
    actionOutcome: clipString(body?.actionOutcome, 120),
    query: clipString(body?.query, 120),
    resultCount: normalizeResultCount(body?.resultCount),
    targetPath: clipString(body?.targetPath, 240),
    variantId: clipString(body?.variantId, 120),
    heroVariant: clipString(body?.heroVariant, 120),
    visitorId: clipString(body?.visitorId, 140),
    ts: parsedTs,
    source: deriveSource(attribution),
    attribution,
    context: {
      referrer: clipString(request.headers.get("referer"), 500),
      country: clipString(request.headers.get("cf-ipcountry"), 8),
      userAgent: clipString(request.headers.get("user-agent"), 180),
      ipClassC: anonymizeIpClassC(request.headers.get("cf-connecting-ip")),
    },
  };

  const day = event.ts.slice(0, 10);
  const random = typeof crypto.randomUUID === "function"
    ? crypto.randomUUID().slice(0, 8)
    : Math.random().toString(36).slice(2, 10);
  const key = `events/${day}/${event.ts.replace(/[:.]/g, "-")}-${random}.json`;

  await env.ARTICLES.put(key, JSON.stringify(event), {
    httpMetadata: { contentType: "application/json" },
  });

  await persistTrackingEventD1(env, event);

  return apiJson({ ok: true, eventId: key });
}

async function listTrackingEvents(env: Env, fromMs: number, toMs: number): Promise<TrackingEvent[]> {
  const out: TrackingEvent[] = [];
  let cursor: string | undefined;

  while (true) {
    const listed = await env.ARTICLES.list({
      prefix: "events/",
      cursor,
      limit: 1000,
    });

    for (const obj of listed.objects) {
      const file = await env.ARTICLES.get(obj.key);
      if (!file) continue;

      try {
        const evRaw = await file.json<TrackingEvent>();
        const ev: TrackingEvent = {
          ...evRaw,
          pageFamily: clipString((evRaw as any)?.pageFamily, 80) ?? pageFamilyFromPath((evRaw as any)?.page),
        };

        const tsMs = Date.parse(ev.ts);
        if (Number.isNaN(tsMs) || tsMs < fromMs || tsMs > toMs) continue;
        if (!TRACKING_EVENT_TYPES.has(ev.eventType)) continue;
        out.push(ev);
      } catch {
        // ignore malformed rows
      }
    }

    if (!listed.truncated || !listed.cursor) break;
    cursor = listed.cursor;
  }

  return out;
}

function topCounts(map: Map<string, number>, limit = 10): Array<{ key: string; count: number }> {
  return [...map.entries()]
    .sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0], "en"))
    .slice(0, limit)
    .map(([key, count]) => ({ key, count }));
}

async function summarizeTrackingEvents(request: Request, env: Env): Promise<Response> {
  const authError = checkAutomationAuth(request, env);
  if (authError) return authError;

  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  let body: any = {};
  try {
    body = await request.json<any>();
  } catch {
    // allow empty JSON body
  }

  const daysRaw = Number(body?.days ?? 7);
  const days = Number.isFinite(daysRaw) ? Math.min(90, Math.max(1, Math.floor(daysRaw))) : 7;

  const nowMs = Date.now();
  const fromRaw = clipString(body?.from, 80);
  const toRaw = clipString(body?.to, 80);

  const fallbackFromMs = nowMs - (days * 24 * 60 * 60 * 1000);
  const fromMs = fromRaw ? Date.parse(fromRaw) : fallbackFromMs;
  const toMs = toRaw ? Date.parse(toRaw) : nowMs;

  if (Number.isNaN(fromMs) || Number.isNaN(toMs) || fromMs > toMs) {
    return apiError("DATE_RANGE_INVALID", "Invalid from/to date range", 400);
  }

  const events = await listTrackingEvents(env, fromMs, toMs);

  const byType = new Map<string, number>();
  const bySource = new Map<string, number>();
  const byPage = new Map<string, number>();
  const byPageFamily = new Map<string, number>();
  const byCta = new Map<string, number>();
  const byCtaVariant = new Map<string, number>();
  const byVariantId = new Map<string, number>();
  const byHeroVariant = new Map<string, number>();
  const byOutcome = new Map<string, number>();

  const variantOutcome = new Map<string, { impressions: number; clicks: number; submits: number }>();

  const searchQueryCount = new Map<string, number>();
  const searchQueryClicks = new Map<string, number>();
  const searchQueryResultsSum = new Map<string, number>();

  const ctaFamilyViews = new Map<string, number>();
  const ctaFamilyActions = new Map<string, number>();
  const ctaFamilyClicks = new Map<string, number>();

  let contactIntentViews = 0;
  let contactIntentActions = 0;
  let searchQueries = 0;
  let searchResultClicks = 0;

  for (const ev of events) {
    byType.set(ev.eventType, (byType.get(ev.eventType) ?? 0) + 1);
    bySource.set(ev.source, (bySource.get(ev.source) ?? 0) + 1);
    byPage.set(ev.page, (byPage.get(ev.page) ?? 0) + 1);
    byPageFamily.set(ev.pageFamily, (byPageFamily.get(ev.pageFamily) ?? 0) + 1);

    const ctaKey = ev.ctaId ?? ev.href ?? "unknown";
    if (ev.eventType === "cta_click" || ev.eventType === "contact_email_click") {
      byCta.set(ctaKey, (byCta.get(ctaKey) ?? 0) + 1);
    }

    if (ev.ctaVariant) {
      byCtaVariant.set(ev.ctaVariant, (byCtaVariant.get(ev.ctaVariant) ?? 0) + 1);
    }

    if (ev.variantId) {
      byVariantId.set(ev.variantId, (byVariantId.get(ev.variantId) ?? 0) + 1);

      const current = variantOutcome.get(ev.variantId) ?? { impressions: 0, clicks: 0, submits: 0 };
      if (ev.eventType === "variant_assignment") current.impressions += 1;
      if (ev.eventType === "cta_click") current.clicks += 1;
      if (ev.eventType === "contact_intent_submit" || ev.eventType === "lead_submit") current.submits += 1;
      variantOutcome.set(ev.variantId, current);
    }

    if (ev.heroVariant) {
      byHeroVariant.set(ev.heroVariant, (byHeroVariant.get(ev.heroVariant) ?? 0) + 1);
    }

    if (ev.actionOutcome) {
      byOutcome.set(ev.actionOutcome, (byOutcome.get(ev.actionOutcome) ?? 0) + 1);
    }

    if (ev.eventType === "contact_intent_view") {
      contactIntentViews += 1;
      ctaFamilyViews.set(ev.pageFamily, (ctaFamilyViews.get(ev.pageFamily) ?? 0) + 1);
    }

    if (ev.eventType === "cta_click") {
      ctaFamilyClicks.set(ev.pageFamily, (ctaFamilyClicks.get(ev.pageFamily) ?? 0) + 1);
    }

    if (ev.eventType === "contact_email_click" || ev.eventType === "contact_intent_submit" || ev.eventType === "lead_submit") {
      contactIntentActions += 1;
      ctaFamilyActions.set(ev.pageFamily, (ctaFamilyActions.get(ev.pageFamily) ?? 0) + 1);
    }

    if (ev.eventType === "search_query" && ev.query) {
      searchQueries += 1;
      searchQueryCount.set(ev.query, (searchQueryCount.get(ev.query) ?? 0) + 1);
      const rc = typeof ev.resultCount === "number" ? ev.resultCount : 0;
      searchQueryResultsSum.set(ev.query, (searchQueryResultsSum.get(ev.query) ?? 0) + rc);
    }

    if (ev.eventType === "search_result_click") {
      searchResultClicks += 1;
      if (ev.query) {
        searchQueryClicks.set(ev.query, (searchQueryClicks.get(ev.query) ?? 0) + 1);
      }
    }
  }

  const intentToActionRate = contactIntentViews > 0
    ? Number((contactIntentActions / contactIntentViews).toFixed(4))
    : 0;
  const searchToClickRate = searchQueries > 0
    ? Number((searchResultClicks / searchQueries).toFixed(4))
    : 0;

  const topSearchQueries = [...searchQueryCount.entries()]
    .map(([query, queries]) => {
      const clicks = searchQueryClicks.get(query) ?? 0;
      const resultsTotal = searchQueryResultsSum.get(query) ?? 0;
      return {
        query,
        queries,
        clicks,
        ctr: queries > 0 ? Number((clicks / queries).toFixed(4)) : 0,
        avgResults: queries > 0 ? Number((resultsTotal / queries).toFixed(2)) : 0,
      };
    })
    .sort((a, b) => (b.queries - a.queries) || a.query.localeCompare(b.query, "en"))
    .slice(0, 20);

  const ctaByPageFamily = [...new Set([
    ...ctaFamilyViews.keys(),
    ...ctaFamilyActions.keys(),
    ...ctaFamilyClicks.keys(),
  ])]
    .map((family) => {
      const views = ctaFamilyViews.get(family) ?? 0;
      const actions = ctaFamilyActions.get(family) ?? 0;
      const clicks = ctaFamilyClicks.get(family) ?? 0;
      return {
        pageFamily: family,
        views,
        clicks,
        actions,
        actionRate: views > 0 ? Number((actions / views).toFixed(4)) : 0,
      };
    })
    .sort((a, b) => (b.actions - a.actions) || a.pageFamily.localeCompare(b.pageFamily, "en"));

  const variantPerformance = [...variantOutcome.entries()]
    .map(([variantId, row]) => ({
      variantId,
      impressions: row.impressions,
      clicks: row.clicks,
      submits: row.submits,
      clickRate: row.impressions > 0 ? Number((row.clicks / row.impressions).toFixed(4)) : 0,
      submitRate: row.impressions > 0 ? Number((row.submits / row.impressions).toFixed(4)) : 0,
    }))
    .sort((a, b) => (b.submitRate - a.submitRate) || (b.impressions - a.impressions) || a.variantId.localeCompare(b.variantId, "en"))
    .slice(0, 40);

  const queue = await loadIndexQueue(env);
  const queueSummary = summarizeIndexQueue(queue);
  const lastQueueRun = await loadLastQueueRun(env);

  return apiJson({
    ok: true,
    range: {
      from: new Date(fromMs).toISOString(),
      to: new Date(toMs).toISOString(),
      days,
    },
    generatedAt: new Date().toISOString(),
    totals: {
      events: events.length,
      contactIntentViews,
      contactIntentActions,
      intentToActionRate,
      searchQueries,
      searchResultClicks,
      searchToClickRate,
    },
    breakdown: {
      byType: topCounts(byType, 30),
      bySource: topCounts(bySource, 30),
      topPages: topCounts(byPage, 30),
      byPageFamily: topCounts(byPageFamily, 30),
      topCtas: topCounts(byCta, 30),
      byCtaVariant: topCounts(byCtaVariant, 30),
      byVariantId: topCounts(byVariantId, 40),
      byHeroVariant: topCounts(byHeroVariant, 40),
      byOutcome: topCounts(byOutcome, 30),
    },
    funnel: {
      search: {
        queries: searchQueries,
        clicks: searchResultClicks,
        searchToClickRate,
        topQueries: topSearchQueries,
      },
      ctaByPageFamily,
      variants: variantPerformance,
    },
    indexing: {
      queue: queueSummary,
      lastRun: lastQueueRun,
    },
  });
}

function envFlag(value: string | undefined, fallback = false): boolean {
  if (value === undefined) return fallback;
  const v = value.trim().toLowerCase();
  if (!v) return fallback;
  return v === "1" || v === "true" || v === "yes" || v === "on";
}

function randomId(prefix = "id"): string {
  const raw = typeof crypto.randomUUID === "function"
    ? crypto.randomUUID().replace(/-/g, "")
    : Math.random().toString(36).slice(2) + Date.now().toString(36);
  return `${prefix}_${raw.slice(0, 24)}`;
}

function base64Url(bytes: Uint8Array): string {
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }

  const b64 = btoa(binary);
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

async function sha256Base64Url(input: string): Promise<string> {
  const data = new TextEncoder().encode(input);
  const digest = await crypto.subtle.digest("SHA-256", data);
  return base64Url(new Uint8Array(digest));
}

function normalizeEmail(input: string | undefined): string {
  return (input ?? "").trim().toLowerCase();
}

function safeJsonParse<T>(raw: string | null, fallback: T): T {
  if (!raw) return fallback;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return fallback;
  }
}

function normalizeLeadPayload(body: any): LeadSubmissionPayload {
  return {
    fullName: clipString(body?.fullName, 120),
    email: clipString(body?.email, 200),
    company: clipString(body?.company, 160),
    role: clipString(body?.role, 120),
    teamSize: clipString(body?.teamSize, 80),
    timeline: clipString(body?.timeline, 120),
    primaryUseCase: clipString(body?.primaryUseCase, 600),
    intentNote: clipString(body?.intentNote, 1200),
    assessment: {
      readinessScore: normalizeResultCount(body?.assessment?.readinessScore),
      roiScore: normalizeResultCount(body?.assessment?.roiScore),
      riskScore: normalizeResultCount(body?.assessment?.riskScore),
      confidenceLabel: clipString(body?.assessment?.confidenceLabel, 80),
    },
    attribution: normalizeAttribution(body?.attribution),
    firstTouch: {
      ts: clipString(body?.firstTouch?.ts, 80),
      path: clipString(body?.firstTouch?.path, 240),
      pageFamily: clipString(body?.firstTouch?.pageFamily, 80),
      source: clipString(body?.firstTouch?.source, 80),
    },
    page: clipString(body?.page, 240),
    pageFamily: clipString(body?.pageFamily, 80),
    turnstileToken: clipString(body?.turnstileToken, 3000),
    idempotencyKey: clipString(body?.idempotencyKey, 160),
  };
}

function scoreLeadIntent(payload: LeadSubmissionPayload): {
  intentScore: number;
  readinessScore: number;
  roiScore: number;
  riskScore: number;
  qualificationScore: number;
  confidenceLabel: string;
} {
  const baseReadiness = Math.min(100, Math.max(0, Number(payload.assessment?.readinessScore ?? 0)));
  const baseRoi = Math.min(100, Math.max(0, Number(payload.assessment?.roiScore ?? 0)));
  const baseRisk = Math.min(100, Math.max(0, Number(payload.assessment?.riskScore ?? 40)));

  const teamBoost = (() => {
    const t = (payload.teamSize ?? "").toLowerCase();
    if (/(500|1000|enterprise|global)/.test(t)) return 15;
    if (/(100|200|300|400)/.test(t)) return 10;
    if (/(50|75)/.test(t)) return 6;
    return 2;
  })();

  const timelineBoost = (() => {
    const t = (payload.timeline ?? "").toLowerCase();
    if (/(now|immediate|this week|2 weeks)/.test(t)) return 14;
    if (/(30|month|q1|q2|q3|q4)/.test(t)) return 8;
    if (/(quarter|90)/.test(t)) return 4;
    return 1;
  })();

  const intentSignals = [
    payload.primaryUseCase,
    payload.intentNote,
  ].join(" ").toLowerCase();

  const urgencyBoost = /(approval|security|audit|compliance|risk|incident|production|rollout)/.test(intentSignals)
    ? 10
    : 0;

  const intentScore = Math.min(100, baseReadiness + teamBoost + timelineBoost + urgencyBoost);
  const readinessScore = Math.min(100, Math.max(0, baseReadiness || Math.round(intentScore * 0.75)));
  const roiScore = Math.min(100, Math.max(0, baseRoi || Math.round(intentScore * 0.7)));
  const riskScore = Math.min(100, Math.max(0, baseRisk));

  const qualificationScore = Math.max(
    0,
    Math.min(
      100,
      Math.round((intentScore * 0.38) + (readinessScore * 0.28) + (roiScore * 0.24) + ((100 - riskScore) * 0.1)),
    ),
  );

  const confidenceLabel = qualificationScore >= 78
    ? "high-intent"
    : qualificationScore >= 55
      ? "medium-intent"
      : "early-intent";

  return {
    intentScore,
    readinessScore,
    roiScore,
    riskScore,
    qualificationScore,
    confidenceLabel,
  };
}

async function verifyTurnstile(token: string | undefined, request: Request, env: Env): Promise<{ ok: boolean; error?: string }> {
  const required = envFlag(env.TURNSTILE_REQUIRED, true);
  const secret = env.TURNSTILE_SECRET_KEY?.trim();

  if (!required) {
    return { ok: true };
  }

  if (!secret) {
    return { ok: false, error: "TURNSTILE_NOT_CONFIGURED" };
  }

  if (!token) {
    return { ok: false, error: "TURNSTILE_TOKEN_MISSING" };
  }

  try {
    const ip = clipString(request.headers.get("cf-connecting-ip"), 120);
    const form = new URLSearchParams();
    form.set("secret", secret);
    form.set("response", token);
    if (ip) form.set("remoteip", ip);

    const res = await fetch("https://challenges.cloudflare.com/turnstile/v0/siteverify", {
      method: "POST",
      headers: { "content-type": "application/x-www-form-urlencoded" },
      body: form.toString(),
    });

    const payload = safeJsonParse<any>(await res.text(), {});
    if (payload?.success === true) return { ok: true };

    const errorCodes = Array.isArray(payload?.["error-codes"])
      ? payload["error-codes"]
      : [];

    const errCode = errorCodes.length > 0
      ? String(errorCodes[0])
      : "TURNSTILE_VERIFY_FAILED";

    return { ok: false, error: errCode };
  } catch {
    return { ok: false, error: "TURNSTILE_UPSTREAM_UNAVAILABLE" };
  }
}

async function persistTrackingEventD1(env: Env, event: TrackingEvent): Promise<void> {
  try {
    await env.DB.prepare(
      `INSERT INTO funnel_events (
        event_id,
        event_type,
        page,
        page_family,
        source,
        cta_id,
        cta_variant,
        action_outcome,
        query,
        result_count,
        target_path,
        variant_id,
        hero_variant,
        visitor_id,
        attribution_json,
        event_ts,
        created_at
      ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15, ?16, ?17)
      `,
    )
      .bind(
        randomId("ev"),
        event.eventType,
        event.page,
        event.pageFamily,
        event.source,
        event.ctaId ?? null,
        event.ctaVariant ?? null,
        event.actionOutcome ?? null,
        event.query ?? null,
        event.resultCount ?? null,
        event.targetPath ?? null,
        event.variantId ?? null,
        event.heroVariant ?? null,
        event.visitorId ?? null,
        JSON.stringify(event.attribution ?? {}),
        event.ts,
        new Date().toISOString(),
      )
      .run();
  } catch (err) {
    console.error("FUNNEL_EVENT_D1_INSERT_FAILED", err);
  }
}

async function upsertLeadFromPayload(payload: LeadSubmissionPayload, request: Request, env: Env): Promise<{
  leadId: string;
  deduped: boolean;
  idempotentReplay: boolean;
  scores: ReturnType<typeof scoreLeadIntent>;
}> {
  const nowIso = new Date().toISOString();
  const email = normalizeEmail(payload.email);

  if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    throw new Error("EMAIL_INVALID");
  }

  const idempotencyKey = payload.idempotencyKey ?? randomId("idem");

  const idemExisting = await env.DB.prepare(
    `SELECT lead_id FROM lead_idempotency WHERE idempotency_key = ?1 LIMIT 1`,
  ).bind(idempotencyKey).first<{ lead_id: string }>();

  if (idemExisting?.lead_id) {
    return {
      leadId: idemExisting.lead_id,
      deduped: true,
      idempotentReplay: true,
      scores: scoreLeadIntent(payload),
    };
  }

  const salt = env.LEAD_ID_HASH_SALT?.trim() ?? "clawea-www-lead";
  const identityHash = await sha256Base64Url(`${salt}|${email}`);
  const emailHash = await sha256Base64Url(email);

  const page = payload.page ?? "/contact";
  const pageFamily = payload.pageFamily ?? pageFamilyFromPath(page);
  const source = payload.attribution?.source ?? payload.firstTouch?.source ?? "direct";

  const scores = scoreLeadIntent(payload);

  const emailParts = email.split("@");
  const emailHint = emailParts.length === 2
    ? `${emailParts[0].slice(0, 2)}***@${emailParts[1]}`
    : "***";

  const existing = await env.DB.prepare(
    `SELECT lead_id, dedupe_count FROM leads WHERE identity_hash = ?1 LIMIT 1`,
  ).bind(identityHash).first<{ lead_id: string; dedupe_count: number }>();

  const leadId = existing?.lead_id ?? randomId("lead");
  const deduped = Boolean(existing?.lead_id);

  if (!deduped) {
    await env.DB.prepare(
      `INSERT INTO leads (
        lead_id,
        identity_hash,
        email_hash,
        email_hint,
        full_name,
        company,
        role,
        team_size,
        timeline,
        primary_use_case,
        intent_note,
        source,
        page,
        page_family,
        attribution_json,
        first_touch_json,
        assessment_json,
        readiness_score,
        roi_score,
        risk_score,
        intent_score,
        qualification_score,
        status,
        dedupe_count,
        created_at,
        updated_at,
        last_seen_at
      ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15, ?16, ?17, ?18, ?19, ?20, ?21, ?22, ?23, 0, ?24, ?24, ?24)
      `,
    )
      .bind(
        leadId,
        identityHash,
        emailHash,
        emailHint,
        payload.fullName ?? "",
        payload.company ?? "",
        payload.role ?? "",
        payload.teamSize ?? "",
        payload.timeline ?? "",
        payload.primaryUseCase ?? "",
        payload.intentNote ?? "",
        source,
        page,
        pageFamily,
        JSON.stringify(payload.attribution ?? {}),
        JSON.stringify(payload.firstTouch ?? {}),
        JSON.stringify(payload.assessment ?? {}),
        scores.readinessScore,
        scores.roiScore,
        scores.riskScore,
        scores.intentScore,
        scores.qualificationScore,
        (scores.qualificationScore >= 78 ? "qualified" : "new"),
        nowIso,
      )
      .run();
  } else {
    await env.DB.prepare(
      `UPDATE leads
        SET
          full_name = COALESCE(NULLIF(?2,''), full_name),
          company = COALESCE(NULLIF(?3,''), company),
          role = COALESCE(NULLIF(?4,''), role),
          team_size = COALESCE(NULLIF(?5,''), team_size),
          timeline = COALESCE(NULLIF(?6,''), timeline),
          primary_use_case = COALESCE(NULLIF(?7,''), primary_use_case),
          intent_note = COALESCE(NULLIF(?8,''), intent_note),
          source = COALESCE(NULLIF(?9,''), source),
          page = COALESCE(NULLIF(?10,''), page),
          page_family = COALESCE(NULLIF(?11,''), page_family),
          attribution_json = CASE WHEN ?12 <> '{}' THEN ?12 ELSE attribution_json END,
          first_touch_json = CASE WHEN ?13 <> '{}' THEN ?13 ELSE first_touch_json END,
          assessment_json = CASE WHEN ?14 <> '{}' THEN ?14 ELSE assessment_json END,
          readiness_score = MAX(readiness_score, ?15),
          roi_score = MAX(roi_score, ?16),
          risk_score = MIN(risk_score, ?17),
          intent_score = MAX(intent_score, ?18),
          qualification_score = MAX(qualification_score, ?19),
          status = CASE WHEN MAX(qualification_score, ?19) >= 78 THEN 'qualified' ELSE status END,
          dedupe_count = dedupe_count + 1,
          updated_at = ?20,
          last_seen_at = ?20
        WHERE lead_id = ?1
      `,
    )
      .bind(
        leadId,
        payload.fullName ?? "",
        payload.company ?? "",
        payload.role ?? "",
        payload.teamSize ?? "",
        payload.timeline ?? "",
        payload.primaryUseCase ?? "",
        payload.intentNote ?? "",
        source,
        page,
        pageFamily,
        JSON.stringify(payload.attribution ?? {}),
        JSON.stringify(payload.firstTouch ?? {}),
        JSON.stringify(payload.assessment ?? {}),
        scores.readinessScore,
        scores.roiScore,
        scores.riskScore,
        scores.intentScore,
        scores.qualificationScore,
        nowIso,
      )
      .run();
  }

  await env.DB.prepare(
    `INSERT OR IGNORE INTO lead_idempotency (idempotency_key, lead_id, created_at)
     VALUES (?1, ?2, ?3)`,
  ).bind(idempotencyKey, leadId, nowIso).run();

  await env.DB.prepare(
    `INSERT INTO lead_events (
      event_id,
      lead_id,
      event_type,
      event_payload_json,
      source,
      page,
      page_family,
      created_at
    ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)`,
  )
    .bind(
      randomId("lead_evt"),
      leadId,
      deduped ? "lead_deduped" : "lead_submitted",
      JSON.stringify({
        deduped,
        scores,
        emailHint,
        attribution: payload.attribution ?? {},
      }),
      source,
      page,
      pageFamily,
      nowIso,
    )
    .run();

  try {
    await env.LEAD_JOBS.send({
      type: "lead_enrich",
      leadId,
      submittedAt: nowIso,
    });
  } catch (err) {
    console.error("LEAD_QUEUE_SEND_FAILED", err);
  }

  return {
    leadId,
    deduped,
    idempotentReplay: false,
    scores,
  };
}

async function submitLead(request: Request, env: Env): Promise<Response> {
  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  let body: any;
  try {
    body = await request.json<any>();
  } catch {
    return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
  }

  const payload = normalizeLeadPayload(body);

  const turnstile = await verifyTurnstile(payload.turnstileToken, request, env);
  if (!turnstile.ok) {
    return apiError("TURNSTILE_FAILED", turnstile.error ?? "Turnstile validation failed", 403);
  }

  try {
    const saved = await upsertLeadFromPayload(payload, request, env);
    return apiJson({
      ok: true,
      leadId: saved.leadId,
      deduped: saved.deduped,
      idempotentReplay: saved.idempotentReplay,
      confidenceLabel: saved.scores.confidenceLabel,
      qualificationScore: saved.scores.qualificationScore,
      next: saved.scores.qualificationScore >= 78 ? "priority_follow_up" : "standard_follow_up",
    });
  } catch (err: any) {
    const code = String(err?.message ?? "LEAD_SUBMIT_FAILED");
    if (code === "EMAIL_INVALID") {
      return apiError("EMAIL_INVALID", "A valid work email is required", 400);
    }
    console.error("LEAD_SUBMIT_FAILED", err);
    return apiError("LEAD_SUBMIT_FAILED", "Lead intake failed", 500);
  }
}

function csvEscape(value: unknown): string {
  const s = String(value ?? "");
  if (/[",\n]/.test(s)) {
    return `"${s.replace(/"/g, '""')}"`;
  }
  return s;
}

async function leadsStatus(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const totalRow = await env.DB.prepare(`SELECT COUNT(*) AS count FROM leads`).first<{ count: number }>();

  const statusRows = await env.DB.prepare(
    `SELECT status AS key, COUNT(*) AS count FROM leads GROUP BY status ORDER BY count DESC`,
  ).all<{ key: string; count: number }>();

  const sourceRows = await env.DB.prepare(
    `SELECT source AS key, COUNT(*) AS count FROM leads GROUP BY source ORDER BY count DESC LIMIT 20`,
  ).all<{ key: string; count: number }>();

  const familyRows = await env.DB.prepare(
    `SELECT page_family AS key, COUNT(*) AS count FROM leads GROUP BY page_family ORDER BY count DESC LIMIT 20`,
  ).all<{ key: string; count: number }>();

  const recentRows = await env.DB.prepare(
    `SELECT
      lead_id,
      created_at,
      updated_at,
      last_seen_at,
      status,
      qualification_score,
      intent_score,
      risk_score,
      readiness_score,
      roi_score,
      dedupe_count,
      source,
      page,
      page_family,
      full_name,
      company,
      role,
      team_size,
      timeline,
      primary_use_case,
      email_hint
    FROM leads
    ORDER BY last_seen_at DESC
    LIMIT 50`,
  ).all<LeadRow>();

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    totals: {
      leads: Number(totalRow?.count ?? 0),
      recentWindow: Number(recentRows.results?.length ?? 0),
    },
    breakdown: {
      byStatus: statusRows.results ?? [],
      bySource: sourceRows.results ?? [],
      byPageFamily: familyRows.results ?? [],
    },
    recent: (recentRows.results ?? []).map((row) => ({
      leadId: row.lead_id,
      status: row.status,
      qualificationScore: row.qualification_score,
      intentScore: row.intent_score,
      readinessScore: row.readiness_score,
      roiScore: row.roi_score,
      riskScore: row.risk_score,
      dedupeCount: row.dedupe_count,
      source: row.source,
      page: row.page,
      pageFamily: row.page_family,
      company: row.company,
      role: row.role,
      teamSize: row.team_size,
      timeline: row.timeline,
      emailHint: row.email_hint,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      lastSeenAt: row.last_seen_at,
    })),
  });
}

async function leadsExport(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const url = new URL(request.url);
  const format = (clipString(url.searchParams.get("format"), 12) ?? "json").toLowerCase();
  const statusFilter = clipString(url.searchParams.get("status"), 32);
  const limit = Math.min(2000, Math.max(1, Number(url.searchParams.get("limit") ?? "500")));

  let sql = `SELECT
    lead_id,
    status,
    qualification_score,
    intent_score,
    readiness_score,
    roi_score,
    risk_score,
    dedupe_count,
    source,
    page,
    page_family,
    company,
    role,
    team_size,
    timeline,
    primary_use_case,
    email_hint,
    created_at,
    updated_at,
    last_seen_at
  FROM leads`;

  const binds: Array<string | number> = [];
  if (statusFilter) {
    sql += ` WHERE status = ?1`;
    binds.push(statusFilter);
  }

  sql += ` ORDER BY last_seen_at DESC LIMIT ${limit}`;

  const rows = await env.DB.prepare(sql).bind(...binds).all<Record<string, unknown>>();
  const results = rows.results ?? [];

  if (format === "csv") {
    const headers = [
      "lead_id",
      "status",
      "qualification_score",
      "intent_score",
      "readiness_score",
      "roi_score",
      "risk_score",
      "dedupe_count",
      "source",
      "page",
      "page_family",
      "company",
      "role",
      "team_size",
      "timeline",
      "primary_use_case",
      "email_hint",
      "created_at",
      "updated_at",
      "last_seen_at",
    ];

    const lines = [headers.join(",")];
    for (const row of results) {
      lines.push(headers.map((h) => csvEscape(row[h])).join(","));
    }

    return new Response(lines.join("\n"), {
      status: 200,
      headers: apiHeaders({
        "content-type": "text/csv;charset=utf-8",
        "content-disposition": `attachment; filename="clawea-leads-${new Date().toISOString().slice(0, 10)}.csv"`,
      }),
    });
  }

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    count: results.length,
    leads: results,
  });
}

async function experimentsWinners(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const url = new URL(request.url);
  const date = clipString(url.searchParams.get("date"), 10);

  let key = date ? `reports/growth/variant-performance-${date}.json` : null;

  if (!key) {
    const listed = await env.ARTICLES.list({
      prefix: "reports/growth/variant-performance-",
      limit: 100,
    });

    const latest = listed.objects
      .map((o) => o.key)
      .filter((k) => k.startsWith("reports/growth/variant-performance-") && k.endsWith(".json"))
      .sort((a, b) => b.localeCompare(a, "en"))[0];

    key = latest ?? null;
  }

  if (!key) {
    return apiError("REPORT_NOT_FOUND", "No variant report found", 404);
  }

  const obj = await env.ARTICLES.get(key);
  if (!obj) {
    return apiError("REPORT_NOT_FOUND", `Variant report not found for key ${key}`, 404);
  }

  const parsed = safeJsonParse(await obj.text(), null);
  return apiJson({
    ok: true,
    key,
    report: parsed,
  });
}

function stableHash(input: string): number {
  let hash = 2166136261;
  for (let i = 0; i < input.length; i++) {
    hash ^= input.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return hash >>> 0;
}

async function loadExperimentConfig(env: Env): Promise<ExperimentVariantConfig> {
  const key = env.EXPERIMENT_CONFIG_KEY?.trim() || "experiment-config-v1";

  try {
    const raw = await env.VARIANT_CONFIG.get(key, "text");
    if (!raw) {
      return {
        ...DEFAULT_EXPERIMENT_CONFIG,
        seed: env.EXPERIMENT_SEED?.trim() || DEFAULT_EXPERIMENT_CONFIG.seed,
      };
    }

    const parsed = safeJsonParse<ExperimentVariantConfig>(raw, DEFAULT_EXPERIMENT_CONFIG);
    const seed = clipString(parsed?.seed, 120) ?? env.EXPERIMENT_SEED?.trim() ?? DEFAULT_EXPERIMENT_CONFIG.seed;
    const families = parsed?.families && typeof parsed.families === "object"
      ? parsed.families
      : DEFAULT_EXPERIMENT_CONFIG.families;

    return { seed, families };
  } catch {
    return {
      ...DEFAULT_EXPERIMENT_CONFIG,
      seed: env.EXPERIMENT_SEED?.trim() || DEFAULT_EXPERIMENT_CONFIG.seed,
    };
  }
}

function assignVariant(config: ExperimentVariantConfig, visitorId: string, pageFamily: string): {
  pageFamily: string;
  heroVariant: string;
  ctaVariant: string;
} {
  const family = pageFamily || "root";
  const familyConfig = config.families[family] ?? config.families.root ?? { hero: ["proof"], cta: ["sales"] };

  const heroOptions = familyConfig.hero.length > 0 ? familyConfig.hero : ["proof"];
  const ctaOptions = familyConfig.cta.length > 0 ? familyConfig.cta : ["sales"];

  const heroHash = stableHash(`${config.seed}|hero|${family}|${visitorId}`);
  const ctaHash = stableHash(`${config.seed}|cta|${family}|${visitorId}`);

  const heroVariant = heroOptions[heroHash % heroOptions.length];
  const ctaVariant = ctaOptions[ctaHash % ctaOptions.length];

  return {
    pageFamily: family,
    heroVariant,
    ctaVariant,
  };
}

function readCookie(request: Request, name: string): string | null {
  const cookies = request.headers.get("cookie") ?? "";
  const entries = cookies.split(";").map((x) => x.trim());
  for (const entry of entries) {
    const [k, ...rest] = entry.split("=");
    if (!k || rest.length === 0) continue;
    if (k === name) return decodeURIComponent(rest.join("="));
  }
  return null;
}

function getOrCreateVisitorId(request: Request): { visitorId: string; cookieNeeded: boolean } {
  const existing = clipString(readCookie(request, "clawea_vid"), 120);
  if (existing) {
    return { visitorId: existing, cookieNeeded: false };
  }

  return {
    visitorId: randomId("vid"),
    cookieNeeded: true,
  };
}

function applyExperimentCookies(response: Response, visitorId: string, assignment: {
  pageFamily: string;
  heroVariant: string;
  ctaVariant: string;
}, setVisitorCookie: boolean, setExperimentCookie: boolean): Response {
  const headers = new Headers(response.headers);
  if (setVisitorCookie) {
    headers.append(
      "set-cookie",
      `clawea_vid=${encodeURIComponent(visitorId)}; Path=/; Max-Age=31536000; SameSite=Lax; Secure`,
    );
  }

  if (setExperimentCookie) {
    headers.append(
      "set-cookie",
      `clawea_exp=${encodeURIComponent(`${assignment.pageFamily}:${assignment.heroVariant}:${assignment.ctaVariant}`)}; Path=/; Max-Age=2592000; SameSite=Lax; Secure`,
    );
  }

  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers,
  });
}

async function experimentAssignmentEndpoint(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const url = new URL(request.url);
  const visitorId = clipString(url.searchParams.get("visitorId"), 120)
    ?? getOrCreateVisitorId(request).visitorId;
  const pageFamily = clipString(url.searchParams.get("pageFamily"), 80) ?? "root";

  const config = await loadExperimentConfig(env);
  const assignment = assignVariant(config, visitorId, pageFamily);

  return apiJson({
    ok: true,
    visitorId,
    seed: config.seed,
    assignment,
  });
}

async function leadJobsQueue(batch: MessageBatch<any>, env: Env): Promise<void> {
  for (const message of batch.messages) {
    const payload = message.body as Record<string, unknown>;
    const type = String(payload?.type ?? "");

    try {
      if (type === "lead_enrich") {
        const leadId = clipString(payload?.leadId, 80);
        if (!leadId) {
          message.ack();
          continue;
        }

        const lead = await env.DB.prepare(
          `SELECT
            lead_id,
            qualification_score,
            intent_score,
            readiness_score,
            roi_score,
            risk_score,
            status,
            source,
            page,
            page_family
          FROM leads
          WHERE lead_id = ?1
          LIMIT 1`,
        ).bind(leadId).first<any>();

        if (!lead) {
          message.ack();
          continue;
        }

        const status = Number(lead.qualification_score ?? 0) >= 78
          ? "qualified"
          : Number(lead.qualification_score ?? 0) >= 55
            ? "enriched"
            : "new";

        const nowIso = new Date().toISOString();

        await env.DB.prepare(
          `UPDATE leads SET status = ?2, updated_at = ?3 WHERE lead_id = ?1`,
        ).bind(leadId, status, nowIso).run();

        await env.DB.prepare(
          `INSERT INTO lead_events (
            event_id,
            lead_id,
            event_type,
            event_payload_json,
            source,
            page,
            page_family,
            created_at
          ) VALUES (?1, ?2, 'lead_enriched', ?3, ?4, ?5, ?6, ?7)`,
        )
          .bind(
            randomId("lead_evt"),
            leadId,
            JSON.stringify({
              status,
              qualificationScore: lead.qualification_score,
              intentScore: lead.intent_score,
              readinessScore: lead.readiness_score,
              roiScore: lead.roi_score,
              riskScore: lead.risk_score,
            }),
            String(lead.source ?? "direct"),
            String(lead.page ?? "/contact"),
            String(lead.page_family ?? "contact"),
            nowIso,
          )
          .run();

        message.ack();
        continue;
      }

      if (type === "variant_weekly_report") {
        const nowIso = new Date().toISOString();
        const fromIso = new Date(Date.now() - (7 * 24 * 60 * 60 * 1000)).toISOString();

        const rows = await env.DB.prepare(
          `SELECT
            page_family,
            cta_variant,
            COUNT(*) AS events,
            SUM(CASE WHEN event_type = 'cta_click' THEN 1 ELSE 0 END) AS cta_clicks,
            SUM(CASE WHEN event_type = 'contact_intent_submit' THEN 1 ELSE 0 END) AS contact_submits
          FROM funnel_events
          WHERE event_ts >= ?1 AND event_ts <= ?2
            AND cta_variant IS NOT NULL
          GROUP BY page_family, cta_variant
          ORDER BY page_family ASC, events DESC`,
        ).bind(fromIso, nowIso).all<any>();

        const grouped = new Map<string, Array<any>>();
        for (const row of rows.results ?? []) {
          const family = String(row.page_family ?? "root");
          const existing = grouped.get(family) ?? [];
          existing.push({
            variant: String(row.cta_variant ?? "unknown"),
            events: Number(row.events ?? 0),
            ctaClicks: Number(row.cta_clicks ?? 0),
            contactSubmits: Number(row.contact_submits ?? 0),
          });
          grouped.set(family, existing);
        }

        const winners = [...grouped.entries()].map(([family, variants]) => {
          const sorted = [...variants].sort((a, b) => {
            const aRate = a.events > 0 ? (a.contactSubmits / a.events) : 0;
            const bRate = b.events > 0 ? (b.contactSubmits / b.events) : 0;
            if (bRate !== aRate) return bRate - aRate;
            return b.events - a.events;
          });

          const winner = sorted[0] ?? null;
          return {
            pageFamily: family,
            winner,
            candidates: sorted,
          };
        });

        const artifact = {
          generatedAt: nowIso,
          range: { from: fromIso, to: nowIso, days: 7 },
          winners,
        };

        const key = `reports/growth/variant-performance-${nowIso.slice(0, 10)}.json`;
        await env.ARTICLES.put(key, JSON.stringify(artifact, null, 2), {
          httpMetadata: { contentType: "application/json" },
        });

        message.ack();
        continue;
      }

      message.ack();
    } catch (err) {
      console.error("LEAD_QUEUE_MESSAGE_FAILED", { type, err });
      message.retry();
    }
  }
}

async function enqueueWeeklyVariantReportIfDue(env: Env): Promise<void> {
  const now = new Date();
  const isMondayMorningUtc = now.getUTCDay() === 1 && now.getUTCHours() >= 6 && now.getUTCHours() < 8;
  if (!isMondayMorningUtc) return;

  const weekKey = `${now.getUTCFullYear()}-W${String(Math.ceil(((Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()) - Date.UTC(now.getUTCFullYear(), 0, 1)) / 86400000 + 1) / 7)).padStart(2, "0")}`;
  const lockKey = `variant-report-lock:${weekKey}`;

  const exists = await env.VARIANT_CONFIG.get(lockKey, "text");
  if (exists) return;

  await env.VARIANT_CONFIG.put(lockKey, now.toISOString(), { expirationTtl: 14 * 24 * 60 * 60 });
  await env.LEAD_JOBS.send({
    type: "variant_weekly_report",
    weekKey,
    requestedAt: now.toISOString(),
  });
}

function breadcrumbsFromSlug(slug: string): { name: string; path: string }[] {
  const parts = slug.split("/");
  const crumbs = [{ name: "Home", path: "/" }];

  const labels: Record<string, string> = {
    // v2 taxonomy
    controls: "Controls",
    policy: "Policy",
    proof: "Proof",
    verify: "Verify",
    audit: "Audit",
    channels: "Channels",
    tools: "Tools",
    workflows: "Workflows",
    events: "Events",
    mcp: "MCP",
    "supply-chain": "Supply Chain",
    compliance: "Compliance",
    guides: "Guides",
    glossary: "Glossary",
    compare: "Compare",
    vs: "Vs",
    for: "For",

    // legacy (if old slugs exist in R2)
    deploy: "Deploy",
    integrations: "Integrations",
    "use-cases": "Use Cases",
    models: "Models",
    solutions: "Solutions",
    connect: "Connect",
    enterprise: "Enterprise",
  };

  let accum = "";
  for (const part of parts) {
    accum += "/" + part;
    crumbs.push({
      name: labels[part] ?? part.split("-").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(" "),
      path: accum,
    });
  }

  return crumbs;
}

// ── Static Pages ──────────────────────────────────────────────────

function homePage(): string {
  return layout({
    meta: {
      title: "Claw EA | Enterprise AI Agents, Deployed and Verified",
      description: "Deploy managed AI agents for your enterprise. Every action cryptographically attested. Every model call receipted. Every output verifiable. Reliable, performant, scalable, flexible, secure.",
      path: "/",
    },
    body: `
    <section class="hero">
      <div class="wrap">
        <span class="badge badge-blue">Enterprise AI Infrastructure</span>
        <h1 data-hero-copy data-hero-proof="AI Agents Your Security Team Can Defend" data-hero-roi="AI Agents That Ship Value Without Governance Debt" data-hero-speed="AI Agents You Can Launch This Month, Not Next Year">AI Agents That Your Enterprise Can Actually Trust</h1>
        <p class="sub">Deploy verified AI agents across Slack, Teams, Discord, and 20+ channels. Every action attested. Every model call receipted. No vendor lock-in. Works with Claude, GPT, Gemini, Llama, and any model you choose.</p>
        <div class="actions">
          <a href="/assessment" class="cta-btn cta-btn-lg" data-cta="home-assessment" data-cta-copy data-cta-proof="Run readiness assessment" data-cta-roi="Estimate rollout ROI" data-cta-speed="Start 2-minute assessment">Run readiness assessment</a>
          <a href="/contact" class="cta-btn cta-btn-outline cta-btn-lg" data-cta="home-contact">Talk to Sales</a>
        </div>
      </div>
    </section>

    <section class="section-sm" style="border-bottom:1px solid var(--border)">
      <div class="wrap stats">
        <div class="stat"><div class="num">20+</div><div class="label">Channel Integrations</div></div>
        <div class="stat"><div class="num">12+</div><div class="label">AI Models Supported</div></div>
        <div class="stat"><div class="num">100%</div><div class="label">Action Attestation</div></div>
        <div class="stat"><div class="num">&lt;200ms</div><div class="label">Receipt Overhead</div></div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Why Claw EA</span>
          <h2>Six Pillars of Enterprise AI Done Right</h2>
          <p>Built on OpenClaw, hardened for enterprise. Every design decision optimizes for these six properties.</p>
        </div>
        <div class="grid-3">
          <div class="card">
            <div class="icon">🛡️</div>
            <h3>Secure by Architecture</h3>
            <p>Hardware-isolated Cloudflare Sandboxes. Per-agent DID identities. Work Policy Contracts enforce egress, DLP, and approval gates before any agent runs.</p>
          </div>
          <div class="card">
            <div class="icon">⚡</div>
            <h3>Performant at the Edge</h3>
            <p>Cloudflare's global edge network. Smart model routing. Sleep/wake cycles that cut costs without sacrificing response time. Sub-200ms receipt overhead.</p>
          </div>
          <div class="card">
            <div class="icon">📈</div>
            <h3>Scales to Thousands</h3>
            <p>Up to 9,999 agents per tenant. Multi-tenant isolation at the infrastructure level. Budget controls per agent, team, or org. Fleet management dashboard.</p>
          </div>
          <div class="card">
            <div class="icon">🔄</div>
            <h3>No Model Lock-in</h3>
            <p>Claude, GPT, Gemini, Llama, Mistral, DeepSeek, Qwen. Any model, any provider. BYOK (Bring Your Own Key) or managed. Switch models without code changes.</p>
          </div>
          <div class="card">
            <div class="icon">✅</div>
            <h3>Reliable Operations</h3>
            <p>Auto-restart on failure. Health checks every 5 minutes. Persistent R2 state survives sleep/wake. Cron-based monitoring with configurable retry limits.</p>
          </div>
          <div class="card">
            <div class="icon">📋</div>
            <h3>Audit-Ready by Default</h3>
            <p>Cryptographic proof bundles for every run. Tamper-evident audit logs. SOC 2, HIPAA, GDPR, FedRAMP compatible. Export to any SIEM.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="section" style="background:var(--bg-alt)">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Permissioned Execution</span>
          <h2>Controls That Make Agents Safe to Run</h2>
          <p>Agents get cheap. Risk gets expensive. Claw EA is built around enforceable policy-as-code controls that prevent exfiltration and force approvals for irreversible actions.</p>
        </div>
        <div class="grid-4">
          ${[
            ["Egress Allowlist", "/controls/egress-allowlist", "Only approved domains and IPs."],
            ["DLP Redaction", "/controls/dlp-redaction", "Redact before data leaves the boundary."],
            ["Approval Gates", "/controls/approval-gates", "Step-up approvals for high-risk steps."],
            ["Two-person Rule", "/controls/two-person-rule", "Require two humans for irreversible actions."],
            ["Budgets", "/controls/budgets", "Token and cost budgets per workflow."],
            ["File Path Scopes", "/controls/file-path-scopes", "Restrict what can be read or written."],
            ["Kill Switch", "/controls/kill-switch", "Stop execution when policy is violated."],
            ["MCP Security", "/mcp/security-best-practices", "Use MCP without turning tools into exfiltration."],
          ]
            .map(([name, href, desc]) => `<a href="${href}" class="card card-link"><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Channels + Tools</span>
          <h2>Chat Control Plane Plus Enterprise Systems</h2>
          <p>Run agents where your team already works, and connect them to enterprise tools under strict policy and proof.</p>
        </div>
        <div class="grid-4">
          ${[
            ["Microsoft Teams", "/channels/microsoft-teams", "🟦", "Approvals and control sessions."],
            ["Slack", "/channels/slack", "💬", "Fast control plane for teams."],
            ["Email", "/channels/email", "📧", "High-risk outbound, policy-first."],
            ["Google Chat", "/channels/google-chat", "🟩", "Workspace-native control plane."],
            ["Entra ID", "/tools/entra-id", "🔐", "Identity and step-up approvals."],
            ["SharePoint", "/tools/sharepoint", "📄", "Scoped document access."],
            ["GitHub", "/tools/github", "🐙", "Code changes with policy and proof."],
            ["Jira", "/tools/jira", "📋", "Change control and ticket workflows."],
          ]
            .map(([name, href, icon, desc]) => `<a href="${href}" class="card card-link"><div class="icon">${icon}</div><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
        <p style="text-align:center;margin-top:2rem">
          <a href="/channels" style="color:var(--text-muted)">Browse channels</a>
          <span style="color:var(--text-muted)"> · </span>
          <a href="/tools" style="color:var(--text-muted)">Browse tools</a>
        </p>
      </div>
    </section>

    <section class="section" style="background:var(--bg-alt)">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Pillars</span>
          <h2>Policy, Proof, and Supply Chain</h2>
          <p>Claw EA is built for permissioned execution you can audit, not generic "AI agents".</p>
        </div>
        <div class="grid-2">
          ${[
            ["Policy-as-Code", "/policy-as-code-for-agents", "Define what agents may do before they run."],
            ["Secure Execution", "/secure-agent-execution", "Sandboxing, tool policy, and secrets boundaries."],
            ["Proof and Attestation", "/agent-proof-and-attestation", "Receipts and proof bundles you can verify."],
            ["Audit and Replay", "/agent-audit-and-replay", "Evidence retention and replay posture."],
            ["Supply Chain Security", "/agent-supply-chain-security", "Signed skills and governance for extensions."],
            ["Event-native Agents", "/event-native-agents", "Webhooks and changefeeds, paired with policy."],
          ]
            .map(([name, href, desc]) => `<a href="${href}" class="card card-link"><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="cta-banner">
          <h2>Deploy Your First Enterprise AI Agent With a Controlled Pilot</h2>
          <p>Start with a scored readiness path, then move to a proof-backed pilot plan your security and platform teams can approve.</p>
          <a href="/assessment" class="cta-btn cta-btn-lg" data-cta="home-bottom-assessment" data-cta-copy>Run readiness assessment</a>
          <a href="/contact" class="cta-btn cta-btn-outline cta-btn-lg" style="margin-left:.75rem" data-cta="home-bottom-contact">Talk to Sales</a>
        </div>
      </div>
    </section>`,
    schemas: [
      serviceSchema(
        "Claw EA - Enterprise AI Agent Platform",
        "Deploy managed, verified AI agents for enterprise. Cryptographic attestation, multi-model support, 20+ channel integrations.",
        "https://www.clawea.com",
      ),
    ],
  });
}

function pricingPage(): string {
  return layout({
    meta: {
      title: "Pricing | Claw EA Enterprise AI Agents",
      description: "Transparent pricing for enterprise AI agent infrastructure. Start free, scale to thousands. Starter, Team, Business, and Enterprise tiers.",
      path: "/pricing",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Pricing", path: "/pricing" }],
    body: `
    <section class="section content-page">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Pricing</span>
          <h2>Start Small, Scale Without Limits</h2>
          <p>Every tier includes full execution attestation, proof bundles, and audit logs.</p>
        </div>
        <div class="grid-4">
          <div class="price-card">
            <div class="tier">Starter</div>
            <div class="amount">$49</div>
            <div class="period">per month</div>
            <ul>
              <li>1 AI agent</li>
              <li>5 skills per agent</li>
              <li>All channels supported</li>
              <li>All models (BYOK)</li>
              <li>Execution attestation</li>
              <li>90-day audit log retention</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card">
            <div class="tier">Team</div>
            <div class="amount">$249</div>
            <div class="period">per month</div>
            <ul>
              <li>5 AI agents</li>
              <li>15 skills per agent</li>
              <li>All channels supported</li>
              <li>Model routing + failover</li>
              <li>Work Policy Contracts</li>
              <li>1-year audit log retention</li>
              <li>Budget controls</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card featured">
            <div class="tier" style="color:var(--accent)">Business</div>
            <div class="amount">$999</div>
            <div class="period">per month</div>
            <ul>
              <li>25 AI agents</li>
              <li>50 skills per agent</li>
              <li>Fleet management dashboard</li>
              <li>Multi-agent orchestration</li>
              <li>Custom agent templates</li>
              <li>3-year audit log retention</li>
              <li>SIEM integration</li>
              <li>Priority support</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card">
            <div class="tier">Enterprise</div>
            <div class="amount">Custom</div>
            <div class="period">contact sales</div>
            <ul>
              <li>Unlimited agents</li>
              <li>Unlimited skills</li>
              <li>Custom container limits</li>
              <li>Custom compliance mapping</li>
              <li>Dedicated support engineer</li>
              <li>7-year audit log retention</li>
              <li>BAA / DPA available</li>
              <li>On-prem option</li>
            </ul>
            <a href="/contact" class="cta-btn">Talk to Sales</a>
          </div>
        </div>
      </div>
    </section>`,
    schemas: [
      productSchema("Claw EA", "Enterprise AI Agent Platform", "https://www.clawea.com/pricing", [
        { price: "49", priceCurrency: "USD" },
        { price: "249", priceCurrency: "USD" },
        { price: "999", priceCurrency: "USD" },
      ]),
    ],
  });
}

type AssessmentResult = {
  readinessScore: number;
  roiScore: number;
  riskScore: number;
  confidenceLabel: string;
  recommendedTrack: "guided-pilot" | "self-serve-pilot" | "architecture-review";
};

function parseAssessmentResult(url: URL): AssessmentResult {
  const readinessScore = Math.min(100, Math.max(0, Number(url.searchParams.get("readiness") ?? "0") || 0));
  const roiScore = Math.min(100, Math.max(0, Number(url.searchParams.get("roi") ?? "0") || 0));
  const riskScore = Math.min(100, Math.max(0, Number(url.searchParams.get("risk") ?? "0") || 0));

  const blended = Math.round((readinessScore * 0.4) + (roiScore * 0.35) + ((100 - riskScore) * 0.25));
  const confidenceLabel = blended >= 78 ? "high-intent" : blended >= 55 ? "medium-intent" : "early-intent";

  const recommendedTrack: AssessmentResult["recommendedTrack"] = blended >= 78
    ? "guided-pilot"
    : blended >= 55
      ? "architecture-review"
      : "self-serve-pilot";

  return {
    readinessScore,
    roiScore,
    riskScore,
    confidenceLabel,
    recommendedTrack,
  };
}

function assessmentPage(turnstileSiteKey: string): string {
  return layout({
    meta: {
      title: "AI Readiness Assessment | Claw EA",
      description: "Score your enterprise readiness, expected ROI, and operational risk in 2 minutes.",
      path: "/assessment",
      canonicalPath: "/assessment",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Assessment", path: "/assessment" }],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:760px">
        <span class="badge badge-purple">Demand capture</span>
        <h1 data-hero-copy>Enterprise Agent Readiness Assessment</h1>
        <p class="lead">Answer five short questions. We return a readiness score, ROI estimate, and risk posture with a clear next step.</p>

        <form class="card lead-form" data-assessment-form style="margin-top:1.5rem">
          <div class="form-grid-2">
            <label class="form-field">
              <span>Team size</span>
              <select name="teamSize" required>
                <option value="">Select…</option>
                <option value="1-20">1-20</option>
                <option value="21-100">21-100</option>
                <option value="101-500">101-500</option>
                <option value="500+">500+</option>
              </select>
            </label>

            <label class="form-field">
              <span>Current stage</span>
              <select name="maturity" required>
                <option value="">Select…</option>
                <option value="exploration">Exploration</option>
                <option value="pilot">Pilot running</option>
                <option value="production">Production with guardrails</option>
              </select>
            </label>

            <label class="form-field">
              <span>Primary objective</span>
              <select name="objective" required>
                <option value="">Select…</option>
                <option value="cost">Reduce manual process cost</option>
                <option value="speed">Faster approvals and delivery</option>
                <option value="compliance">Audit and compliance confidence</option>
              </select>
            </label>

            <label class="form-field">
              <span>Risk tolerance</span>
              <select name="riskTolerance" required>
                <option value="">Select…</option>
                <option value="low">Low (strict approvals)</option>
                <option value="moderate">Moderate</option>
                <option value="high">High (speed first)</option>
              </select>
            </label>

            <label class="form-field form-field-wide">
              <span>Timeline to launch</span>
              <select name="timeline" required>
                <option value="">Select…</option>
                <option value="2-weeks">Within 2 weeks</option>
                <option value="30-days">Within 30 days</option>
                <option value="quarter">This quarter</option>
                <option value="later">Later planning</option>
              </select>
            </label>
          </div>

          <div class="form-actions" style="margin-top:1.25rem">
            <button type="submit" class="cta-btn cta-btn-lg" data-cta="assessment-calculate" data-cta-copy>Calculate my score</button>
            <a href="/contact" class="cta-btn cta-btn-outline cta-btn-lg" data-cta="assessment-contact">Talk to sales now</a>
          </div>

          <p class="form-note">No signup required for scoring. You can submit your details on the result page if you want a tailored plan.</p>
        </form>
      </div>
    </section>
    <script>
    (function(){
      var form=document.querySelector('[data-assessment-form]');
      if(!form)return;

      function pick(value,map,fallback){return (map&&map[value])||fallback;}

      form.addEventListener('submit',function(e){
        e.preventDefault();

        var fd=new FormData(form);
        var team=String(fd.get('teamSize')||'');
        var maturity=String(fd.get('maturity')||'');
        var objective=String(fd.get('objective')||'');
        var riskTolerance=String(fd.get('riskTolerance')||'');
        var timeline=String(fd.get('timeline')||'');

        var readiness=Math.round(
          pick(team,{'1-20':40,'21-100':55,'101-500':70,'500+':78},42)
          + pick(maturity,{'exploration':8,'pilot':18,'production':25},10)
          + pick(timeline,{'2-weeks':15,'30-days':10,'quarter':6,'later':3},5)
        );

        var roi=Math.round(
          pick(objective,{'cost':72,'speed':68,'compliance':64},60)
          + pick(team,{'1-20':5,'21-100':8,'101-500':12,'500+':15},6)
        );

        var risk=Math.round(
          pick(riskTolerance,{'low':30,'moderate':48,'high':66},48)
          - pick(maturity,{'exploration':0,'pilot':5,'production':10},0)
        );

        readiness=Math.max(0,Math.min(100,readiness));
        roi=Math.max(0,Math.min(100,roi));
        risk=Math.max(0,Math.min(100,risk));

        var out='/assessment/result?readiness='+encodeURIComponent(String(readiness))
          +'&roi='+encodeURIComponent(String(roi))
          +'&risk='+encodeURIComponent(String(risk))
          +'&team='+encodeURIComponent(team)
          +'&objective='+encodeURIComponent(objective)
          +'&timeline='+encodeURIComponent(timeline);

        if(window.__claweaTrack){
          window.__claweaTrack('cta_click',{
            ctaId:'assessment-calculate',
            ctaVariant:'calculator',
            actionOutcome:'calculated',
            targetPath:'/assessment/result'
          });
        }

        window.location.href=out;
      });
    })();
    </script>`,
    schemas: [
      faqSchema([
        { q: "How long does this take?", a: "Around two minutes. You only answer five questions." },
        { q: "Do I need to sign up?", a: "No. You can calculate your score without entering contact details." },
        { q: "Can I share this with my team?", a: "Yes. Copy the result URL and share it internally." },
      ]),
    ],
  });
}

function assessmentResultPage(result: AssessmentResult, turnstileSiteKey: string): string {
  const trackLabel = result.recommendedTrack === "guided-pilot"
    ? "Guided pilot"
    : result.recommendedTrack === "architecture-review"
      ? "Architecture review"
      : "Self-serve pilot";

  return layout({
    meta: {
      title: `Assessment Result (${result.confidenceLabel}) | Claw EA`,
      description: "Review your readiness, ROI, and risk score. Get the fastest next step for enterprise agent rollout.",
      path: "/assessment/result",
      canonicalPath: "/assessment/result",
      noindex: true,
    },
    breadcrumbs: [
      { name: "Home", path: "/" },
      { name: "Assessment", path: "/assessment" },
      { name: "Result", path: "/assessment/result" },
    ],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:820px">
        <span class="badge badge-green">Assessment result</span>
        <h1>Your recommended track: ${esc(trackLabel)}</h1>
        <p class="lead">We scored your current operating posture across readiness, ROI potential, and risk control fit.</p>

        <div class="score-grid">
          <article class="score-card">
            <h3>Readiness</h3>
            <div class="score-value">${result.readinessScore}</div>
            <p>How prepared your team is to launch a controlled pilot quickly.</p>
          </article>
          <article class="score-card">
            <h3>ROI signal</h3>
            <div class="score-value">${result.roiScore}</div>
            <p>Estimated value potential from throughput and approval cycle improvements.</p>
          </article>
          <article class="score-card">
            <h3>Risk posture</h3>
            <div class="score-value">${result.riskScore}</div>
            <p>Higher scores indicate higher risk exposure without strict execution controls.</p>
          </article>
        </div>

        <div class="proof-summary-block" style="margin-top:1.5rem">
          <h3>Proof-first rollout checklist</h3>
          <ul>
            <li>Start with one irreversible workflow and enforce approval gates.</li>
            <li>Require receipts and proof bundles for every model call and side effect.</li>
            <li>Track lead-to-launch metrics weekly and keep an explicit rollback path.</li>
          </ul>
        </div>

        <div class="cta-banner" style="margin-top:2rem">
          <h2>Want a tailored rollout plan?</h2>
          <p>Submit one short form and we return a deployment recommendation with control policy examples.</p>
          <a href="/contact?from=assessment-result&confidence=${encodeURIComponent(result.confidenceLabel)}" class="cta-btn cta-btn-lg" data-cta="assessment-result-contact" data-cta-copy>Request tailored plan</a>
          <a href="/trust" class="cta-btn cta-btn-outline cta-btn-lg" style="margin-left:.75rem" data-cta="assessment-result-trust">Review trust controls</a>
        </div>

        <form class="card lead-form" data-lead-form data-cta="assessment-result-form" style="margin-top:2rem">
          <h3 style="margin-bottom:.5rem">Fast qualification form</h3>
          <p class="form-note" style="margin-bottom:1rem">This takes less than 45 seconds.</p>

          <div class="form-grid-2">
            <label class="form-field">
              <span>Work email</span>
              <input type="email" name="email" required placeholder="you@company.com" autocomplete="email">
            </label>
            <label class="form-field">
              <span>Company</span>
              <input type="text" name="company" required placeholder="Company name" autocomplete="organization">
            </label>
            <label class="form-field">
              <span>Your role</span>
              <input type="text" name="role" placeholder="Security lead, platform lead, CTO..." autocomplete="organization-title">
            </label>
            <label class="form-field">
              <span>Timeline</span>
              <input type="text" name="timeline" placeholder="2 weeks, this month, this quarter">
            </label>
          </div>

          <input type="hidden" name="primaryUseCase" value="assessment-result-followup">
          <input type="hidden" name="assessment.readinessScore" value="${result.readinessScore}">
          <input type="hidden" name="assessment.roiScore" value="${result.roiScore}">
          <input type="hidden" name="assessment.riskScore" value="${result.riskScore}">
          <input type="hidden" name="assessment.confidenceLabel" value="${esc(result.confidenceLabel)}">

          <div class="cf-turnstile" data-sitekey="${esc(turnstileSiteKey)}"></div>

          <div class="form-actions">
            <button type="submit" class="cta-btn" data-cta="assessment-result-submit">Send to solutions team</button>
            <span class="form-status" data-lead-form-status aria-live="polite"></span>
          </div>
        </form>
      </div>
    </section>`,
    schemas: [
      serviceSchema(
        "Claw EA Readiness Assessment",
        "Assessment route for enterprise AI agent rollout readiness and risk-to-proof conversion planning.",
        "https://www.clawea.com/assessment",
      ),
    ],
  });
}

function contactPage(turnstileSiteKey: string): string {
  return layout({
    meta: {
      title: "Contact Sales | Claw EA Enterprise AI Agents",
      description: "Talk to our enterprise sales team about deploying verified AI agents for your organization.",
      path: "/contact",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Contact", path: "/contact" }],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:760px">
        <h1>Talk to Sales</h1>
        <p class="lead">Short path: tell us your team, objective, and timeline. We reply with a scoped recommendation and next steps.</p>

        <form class="card lead-form" data-lead-form data-cta="contact-lead-form">
          <div class="form-grid-2">
            <label class="form-field">
              <span>Work email</span>
              <input type="email" name="email" required placeholder="you@company.com" autocomplete="email">
            </label>
            <label class="form-field">
              <span>Company</span>
              <input type="text" name="company" required placeholder="Company name" autocomplete="organization">
            </label>
            <label class="form-field">
              <span>Full name</span>
              <input type="text" name="fullName" placeholder="Your name" autocomplete="name">
            </label>
            <label class="form-field">
              <span>Role</span>
              <input type="text" name="role" placeholder="Security lead, platform lead, CTO..." autocomplete="organization-title">
            </label>
            <label class="form-field">
              <span>Team size</span>
              <select name="teamSize">
                <option value="">Select…</option>
                <option value="1-20">1-20</option>
                <option value="21-100">21-100</option>
                <option value="101-500">101-500</option>
                <option value="500+">500+</option>
              </select>
            </label>
            <label class="form-field">
              <span>Timeline</span>
              <select name="timeline">
                <option value="">Select…</option>
                <option value="2-weeks">Within 2 weeks</option>
                <option value="30-days">Within 30 days</option>
                <option value="quarter">This quarter</option>
                <option value="later">Later planning</option>
              </select>
            </label>
            <label class="form-field form-field-wide">
              <span>Primary use case</span>
              <textarea name="primaryUseCase" rows="3" placeholder="Example: production deploy approvals, SIEM evidence collection, identity lifecycle approvals"></textarea>
            </label>
          </div>

          <div class="cf-turnstile" data-sitekey="${esc(turnstileSiteKey)}"></div>

          <div class="form-actions">
            <button type="submit" class="cta-btn cta-btn-lg" data-cta="contact-fast-submit" data-cta-copy>Request tailored plan</button>
            <a href="/assessment" class="cta-btn cta-btn-outline cta-btn-lg" data-cta="contact-assessment">Run readiness assessment</a>
            <span class="form-status" data-lead-form-status aria-live="polite"></span>
          </div>

          <p class="form-note">Prefer email? Write to <a href="mailto:enterprise@clawbureau.com">enterprise@clawbureau.com</a>. Include company, team size, and target timeline.</p>
        </form>
      </div>
    </section>`,
    schemas: [
      faqSchema([
        { q: "How fast do you reply?", a: "Typically within four business hours." },
        { q: "Do you support pilots before contract?", a: "Yes. We can run a guided pilot with strict scope and measurable success criteria." },
        { q: "Can we bring our own model keys?", a: "Yes. BYOK is supported, and we keep proof and policy controls in place." },
      ]),
    ],
  });
}

function sourcesHubPage(manifest: Record<string, ManifestEntry>): string {
  const rows = Object.entries(manifest)
    .map(([slug, meta]) => ({ slug, meta }))
    .filter((row) => row.meta.indexable !== false)
    .slice(0, 80);

  const familyCounts = new Map<string, number>();
  for (const row of rows) {
    const family = row.slug.split("/")[0] || "root";
    familyCounts.set(family, (familyCounts.get(family) ?? 0) + 1);
  }

  const familySummary = [...familyCounts.entries()]
    .sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0], "en"))
    .map(([family, count]) => `<li><a href="/${family}">${esc(family)}</a> · ${count} indexable pages</li>`)
    .join("");

  const topIndexable = rows
    .slice(0, 24)
    .map((row) => `<li><a href="/${row.slug}">${esc(row.meta.title.replace(/ \| Claw EA$/, ""))}</a></li>`)
    .join("");

  return layout({
    meta: {
      title: "Citation Source Hub | Claw EA",
      description: "Source-first routing hub for citation-ready Claw EA pages and proof-linked implementation guides.",
      path: "/sources",
      canonicalPath: "/sources",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Sources", path: "/sources" }],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:900px">
        <span class="badge badge-blue">Citation routing</span>
        <h1>Source hub for AI discovery and enterprise buyers</h1>
        <p class="lead">Use this page to route to citation-ready articles, workflow runbooks, and proof-first pages with explicit references.</p>

        <div class="proof-summary-block">
          <h3>How to cite Claw EA pages</h3>
          <ul>
            <li>Prefer direct article URLs under <code>/tools</code>, <code>/workflows</code>, and <code>/controls</code>.</li>
            <li>Use pages that include explicit Sources sections and proof summaries.</li>
            <li>For platform trust claims, cite <a href="/trust">/trust</a> and <a href="/agent-proof-and-attestation">/agent-proof-and-attestation</a>.</li>
          </ul>
        </div>

        <div class="grid-2" style="margin-top:1.5rem">
          <article class="card">
            <h3>Indexable families</h3>
            <ul>${familySummary}</ul>
          </article>
          <article class="card">
            <h3>High-intent next steps</h3>
            <ul>
              <li><a href="/assessment">Run readiness assessment</a></li>
              <li><a href="/contact">Submit high-intent brief</a></li>
              <li><a href="/trust">Review trust controls</a></li>
              <li><a href="/pricing">Review pricing and rollout tiers</a></li>
            </ul>
          </article>
        </div>

        <article class="card" style="margin-top:1.5rem">
          <h3>Frequently cited pages</h3>
          <ul class="sources-hub-list">${topIndexable}</ul>
        </article>
      </div>
    </section>`,
  });
}

function notFoundPage(): string {
  return layout({
    meta: { title: "Page Not Found | Claw EA", description: "The page you're looking for doesn't exist.", path: "/404", noindex: true },
    body: `
    <section class="section content-page" style="text-align:center">
      <div class="wrap">
        <h1>404 - Page Not Found</h1>
        <p class="lead">The page you're looking for doesn't exist or has been moved.</p>
        <div class="actions" style="margin-top:2rem;justify-content:center">
          <a href="/" class="cta-btn cta-btn-lg">Back to Home</a>
          <a href="/assessment" class="cta-btn cta-btn-outline cta-btn-lg">Run assessment</a>
          <a href="/contact" class="cta-btn cta-btn-outline cta-btn-lg">Talk to sales</a>
        </div>
      </div>
    </section>`,
  });
}

// ── Article Page Renderer ─────────────────────────────────────────

function formatDateYmd(iso: string): string {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return iso;
  return d.toISOString().slice(0, 10);
}

function estimateReadMinutes(rawHtml: string, wordsPerMinute = 220): number {
  const words = rawHtml
    .replace(/<[^>]+>/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .split(" ")
    .filter(Boolean).length;

  if (words <= 0) return 1;
  return Math.max(1, Math.round(words / wordsPerMinute));
}

function toTitle(s: string): string {
  return s
    .split("-")
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(" ");
}

function uniqueLinks(items: Array<{ name: string; path: string }>): Array<{ name: string; path: string }> {
  const out: Array<{ name: string; path: string }> = [];
  const seen = new Set<string>();
  for (const i of items) {
    if (!i?.path || seen.has(i.path)) continue;
    seen.add(i.path);
    out.push(i);
  }
  return out;
}

function relatedLinksForArticle(article: Article): Array<{ name: string; path: string }> {
  const slugParts = article.slug.split("/").filter(Boolean);
  const family = slugParts[0] ?? "";

  const links: Array<{ name: string; path: string }> = [
    { name: "Run readiness assessment", path: "/assessment" },
    { name: "Talk to sales", path: "/contact" },
    { name: "Policy-as-Code", path: "/policy-as-code-for-agents" },
    { name: "Secure Execution", path: "/secure-agent-execution" },
    { name: "Proof and Attestation", path: "/agent-proof-and-attestation" },
  ];

  if (family) {
    links.push({ name: `${toTitle(family)} hub`, path: `/${family}` });
  }

  // Family-specific helpers
  if (family === "workflows") {
    const toolSlug = slugParts[2];
    const channelSlug = slugParts[3];
    if (toolSlug) links.push({ name: `${toTitle(toolSlug)} tool page`, path: `/tools/${toolSlug}` });
    if (channelSlug) links.push({ name: `${toTitle(channelSlug)} channel page`, path: `/channels/${channelSlug}` });

    links.push({ name: "Approval gates", path: "/controls/approval-gates" });
    links.push({ name: "Two-person rule", path: "/controls/two-person-rule" });
    links.push({ name: "Budgets", path: "/controls/budgets" });
  }

  if (family === "tools") {
    const toolSlug = slugParts[1];
    if (toolSlug) links.push({ name: `${toTitle(toolSlug)} overview`, path: `/tools/${toolSlug}` });

    links.push({ name: "Egress allowlist", path: "/controls/egress-allowlist" });
    links.push({ name: "DLP and redaction", path: "/controls/dlp-redaction" });
    links.push({ name: "Secrets boundary", path: "/controls/secret-boundary" });
  }

  if (family === "channels") {
    const channelSlug = slugParts[1];
    if (channelSlug) links.push({ name: `${toTitle(channelSlug)} overview`, path: `/channels/${channelSlug}` });

    links.push({ name: "Tool allow/deny", path: "/controls/tool-allow-deny" });
    links.push({ name: "Approval gates", path: "/controls/approval-gates" });
    links.push({ name: "Kill switch", path: "/controls/kill-switch" });
  }

  if (family === "controls") {
    links.push({ name: "Controls hub", path: "/controls" });
    links.push({ name: "Policy artifacts", path: "/policy" });
  }

  // Remove self-link and dedupe
  const self = `/${article.slug}`;
  return uniqueLinks(links.filter((l) => l.path !== self)).slice(0, 8);
}

// ── Article Processing Helpers ────────────────────────────────────

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/<[^>]+>/g, "")
    .replace(/&[^;]+;/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "");
}

interface TocEntry {
  id: string;
  text: string;
  depth: number;
}

/** Inject `id` attributes + anchor links into h2/h3 elements, extract TOC. */
function extractAndInjectHeadings(rawHtml: string): { html: string; toc: TocEntry[] } {
  const toc: TocEntry[] = [];
  const seen = new Set<string>();
  const processed = rawHtml.replace(
    /<(h[23])([^>]*)>([\s\S]*?)<\/\1>/gi,
    (_match, tag: string, attrs: string, content: string) => {
      if (attrs.includes(" id=")) return _match; // already has id
      const text = content.replace(/<[^>]+>/g, "").trim();
      let id = slugify(text);
      if (!id) return _match;
      if (seen.has(id)) id += "-" + seen.size;
      seen.add(id);
      const depth = tag.toLowerCase() === "h2" ? 2 : 3;
      toc.push({ id, text, depth });
      return `<${tag}${attrs} id="${id}">${content}<a href="#${id}" class="heading-anchor" aria-hidden="true">#</a></${tag}>`;
    },
  );
  return { html: processed, toc };
}

/** Render a sticky sidebar Table of Contents from extracted headings. */
function renderToc(toc: TocEntry[]): string {
  if (toc.length < 3) return "";
  const items = toc
    .map((e) => `<li class="depth-${e.depth}"><a href="#${e.id}">${esc(e.text)}</a></li>`)
    .join("");
  return `
  <aside class="toc" aria-label="Table of contents">
    <details open>
      <summary>On this page</summary>
      <nav><ol>${items}</ol></nav>
    </details>
  </aside>`;
}

/** Wrap bare <table> elements in a responsive scroll container. */
function wrapTables(rawHtml: string): string {
  return rawHtml
    .replace(/<table\b/g, '<div class="table-wrap" role="region" tabindex="0"><table')
    .replace(/<\/table>/g, "</table></div>");
}

function isBofuArticle(article: Article): boolean {
  return (
    article.slug.startsWith("tools/")
    || article.slug.startsWith("workflows/")
    || article.slug.startsWith("channels/")
    || article.slug.startsWith("compliance/")
    || article.slug.startsWith("compare/")
    || article.slug.startsWith("for/")
  );
}

function renderProofSummaryBlock(article: Article): string {
  if (!isBofuArticle(article)) return "";

  const sourceList = (article.sources ?? [])
    .slice(0, 3)
    .map((s) => `<li><a href="${esc(s.uri)}" rel="noopener" target="_blank">${esc(s.title || s.uri)}</a></li>`)
    .join("");

  return `
  <section class="proof-summary-block" aria-label="Proof-first summary">
    <h3>Proof-first summary</h3>
    <ul>
      <li>Execution policy is explicit before an agent can run irreversible actions.</li>
      <li>Every model call and tool action can be tied to receipts and audit evidence.</li>
      <li>Rollback posture is documented with deterministic failure handling paths.</li>
    </ul>
    <p class="proof-summary-links">
      <a href="/assessment" data-cta="proof-summary-assessment">Run readiness assessment</a>
      <span>·</span>
      <a href="/contact" data-cta="proof-summary-contact">Request tailored rollout plan</a>
    </p>
    ${sourceList ? `<div class="proof-summary-sources"><strong>Top references</strong><ul>${sourceList}</ul></div>` : ""}
  </section>`;
}

function articlePage(article: Article): string {
  const breadcrumbs = breadcrumbsFromSlug(article.slug);
  const schemas: string[] = [];

  const url = canonical(`/${article.slug}`);
  const headline = article.title.replace(/ \| Claw EA$/, "");

  if (article.faqs.length > 0) {
    schemas.push(faqSchema(article.faqs));
  }

  if (article.howToSteps && article.howToSteps.length > 0) {
    schemas.push(
      howToSchema(
        { title: article.howToTitle ?? headline, steps: article.howToSteps },
        url,
      ),
    );
  }

  if (article.category === "glossary") {
    schemas.push(definedTermSchema(headline, article.description, url));
  } else {
    schemas.push(
      techArticleSchema({
        headline,
        description: article.description,
        url,
        datePublished: article.generatedAt,
        dateModified: article.generatedAt,
        section: article.category,
      }),
    );
  }

  const updated = formatDateYmd(article.generatedAt);
  const readMinutes = estimateReadMinutes(article.html);
  const slugParts = article.slug.split("/").filter(Boolean);

  // Process article body: inject heading IDs, extract TOC, wrap tables
  const { html: processedHtml, toc } = extractAndInjectHeadings(article.html);
  const bodyHtml = wrapTables(processedHtml);
  const tocHtml = renderToc(toc);

  // Key takeaways module (uses article description as summary)
  const takeawaysHtml = article.description
    ? `<div class="takeaways"><div class="takeaways-title">&#9672; Key takeaway</div><p>${esc(article.description)}</p></div>`
    : "";

  const proofSummaryHtml = renderProofSummaryBlock(article);

  // Related content with card styling
  const related = relatedLinksForArticle(article);
  const relatedHtml = related.length
    ? `<div class="related"><h3>Related</h3><div class="related-grid">${related
        .map((l) => `<a href="${l.path}" class="related-card"><span class="related-label">${esc(l.name)}</span></a>`)
        .join("")}</div></div>`
    : "";

  const categoryLabel = article.category
    .replace(/-/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase());

  const familySlug = slugParts.length > 1 ? slugParts[0] : null;
  const familyLinkHtml = familySlug
    ? `<a href="/${familySlug}" class="meta-chip meta-chip-link" role="listitem">${esc(toTitle(familySlug))} hub</a>`
    : "";

  return layout({
    meta: {
      title: article.title,
      description: article.description,
      path: `/${article.slug}`,
      ogType: "article",
      ogImageAlt: `${headline} | Claw EA`,
      articleSection: categoryLabel,
      publishedTime: article.generatedAt,
      modifiedTime: article.generatedAt,
      // Plan A: fail-closed. Only explicitly indexable pages should be indexed.
      noindex: article.indexable !== true,
    },
    breadcrumbs,
    schemas,
    body: `
    <section class="section content-page">
      <div class="wrap">
        <span class="badge badge-blue">${categoryLabel}</span>
        <h1>${esc(headline)}</h1>
        <p class="article-meta">Evidence is linked in Sources when available.</p>
        <div class="article-meta-strip" role="list" aria-label="Article metadata">
          <span class="meta-chip" role="listitem">Updated <time datetime="${esc(article.generatedAt)}">${updated}</time></span>
          <span class="meta-chip" role="listitem">${readMinutes} min read</span>
          <span class="meta-chip" role="listitem">${esc(categoryLabel)}</span>
          ${familyLinkHtml}
        </div>
        ${takeawaysHtml}
        ${proofSummaryHtml}
        <div class="article-layout">
          ${tocHtml}
          <div class="article-main">
            <div class="article-body">${bodyHtml}</div>
            ${relatedHtml}
          </div>
        </div>
      </div>
    </section>`,
  });
}

function esc(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ── Router ────────────────────────────────────────────────────────

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname.replace(/\/+$/, "") || "/";

    const visitor = getOrCreateVisitorId(request);
    const existingExpCookie = clipString(readCookie(request, "clawea_exp"), 240);
    const experimentConfigPromise = loadExperimentConfig(env);

    const htmlWithExperiment = async (response: Response, routePath = path): Promise<Response> => {
      const config = await experimentConfigPromise;
      const assignment = assignVariant(config, visitor.visitorId, pageFamilyFromPath(routePath));
      const expectedExp = `${assignment.pageFamily}:${assignment.heroVariant}:${assignment.ctaVariant}`;
      const shouldSetExpCookie = existingExpCookie !== expectedExp;
      return applyExperimentCookies(response, visitor.visitorId, assignment, visitor.cookieNeeded, shouldSetExpCookie);
    };

    // ── IndexNow key file ──
    if ((request.method === "GET" || request.method === "HEAD") && env.INDEXNOW_KEY && path === `/${env.INDEXNOW_KEY}.txt`) {
      return new Response(request.method === "HEAD" ? null : `${env.INDEXNOW_KEY}\n`, {
        headers: {
          "content-type": "text/plain;charset=utf-8",
          "cache-control": "public, max-age=86400",
        },
      });
    }

    // ── API routes (search + indexing + conversion telemetry) ──
    if (path.startsWith("/api/")) {
      if (request.method === "OPTIONS") {
        return new Response(null, { status: 204, headers: apiHeaders() });
      }

      // Public conversion instrumentation endpoint (no bearer token)
      if (path === "/api/events") {
        return await ingestTrackingEvent(request, env);
      }

      // Public search endpoint
      if (path === "/api/search") {
        if (request.method !== "GET") {
          return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
        }

        const query = normalizeSearchQuery(url.searchParams.get("q"));
        const limit = Math.min(50, Math.max(1, Number(url.searchParams.get("limit") ?? "10")));

        if (query.length < 2) {
          return apiError("QUERY_TOO_SHORT", "q must be at least 2 characters", 400);
        }

        const manifest = await loadManifest(env);
        const corpus = buildSearchCorpus(manifest);
        const results = searchCorpus(corpus, query, limit);

        return apiJson({
          ok: true,
          query,
          count: results.length,
          results: results.map((r) => ({
            path: r.path,
            title: r.title,
            description: previewText(r.description, 240),
            category: r.category,
            kind: r.kind,
            score: r.score,
          })),
        });
      }

      if (path === "/api/experiments/config") {
        if (request.method !== "GET") {
          return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
        }

        const config = await loadExperimentConfig(env);
        return apiJson({ ok: true, config });
      }

      if (path === "/api/experiments/assignment") {
        return await experimentAssignmentEndpoint(request, env);
      }

      if (path === "/api/experiments/winners") {
        return await experimentsWinners(request, env);
      }

      if (path === "/api/leads/submit") {
        return await submitLead(request, env);
      }

      if (path === "/api/leads/status") {
        return await leadsStatus(request, env);
      }

      if (path === "/api/leads/export") {
        return await leadsExport(request, env);
      }

      // Protected telemetry summary endpoint
      if (path === "/api/events/summary") {
        return await summarizeTrackingEvents(request, env);
      }

      const authError = checkAutomationAuth(request, env);
      if (authError) return authError;

      if (path === "/api/index-queue/status") {
        if (request.method !== "GET") {
          return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
        }

        const queue = await loadIndexQueue(env);
        const lastRun = await loadLastQueueRun(env);
        return apiJson({
          ok: true,
          enabled: queueEnabled(env),
          ...summarizeQueueForResponse(queue),
          lastRun,
        });
      }

      if (request.method !== "POST") {
        return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
      }

      let body: any;
      try {
        body = await request.json<any>();
      } catch {
        return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
      }

      if (path === "/api/index-queue/replay") {
        const forceFailed = body?.forceFailed === true;
        const simulate429 = body?.simulate429 === true;
        const maxEntries = Math.min(500, Math.max(1, Number(body?.maxEntries ?? queueMaxEntriesPerRun(env))));

        let forced = 0;
        if (forceFailed) {
          const out = await forceRequeueFailedEntries(env);
          forced = out.requeued;
        }

        const processed = await processIndexQueue(env, {
          source: "api:index-queue-replay",
          maxEntries,
          simulate429,
        });

        return apiJson({
          ok: true,
          forced,
          artifactKey: processed.artifactKey,
          run: processed.run,
        }, 200);
      }

      if (path === "/api/index-queue/enqueue") {
        const { accepted, rejected } = normalizeUrlList(body?.urls, 500);
        if (accepted.length === 0) {
          return apiError("URLS_INVALID", "No valid clawea.com URLs were provided", 400);
        }

        const action: IndexAction = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const engines = parseIndexingEngines(body?.engines);
        if (engines.length === 0) {
          return apiError("ENGINES_INVALID", "engines must include indexnow, google, or all", 400);
        }

        const enqueued = await enqueueIndexQueue(env, {
          urls: accepted,
          action,
          engines,
          force: body?.force === true,
          source: "api:index-queue-enqueue",
        });

        return apiJson({
          ok: true,
          action,
          engines,
          requested: accepted.length,
          rejected,
          created: enqueued.created,
          updated: enqueued.updated,
          deduped: enqueued.deduped,
          queue: enqueued.summary,
        });
      }

      const { accepted, rejected } = normalizeUrlList(body?.urls, 500);
      if (accepted.length === 0) {
        return apiError("URLS_INVALID", "No valid clawea.com URLs were provided", 400);
      }

      if (path === "/api/indexnow") {
        const result = await submitIndexNow(accepted, env);
        return apiJson({
          ok: result.ok,
          engine: "indexnow",
          submitted: result.submitted,
          requested: accepted.length,
          rejected,
          status: result.status,
          attempts: result.attempts,
          retried: result.retried,
          retryableFailures: result.retryableFailures,
          attemptLog: result.attemptLog,
          body: result.body,
          error: result.error,
        }, result.ok ? 200 : 502);
      }

      if (path === "/api/google-index") {
        const action = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const result = await submitGoogleIndexing(accepted, action, env);
        return apiJson({
          ok: result.ok,
          engine: "google",
          action,
          submitted: result.submitted,
          failed: result.failed,
          requested: accepted.length,
          rejected,
          status: result.status,
          details: result.details,
          error: result.error,
        }, result.ok ? 200 : result.status);
      }

      if (path === "/api/index-urls") {
        const action: IndexAction = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const engines = parseIndexingEngines(body?.engines);
        if (engines.length === 0) {
          return apiError("ENGINES_INVALID", "engines must include indexnow, google, or all", 400);
        }

        const queueOnly = body?.queueOnly === true;
        const queueOnFailure = body?.queueOnFailure !== false;

        if (queueOnly) {
          const queued = await enqueueIndexQueue(env, {
            urls: accepted,
            action,
            engines,
            force: body?.force === true,
            source: "api:index-urls(queue-only)",
          });

          return apiJson({
            ok: true,
            mode: "queue_only",
            action,
            engines,
            requested: accepted.length,
            rejected,
            created: queued.created,
            updated: queued.updated,
            deduped: queued.deduped,
            queue: queued.summary,
          });
        }

        const out: Record<string, unknown> = {
          ok: true,
          requested: accepted.length,
          rejected,
          action,
          engines,
          queueOnFailure,
        };

        const failedForQueue: Record<IndexEngine, string[]> = {
          indexnow: [],
          google: [],
        };

        if (engines.includes("indexnow")) {
          const r = await submitIndexNow(accepted, env);
          out.indexnow = {
            ok: r.ok,
            submitted: r.submitted,
            status: r.status,
            attempts: r.attempts,
            retried: r.retried,
            retryableFailures: r.retryableFailures,
            attemptLog: r.attemptLog,
            body: r.body,
            error: r.error,
          };

          if (!r.ok) {
            out.ok = false;
            failedForQueue.indexnow.push(...accepted);
          }
        }

        if (engines.includes("google")) {
          const r = await submitGoogleIndexing(accepted, action, env);
          out.google = {
            ok: r.ok,
            submitted: r.submitted,
            failed: r.failed,
            status: r.status,
            details: r.details,
            error: r.error,
          };

          if (!r.ok) {
            out.ok = false;
          }

          for (const detail of r.details) {
            if (!detail.ok) failedForQueue.google.push(detail.url);
          }
        }

        const queuedFailures: Record<string, unknown> = {};
        if (queueOnFailure) {
          if (failedForQueue.indexnow.length > 0) {
            const q = await enqueueIndexQueue(env, {
              urls: [...new Set(failedForQueue.indexnow)],
              action,
              engines: ["indexnow"],
              source: "api:index-urls(indexnow-failure)",
            });
            queuedFailures.indexnow = {
              queued: failedForQueue.indexnow.length,
              created: q.created,
              updated: q.updated,
              deduped: q.deduped,
            };
          }

          if (failedForQueue.google.length > 0) {
            const q = await enqueueIndexQueue(env, {
              urls: [...new Set(failedForQueue.google)],
              action,
              engines: ["google"],
              source: "api:index-urls(google-failure)",
            });
            queuedFailures.google = {
              queued: failedForQueue.google.length,
              created: q.created,
              updated: q.updated,
              deduped: q.deduped,
            };
          }
        }

        const queue = await loadIndexQueue(env);
        out.queue = summarizeQueueForResponse(queue);
        out.queuedFailures = queuedFailures;

        return apiJson(out, out.ok ? 200 : 207);
      }

      return apiError("NOT_FOUND", "Unknown API route", 404);
    }

    // ── Static routes ──
    if (path === "/health") return json({ ok: true, service: "clawea-www", ts: new Date().toISOString() });

    const turnstileSiteKey = env.TURNSTILE_SITE_KEY?.trim() || "1x00000000000000000000AA";

    if (path === "/") return await htmlWithExperiment(html(homePage(), 200, 7200), path);
    if (path === "/pricing") return await htmlWithExperiment(html(pricingPage()), path);
    if (path === "/assessment") return await htmlWithExperiment(html(assessmentPage(turnstileSiteKey), 200, 1800), path);
    if (path === "/assessment/result") return await htmlWithExperiment(html(assessmentResultPage(parseAssessmentResult(url), turnstileSiteKey), 200, 900), "/assessment/result");
    if (path === "/contact") return await htmlWithExperiment(html(contactPage(turnstileSiteKey)), path);
    if (path === "/trust") return await htmlWithExperiment(html(trustPage()), path);
    if (path === "/secure-workers") return await htmlWithExperiment(html(secureWorkersPage()), path);
    if (path === "/consulting") return await htmlWithExperiment(html(consultingPage()), path);
    if (path === "/about") return await htmlWithExperiment(html(aboutPage()), path);
    if (path === "/sources") {
      const manifest = await loadManifest(env);
      return await htmlWithExperiment(html(sourcesHubPage(manifest), 200, 1800), path);
    }

    if (path === "/glossary") {
      const q = normalizeSearchQuery(url.searchParams.get("q"));
      if (q) {
        const manifest = await loadManifest(env);
        const corpus = buildSearchCorpus(manifest);
        const results = searchCorpus(corpus, q, 32);
        return await htmlWithExperiment(html(glossarySearchPage(q, results), 200, 300), "/glossary");
      }
    }

    if (path === "/llms.txt") {
      return new Response(
        [
          "# Claw EA",
          "",
          "Claw EA publishes policy-first enterprise agent implementation references.",
          "Use citation-ready pages with explicit sources and proof summaries.",
          "",
          "## High-intent routes",
          "- https://www.clawea.com/assessment",
          "- https://www.clawea.com/contact",
          "- https://www.clawea.com/trust",
          "- https://www.clawea.com/sources",
          "",
          "## Core references",
          "- https://www.clawea.com/policy-as-code-for-agents",
          "- https://www.clawea.com/secure-agent-execution",
          "- https://www.clawea.com/agent-proof-and-attestation",
          "- https://www.clawea.com/agent-audit-and-replay",
          "",
          "## Sitemap",
          "- https://www.clawea.com/sitemap.xml",
        ].join("\n"),
        { headers: { "content-type": "text/plain;charset=utf-8", "cache-control": "public, max-age=86400" } },
      );
    }

    // ── Robots.txt ──
    if (path === "/robots.txt") {
      return new Response(
        `User-agent: *\nAllow: /\nDisallow: /api/\nDisallow: /v1/\n\nSitemap: https://www.clawea.com/sitemap.xml\n`,
        { headers: { "content-type": "text/plain", "cache-control": "public, max-age=86400" } },
      );
    }

    // ── Sitemap ──
    if (path === "/sitemap.xml") {
      return await serveSitemap(env);
    }

    // ── Dynamic article routes ──
    const slug = slugFromPath(path);
    const article = await loadArticle(env, slug);
    if (article) {
      return await htmlWithExperiment(html(articlePage(article), 200, 3600), `/${article.slug}`);
    }

    // ── 404 ──
    return await htmlWithExperiment(html(notFoundPage(), 404), path);
  },

  async scheduled(_controller: ScheduledController, env: Env, ctx: ExecutionContext): Promise<void> {
    if (queueEnabled(env)) {
      const maxEntries = queueMaxEntriesPerRun(env);
      ctx.waitUntil((async () => {
        try {
          await processIndexQueue(env, {
            source: "scheduled",
            maxEntries,
          });
        } catch (err) {
          console.error("INDEX_QUEUE_SCHEDULED_FAILED", err);
        }
      })());
    }

    ctx.waitUntil((async () => {
      try {
        await enqueueWeeklyVariantReportIfDue(env);
      } catch (err) {
        console.error("VARIANT_REPORT_ENQUEUE_FAILED", err);
      }
    })());
  },

  async queue(batch: MessageBatch<any>, env: Env): Promise<void> {
    await leadJobsQueue(batch, env);
  },
} satisfies ExportedHandler<Env>;

// ── Sitemap Generator ─────────────────────────────────────────────

async function serveSitemap(env: Env): Promise<Response> {
  // Load sitemap index from R2
  // Core sitemap only (Plan A)
  const obj = await env.ARTICLES.get("articles/_sitemap_core.json");
  const staticPages = [
    { slug: "", priority: "1.0" },
    { slug: "assessment", priority: "0.9" },
    { slug: "trust", priority: "0.8" },
    { slug: "secure-workers", priority: "0.8" },
    { slug: "consulting", priority: "0.8" },
    { slug: "pricing", priority: "0.8" },
    { slug: "contact", priority: "0.8" },
    { slug: "sources", priority: "0.7" },
    { slug: "about", priority: "0.6" },
  ];

  let entries = staticPages.map((p) => `  <url><loc>https://www.clawea.com/${p.slug}</loc><priority>${p.priority}</priority><changefreq>weekly</changefreq></url>`);

  if (obj) {
    const articles = await obj.json<{ slug: string; category: string }[]>();
    for (const a of articles) {
      const pri =
        a.category === "pillars" || a.category === "hubs" ? "0.8"
          : a.category === "guides" ? "0.7"
            : ["controls", "policy", "proof", "verify", "audit"].includes(a.category) ? "0.7"
              : [
                  "workflows",
                  "tools",
                  "channels",
                  "mcp",
                  "supply-chain",
                  "compliance",
                  "compare",
                  "roles",
                ].includes(a.category) ? "0.6"
                : a.category === "glossary" ? "0.5"
                  : "0.5";
      entries.push(`  <url><loc>https://www.clawea.com/${a.slug}</loc><priority>${pri}</priority><changefreq>monthly</changefreq></url>`);
    }
  }

  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${entries.join("\n")}
</urlset>`;

  return new Response(xml, {
    headers: { "content-type": "application/xml", "cache-control": "public, max-age=3600" },
  });
}
