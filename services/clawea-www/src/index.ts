/**
 * clawea-www — Programmatic SEO site for clawea.com
 *
 * Serves 10k+ pages from R2-stored articles generated by Gemini.
 * Full SEO: JSON-LD, FAQ schema, OG tags, sitemap, robots.txt,
 * internal linking mesh, breadcrumbs, canonical URLs.
 *
 * Routes:
 *   GET /                        → homepage
 *
 *   Core permissioned-execution taxonomy:
 *   GET /policy-as-code-for-agents
 *   GET /secure-agent-execution
 *   GET /agent-proof-and-attestation
 *   GET /agent-audit-and-replay
 *   GET /agent-supply-chain-security
 *   GET /event-native-agents
 *   GET /mcp-security
 *
 *   Families:
 *   GET /controls/*              → control pages
 *   GET /tools/*                 → enterprise tool pages
 *   GET /channels/*              → channel control plane pages
 *   GET /workflows/*             → workflow recipes (workflow → tool → channel)
 *   GET /policy/*                → policy artifacts and validation
 *   GET /proof/*                 → proof pages
 *   GET /verify/*                → verification pages
 *   GET /audit/*                 → audit/replay pages
 *   GET /mcp/*                   → MCP security and server governance
 *   GET /supply-chain/*          → extension supply chain security
 *   GET /events/*                → event-native trigger patterns
 *   GET /compliance/*            → compliance mappings and evidence
 *   GET /guides/*                → implementation guides
 *   GET /glossary/*              → glossary entries
 *   GET /vs/*, /compare/*, /for/* → comparisons and role-based pages
 *
 *   Static pages:
 *   GET /pricing, /assessment, /assessment/result, /contact, /book, /about, /trust, /secure-workers, /consulting, /sources
 *
 *   System endpoints:
 *   GET /sitemap.xml, /robots.txt, /llms.txt, /health
 *   GET /<INDEXNOW_KEY>.txt
 *   GET /api/search?q=...
 *   GET /api/experiments/config, /api/experiments/assignment, /api/experiments/winners (token-protected)
 *   POST /api/experiments/recommend (token-protected, guardrailed recommendations)
 *   POST /api/leads/submit
 *   GET /api/leads/status, /api/leads/export (token-protected)
 *   GET /api/routing/status, POST /api/routing/replay (token-protected)
 *   GET /api/attribution/summary, /api/attribution/revenue (token-protected)
 *   GET /api/ops/lead-funnel-health, /api/ops/routing-health, /api/ops/conversion-heatmap, /api/ops/failing-steps, /api/ops/lead-intake-security (token-protected)
 *   POST /api/book/submit, POST /api/book/complete (complete is token-protected)
 *   POST /api/indexnow, /api/google-index, /api/index-urls
 *   GET /api/index-queue/status
 *   POST /api/index-queue/enqueue, /api/index-queue/replay
 *   POST /api/events (public conversion telemetry)
 *   POST /api/events/summary (token-protected weekly summary)
 *
 * Dynamic article routing:
 * - Any non-static route attempts to load articles/<slug>.json from R2.
 */

import { layout } from "./layout";
import {
  faqSchema,
  howToSchema,
  serviceSchema,
  canonical,
  definedTermSchema,
  techArticleSchema,
  productSchema,
  softwareApplicationSchema,
  offerCatalogSchema,
  type PageMeta,
} from "./seo";
import { trustPage, securityReviewPackPage, secureWorkersPage, consultingPage, aboutPage } from "./pages/static";
import { compareManualAuditPage, compareGuardrailsPage, compareLangfusePage, compareCustomWrappersPage, compareGovernanceLandscapePage } from "./pages/compare";
import { guideGithubActionsProofPage, guideOktaScopedTokensPage, guideComplianceExportPage } from "./pages/guides";
import { industryFinancialServicesPage, industryHealthcarePage, industryGovernmentPage, industryInsurancePage, industryLegalPage, industryTechnologyPage } from "./pages/industries";
import { pricingStarterPage, pricingTeamPage, pricingEnterprisePage } from "./pages/pricing-tiers";
import { proofPointsPage } from "./pages/proof-points";
import { resourceProtocolWhitepaperPage, resourceSecurityChecklistPage, resourceComplianceMappingPage } from "./pages/resources";
import { securityPage, privacyPage, termsPage, docsPage, changelogPage, statusPage } from "./pages/trust-infra";
import { caseStudiesIndexPage, caseStudyDogfoodPage } from "./pages/case-studies";

export interface Env {
  ARTICLES: R2Bucket;
  SITE_URL: string;
  ENVIRONMENT: string;

  // Demand capture data + jobs
  DB: D1Database;
  VARIANT_CONFIG: KVNamespace;
  LEAD_JOBS: Queue;
  LEAD_ROUTE_ENTERPRISE: Queue;
  LEAD_ROUTE_SMB: Queue;
  LEAD_ROUTE_PARTNER: Queue;
  LEAD_SUBMIT_LOCK: DurableObjectNamespace;
  ANALYTICS?: AnalyticsEngineDataset;

  // Indexing automation
  INDEXNOW_KEY?: string;
  INDEX_AUTOMATION_TOKEN?: string;
  LEADS_API_TOKEN?: string;
  GOOGLE_INDEXING_SERVICE_ACCOUNT_JSON?: string;
  INDEXNOW_MAX_ATTEMPTS?: string;
  INDEXNOW_RETRY_BASE_MS?: string;
  INDEXNOW_RETRY_MAX_MS?: string;
  GOOGLE_INDEX_MAX_ATTEMPTS?: string;
  GOOGLE_INDEX_RETRY_BASE_MS?: string;
  GOOGLE_INDEX_RETRY_MAX_MS?: string;

  // Durable indexing queue
  INDEX_QUEUE_ENABLED?: string;
  INDEX_QUEUE_MAX_ENTRIES_PER_RUN?: string;
  INDEX_QUEUE_INDEXNOW_MAX_ATTEMPTS?: string;
  INDEX_QUEUE_GOOGLE_MAX_ATTEMPTS?: string;
  INDEX_QUEUE_RETRY_BASE_MS?: string;
  INDEX_QUEUE_RETRY_MAX_MS?: string;

  // Lead intake + Turnstile
  TURNSTILE_SECRET_KEY?: string;
  TURNSTILE_SITE_KEY?: string;
  TURNSTILE_REQUIRED?: string;
  TURNSTILE_STRICT_REAL_KEY?: string;
  LEAD_ID_HASH_SALT?: string;
  LEAD_SUBMIT_IP_WINDOW_LIMIT?: string;
  LEAD_SUBMIT_EMAIL_WINDOW_LIMIT?: string;
  LEAD_SUBMIT_WINDOW_MINUTES?: string;

  // Routing / CRM handoff
  ROUTING_MAX_ATTEMPTS?: string;
  CRM_PROVIDER_CONFIG_KEY?: string;
  CRM_PROVIDER_CONFIG_JSON?: string;
  CRM_PROVIDER_AUTH_JSON?: string;
  CRM_HANDOFF_SIGNING_SECRET?: string;

  // Experiment routing
  EXPERIMENT_SEED?: string;
  EXPERIMENT_CONFIG_KEY?: string;
  EXPERIMENT_WINNER_MIN_IMPRESSIONS?: string;
  EXPERIMENT_WINNER_MIN_BOOKED?: string;
  EXPERIMENT_WINNER_MIN_CONFIDENCE?: string;
  EXPERIMENT_HOLDOUT_PERCENT?: string;

  // Rev-007 operator thresholds
  LEAD_RESPONSE_SLA_MINUTES?: string;
  ROUTING_QUEUE_LAG_ALERT_MINUTES?: string;
}

export interface Article {
  slug: string;
  title: string;
  category: string;
  html: string;
  description: string;
  faqs: { q: string; a: string }[];
  /** v2 structured how-to support (optional, used when present) */
  howToTitle?: string;
  howToSteps?: Array<{ name: string; text: string }>;
  sources: { title: string; uri: string }[];
  model: string;
  generatedAt: string;
  /** Plan A: only index selected pages initially. */
  indexable?: boolean;
}

export interface ManifestEntry {
  title: string;
  category: string;
  description: string;
  indexable?: boolean;
}

export type SearchDocumentKind = "article" | "static";

export interface SearchDocument {
  path: string;
  title: string;
  description: string;
  category: string;
  kind: SearchDocumentKind;
}

export interface SearchResult extends SearchDocument {
  score: number;
}

export type TurnstilePostureCode =
  | "TURNSTILE_OPTIONAL"
  | "TURNSTILE_READY"
  | "TURNSTILE_NOT_CONFIGURED"
  | "TURNSTILE_SITE_KEY_MISSING"
  | "TURNSTILE_TEST_KEY_FORBIDDEN";

export interface TurnstilePosture {
  required: boolean;
  strictRealKey: boolean;
  siteKey?: string;
  secretConfigured: boolean;
  usesTestSiteKey: boolean;
  formEnabled: boolean;
  code: TurnstilePostureCode;
  message: string;
}

export type LeadLifecycleStatus =
  | "new"
  | "validated"
  | "scored"
  | "routed"
  | "contacted"
  | "qualified"
  | "disqualified"
  | "booked"
  // legacy aliases retained for backward compatibility
  | "enriched"
  | "closed"
  | "rejected";

export type LeadSegment = "enterprise" | "smb" | "partner";
export type LeadScoreBand = "high" | "medium" | "low";
export type LeadSourceIntent = "partner" | "paid-intent" | "high-intent" | "organic" | "direct";

export interface LeadBehaviorSignals {
  sessionEvents?: number;
  ctaClicks?: number;
  intentViews?: number;
  assessmentCompleted?: boolean;
  secondsOnSite?: number;
}

export interface LeadSubmissionPayload {
  fullName?: string;
  email?: string;
  company?: string;
  role?: string;
  teamSize?: string;
  timeline?: string;
  primaryUseCase?: string;
  intentNote?: string;
  assessment?: {
    readinessScore?: number;
    roiScore?: number;
    riskScore?: number;
    confidenceLabel?: string;
  };
  behavior?: LeadBehaviorSignals;
  attribution?: Record<string, string>;
  firstTouch?: {
    ts?: string;
    path?: string;
    pageFamily?: string;
    source?: string;
  };
  page?: string;
  pageFamily?: string;
  variantId?: string;
  heroVariant?: string;
  ctaVariant?: string;
  visitorId?: string;
  turnstileToken?: string;
  idempotencyKey?: string;
}

export interface LeadRow {
  lead_id: string;
  created_at: string;
  updated_at: string;
  last_seen_at: string;
  status: LeadLifecycleStatus;
  qualification_score: number;
  intent_score: number;
  risk_score: number;
  readiness_score: number;
  roi_score: number;
  dedupe_count: number;
  source: string;
  source_intent: LeadSourceIntent;
  page: string;
  page_family: string;
  full_name: string;
  company: string;
  role: string;
  team_size: string;
  timeline: string;
  primary_use_case: string;
  email_hint: string;
  score_band: LeadScoreBand;
  segment: LeadSegment;
  campaign_id: string;
  variant_id: string;
  hero_variant: string;
  cta_variant: string;
  route_status: string;
  routed_provider_id: string;
  booked_at: string | null;
  completed_at: string | null;
}

export interface ExperimentFamilyConfig {
  hero: string[];
  cta: string[];
  holdoutPercent?: number;
}

export interface ExperimentVariantConfig {
  seed: string;
  holdoutPercent?: number;
  families: Record<string, ExperimentFamilyConfig>;
}

export const DEFAULT_EXPERIMENT_CONFIG: ExperimentVariantConfig = {
  seed: "aeo-rev-007-default",
  holdoutPercent: 5,
  families: {
    home: { hero: ["proof", "roi", "speed"], cta: ["proof", "roi", "speed"], holdoutPercent: 5 },
    assessment: { hero: ["proof", "roi", "speed"], cta: ["proof", "roi", "speed"], holdoutPercent: 5 },
    tools: { hero: ["proof", "risk"], cta: ["assessment", "sales"], holdoutPercent: 4 },
    workflows: { hero: ["proof", "automation"], cta: ["assessment", "sales"], holdoutPercent: 4 },
    contact: { hero: ["fast-path", "proof"], cta: ["submit", "assessment"], holdoutPercent: 8 },
    book: { hero: ["proof", "speed"], cta: ["submit", "assessment"], holdoutPercent: 10 },
    pricing: { hero: ["roi", "proof"], cta: ["proof", "roi", "sales"], holdoutPercent: 6 },
    sources: { hero: ["proof", "citation"], cta: ["assessment", "sales"], holdoutPercent: 5 },
    root: { hero: ["proof", "roi"], cta: ["proof", "roi"], holdoutPercent: 4 },
  },
};

export type LeadScoreReason = {
  code: string;
  points: number;
  detail?: string;
};

export type LeadScoreResult = {
  intentScore: number;
  readinessScore: number;
  roiScore: number;
  riskScore: number;
  qualificationScore: number;
  confidenceLabel: string;
  scoreBand: LeadScoreBand;
  segment: LeadSegment;
  sourceIntent: LeadSourceIntent;
  scoreReasons: LeadScoreReason[];
  denyCode?: string;
};

export type CrmProvider = {
  id: string;
  endpoint?: string;
  authType?: "none" | "bearer" | "header";
  authHeader?: string;
};

export type CrmRoutingRule = {
  providerId: string;
  segment?: LeadSegment;
  scoreBand?: LeadScoreBand;
  sourceIntent?: LeadSourceIntent;
};

export type CrmRoutingConfig = {
  defaultProviderBySegment: Record<LeadSegment, string>;
  providers: CrmProvider[];
  providerRules: CrmRoutingRule[];
};

export type LeadHandoffEnvelope = {
  version: "1.0";
  handoffId: string;
  leadId: string;
  idempotencyKey: string;
  occurredAt: string;
  segment: LeadSegment;
  score: {
    qualification: number;
    band: LeadScoreBand;
    intent: number;
    readiness: number;
    roi: number;
    risk: number;
    sourceIntent: LeadSourceIntent;
    reasons: LeadScoreReason[];
  };
  attribution: {
    source: string;
    campaignId: string;
    pageFamily: string;
    variantId: string;
    heroVariant: string;
    ctaVariant: string;
  };
  lead: {
    company: string;
    role: string;
    teamSize: string;
    timeline: string;
    primaryUseCase: string;
    emailHint: string;
  };
};

export const DEFAULT_CRM_ROUTING_CONFIG: CrmRoutingConfig = {
  defaultProviderBySegment: {
    enterprise: "internal-r2",
    smb: "internal-r2",
    partner: "internal-r2",
  },
  providers: [
    { id: "internal-r2", authType: "none" },
  ],
  providerRules: [
    { providerId: "internal-r2", segment: "partner", sourceIntent: "partner" },
    { providerId: "internal-r2", segment: "enterprise", scoreBand: "high" },
    { providerId: "internal-r2", segment: "enterprise", scoreBand: "medium" },
    { providerId: "internal-r2", segment: "smb" },
  ],
};

export const DISPOSABLE_EMAIL_DOMAINS = new Set([
  "mailinator.com",
  "guerrillamail.com",
  "yopmail.com",
  "tempmail.com",
  "10minutemail.com",
]);

export const LEAD_STATE_TRANSITIONS: Record<string, ReadonlyArray<LeadLifecycleStatus>> = {
  new: ["validated"],
  validated: ["scored"],
  scored: ["routed"],
  routed: ["contacted"],
  contacted: ["qualified", "disqualified", "booked"],
  qualified: ["booked"],
  disqualified: ["booked"],
  booked: [],
};

export const RESPONSE_SLA_OPEN_STATES = new Set<LeadLifecycleStatus>(["new", "validated", "scored", "routed"]);
export const RESPONSE_SLA_CLOSED_STATES = new Set<LeadLifecycleStatus>(["contacted", "qualified", "disqualified", "booked"]);

// ── Helpers ───────────────────────────────────────────────────────

export function json(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: { "content-type": "application/json", "access-control-allow-origin": "*" },
  });
}

export function html(body: string, status = 200, cacheSeconds = 3600): Response {
  return new Response(body, {
    status,
    headers: {
      "content-type": "text/html;charset=utf-8",
      "cache-control": `public, max-age=${cacheSeconds}, s-maxage=${cacheSeconds * 24}`,
    },
  });
}

export function apiHeaders(extra: HeadersInit = {}): Headers {
  const h = new Headers(extra);
  h.set("access-control-allow-origin", "*");
  h.set("access-control-allow-methods", "GET,POST,OPTIONS");
  h.set("access-control-allow-headers", "content-type,authorization");
  h.set("cache-control", "no-store");
  return h;
}

export function apiJson(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: apiHeaders({ "content-type": "application/json" }),
  });
}

export function apiError(code: string, message: string, status = 400): Response {
  return apiJson({ ok: false, error: { code, message } }, status);
}

export function getBearerToken(request: Request): string | null {
  const auth = request.headers.get("authorization") ?? "";
  const m = auth.match(/^Bearer\s+(.+)$/i);
  return m?.[1]?.trim() ?? null;
}

export function checkAutomationAuth(request: Request, env: Env): Response | null {
  const secret = env.INDEX_AUTOMATION_TOKEN?.trim();
  if (!secret) {
    return apiError("INDEX_AUTOMATION_NOT_CONFIGURED", "Indexing automation token is not configured", 503);
  }

  const token = getBearerToken(request);
  if (!token || token !== secret) {
    return apiError("UNAUTHORIZED", "Missing or invalid bearer token", 401);
  }

  return null;
}

export function checkOpsAuth(request: Request, env: Env): Response | null {
  const secret = env.LEADS_API_TOKEN?.trim() || env.INDEX_AUTOMATION_TOKEN?.trim();
  if (!secret) {
    return apiError("OPS_AUTH_NOT_CONFIGURED", "Ops bearer token is not configured", 503);
  }

  const token = getBearerToken(request);
  if (!token || token !== secret) {
    return apiError("UNAUTHORIZED", "Missing or invalid bearer token", 401);
  }

  return null;
}

export class LeadSubmitLockDO {
  constructor(private readonly state: DurableObjectState) {}

  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);

    if (request.method !== "POST") {
      return new Response(JSON.stringify({ ok: false, error: "METHOD_NOT_ALLOWED" }), {
        status: 405,
        headers: { "content-type": "application/json" },
      });
    }

    const body = await request.json<any>().catch(() => ({}));
    const now = Date.now();

    if (url.pathname === "/acquire") {
      const ttlMs = Math.max(10_000, Math.min(120_000, Number(body?.ttlMs ?? 45_000)));
      const lock = await this.state.storage.get<any>("lock");

      if (lock?.status === "done" && typeof lock.leadId === "string") {
        return new Response(JSON.stringify({ ok: true, replay: true, leadId: lock.leadId }), {
          status: 200,
          headers: { "content-type": "application/json" },
        });
      }

      if (lock?.status === "processing" && Number(lock.expiresAt ?? 0) > now) {
        return new Response(JSON.stringify({ ok: false, replay: false, inFlight: true }), {
          status: 409,
          headers: { "content-type": "application/json" },
        });
      }

      await this.state.storage.put("lock", {
        status: "processing",
        startedAt: now,
        expiresAt: now + ttlMs,
      });

      return new Response(JSON.stringify({ ok: true, replay: false }), {
        status: 200,
        headers: { "content-type": "application/json" },
      });
    }

    if (url.pathname === "/complete") {
      const leadId = typeof body?.leadId === "string" ? body.leadId : "";
      await this.state.storage.put("lock", {
        status: "done",
        leadId,
        completedAt: now,
        expiresAt: now + (1000 * 60 * 60 * 24),
      });
      return new Response(JSON.stringify({ ok: true }), {
        status: 200,
        headers: { "content-type": "application/json" },
      });
    }

    if (url.pathname === "/fail") {
      await this.state.storage.delete("lock");
      return new Response(JSON.stringify({ ok: true }), {
        status: 200,
        headers: { "content-type": "application/json" },
      });
    }

    return new Response(JSON.stringify({ ok: false, error: "NOT_FOUND" }), {
      status: 404,
      headers: { "content-type": "application/json" },
    });
  }
}


// ── Indexing (extracted to indexing.ts) ──
import {
  submitIndexNow, submitGoogleIndexing,
  loadIndexQueue as _loadIndexQueue, loadLastQueueRun as _loadLastQueueRun,
  summarizeQueueForResponse,
  enqueueIndexQueue, processIndexQueue, forceRequeueFailedEntries,
  normalizeUrlList, parseIndexingEngines,
  queueEnabled, queueMaxEntriesPerRun,
  summarizeIndexQueue as _summarizeIndexQueue,
  type IndexAction, type IndexEngine,
  loadArticle, loadManifest, slugFromPath,
  normalizeSearchQuery, buildSearchCorpus, searchCorpus, previewText,
  glossarySearchPage,
} from "./indexing";

// Re-export for leads.ts
export { _loadIndexQueue as loadIndexQueue, _summarizeIndexQueue as summarizeIndexQueue, _loadLastQueueRun as loadLastQueueRun };


// ── Leads/CRM/Routing/Tracking/Experiments/Queue (extracted to leads.ts) ──
import {
  ingestTrackingEvent, summarizeTrackingEvents,
  submitLead, leadsStatus, leadsExport,
  routingStatus, routingReplay,
  attributionSummary, attributionRevenueSummary,
  opsLeadFunnelHealth, opsRoutingHealth, opsConversionHeatmap,
  opsFailingSteps, opsLeadIntakeSecurityPosture,
  bookSubmit, bookComplete,
  recommendExperimentWinners, experimentsWinners,
  stableHash, loadExperimentConfig, assignVariant,
  readCookie, getOrCreateVisitorId, applyExperimentCookies,
  experimentAssignmentEndpoint,
  leadJobsQueue, enqueueWeeklyVariantReportIfDue,
  computeLeadResponseSla, computeRoutingHealth,
  clipString, pageFamilyFromPath, shouldRenderTurnstileWidget,
  resolveTurnstilePosture,
} from "./leads";

export function breadcrumbsFromSlug(slug: string): { name: string; path: string }[] {
  const parts = slug.split("/");
  const crumbs = [{ name: "Home", path: "/" }];

  const labels: Record<string, string> = {
    // v2 taxonomy
    controls: "Controls",
    policy: "Policy",
    proof: "Proof",
    verify: "Verify",
    audit: "Audit",
    channels: "Channels",
    tools: "Tools",
    workflows: "Workflows",
    events: "Events",
    mcp: "MCP",
    "supply-chain": "Supply Chain",
    compliance: "Compliance",
    guides: "Guides",
    glossary: "Glossary",
    compare: "Compare",
    vs: "Vs",
    for: "For",

    // legacy (if old slugs exist in R2)
    deploy: "Deploy",
    integrations: "Integrations",
    "use-cases": "Use Cases",
    models: "Models",
    solutions: "Solutions",
    connect: "Connect",
    enterprise: "Enterprise",
  };

  let accum = "";
  for (const part of parts) {
    accum += "/" + part;
    crumbs.push({
      name: labels[part] ?? part.split("-").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(" "),
      path: accum,
    });
  }

  return crumbs;
}

// ── Static Pages ──────────────────────────────────────────────────


// ── Core pages (extracted to pages/core.ts) ──
import {
  homePage, pricingPage, contactPage, bookPage,
  sourcesHubPage, notFoundPage,
  parseAssessmentResult, assessmentPage, assessmentResultPage,
  articlePage, renderTurnstileBlock,
} from "./pages/core";

// ── Weekly analytics report ─────────────────────────────────────────────
// Self-dedupes: checks KV for last run timestamp, skips if < 6 days ago.

const ANALYTICS_REPORT_KV_KEY = "analytics:weekly-report:last-run";

async function generateWeeklyAnalyticsReport(env: Env): Promise<void> {
  // Check if we already ran this week
  const lastRunRaw = await env.VARIANT_CONFIG.get(ANALYTICS_REPORT_KV_KEY);
  if (lastRunRaw) {
    const lastRun = new Date(lastRunRaw);
    const now = new Date();
    const daysSinceLastRun = (now.getTime() - lastRun.getTime()) / (1000 * 60 * 60 * 24);
    if (daysSinceLastRun < 6) return; // Skip, already ran this week
  }

  // Query D1 for tracking events from the last 7 days
  const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
  const now = new Date().toISOString();

  // Top pages by events
  const topPages = await env.DB.prepare(
    `SELECT page, COUNT(*) as count FROM tracking_events 
     WHERE created_at >= ? GROUP BY page ORDER BY count DESC LIMIT 20`
  ).bind(sevenDaysAgo).all<{ page: string; count: number }>();

  // Events by type
  const eventsByType = await env.DB.prepare(
    `SELECT event_type, COUNT(*) as count FROM tracking_events 
     WHERE created_at >= ? GROUP BY event_type ORDER BY count DESC`
  ).bind(sevenDaysAgo).all<{ event_type: string; count: number }>();

  // Top referrers
  const topReferrers = await env.DB.prepare(
    `SELECT page_family, COUNT(*) as count FROM tracking_events 
     WHERE created_at >= ? AND event_type = 'cta_click' GROUP BY page_family ORDER BY count DESC LIMIT 10`
  ).bind(sevenDaysAgo).all<{ page_family: string; count: number }>();

  // Lead submissions this week
  const leadCount = await env.DB.prepare(
    `SELECT COUNT(*) as count FROM leads WHERE created_at >= ?`
  ).bind(sevenDaysAgo).first<{ count: number }>();

  // Assessment completions
  const assessmentCount = await env.DB.prepare(
    `SELECT COUNT(*) as count FROM tracking_events 
     WHERE created_at >= ? AND event_type = 'assessment_complete'`
  ).bind(sevenDaysAgo).first<{ count: number }>();

  // Book clicks
  const bookCount = await env.DB.prepare(
    `SELECT COUNT(*) as count FROM tracking_events 
     WHERE created_at >= ? AND event_type = 'book_click'`
  ).bind(sevenDaysAgo).first<{ count: number }>();

  const report = {
    generatedAt: now,
    period: { from: sevenDaysAgo, to: now },
    summary: {
      totalEvents: (eventsByType.results ?? []).reduce((sum, r) => sum + r.count, 0),
      leadSubmissions: leadCount?.count ?? 0,
      assessmentCompletions: assessmentCount?.count ?? 0,
      bookClicks: bookCount?.count ?? 0,
    },
    topPagesByEvents: (topPages.results ?? []).map(r => ({ page: r.page, events: r.count })),
    eventsByType: (eventsByType.results ?? []).map(r => ({ type: r.event_type, count: r.count })),
    ctaClicksByPageFamily: (topReferrers.results ?? []).map(r => ({ family: r.page_family, clicks: r.count })),
  };

  // Write report to R2
  const reportDate = now.slice(0, 10);
  const reportKey = `reports/conversion/weekly-${reportDate}.json`;
  await env.ARTICLES.put(reportKey, JSON.stringify(report, null, 2), {
    httpMetadata: { contentType: "application/json" },
  });

  // Update last-run timestamp
  await env.VARIANT_CONFIG.put(ANALYTICS_REPORT_KV_KEY, now);

  console.log(`WEEKLY_ANALYTICS_REPORT_GENERATED: ${reportKey} (${report.summary.totalEvents} events)`);
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname.replace(/\/+$/, "") || "/";

    const visitor = getOrCreateVisitorId(request);
    const existingExpCookie = clipString(readCookie(request, "clawea_exp"), 240);
    const experimentConfigPromise = loadExperimentConfig(env);

    const htmlWithExperiment = async (response: Response, routePath = path): Promise<Response> => {
      const config = await experimentConfigPromise;
      const assignment = assignVariant(config, visitor.visitorId, pageFamilyFromPath(routePath));
      const expectedExp = `${assignment.pageFamily}:${assignment.heroVariant}:${assignment.ctaVariant}`;
      const shouldSetExpCookie = existingExpCookie !== expectedExp;

      // ── Lightweight page-view analytics (Analytics Engine) ──
      // No JS, no cookies, no third-party — just server-side writeDataPoint.
      try {
        const utmSource = url.searchParams.get("utm_source") ?? "";
        const utmMedium = url.searchParams.get("utm_medium") ?? "";
        const utmCampaign = url.searchParams.get("utm_campaign") ?? "";
        const referer = request.headers.get("referer") ?? "";
        const country = (request as any).cf?.country ?? "";
        const device = /Mobile|Android|iPhone|iPad/i.test(request.headers.get("user-agent") ?? "") ? "mobile" : "desktop";

        env.ANALYTICS?.writeDataPoint({
          indexes: ["pageview", pageFamilyFromPath(routePath), device, country],
          blobs: [routePath, referer, utmSource, utmMedium, utmCampaign, visitor.visitorId],
          doubles: [1],
        });
      } catch { /* analytics must never block rendering */ }

      return applyExperimentCookies(response, visitor.visitorId, assignment, visitor.cookieNeeded, shouldSetExpCookie);
    };

    // ── IndexNow key file ──
    if ((request.method === "GET" || request.method === "HEAD") && env.INDEXNOW_KEY && path === `/${env.INDEXNOW_KEY}.txt`) {
      return new Response(request.method === "HEAD" ? null : `${env.INDEXNOW_KEY}\n`, {
        headers: {
          "content-type": "text/plain;charset=utf-8",
          "cache-control": "public, max-age=86400",
        },
      });
    }

    // ── API routes (search + indexing + conversion telemetry) ──
    if (path.startsWith("/api/")) {
      if (request.method === "OPTIONS") {
        return new Response(null, { status: 204, headers: apiHeaders() });
      }

      // Public conversion instrumentation endpoint (no bearer token)
      if (path === "/api/events") {
        return await ingestTrackingEvent(request, env);
      }

      // Public search endpoint
      if (path === "/api/search") {
        if (request.method !== "GET") {
          return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
        }

        const query = normalizeSearchQuery(url.searchParams.get("q"));
        const limit = Math.min(50, Math.max(1, Number(url.searchParams.get("limit") ?? "10")));

        if (query.length < 2) {
          return apiError("QUERY_TOO_SHORT", "q must be at least 2 characters", 400);
        }

        const manifest = await loadManifest(env);
        const corpus = buildSearchCorpus(manifest);
        const results = searchCorpus(corpus, query, limit);

        return apiJson({
          ok: true,
          query,
          count: results.length,
          results: results.map((r) => ({
            path: r.path,
            title: r.title,
            description: previewText(r.description, 240),
            category: r.category,
            kind: r.kind,
            score: r.score,
          })),
        });
      }

      if (path === "/api/experiments/config") {
        if (request.method !== "GET") {
          return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
        }

        const config = await loadExperimentConfig(env);
        return apiJson({ ok: true, config });
      }

      if (path === "/api/experiments/assignment") {
        return await experimentAssignmentEndpoint(request, env);
      }

      if (path === "/api/experiments/winners") {
        return await experimentsWinners(request, env);
      }

      if (path === "/api/leads/submit") {
        return await submitLead(request, env);
      }

      if (path === "/api/leads/status") {
        return await leadsStatus(request, env);
      }

      if (path === "/api/leads/export") {
        return await leadsExport(request, env);
      }

      if (path === "/api/routing/status") {
        return await routingStatus(request, env);
      }

      if (path === "/api/routing/replay") {
        return await routingReplay(request, env);
      }

      if (path === "/api/attribution/summary") {
        return await attributionSummary(request, env);
      }

      if (path === "/api/attribution/revenue") {
        return await attributionRevenueSummary(request, env);
      }

      if (path === "/api/ops/lead-funnel-health") {
        return await opsLeadFunnelHealth(request, env);
      }

      if (path === "/api/ops/routing-health") {
        return await opsRoutingHealth(request, env);
      }

      if (path === "/api/ops/conversion-heatmap") {
        return await opsConversionHeatmap(request, env);
      }

      if (path === "/api/ops/failing-steps") {
        return await opsFailingSteps(request, env);
      }

      if (path === "/api/ops/lead-intake-security") {
        return await opsLeadIntakeSecurityPosture(request, env);
      }

      if (path === "/api/experiments/recommend") {
        return await recommendExperimentWinners(request, env);
      }

      if (path === "/api/book/submit") {
        return await bookSubmit(request, env);
      }

      if (path === "/api/book/complete") {
        return await bookComplete(request, env);
      }

      // Protected telemetry summary endpoint
      if (path === "/api/events/summary") {
        return await summarizeTrackingEvents(request, env);
      }

      const authError = checkAutomationAuth(request, env);
      if (authError) return authError;

      if (path === "/api/index-queue/status") {
        if (request.method !== "GET") {
          return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
        }

        const queue = await _loadIndexQueue(env);
        const lastRun = await _loadLastQueueRun(env);
        return apiJson({
          ok: true,
          enabled: queueEnabled(env),
          ...summarizeQueueForResponse(queue),
          lastRun,
        });
      }

      if (request.method !== "POST") {
        return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
      }

      let body: any;
      try {
        body = await request.json<any>();
      } catch {
        return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
      }

      if (path === "/api/index-queue/replay") {
        const forceFailed = body?.forceFailed === true;
        const simulate429 = body?.simulate429 === true;
        const maxEntries = Math.min(500, Math.max(1, Number(body?.maxEntries ?? queueMaxEntriesPerRun(env))));

        let forced = 0;
        if (forceFailed) {
          const out = await forceRequeueFailedEntries(env);
          forced = out.requeued;
        }

        const processed = await processIndexQueue(env, {
          source: "api:index-queue-replay",
          maxEntries,
          simulate429,
        });

        return apiJson({
          ok: true,
          forced,
          artifactKey: processed.artifactKey,
          run: processed.run,
        }, 200);
      }

      if (path === "/api/index-queue/enqueue") {
        const { accepted, rejected } = normalizeUrlList(body?.urls, 500);
        if (accepted.length === 0) {
          return apiError("URLS_INVALID", "No valid clawea.com URLs were provided", 400);
        }

        const action: IndexAction = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const engines = parseIndexingEngines(body?.engines);
        if (engines.length === 0) {
          return apiError("ENGINES_INVALID", "engines must include indexnow, google, or all", 400);
        }

        const enqueued = await enqueueIndexQueue(env, {
          urls: accepted,
          action,
          engines,
          force: body?.force === true,
          source: "api:index-queue-enqueue",
        });

        return apiJson({
          ok: true,
          action,
          engines,
          requested: accepted.length,
          rejected,
          created: enqueued.created,
          updated: enqueued.updated,
          deduped: enqueued.deduped,
          queue: enqueued.summary,
        });
      }

      const { accepted, rejected } = normalizeUrlList(body?.urls, 500);
      if (accepted.length === 0) {
        return apiError("URLS_INVALID", "No valid clawea.com URLs were provided", 400);
      }

      if (path === "/api/indexnow") {
        const result = await submitIndexNow(accepted, env);
        return apiJson({
          ok: result.ok,
          engine: "indexnow",
          submitted: result.submitted,
          requested: accepted.length,
          rejected,
          status: result.status,
          attempts: result.attempts,
          retried: result.retried,
          retryableFailures: result.retryableFailures,
          attemptLog: result.attemptLog,
          body: result.body,
          error: result.error,
        }, result.ok ? 200 : 502);
      }

      if (path === "/api/google-index") {
        const action = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const result = await submitGoogleIndexing(accepted, action, env);
        return apiJson({
          ok: result.ok,
          engine: "google",
          action,
          submitted: result.submitted,
          failed: result.failed,
          requested: accepted.length,
          rejected,
          status: result.status,
          details: result.details,
          error: result.error,
        }, result.ok ? 200 : result.status);
      }

      if (path === "/api/index-urls") {
        const action: IndexAction = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const engines = parseIndexingEngines(body?.engines);
        if (engines.length === 0) {
          return apiError("ENGINES_INVALID", "engines must include indexnow, google, or all", 400);
        }

        const queueOnly = body?.queueOnly === true;
        const queueOnFailure = body?.queueOnFailure !== false;

        if (queueOnly) {
          const queued = await enqueueIndexQueue(env, {
            urls: accepted,
            action,
            engines,
            force: body?.force === true,
            source: "api:index-urls(queue-only)",
          });

          return apiJson({
            ok: true,
            mode: "queue_only",
            action,
            engines,
            requested: accepted.length,
            rejected,
            created: queued.created,
            updated: queued.updated,
            deduped: queued.deduped,
            queue: queued.summary,
          });
        }

        const out: Record<string, unknown> = {
          ok: true,
          requested: accepted.length,
          rejected,
          action,
          engines,
          queueOnFailure,
        };

        const failedForQueue: Record<IndexEngine, string[]> = {
          indexnow: [],
          google: [],
        };

        if (engines.includes("indexnow")) {
          const r = await submitIndexNow(accepted, env);
          out.indexnow = {
            ok: r.ok,
            submitted: r.submitted,
            status: r.status,
            attempts: r.attempts,
            retried: r.retried,
            retryableFailures: r.retryableFailures,
            attemptLog: r.attemptLog,
            body: r.body,
            error: r.error,
          };

          if (!r.ok) {
            out.ok = false;
            failedForQueue.indexnow.push(...accepted);
          }
        }

        if (engines.includes("google")) {
          const r = await submitGoogleIndexing(accepted, action, env);
          out.google = {
            ok: r.ok,
            submitted: r.submitted,
            failed: r.failed,
            status: r.status,
            details: r.details,
            error: r.error,
          };

          if (!r.ok) {
            out.ok = false;
          }

          for (const detail of r.details) {
            if (!detail.ok) failedForQueue.google.push(detail.url);
          }
        }

        const queuedFailures: Record<string, unknown> = {};
        if (queueOnFailure) {
          if (failedForQueue.indexnow.length > 0) {
            const q = await enqueueIndexQueue(env, {
              urls: [...new Set(failedForQueue.indexnow)],
              action,
              engines: ["indexnow"],
              source: "api:index-urls(indexnow-failure)",
            });
            queuedFailures.indexnow = {
              queued: failedForQueue.indexnow.length,
              created: q.created,
              updated: q.updated,
              deduped: q.deduped,
            };
          }

          if (failedForQueue.google.length > 0) {
            const q = await enqueueIndexQueue(env, {
              urls: [...new Set(failedForQueue.google)],
              action,
              engines: ["google"],
              source: "api:index-urls(google-failure)",
            });
            queuedFailures.google = {
              queued: failedForQueue.google.length,
              created: q.created,
              updated: q.updated,
              deduped: q.deduped,
            };
          }
        }

        const queue = await _loadIndexQueue(env);
        out.queue = summarizeQueueForResponse(queue);
        out.queuedFailures = queuedFailures;

        return apiJson(out, out.ok ? 200 : 207);
      }

      return apiError("NOT_FOUND", "Unknown API route", 404);
    }

    // ── Static routes ──
    if (path === "/health") return json({ ok: true, service: "clawea-www", ts: new Date().toISOString() });

    const turnstile = resolveTurnstilePosture(env);
    const host = url.hostname.toLowerCase();
    const widgetEnabled = host !== "localhost" && host !== "127.0.0.1" && host !== "::1";

    if (path === "/") return await htmlWithExperiment(html(homePage(), 200, 7200), path);
    if (path === "/pricing") return await htmlWithExperiment(html(pricingPage()), path);
    if (path === "/assessment") return await htmlWithExperiment(html(assessmentPage(turnstile), 200, 1800), path);
    if (path === "/assessment/result") {
      return await htmlWithExperiment(
        html(assessmentResultPage(parseAssessmentResult(url), turnstile, { widgetEnabled }), 200, 900),
        "/assessment/result",
      );
    }
    if (path === "/contact") return await htmlWithExperiment(html(contactPage(turnstile, { widgetEnabled })), path);
    if (path === "/book") return await htmlWithExperiment(html(bookPage(url, turnstile, { widgetEnabled }), 200, 900), path);
    if (path === "/trust") return await htmlWithExperiment(html(trustPage()), path);
    if (path === "/trust/security-review") return await htmlWithExperiment(html(securityReviewPackPage()), path);
    if (path === "/secure-workers") return await htmlWithExperiment(html(secureWorkersPage()), path);
    if (path === "/consulting") return await htmlWithExperiment(html(consultingPage()), path);
    if (path === "/about") return await htmlWithExperiment(html(aboutPage()), path);

    // Compare pages
    if (path === "/compare/claw-vs-manual-audit") return await htmlWithExperiment(html(compareManualAuditPage()), path);
    if (path === "/compare/claw-vs-guardrails") return await htmlWithExperiment(html(compareGuardrailsPage()), path);
    if (path === "/compare/claw-vs-langfuse") return await htmlWithExperiment(html(compareLangfusePage()), path);
    if (path === "/compare/claw-vs-custom-wrappers") return await htmlWithExperiment(html(compareCustomWrappersPage()), path);
    if (path === "/compare/agent-governance-platforms") return await htmlWithExperiment(html(compareGovernanceLandscapePage()), path);

    // Implementation guides
    if (path === "/guides/github-actions-proof-pipeline") return await htmlWithExperiment(html(guideGithubActionsProofPage()), path);
    if (path === "/guides/okta-scoped-tokens") return await htmlWithExperiment(html(guideOktaScopedTokensPage()), path);
    if (path === "/guides/compliance-evidence-export") return await htmlWithExperiment(html(guideComplianceExportPage()), path);

    // Industry vertical pages
    if (path === "/industries/financial-services") return await htmlWithExperiment(html(industryFinancialServicesPage()), path);
    if (path === "/industries/healthcare") return await htmlWithExperiment(html(industryHealthcarePage()), path);
    if (path === "/industries/government") return await htmlWithExperiment(html(industryGovernmentPage()), path);
    if (path === "/industries/insurance") return await htmlWithExperiment(html(industryInsurancePage()), path);
    if (path === "/industries/legal") return await htmlWithExperiment(html(industryLegalPage()), path);
    if (path === "/industries/technology") return await htmlWithExperiment(html(industryTechnologyPage()), path);

    // Proof points
    if (path === "/proof-points") return await htmlWithExperiment(html(proofPointsPage()), path);

    // Pricing tier detail pages
    if (path === "/pricing/starter") return await htmlWithExperiment(html(pricingStarterPage()), path);
    if (path === "/pricing/team") return await htmlWithExperiment(html(pricingTeamPage()), path);
    if (path === "/pricing/enterprise") return await htmlWithExperiment(html(pricingEnterprisePage()), path);

    // Resource gate pages (email capture)
    const tsHtml = renderTurnstileBlock(turnstile, { widgetEnabled });
    if (path === "/resources/protocol-whitepaper") return await htmlWithExperiment(html(resourceProtocolWhitepaperPage(tsHtml)), path);
    if (path === "/resources/security-checklist") return await htmlWithExperiment(html(resourceSecurityChecklistPage(tsHtml)), path);
    if (path === "/resources/compliance-mapping") return await htmlWithExperiment(html(resourceComplianceMappingPage(tsHtml)), path);

    // Trust infrastructure pages
    if (path === "/security") return await htmlWithExperiment(html(securityPage()), path);
    if (path === "/privacy") return await htmlWithExperiment(html(privacyPage()), path);
    if (path === "/terms") return await htmlWithExperiment(html(termsPage()), path);
    if (path === "/docs") return await htmlWithExperiment(html(docsPage()), path);
    if (path === "/changelog") {
      const prs = await fetchMergedPrs();
      return await htmlWithExperiment(html(changelogPage(prs)), path);
    }
    if (path === "/status") return await htmlWithExperiment(html(statusPage()), path);

    // Case studies
    if (path === "/case-studies") return await htmlWithExperiment(html(caseStudiesIndexPage()), path);
    if (path === "/case-studies/dogfood-claw-bureau") return await htmlWithExperiment(html(caseStudyDogfoodPage()), path);

    if (path === "/sources") {
      const manifest = await loadManifest(env);
      return await htmlWithExperiment(html(sourcesHubPage(manifest), 200, 1800), path);
    }

    if (path === "/glossary") {
      const q = normalizeSearchQuery(url.searchParams.get("q"));
      if (q) {
        const manifest = await loadManifest(env);
        const corpus = buildSearchCorpus(manifest);
        const results = searchCorpus(corpus, q, 32);
        return await htmlWithExperiment(html(glossarySearchPage(q, results), 200, 300), "/glossary");
      }
    }

    if (path === "/llms.txt") {
      return new Response(
        [
          "# Claw EA",
          "",
          "Claw EA publishes policy-first enterprise agent implementation references.",
          "Use citation-ready pages with explicit sources and proof summaries.",
          "",
          "## High-intent routes",
          "- https://www.clawea.com/assessment",
          "- https://www.clawea.com/contact",
          "- https://www.clawea.com/book",
          "- https://www.clawea.com/trust",
          "- https://www.clawea.com/trust/security-review",
          "- https://www.clawea.com/proof-points",
          "- https://www.clawea.com/pricing",
          "- https://www.clawea.com/docs",
          "- https://www.clawea.com/security",
          "- https://www.clawea.com/case-studies/dogfood-claw-bureau",
          "- https://www.clawea.com/sources",
          "",
          "## Core references",
          "- https://www.clawea.com/policy-as-code-for-agents",
          "- https://www.clawea.com/secure-agent-execution",
          "- https://www.clawea.com/agent-proof-and-attestation",
          "- https://www.clawea.com/agent-audit-and-replay",
          "",
          "## Full knowledge document",
          "- https://www.clawea.com/llms-full.txt",
          "",
          "## Sitemap",
          "- https://www.clawea.com/sitemap.xml",
        ].join("\n"),
        { headers: { "content-type": "text/plain;charset=utf-8", "cache-control": "public, max-age=86400" } },
      );
    }

    if (path === "/llms-full.txt") {
      const manifest = await loadManifest(env);
      return new Response(generateLlmsFullTxt(manifest), {
        headers: { "content-type": "text/plain;charset=utf-8", "cache-control": "public, max-age=3600" },
      });
    }

    // ── Robots.txt ──
    if (path === "/robots.txt") {
      return new Response(
        [
          "User-agent: *",
          "Allow: /",
          "Disallow: /api/",
          "Disallow: /v1/",
          "Disallow: /assessment/result",
          "Crawl-delay: 1",
          "",
          "# LLM crawlers — see llms.txt for structured content",
          "User-agent: GPTBot",
          "Allow: /llms.txt",
          "Allow: /llms-full.txt",
          "Allow: /",
          "",
          "User-agent: ChatGPT-User",
          "Allow: /",
          "",
          "User-agent: Claude-Web",
          "Allow: /",
          "",
          "User-agent: Amazonbot",
          "Allow: /",
          "",
          "User-agent: PerplexityBot",
          "Allow: /",
          "",
          "Sitemap: https://www.clawea.com/sitemap.xml",
          "",
          "# LLM knowledge files",
          "# llms.txt: https://www.clawea.com/llms.txt",
          "# llms-full.txt: https://www.clawea.com/llms-full.txt",
          "",
        ].join("\n"),
        { headers: { "content-type": "text/plain", "cache-control": "public, max-age=86400" } },
      );
    }

    // ── Sitemap ──
    if (path === "/sitemap.xml") {
      return await serveSitemap(env);
    }

    // ── Dynamic article routes ──
    const slug = slugFromPath(path);
    const article = await loadArticle(env, slug);
    if (article) {
      return await htmlWithExperiment(html(articlePage(article), 200, 3600), `/${article.slug}`);
    }

    // ── 404 ──
    return await htmlWithExperiment(html(notFoundPage(), 404), path);
  },

  async scheduled(_controller: ScheduledController, env: Env, ctx: ExecutionContext): Promise<void> {
    if (queueEnabled(env)) {
      const maxEntries = queueMaxEntriesPerRun(env);
      ctx.waitUntil((async () => {
        try {
          await processIndexQueue(env, {
            source: "scheduled",
            maxEntries,
          });
        } catch (err) {
          console.error("INDEX_QUEUE_SCHEDULED_FAILED", err);
        }
      })());
    }

    ctx.waitUntil((async () => {
      try {
        await enqueueWeeklyVariantReportIfDue(env);
      } catch (err) {
        console.error("VARIANT_REPORT_ENQUEUE_FAILED", err);
      }
    })());

    ctx.waitUntil((async () => {
      try {
        await computeLeadResponseSla(env);
        await computeRoutingHealth(env);
      } catch (err) {
        console.error("OPS_HEALTH_SWEEP_FAILED", err);
      }
    })());

    // Weekly analytics report (runs every cron tick, self-dedupes to once per week)
    ctx.waitUntil((async () => {
      try {
        await generateWeeklyAnalyticsReport(env);
      } catch (err) {
        console.error("WEEKLY_ANALYTICS_REPORT_FAILED", err);
      }
    })());
  },

  async queue(batch: MessageBatch<any>, env: Env): Promise<void> {
    await leadJobsQueue(batch, env);
  },
} satisfies ExportedHandler<Env>;

// ── Sitemap Generator ─────────────────────────────────────────────

async function serveSitemap(env: Env): Promise<Response> {
  // Load sitemap index from R2
  // Core sitemap only (Plan A)
  const obj = await env.ARTICLES.get("articles/_sitemap_core.json");
  const staticPages = [
    { slug: "", priority: "1.0" },
    { slug: "assessment", priority: "0.9" },
    { slug: "trust", priority: "0.8" },
    { slug: "trust/security-review", priority: "0.9" },
    { slug: "secure-workers", priority: "0.8" },
    { slug: "consulting", priority: "0.8" },
    { slug: "pricing", priority: "0.8" },
    { slug: "contact", priority: "0.8" },
    { slug: "book", priority: "0.85" },
    { slug: "sources", priority: "0.7" },
    { slug: "about", priority: "0.6" },
    { slug: "compare/claw-vs-manual-audit", priority: "0.7" },
    { slug: "compare/claw-vs-guardrails", priority: "0.7" },
    { slug: "compare/claw-vs-langfuse", priority: "0.7" },
    { slug: "compare/claw-vs-custom-wrappers", priority: "0.7" },
    { slug: "compare/agent-governance-platforms", priority: "0.7" },
    { slug: "guides/github-actions-proof-pipeline", priority: "0.8" },
    { slug: "guides/okta-scoped-tokens", priority: "0.7" },
    { slug: "guides/compliance-evidence-export", priority: "0.7" },
    { slug: "proof-points", priority: "0.8" },
    { slug: "resources/protocol-whitepaper", priority: "0.6" },
    { slug: "resources/security-checklist", priority: "0.6" },
    { slug: "resources/compliance-mapping", priority: "0.6" },
    { slug: "pricing/starter", priority: "0.7" },
    { slug: "pricing/team", priority: "0.7" },
    { slug: "pricing/enterprise", priority: "0.8" },
    { slug: "industries/financial-services", priority: "0.8" },
    { slug: "industries/healthcare", priority: "0.8" },
    { slug: "industries/government", priority: "0.8" },
    { slug: "industries/insurance", priority: "0.7" },
    { slug: "industries/legal", priority: "0.7" },
    { slug: "industries/technology", priority: "0.8" },
    { slug: "security", priority: "0.8" },
    { slug: "privacy", priority: "0.5" },
    { slug: "terms", priority: "0.4" },
    { slug: "docs", priority: "0.8" },
    { slug: "changelog", priority: "0.6" },
    { slug: "status", priority: "0.6" },
    { slug: "case-studies", priority: "0.7" },
    { slug: "case-studies/dogfood-claw-bureau", priority: "0.8" },
  ];

  let entries = staticPages.map((p) => `  <url><loc>https://www.clawea.com/${p.slug}</loc><priority>${p.priority}</priority><changefreq>weekly</changefreq></url>`);

  if (obj) {
    const articles = await obj.json<{ slug: string; category: string }[]>();
    for (const a of articles) {
      const pri =
        a.category === "pillars" || a.category === "hubs" ? "0.8"
          : a.category === "guides" ? "0.7"
            : ["controls", "policy", "proof", "verify", "audit"].includes(a.category) ? "0.7"
              : [
                  "workflows",
                  "tools",
                  "channels",
                  "mcp",
                  "supply-chain",
                  "compliance",
                  "compare",
                  "roles",
                ].includes(a.category) ? "0.6"
                : a.category === "glossary" ? "0.5"
                  : "0.5";
      entries.push(`  <url><loc>https://www.clawea.com/${a.slug}</loc><priority>${pri}</priority><changefreq>monthly</changefreq></url>`);
    }
  }

  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${entries.join("\n")}
</urlset>`;

  return new Response(xml, {
    headers: { "content-type": "application/xml", "cache-control": "public, max-age=3600" },
  });
}

// ── llms-full.txt Generator ────────────────────────────────────────

// ── GitHub PR fetcher for changelog ──────────────────────────────────────

interface MergedPr {
  number: number;
  title: string;
  mergedAt: string;
  url: string;
}

async function fetchMergedPrs(): Promise<MergedPr[]> {
  try {
    const cacheUrl = "https://api.github.com/repos/clawbureau/clawbureau/pulls?state=closed&sort=updated&direction=desc&per_page=30";
    const cached = await caches.default.match(cacheUrl);
    if (cached) {
      return (await cached.json()) as MergedPr[];
    }

    const resp = await fetch(cacheUrl, {
      headers: {
        "accept": "application/vnd.github+json",
        "user-agent": "clawea-www/1.0",
      },
    });
    if (!resp.ok) return [];

    const raw: any[] = await resp.json();
    const prs: MergedPr[] = raw
      .filter((pr: any) => pr.merged_at)
      .filter((pr: any) => {
        const title = (pr.title ?? "").toLowerCase();
        // Exclude internal-only PRs
        return !title.startsWith("chore(proofs)") && !title.startsWith("chore: bump");
      })
      .map((pr: any) => ({
        number: pr.number,
        title: pr.title,
        mergedAt: pr.merged_at,
        url: pr.html_url,
      }));

    // Cache for 1 hour
    const cacheResp = new Response(JSON.stringify(prs), {
      headers: { "content-type": "application/json", "cache-control": "public, max-age=3600" },
    });
    await caches.default.put(cacheUrl, cacheResp);

    return prs;
  } catch {
    return [];
  }
}

function generateLlmsFullTxt(manifest: Record<string, { title?: string; category?: string; description?: string; indexable?: boolean }>): string {
  const BASE = "https://www.clawea.com";
  const lines: string[] = [];
  const ln = (s = "") => lines.push(s);

  // ── Opening block ──
  ln("# Claw EA — Full Knowledge Document for LLM Retrieval");
  ln();
  ln("Claw EA is enterprise infrastructure for deploying AI agents with cryptographic proof of every action.");
  ln("It solves the problem of running autonomous AI agents in regulated environments where audit, compliance,");
  ln("and security review are mandatory. It is built for CISOs, platform engineering leads, and compliance teams");
  ln("at enterprises that need verifiable agent execution, not just logging.");
  ln();

  // ── Protocol summary ──
  ln("---");
  ln();
  ln("## Clawsig Protocol: 5 Primitives");
  ln();
  ln("The Clawsig Protocol defines a narrow waist of five composable primitives. Everything else is built on these.");
  ln();
  ln("### 1. Policy Artifact (WPC)");
  ln("A signed, immutable, content-addressed policy contract. Defines what an agent may do before it runs:");
  ln("egress allowlists, DLP rules, model restrictions, approval gates, file path scopes, and budget limits.");
  ln("Published to a policy registry and pinned by hash in capability tokens and receipts.");
  ln("Schema: work_policy_contract.v1.json / work_policy_contract_envelope.v1.json");
  ln();
  ln("### 2. Capability Token (CST)");
  ln("A short-lived, scope-hashed, job-bound token that grants an agent permission to act. Optionally pinned");
  ln("to a specific policy hash. Offline-verifiable via JWKS. Revocation-aware. Short TTL enforced by policy.");
  ln("Schema: scoped_token_claims.v1.json");
  ln();
  ln("### 3. Receipt");
  ln("A signed event emitted at an enforcement boundary. Not a log entry; a cryptographic attestation that a");
  ln("boundary was crossed under policy. Receipt classes:");
  ln("- Model gateway receipt (SHIPPED): signed by clawproxy when an LLM call is mediated. Includes request");
  ln("  hash, response hash, model, provider, latency, token counts, and receipt binding to the event chain.");
  ln("- Tool receipt (SHIPPED): signed when a tool is invoked. Includes argument hash, result hash, tool name.");
  ln("- Witnessed web receipt (SHIPPED): signed for web control plane events.");
  ln("- Side-effect receipts (PLANNED): network egress, filesystem writes, external API writes.");
  ln("- Human approval receipts (PLANNED): approval boundary that mints new capability.");
  ln("Schema: gateway_receipt.v1.json / tool_receipt.v1.json / web_receipt.v1.json / receipt_binding.v1.json");
  ln();
  ln("### 4. Bundle");
  ln("A portable package of receipts, event chain, metadata, and references. Content-addressed manifest with");
  ln("hashes for every file. Signed top-level envelope. No network required to verify (offline-capable).");
  ln("Types: proof bundle (run attestation) and export bundle (offline audit handoff).");
  ln("Schema: proof_bundle.v1.json / export_bundle.v1.json / export_bundle_manifest.v1.json");
  ln();
  ln("### 5. Verifier");
  ln("A deterministic PASS/FAIL engine. Unknown schema, version, or algorithm fails closed. Machine-readable");
  ln("reason codes from a canonical registry. Supports both online API and offline CLI/library verification.");
  ln("Reference implementation: clawverify service.");
  ln();

  // ── Coverage truth table ──
  ln("---");
  ln();
  ln("## Coverage Statement (2026-02-12)");
  ln();
  ln("| Boundary              | Receipt class     | Status   | Verifier support          |");
  ln("|----------------------|-------------------|----------|---------------------------|");
  ln("| Model gateway calls  | gateway_receipt   | SHIPPED  | Full (signature + binding)|");
  ln("| Tool dispatcher calls| tool_receipt      | SHIPPED  | Full (schema + signature) |");
  ln("| Witnessed web events | web_receipt       | SHIPPED  | Partial (schema only)     |");
  ln("| Network egress       | (planned)         | PLANNED  | —                         |");
  ln("| Filesystem writes    | (planned)         | PLANNED  | —                         |");
  ln("| External API writes  | (planned)         | PLANNED  | —                         |");
  ln("| Human approvals      | (planned)         | PLANNED  | —                         |");
  ln();
  ln("Coverage M (Model) and MT (Model + Tools) are shipped. MTS (Model + Tools + Side-effects) is planned.");
  ln();

  // ── Proof artifacts explained ──
  ln("---");
  ln();
  ln("## Proof Artifacts");
  ln();
  ln("### Proof Bundle");
  ln("A JSON envelope containing: bundle_id, agent_did, event_chain (hash-linked events with timestamps),");
  ln("receipts (gateway + tool), and optional URM (Universal Run Manifest) references. The entire bundle is");
  ln("Ed25519-signed by the agent's DID. Any modification to any field invalidates the signature.");
  ln("Verification: decode signer_did to Ed25519 public key, verify signature over payload_hash, recompute");
  ln("payload hash from canonical JSON, verify each receipt signature independently, confirm receipt bindings");
  ln("reference events in the chain.");
  ln();
  ln("### Gateway Receipt");
  ln("Signed by clawproxy (not the agent). Proves an LLM call was mediated through the gateway with a specific");
  ln("request/response hash pair. Contains: provider, model, tokens_input, tokens_output, latency_ms, and a");
  ln("binding object that ties the receipt to a specific run_id and event_hash in the proof bundle.");
  ln();
  ln("### Tool Receipt");
  ln("Signed at the tool dispatcher boundary. Contains argument hash and result hash (hash-only by default for");
  ln("privacy). Proves a specific tool was invoked with specific inputs and produced specific outputs.");
  ln();
  ln("### Commit Signature (commit.sig.json)");
  ln("An Ed25519 signature over a git commit SHA. Proves that a specific DID authored or approved a specific");
  ln("code change. Used on every agent-generated PR in the Claw Bureau repository. Offline-verifiable.");
  ln("Structure: {version, type, algo, did, message: \"commit:<sha>\", createdAt, signature}");
  ln();

  // ── Static pages ──
  ln("---");
  ln();
  ln("## Site Pages");
  ln();

  const staticPages: Array<{ path: string; title: string; summary: string; category: string }> = [
    { path: "/", title: "Claw EA Home", summary: "Landing page. Ship irreversible agent workflows with proof. Two-week pilot offer. Assessment and Security Review Pack CTAs.", category: "landing" },
    { path: "/assessment", title: "AI Readiness Assessment", summary: "Two-minute scored assessment for enterprise AI agent readiness, ROI potential, and risk posture.", category: "assessment" },
    { path: "/trust", title: "Trust Layer", summary: "Three layers of trust: execution attestation, Proof of Harness, and Work Policy Contracts. How agent actions become verifiable proof bundles.", category: "trust" },
    { path: "/trust/security-review", title: "Security Review Pack", summary: "Architecture diagram, real proof bundle and commit signature examples, threat model (replay, exfiltration, prompt injection, nondeterminism), Merkle transparency logging, deployment integrity. For CISO and security team review.", category: "trust" },
    { path: "/secure-workers", title: "Secure AI Workers", summary: "Hardware-isolated Cloudflare Sandboxes. Per-agent DID identity. Scoped R2 storage. Egress mediation. Sleep/wake lifecycle. DLP redaction pipeline.", category: "infrastructure" },
    { path: "/consulting", title: "Enterprise AI Consulting", summary: "Strategy, deployment, compliance mapping, custom development, optimization, and training services.", category: "services" },
    { path: "/pricing", title: "Pricing", summary: "Four tiers: Starter ($49/mo, 1 agent), Team ($199/mo, 5 agents), Business ($499/mo, 25 agents), Enterprise (custom). All tiers include attestation and proof bundles.", category: "pricing" },
    { path: "/contact", title: "Contact Sales", summary: "Lead intake form with attribution tracking and experiment variants.", category: "contact" },
    { path: "/book", title: "Book a Rollout Session", summary: "Booking form for deployment planning sessions with lead-context prefill.", category: "contact" },
    { path: "/sources", title: "Citation Source Hub", summary: "Central hub routing to citation-backed pages with explicit source attribution.", category: "reference" },
    { path: "/about", title: "About Claw Bureau", summary: "Mission, approach, and ecosystem overview. Links to clawverify, clawproxy, clawbounties, clawescrow, clawcuts.", category: "about" },
    { path: "/proof-points", title: "Proof Points", summary: "Protocol adoption metrics (22 conformance vectors, 8 receipt schemas, 30+ reason codes, 150+ pages). Dogfooding evidence (DID commit proofs on every PR). Architecture credibility (Cloudflare Workers, Ed25519, SHA-256, offline verification).", category: "trust" },
    { path: "/compare/claw-vs-manual-audit", title: "Claw EA vs Manual Audit Evidence", summary: "Head-to-head comparison of automated proof bundles vs spreadsheet-based manual evidence collection.", category: "compare" },
    { path: "/compare/claw-vs-guardrails", title: "Claw EA vs Guardrails", summary: "Protocol-level proof of execution vs inference-time guardrails (NeMo, Guardrails AI). Complementary, not competing.", category: "compare" },
    { path: "/compare/claw-vs-langfuse", title: "Claw EA vs Langfuse", summary: "Cryptographic receipts vs observability dashboards. Proof and monitoring solve different compliance requirements.", category: "compare" },
    { path: "/compare/claw-vs-custom-wrappers", title: "Claw EA vs Custom Wrappers", summary: "Protocol-level receipts vs ad-hoc custom wrapper logging. Standard schemas and signing vs team-maintained code.", category: "compare" },
    { path: "/compare/agent-governance-platforms", title: "Agent Governance Platforms Landscape", summary: "Four approaches compared: guardrails, observability, custom wrappers, protocol-first proof. When to use what.", category: "compare" },
    { path: "/guides/github-actions-proof-pipeline", title: "GitHub Actions Proof Pipeline Guide", summary: "Step-by-step: install SDK, configure allowlist, sign commits, add workflow, push and verify.", category: "guides" },
    { path: "/guides/okta-scoped-tokens", title: "Okta Scoped Tokens Guide", summary: "Map Okta groups to CST scopes for policy-gated agent execution with audit trail.", category: "guides" },
    { path: "/guides/compliance-evidence-export", title: "Compliance Evidence Export Guide", summary: "Generate export bundles, verify offline, deliver to auditors for SOX/SOC 2 evidence.", category: "guides" },
    { path: "/industries/financial-services", title: "Financial Services", summary: "AI agent compliance for banks, asset managers, and fintechs. SOX, OCC, FFIEC, MAS TRM regulatory mapping.", category: "industries" },
    { path: "/industries/healthcare", title: "Healthcare", summary: "HIPAA, HITECH, 21 CFR Part 11 compliance for AI agents. DLP redaction, secret boundaries, egress controls.", category: "industries" },
    { path: "/industries/government", title: "Government", summary: "FedRAMP, NIST 800-53, EO 14110 compliance. Two-person rule, kill switch, forced dry-run, Merkle logs.", category: "industries" },
    { path: "/industries/insurance", title: "Insurance", summary: "Underwriting and claims governance. NAIC model laws, Colorado SB 21-169, EU AI Act. Approval gates and proof bundles.", category: "industries" },
    { path: "/industries/legal", title: "Legal", summary: "Attorney-client privilege protection. File path scopes, DLP, two-person rule, audit replay for law firms.", category: "industries" },
    { path: "/industries/technology", title: "Technology", summary: "DevOps governance. Deploy approvals, GitHub Actions proof pipeline, credential rotation, rate limits.", category: "industries" },
    { path: "/pricing/starter", title: "Starter Plan ($49/mo)", summary: "1 agent, 5 skills, execution attestation, 90-day retention. Entry point for proof-first governance.", category: "pricing" },
    { path: "/pricing/team", title: "Team Plan ($249/mo)", summary: "5 agents, Work Policy Contracts, budget controls, model routing, 1-year retention.", category: "pricing" },
    { path: "/pricing/enterprise", title: "Enterprise Plan (Custom)", summary: "Unlimited agents, custom compliance mapping, 7-year retention, BAA/DPA, on-prem option.", category: "pricing" },
    { path: "/resources/protocol-whitepaper", title: "Clawsig Protocol v0.1 Spec (Download)", summary: "Full protocol specification with five primitives, JSON schemas, and verification algorithm.", category: "resources" },
    { path: "/resources/security-checklist", title: "Agent Security Checklist (Download)", summary: "15 controls every enterprise needs: policy, identity, data protection, monitoring.", category: "resources" },
    { path: "/resources/compliance-mapping", title: "Regulatory Mapping (Download)", summary: "SOX, HIPAA, FedRAMP, SOC 2, EU AI Act mapped to specific agent controls and evidence.", category: "resources" },
    { path: "/security", title: "Security", summary: "Hash-only protocol design. Ed25519 signatures. SHA-256 hashing. TLS 1.3. DID-based identity. Cloudflare Workers isolation. Offline verification independence.", category: "trust" },
    { path: "/privacy", title: "Privacy Policy", summary: "Proof bundles contain hashes not content. No PII in receipts. GDPR-compatible. No third-party tracking cookies.", category: "legal" },
    { path: "/terms", title: "Terms of Service", summary: "SaaS terms with pilot engagement scope, liability limits, data ownership, proof artifact disclaimers.", category: "legal" },
    { path: "/docs", title: "Documentation Hub", summary: "Organized by audience: developers (SDK, CLI, protocol spec), security teams (review pack, controls), compliance teams (regulatory mapping, audit).", category: "docs" },
    { path: "/changelog", title: "Product Changelog", summary: "Shipped features by date with PR numbers. AEO-MKT series, UX remediation, REV pipeline, content factory, indexing automation.", category: "docs" },
    { path: "/status", title: "System Status", summary: "Live health dashboard for clawverify, clawproxy, clawbounties, clawescrow, clawcuts, clawscope. Auto-refresh every 60s.", category: "status" },
    { path: "/case-studies", title: "Case Studies", summary: "Pilot engagements and deployment patterns. Dogfooding case study available, enterprise pilots in progress.", category: "case-studies" },
    { path: "/case-studies/dogfood-claw-bureau", title: "Dogfooding Case Study", summary: "3 autonomous agents, 190+ PRs with DID-signed commit proofs, 12 services, 22 conformance vectors. Real, verifiable, public.", category: "case-studies" },
  ];

  ln("### Static Pages");
  ln();
  for (const p of staticPages) {
    ln(`- ${BASE}${p.path}`);
    ln(`  Title: ${p.title}`);
    ln(`  ${p.summary}`);
    ln(`  Category: ${p.category}`);
    ln();
  }

  // ── Article pages by category ──
  const catOrder = ["pillars", "hubs", "controls", "policy", "proof", "verify", "audit", "workflows", "tools", "channels"];
  const catLabels: Record<string, string> = {
    pillars: "Pillar Pages (core concepts)",
    hubs: "Hub Pages (category landing pages)",
    controls: "Control Pages (policy-as-code enforcement)",
    policy: "Policy Pages (Work Policy Contract details)",
    proof: "Proof Pages (attestation and verification)",
    verify: "Verification Pages",
    audit: "Audit Pages (logging and replay)",
    workflows: "Workflow Pages (automated processes)",
    tools: "Tool Integration Pages (enterprise connectors)",
    channels: "Channel Pages (communication platforms)",
  };

  const byCategory: Record<string, Array<{ slug: string; title: string; description: string }>> = {};
  for (const [slug, entry] of Object.entries(manifest)) {
    if (!entry.indexable) continue;
    const cat = entry.category ?? "other";
    if (!byCategory[cat]) byCategory[cat] = [];
    byCategory[cat].push({
      slug,
      title: (entry.title ?? slug).replace(/ \| Claw EA$/, ""),
      description: entry.description ?? "",
    });
  }

  for (const cat of catOrder) {
    const articles = byCategory[cat];
    if (!articles?.length) continue;
    articles.sort((a, b) => a.slug.localeCompare(b.slug));

    ln(`### ${catLabels[cat] ?? cat} (${articles.length} pages)`);
    ln();
    for (const a of articles) {
      const desc = a.description ? (a.description.length > 120 ? a.description.slice(0, 117) + "..." : a.description) : "";
      ln(`- ${BASE}/${a.slug} — ${a.title}${desc ? ". " + desc : ""}`);
    }
    ln();
  }

  // ── Remaining categories ──
  for (const [cat, articles] of Object.entries(byCategory)) {
    if (catOrder.includes(cat)) continue;
    if (!articles?.length) continue;
    articles.sort((a, b) => a.slug.localeCompare(b.slug));
    ln(`### ${cat} (${articles.length} pages)`);
    ln();
    for (const a of articles) {
      const desc = a.description ? (a.description.length > 120 ? a.description.slice(0, 117) + "..." : a.description) : "";
      ln(`- ${BASE}/${a.slug} — ${a.title}${desc ? ". " + desc : ""}`);
    }
    ln();
  }

  // ── CTAs ──
  ln("---");
  ln();
  ln("## Actions");
  ln();
  ln(`Assessment: ${BASE}/assessment`);
  ln(`Security Review Pack: ${BASE}/trust/security-review`);
  ln(`Book a rollout session: ${BASE}/book`);
  ln(`Contact sales: ${BASE}/contact`);
  ln(`Sitemap: ${BASE}/sitemap.xml`);
  ln();

  return lines.join("\n");
}
