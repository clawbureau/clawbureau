/**
 * clawea-www — Programmatic SEO site for clawea.com
 *
 * Serves 10k+ pages from R2-stored articles generated by Gemini.
 * Full SEO: JSON-LD, FAQ schema, OG tags, sitemap, robots.txt,
 * internal linking mesh, breadcrumbs, canonical URLs.
 *
 * Routes:
 *   GET /                        → homepage
 *
 *   Core permissioned-execution taxonomy:
 *   GET /policy-as-code-for-agents
 *   GET /secure-agent-execution
 *   GET /agent-proof-and-attestation
 *   GET /agent-audit-and-replay
 *   GET /agent-supply-chain-security
 *   GET /event-native-agents
 *   GET /mcp-security
 *
 *   Families:
 *   GET /controls/*              → control pages
 *   GET /tools/*                 → enterprise tool pages
 *   GET /channels/*              → channel control plane pages
 *   GET /workflows/*             → workflow recipes (workflow → tool → channel)
 *   GET /policy/*                → policy artifacts and validation
 *   GET /proof/*                 → proof pages
 *   GET /verify/*                → verification pages
 *   GET /audit/*                 → audit/replay pages
 *   GET /mcp/*                   → MCP security and server governance
 *   GET /supply-chain/*          → extension supply chain security
 *   GET /events/*                → event-native trigger patterns
 *   GET /compliance/*            → compliance mappings and evidence
 *   GET /guides/*                → implementation guides
 *   GET /glossary/*              → glossary entries
 *   GET /vs/*, /compare/*, /for/* → comparisons and role-based pages
 *
 *   Static pages:
 *   GET /pricing, /assessment, /assessment/result, /contact, /book, /about, /trust, /secure-workers, /consulting, /sources
 *
 *   System endpoints:
 *   GET /sitemap.xml, /robots.txt, /llms.txt, /health
 *   GET /<INDEXNOW_KEY>.txt
 *   GET /api/search?q=...
 *   GET /api/experiments/config, /api/experiments/assignment, /api/experiments/winners (token-protected)
 *   POST /api/experiments/recommend (token-protected, guardrailed recommendations)
 *   POST /api/leads/submit
 *   GET /api/leads/status, /api/leads/export (token-protected)
 *   GET /api/routing/status, POST /api/routing/replay (token-protected)
 *   GET /api/attribution/summary, /api/attribution/revenue (token-protected)
 *   GET /api/ops/lead-funnel-health, /api/ops/routing-health, /api/ops/conversion-heatmap, /api/ops/failing-steps, /api/ops/lead-intake-security (token-protected)
 *   POST /api/book/submit, POST /api/book/complete (complete is token-protected)
 *   POST /api/indexnow, /api/google-index, /api/index-urls
 *   GET /api/index-queue/status
 *   POST /api/index-queue/enqueue, /api/index-queue/replay
 *   POST /api/events (public conversion telemetry)
 *   POST /api/events/summary (token-protected weekly summary)
 *
 * Dynamic article routing:
 * - Any non-static route attempts to load articles/<slug>.json from R2.
 */

import { layout } from "./layout";
import {
  faqSchema,
  howToSchema,
  serviceSchema,
  canonical,
  definedTermSchema,
  techArticleSchema,
  productSchema,
  type PageMeta,
} from "./seo";
import { trustPage, securityReviewPackPage, secureWorkersPage, consultingPage, aboutPage } from "./pages/static";

interface Env {
  ARTICLES: R2Bucket;
  SITE_URL: string;
  ENVIRONMENT: string;

  // Demand capture data + jobs
  DB: D1Database;
  VARIANT_CONFIG: KVNamespace;
  LEAD_JOBS: Queue;
  LEAD_ROUTE_ENTERPRISE: Queue;
  LEAD_ROUTE_SMB: Queue;
  LEAD_ROUTE_PARTNER: Queue;
  LEAD_SUBMIT_LOCK: DurableObjectNamespace;
  ANALYTICS?: AnalyticsEngineDataset;

  // Indexing automation
  INDEXNOW_KEY?: string;
  INDEX_AUTOMATION_TOKEN?: string;
  LEADS_API_TOKEN?: string;
  GOOGLE_INDEXING_SERVICE_ACCOUNT_JSON?: string;
  INDEXNOW_MAX_ATTEMPTS?: string;
  INDEXNOW_RETRY_BASE_MS?: string;
  INDEXNOW_RETRY_MAX_MS?: string;
  GOOGLE_INDEX_MAX_ATTEMPTS?: string;
  GOOGLE_INDEX_RETRY_BASE_MS?: string;
  GOOGLE_INDEX_RETRY_MAX_MS?: string;

  // Durable indexing queue
  INDEX_QUEUE_ENABLED?: string;
  INDEX_QUEUE_MAX_ENTRIES_PER_RUN?: string;
  INDEX_QUEUE_INDEXNOW_MAX_ATTEMPTS?: string;
  INDEX_QUEUE_GOOGLE_MAX_ATTEMPTS?: string;
  INDEX_QUEUE_RETRY_BASE_MS?: string;
  INDEX_QUEUE_RETRY_MAX_MS?: string;

  // Lead intake + Turnstile
  TURNSTILE_SECRET_KEY?: string;
  TURNSTILE_SITE_KEY?: string;
  TURNSTILE_REQUIRED?: string;
  TURNSTILE_STRICT_REAL_KEY?: string;
  LEAD_ID_HASH_SALT?: string;
  LEAD_SUBMIT_IP_WINDOW_LIMIT?: string;
  LEAD_SUBMIT_EMAIL_WINDOW_LIMIT?: string;
  LEAD_SUBMIT_WINDOW_MINUTES?: string;

  // Routing / CRM handoff
  ROUTING_MAX_ATTEMPTS?: string;
  CRM_PROVIDER_CONFIG_KEY?: string;
  CRM_PROVIDER_CONFIG_JSON?: string;
  CRM_PROVIDER_AUTH_JSON?: string;
  CRM_HANDOFF_SIGNING_SECRET?: string;

  // Experiment routing
  EXPERIMENT_SEED?: string;
  EXPERIMENT_CONFIG_KEY?: string;
  EXPERIMENT_WINNER_MIN_IMPRESSIONS?: string;
  EXPERIMENT_WINNER_MIN_BOOKED?: string;
  EXPERIMENT_WINNER_MIN_CONFIDENCE?: string;
  EXPERIMENT_HOLDOUT_PERCENT?: string;

  // Rev-007 operator thresholds
  LEAD_RESPONSE_SLA_MINUTES?: string;
  ROUTING_QUEUE_LAG_ALERT_MINUTES?: string;
}

interface Article {
  slug: string;
  title: string;
  category: string;
  html: string;
  description: string;
  faqs: { q: string; a: string }[];
  /** v2 structured how-to support (optional, used when present) */
  howToTitle?: string;
  howToSteps?: Array<{ name: string; text: string }>;
  sources: { title: string; uri: string }[];
  model: string;
  generatedAt: string;
  /** Plan A: only index selected pages initially. */
  indexable?: boolean;
}

interface ManifestEntry {
  title: string;
  category: string;
  description: string;
  indexable?: boolean;
}

type SearchDocumentKind = "article" | "static";

interface SearchDocument {
  path: string;
  title: string;
  description: string;
  category: string;
  kind: SearchDocumentKind;
}

interface SearchResult extends SearchDocument {
  score: number;
}

type TurnstilePostureCode =
  | "TURNSTILE_OPTIONAL"
  | "TURNSTILE_READY"
  | "TURNSTILE_NOT_CONFIGURED"
  | "TURNSTILE_SITE_KEY_MISSING"
  | "TURNSTILE_TEST_KEY_FORBIDDEN";

interface TurnstilePosture {
  required: boolean;
  strictRealKey: boolean;
  siteKey?: string;
  secretConfigured: boolean;
  usesTestSiteKey: boolean;
  formEnabled: boolean;
  code: TurnstilePostureCode;
  message: string;
}

type LeadLifecycleStatus =
  | "new"
  | "validated"
  | "scored"
  | "routed"
  | "contacted"
  | "qualified"
  | "disqualified"
  | "booked"
  // legacy aliases retained for backward compatibility
  | "enriched"
  | "closed"
  | "rejected";

type LeadSegment = "enterprise" | "smb" | "partner";
type LeadScoreBand = "high" | "medium" | "low";
type LeadSourceIntent = "partner" | "paid-intent" | "high-intent" | "organic" | "direct";

interface LeadBehaviorSignals {
  sessionEvents?: number;
  ctaClicks?: number;
  intentViews?: number;
  assessmentCompleted?: boolean;
  secondsOnSite?: number;
}

interface LeadSubmissionPayload {
  fullName?: string;
  email?: string;
  company?: string;
  role?: string;
  teamSize?: string;
  timeline?: string;
  primaryUseCase?: string;
  intentNote?: string;
  assessment?: {
    readinessScore?: number;
    roiScore?: number;
    riskScore?: number;
    confidenceLabel?: string;
  };
  behavior?: LeadBehaviorSignals;
  attribution?: Record<string, string>;
  firstTouch?: {
    ts?: string;
    path?: string;
    pageFamily?: string;
    source?: string;
  };
  page?: string;
  pageFamily?: string;
  variantId?: string;
  heroVariant?: string;
  ctaVariant?: string;
  visitorId?: string;
  turnstileToken?: string;
  idempotencyKey?: string;
}

interface LeadRow {
  lead_id: string;
  created_at: string;
  updated_at: string;
  last_seen_at: string;
  status: LeadLifecycleStatus;
  qualification_score: number;
  intent_score: number;
  risk_score: number;
  readiness_score: number;
  roi_score: number;
  dedupe_count: number;
  source: string;
  source_intent: LeadSourceIntent;
  page: string;
  page_family: string;
  full_name: string;
  company: string;
  role: string;
  team_size: string;
  timeline: string;
  primary_use_case: string;
  email_hint: string;
  score_band: LeadScoreBand;
  segment: LeadSegment;
  campaign_id: string;
  variant_id: string;
  hero_variant: string;
  cta_variant: string;
  route_status: string;
  routed_provider_id: string;
  booked_at: string | null;
  completed_at: string | null;
}

interface ExperimentFamilyConfig {
  hero: string[];
  cta: string[];
  holdoutPercent?: number;
}

interface ExperimentVariantConfig {
  seed: string;
  holdoutPercent?: number;
  families: Record<string, ExperimentFamilyConfig>;
}

const DEFAULT_EXPERIMENT_CONFIG: ExperimentVariantConfig = {
  seed: "aeo-rev-007-default",
  holdoutPercent: 5,
  families: {
    home: { hero: ["proof", "roi", "speed"], cta: ["proof", "roi", "speed"], holdoutPercent: 5 },
    assessment: { hero: ["proof", "roi", "speed"], cta: ["proof", "roi", "speed"], holdoutPercent: 5 },
    tools: { hero: ["proof", "risk"], cta: ["assessment", "sales"], holdoutPercent: 4 },
    workflows: { hero: ["proof", "automation"], cta: ["assessment", "sales"], holdoutPercent: 4 },
    contact: { hero: ["fast-path", "proof"], cta: ["submit", "assessment"], holdoutPercent: 8 },
    book: { hero: ["proof", "speed"], cta: ["submit", "assessment"], holdoutPercent: 10 },
    pricing: { hero: ["roi", "proof"], cta: ["proof", "roi", "sales"], holdoutPercent: 6 },
    sources: { hero: ["proof", "citation"], cta: ["assessment", "sales"], holdoutPercent: 5 },
    root: { hero: ["proof", "roi"], cta: ["proof", "roi"], holdoutPercent: 4 },
  },
};

type LeadScoreReason = {
  code: string;
  points: number;
  detail?: string;
};

type LeadScoreResult = {
  intentScore: number;
  readinessScore: number;
  roiScore: number;
  riskScore: number;
  qualificationScore: number;
  confidenceLabel: string;
  scoreBand: LeadScoreBand;
  segment: LeadSegment;
  sourceIntent: LeadSourceIntent;
  scoreReasons: LeadScoreReason[];
  denyCode?: string;
};

type CrmProvider = {
  id: string;
  endpoint?: string;
  authType?: "none" | "bearer" | "header";
  authHeader?: string;
};

type CrmRoutingRule = {
  providerId: string;
  segment?: LeadSegment;
  scoreBand?: LeadScoreBand;
  sourceIntent?: LeadSourceIntent;
};

type CrmRoutingConfig = {
  defaultProviderBySegment: Record<LeadSegment, string>;
  providers: CrmProvider[];
  providerRules: CrmRoutingRule[];
};

type LeadHandoffEnvelope = {
  version: "1.0";
  handoffId: string;
  leadId: string;
  idempotencyKey: string;
  occurredAt: string;
  segment: LeadSegment;
  score: {
    qualification: number;
    band: LeadScoreBand;
    intent: number;
    readiness: number;
    roi: number;
    risk: number;
    sourceIntent: LeadSourceIntent;
    reasons: LeadScoreReason[];
  };
  attribution: {
    source: string;
    campaignId: string;
    pageFamily: string;
    variantId: string;
    heroVariant: string;
    ctaVariant: string;
  };
  lead: {
    company: string;
    role: string;
    teamSize: string;
    timeline: string;
    primaryUseCase: string;
    emailHint: string;
  };
};

const DEFAULT_CRM_ROUTING_CONFIG: CrmRoutingConfig = {
  defaultProviderBySegment: {
    enterprise: "internal-r2",
    smb: "internal-r2",
    partner: "internal-r2",
  },
  providers: [
    { id: "internal-r2", authType: "none" },
  ],
  providerRules: [
    { providerId: "internal-r2", segment: "partner", sourceIntent: "partner" },
    { providerId: "internal-r2", segment: "enterprise", scoreBand: "high" },
    { providerId: "internal-r2", segment: "enterprise", scoreBand: "medium" },
    { providerId: "internal-r2", segment: "smb" },
  ],
};

const DISPOSABLE_EMAIL_DOMAINS = new Set([
  "mailinator.com",
  "guerrillamail.com",
  "yopmail.com",
  "tempmail.com",
  "10minutemail.com",
]);

const LEAD_STATE_TRANSITIONS: Record<string, ReadonlyArray<LeadLifecycleStatus>> = {
  new: ["validated"],
  validated: ["scored"],
  scored: ["routed"],
  routed: ["contacted"],
  contacted: ["qualified", "disqualified", "booked"],
  qualified: ["booked"],
  disqualified: ["booked"],
  booked: [],
};

const RESPONSE_SLA_OPEN_STATES = new Set<LeadLifecycleStatus>(["new", "validated", "scored", "routed"]);
const RESPONSE_SLA_CLOSED_STATES = new Set<LeadLifecycleStatus>(["contacted", "qualified", "disqualified", "booked"]);

// ── Helpers ───────────────────────────────────────────────────────

function json(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: { "content-type": "application/json", "access-control-allow-origin": "*" },
  });
}

function html(body: string, status = 200, cacheSeconds = 3600): Response {
  return new Response(body, {
    status,
    headers: {
      "content-type": "text/html;charset=utf-8",
      "cache-control": `public, max-age=${cacheSeconds}, s-maxage=${cacheSeconds * 24}`,
    },
  });
}

function apiHeaders(extra: HeadersInit = {}): Headers {
  const h = new Headers(extra);
  h.set("access-control-allow-origin", "*");
  h.set("access-control-allow-methods", "GET,POST,OPTIONS");
  h.set("access-control-allow-headers", "content-type,authorization");
  h.set("cache-control", "no-store");
  return h;
}

function apiJson(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: apiHeaders({ "content-type": "application/json" }),
  });
}

function apiError(code: string, message: string, status = 400): Response {
  return apiJson({ ok: false, error: { code, message } }, status);
}

function getBearerToken(request: Request): string | null {
  const auth = request.headers.get("authorization") ?? "";
  const m = auth.match(/^Bearer\s+(.+)$/i);
  return m?.[1]?.trim() ?? null;
}

function checkAutomationAuth(request: Request, env: Env): Response | null {
  const secret = env.INDEX_AUTOMATION_TOKEN?.trim();
  if (!secret) {
    return apiError("INDEX_AUTOMATION_NOT_CONFIGURED", "Indexing automation token is not configured", 503);
  }

  const token = getBearerToken(request);
  if (!token || token !== secret) {
    return apiError("UNAUTHORIZED", "Missing or invalid bearer token", 401);
  }

  return null;
}

function checkOpsAuth(request: Request, env: Env): Response | null {
  const secret = env.LEADS_API_TOKEN?.trim() || env.INDEX_AUTOMATION_TOKEN?.trim();
  if (!secret) {
    return apiError("OPS_AUTH_NOT_CONFIGURED", "Ops bearer token is not configured", 503);
  }

  const token = getBearerToken(request);
  if (!token || token !== secret) {
    return apiError("UNAUTHORIZED", "Missing or invalid bearer token", 401);
  }

  return null;
}

export class LeadSubmitLockDO {
  constructor(private readonly state: DurableObjectState) {}

  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);

    if (request.method !== "POST") {
      return new Response(JSON.stringify({ ok: false, error: "METHOD_NOT_ALLOWED" }), {
        status: 405,
        headers: { "content-type": "application/json" },
      });
    }

    const body = await request.json<any>().catch(() => ({}));
    const now = Date.now();

    if (url.pathname === "/acquire") {
      const ttlMs = Math.max(10_000, Math.min(120_000, Number(body?.ttlMs ?? 45_000)));
      const lock = await this.state.storage.get<any>("lock");

      if (lock?.status === "done" && typeof lock.leadId === "string") {
        return new Response(JSON.stringify({ ok: true, replay: true, leadId: lock.leadId }), {
          status: 200,
          headers: { "content-type": "application/json" },
        });
      }

      if (lock?.status === "processing" && Number(lock.expiresAt ?? 0) > now) {
        return new Response(JSON.stringify({ ok: false, replay: false, inFlight: true }), {
          status: 409,
          headers: { "content-type": "application/json" },
        });
      }

      await this.state.storage.put("lock", {
        status: "processing",
        startedAt: now,
        expiresAt: now + ttlMs,
      });

      return new Response(JSON.stringify({ ok: true, replay: false }), {
        status: 200,
        headers: { "content-type": "application/json" },
      });
    }

    if (url.pathname === "/complete") {
      const leadId = typeof body?.leadId === "string" ? body.leadId : "";
      await this.state.storage.put("lock", {
        status: "done",
        leadId,
        completedAt: now,
        expiresAt: now + (1000 * 60 * 60 * 24),
      });
      return new Response(JSON.stringify({ ok: true }), {
        status: 200,
        headers: { "content-type": "application/json" },
      });
    }

    if (url.pathname === "/fail") {
      await this.state.storage.delete("lock");
      return new Response(JSON.stringify({ ok: true }), {
        status: 200,
        headers: { "content-type": "application/json" },
      });
    }

    return new Response(JSON.stringify({ ok: false, error: "NOT_FOUND" }), {
      status: 404,
      headers: { "content-type": "application/json" },
    });
  }
}

const INDEXABLE_HOSTS = new Set(["clawea.com", "www.clawea.com"]);

function normalizeIndexingUrl(input: string): string | null {
  try {
    const u = new URL(input);
    if (u.protocol !== "https:") return null;
    const host = u.hostname.toLowerCase();
    if (!INDEXABLE_HOSTS.has(host)) return null;

    u.hash = "";
    return u.toString();
  } catch {
    return null;
  }
}

function normalizeUrlList(input: unknown, maxUrls = 500): { accepted: string[]; rejected: string[] } {
  const accepted: string[] = [];
  const rejected: string[] = [];

  if (!Array.isArray(input)) {
    return { accepted, rejected: ["urls_must_be_array"] };
  }

  for (const raw of input) {
    if (accepted.length >= maxUrls) break;
    if (typeof raw !== "string") {
      rejected.push(String(raw));
      continue;
    }

    const normalized = normalizeIndexingUrl(raw.trim());
    if (!normalized) {
      rejected.push(raw);
      continue;
    }

    if (!accepted.includes(normalized)) accepted.push(normalized);
  }

  return { accepted, rejected };
}

type IndexNowAttempt = {
  attempt: number;
  status: number;
  ok: boolean;
  retryable: boolean;
  waitMs?: number;
};

type IndexNowResult = {
  ok: boolean;
  submitted: number;
  status: number;
  body?: unknown;
  error?: string;
  attempts: number;
  retried: number;
  retryableFailures: number;
  attemptLog: IndexNowAttempt[];
};

const RETRYABLE_HTTP_STATUS = new Set([429, 500, 502, 503, 504]);

function isRetryableStatus(status: number): boolean {
  return RETRYABLE_HTTP_STATUS.has(status);
}

function parseRetryAfterMs(value: string | null): number | null {
  if (!value) return null;

  const asNum = Number(value);
  if (Number.isFinite(asNum) && asNum >= 0) {
    return Math.floor(asNum * 1000);
  }

  const asDate = Date.parse(value);
  if (Number.isNaN(asDate)) return null;

  const delta = asDate - Date.now();
  return delta > 0 ? delta : 0;
}

function backoffMs(attempt: number, baseMs = 900, maxMs = 30000): number {
  const exp = Math.min(maxMs, baseMs * 2 ** Math.max(0, attempt - 1));
  const jitter = Math.floor(exp * 0.2 * Math.random());
  return Math.min(maxMs, exp + jitter);
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function submitIndexNow(urls: string[], env: Env): Promise<IndexNowResult> {
  const key = env.INDEXNOW_KEY?.trim();
  if (!key) {
    return {
      ok: false,
      submitted: 0,
      status: 503,
      error: "INDEXNOW_KEY_NOT_CONFIGURED",
      attempts: 0,
      retried: 0,
      retryableFailures: 0,
      attemptLog: [],
    };
  }

  const maxAttempts = Math.max(1, Number(env.INDEXNOW_MAX_ATTEMPTS ?? "4"));
  const baseBackoffMs = Math.max(250, Number(env.INDEXNOW_RETRY_BASE_MS ?? "900"));
  const maxBackoffMs = Math.max(baseBackoffMs, Number(env.INDEXNOW_RETRY_MAX_MS ?? "30000"));

  const payload = {
    host: "clawea.com",
    key,
    keyLocation: `https://clawea.com/${key}.txt`,
    urlList: urls,
  };

  const attemptLog: IndexNowAttempt[] = [];
  let retried = 0;
  let retryableFailures = 0;
  let lastBody: unknown = null;
  let lastStatus = 502;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const res = await fetch("https://api.indexnow.org/IndexNow", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(payload),
      });

      const raw = await res.text();
      let parsed: unknown = raw;
      try {
        parsed = raw ? JSON.parse(raw) : null;
      } catch {
        // keep raw text body
      }

      const retryable = isRetryableStatus(res.status);
      const nextAllowed = attempt < maxAttempts && retryable;

      let waitMs: number | undefined;
      if (nextAllowed) {
        const retryAfterMs = parseRetryAfterMs(res.headers.get("retry-after"));
        waitMs = retryAfterMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs);
      }

      attemptLog.push({
        attempt,
        status: res.status,
        ok: res.ok,
        retryable,
        waitMs,
      });

      lastBody = parsed;
      lastStatus = res.status;

      if (res.ok) {
        return {
          ok: true,
          submitted: urls.length,
          status: res.status,
          body: parsed,
          attempts: attempt,
          retried,
          retryableFailures,
          attemptLog,
        };
      }

      if (!nextAllowed) {
        return {
          ok: false,
          submitted: 0,
          status: res.status,
          body: parsed,
          error: "INDEXNOW_REQUEST_FAILED",
          attempts: attempt,
          retried,
          retryableFailures,
          attemptLog,
        };
      }

      retryableFailures += 1;
      retried += 1;
      await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
    } catch (err: any) {
      const nextAllowed = attempt < maxAttempts;
      const waitMs = nextAllowed ? backoffMs(attempt, baseBackoffMs, maxBackoffMs) : undefined;

      attemptLog.push({
        attempt,
        status: 0,
        ok: false,
        retryable: nextAllowed,
        waitMs,
      });

      lastBody = { message: String(err?.message ?? err) };
      lastStatus = 502;

      if (!nextAllowed) {
        return {
          ok: false,
          submitted: 0,
          status: 502,
          body: lastBody,
          error: "INDEXNOW_FETCH_FAILED",
          attempts: attempt,
          retried,
          retryableFailures,
          attemptLog,
        };
      }

      retryableFailures += 1;
      retried += 1;
      await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
    }
  }

  return {
    ok: false,
    submitted: 0,
    status: lastStatus,
    body: lastBody,
    error: "INDEXNOW_REQUEST_FAILED",
    attempts: attemptLog.length,
    retried,
    retryableFailures,
    attemptLog,
  };
}

type GoogleServiceAccount = {
  client_email: string;
  private_key: string;
  token_uri?: string;
};

type GoogleAttempt = {
  attempt: number;
  status: number;
  ok: boolean;
  retryable: boolean;
  waitMs?: number;
};

type GoogleIndexDetail = {
  url: string;
  ok: boolean;
  status: number;
  body?: unknown;
  attempts: number;
  retried: number;
  retryableFailures: number;
  attemptLog: GoogleAttempt[];
};

type GoogleIndexResult = {
  ok: boolean;
  submitted: number;
  failed: number;
  status: number;
  details: GoogleIndexDetail[];
  error?: string;
};

function b64Url(input: string | Uint8Array): string {
  const str =
    typeof input === "string"
      ? input
      : String.fromCharCode(...input);
  return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function pemToPkcs8Bytes(pem: string): Uint8Array {
  const b64 = pem
    .replace(/-----BEGIN PRIVATE KEY-----/g, "")
    .replace(/-----END PRIVATE KEY-----/g, "")
    .replace(/\s+/g, "");

  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
  return out;
}

async function buildGoogleAccessToken(env: Env): Promise<string> {
  const raw = env.GOOGLE_INDEXING_SERVICE_ACCOUNT_JSON?.trim();
  if (!raw) {
    throw new Error("GOOGLE_INDEXING_NOT_CONFIGURED");
  }

  let sa: GoogleServiceAccount;
  try {
    sa = JSON.parse(raw) as GoogleServiceAccount;
  } catch {
    throw new Error("GOOGLE_INDEXING_SERVICE_ACCOUNT_INVALID_JSON");
  }

  if (!sa.client_email || !sa.private_key) {
    throw new Error("GOOGLE_INDEXING_SERVICE_ACCOUNT_FIELDS_MISSING");
  }

  const tokenUri = sa.token_uri ?? "https://oauth2.googleapis.com/token";
  const iat = Math.floor(Date.now() / 1000);
  const exp = iat + 3600;

  const header = { alg: "RS256", typ: "JWT" };
  const claim = {
    iss: sa.client_email,
    scope: "https://www.googleapis.com/auth/indexing",
    aud: tokenUri,
    iat,
    exp,
  };

  const encodedHeader = b64Url(JSON.stringify(header));
  const encodedClaim = b64Url(JSON.stringify(claim));
  const signingInput = `${encodedHeader}.${encodedClaim}`;

  const key = await crypto.subtle.importKey(
    "pkcs8",
    pemToPkcs8Bytes(sa.private_key),
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"],
  );

  const sig = await crypto.subtle.sign(
    { name: "RSASSA-PKCS1-v1_5" },
    key,
    new TextEncoder().encode(signingInput),
  );

  const jwt = `${signingInput}.${b64Url(new Uint8Array(sig))}`;

  const tokenRes = await fetch(tokenUri, {
    method: "POST",
    headers: { "content-type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: jwt,
    }).toString(),
  });

  if (!tokenRes.ok) {
    const errBody = await tokenRes.text();
    throw new Error(`GOOGLE_OAUTH_FAILED:${tokenRes.status}:${errBody.slice(0, 400)}`);
  }

  const tokenJson = await tokenRes.json<any>();
  const accessToken = tokenJson?.access_token;
  if (!accessToken || typeof accessToken !== "string") {
    throw new Error("GOOGLE_OAUTH_NO_ACCESS_TOKEN");
  }

  return accessToken;
}

async function submitGoogleIndexing(
  urls: string[],
  action: "URL_UPDATED" | "URL_DELETED",
  env: Env,
): Promise<GoogleIndexResult> {
  try {
    const accessToken = await buildGoogleAccessToken(env);

    const details: GoogleIndexResult["details"] = [];
    let submitted = 0;
    let failed = 0;

    const maxAttempts = Math.max(1, Number(env.GOOGLE_INDEX_MAX_ATTEMPTS ?? "4"));
    const baseBackoffMs = Math.max(250, Number(env.GOOGLE_INDEX_RETRY_BASE_MS ?? "1200"));
    const maxBackoffMs = Math.max(baseBackoffMs, Number(env.GOOGLE_INDEX_RETRY_MAX_MS ?? "45000"));

    for (const url of urls) {
      const attemptLog: GoogleAttempt[] = [];
      let retried = 0;
      let retryableFailures = 0;
      let finalOk = false;
      let finalStatus = 503;
      let finalBody: unknown = null;

      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          const res = await fetch("https://indexing.googleapis.com/v3/urlNotifications:publish", {
            method: "POST",
            headers: {
              "content-type": "application/json",
              authorization: `Bearer ${accessToken}`,
            },
            body: JSON.stringify({
              url,
              type: action,
            }),
          });

          const raw = await res.text();
          let parsed: unknown = raw;
          try {
            parsed = raw ? JSON.parse(raw) : null;
          } catch {
            // leave as text
          }

          const retryable = isRetryableStatus(res.status);
          const shouldRetry = !res.ok && retryable && attempt < maxAttempts;
          const retryAfterMs = shouldRetry ? parseRetryAfterMs(res.headers.get("retry-after")) : null;
          const waitMs = shouldRetry ? (retryAfterMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs)) : undefined;

          attemptLog.push({
            attempt,
            status: res.status,
            ok: res.ok,
            retryable,
            waitMs,
          });

          finalOk = res.ok;
          finalStatus = res.status;
          finalBody = parsed;

          if (res.ok) break;
          if (!shouldRetry) break;

          retryableFailures += 1;
          retried += 1;
          await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
        } catch (err: any) {
          const shouldRetry = attempt < maxAttempts;
          const waitMs = shouldRetry ? backoffMs(attempt, baseBackoffMs, maxBackoffMs) : undefined;

          attemptLog.push({
            attempt,
            status: 0,
            ok: false,
            retryable: shouldRetry,
            waitMs,
          });

          finalOk = false;
          finalStatus = 503;
          finalBody = { message: String(err?.message ?? err) };

          if (!shouldRetry) break;

          retryableFailures += 1;
          retried += 1;
          await sleep(waitMs ?? backoffMs(attempt, baseBackoffMs, maxBackoffMs));
        }
      }

      if (finalOk) submitted += 1;
      else failed += 1;

      details.push({
        url,
        ok: finalOk,
        status: finalStatus,
        body: finalBody,
        attempts: attemptLog.length,
        retried,
        retryableFailures,
        attemptLog,
      });
    }

    return {
      ok: failed === 0,
      submitted,
      failed,
      status: failed === 0 ? 200 : 207,
      details,
    };
  } catch (err: any) {
    return {
      ok: false,
      submitted: 0,
      failed: urls.length,
      status: 503,
      details: [],
      error: String(err?.message ?? err),
    };
  }
}

// ── Durable Indexing Queue ──────────────────────────────────────

type IndexEngine = "indexnow" | "google";
type IndexAction = "URL_UPDATED" | "URL_DELETED";
type IndexQueueEngineStatus = "queued" | "retry" | "done" | "failed";

const INDEX_ENGINES: IndexEngine[] = ["indexnow", "google"];
const INDEX_QUEUE_KEY = "articles/_indexing_queue.v1.json";
const INDEX_QUEUE_SUMMARY_KEY = "articles/_indexing_queue_summary.json";

interface IndexQueueEngineState {
  status: IndexQueueEngineStatus;
  attempts: number;
  maxAttempts: number;
  nextAttemptAt?: string;
  lastStatus?: number;
  lastError?: string;
  lastProcessedAt?: string;
}

interface IndexQueueEntry {
  id: string;
  url: string;
  action: IndexAction;
  engines: Partial<Record<IndexEngine, IndexQueueEngineState>>;
  createdAt: string;
  updatedAt: string;
  source?: string;
}

interface IndexQueueState {
  version: 1;
  updatedAt: string;
  entries: Record<string, IndexQueueEntry>;
}

interface IndexQueueRunEngineResult {
  engine: IndexEngine;
  ok: boolean;
  status: number;
  retryable: boolean;
  attempts: number;
  maxAttempts: number;
  nextAttemptAt?: string;
  error?: string;
}

interface IndexQueueRunItem {
  id: string;
  url: string;
  action: IndexAction;
  engineResults: IndexQueueRunEngineResult[];
}

interface IndexQueueRunArtifact {
  runId: string;
  source: string;
  startedAt: string;
  finishedAt: string;
  processedEntries: number;
  processedEngines: number;
  succeeded: number;
  scheduledRetry: number;
  failed: number;
  clearedEntries: number;
  simulate429: boolean;
  items: IndexQueueRunItem[];
  queueAfter: ReturnType<typeof summarizeIndexQueue>;
}

interface QueueStatusSummary {
  totalEntries: number;
  byEngine: Record<IndexEngine, { queued: number; retry: number; done: number; failed: number }>;
  nextAttemptAt?: string;
}

interface EnqueueQueueOptions {
  urls: string[];
  action: IndexAction;
  engines: IndexEngine[];
  force?: boolean;
  source?: string;
}

interface ProcessQueueOptions {
  source: string;
  maxEntries?: number;
  simulate429?: boolean;
}

interface ProcessQueueResult {
  run: IndexQueueRunArtifact;
  artifactKey: string;
}

function envInt(raw: string | undefined, fallback: number, min = 1): number {
  const n = Number(raw);
  if (!Number.isFinite(n)) return fallback;
  return Math.max(min, Math.floor(n));
}

function queueEnabled(env: Env): boolean {
  return env.INDEX_QUEUE_ENABLED !== "0";
}

function queueMaxEntriesPerRun(env: Env): number {
  return envInt(env.INDEX_QUEUE_MAX_ENTRIES_PER_RUN, 40, 1);
}

function queueMaxAttemptsForEngine(env: Env, engine: IndexEngine): number {
  if (engine === "indexnow") {
    return envInt(env.INDEX_QUEUE_INDEXNOW_MAX_ATTEMPTS, 8, 1);
  }
  return envInt(env.INDEX_QUEUE_GOOGLE_MAX_ATTEMPTS, 6, 1);
}

function deterministicJitter(seed: string, limit: number): number {
  if (limit <= 0) return 0;
  let h = 2166136261;
  for (let i = 0; i < seed.length; i++) {
    h ^= seed.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return Math.abs(h) % Math.max(1, limit);
}

function queueBackoffMs(env: Env, seed: string, attempt: number): number {
  const baseMs = envInt(env.INDEX_QUEUE_RETRY_BASE_MS, 60_000, 250);
  const maxMs = envInt(env.INDEX_QUEUE_RETRY_MAX_MS, 3_600_000, baseMs);
  const exp = Math.min(maxMs, baseMs * 2 ** Math.max(0, attempt - 1));
  const jitter = deterministicJitter(`${seed}:${attempt}`, Math.floor(exp * 0.25));
  return Math.min(maxMs, exp + jitter);
}

function parseDueMs(iso: string | undefined): number {
  if (!iso) return 0;
  const ms = Date.parse(iso);
  return Number.isNaN(ms) ? 0 : ms;
}

function isPendingState(status: IndexQueueEngineStatus): boolean {
  return status === "queued" || status === "retry";
}

async function queueEntryId(url: string, action: IndexAction): Promise<string> {
  const input = new TextEncoder().encode(`${action}|${url}`);
  const digest = await crypto.subtle.digest("SHA-256", input);
  return b64Url(new Uint8Array(digest));
}

async function loadIndexQueue(env: Env): Promise<IndexQueueState> {
  const obj = await env.ARTICLES.get(INDEX_QUEUE_KEY);
  if (!obj) {
    return {
      version: 1,
      updatedAt: new Date().toISOString(),
      entries: {},
    };
  }

  try {
    const parsed = await obj.json<IndexQueueState>();
    if (!parsed || typeof parsed !== "object" || parsed.version !== 1 || typeof parsed.entries !== "object") {
      throw new Error("invalid_queue_shape");
    }

    return {
      version: 1,
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : new Date().toISOString(),
      entries: parsed.entries ?? {},
    };
  } catch {
    return {
      version: 1,
      updatedAt: new Date().toISOString(),
      entries: {},
    };
  }
}

async function saveIndexQueue(env: Env, state: IndexQueueState): Promise<void> {
  state.updatedAt = new Date().toISOString();
  await env.ARTICLES.put(INDEX_QUEUE_KEY, JSON.stringify(state, null, 2), {
    httpMetadata: { contentType: "application/json" },
  });
}

function summarizeIndexQueue(state: IndexQueueState): QueueStatusSummary {
  const byEngine: QueueStatusSummary["byEngine"] = {
    indexnow: { queued: 0, retry: 0, done: 0, failed: 0 },
    google: { queued: 0, retry: 0, done: 0, failed: 0 },
  };

  let nextAttemptMs = Number.POSITIVE_INFINITY;

  for (const entry of Object.values(state.entries)) {
    for (const engine of INDEX_ENGINES) {
      const s = entry.engines[engine];
      if (!s) continue;
      byEngine[engine][s.status] += 1;
      if (isPendingState(s.status)) {
        const due = parseDueMs(s.nextAttemptAt);
        if (due > 0 && due < nextAttemptMs) nextAttemptMs = due;
      }
    }
  }

  return {
    totalEntries: Object.keys(state.entries).length,
    byEngine,
    nextAttemptAt: Number.isFinite(nextAttemptMs) ? new Date(nextAttemptMs).toISOString() : undefined,
  };
}

function summarizeQueueForResponse(state: IndexQueueState) {
  const summary = summarizeIndexQueue(state);
  const pending = Object.values(state.entries)
    .filter((entry) =>
      INDEX_ENGINES.some((engine) => {
        const s = entry.engines[engine];
        return s && isPendingState(s.status);
      }),
    )
    .sort((a, b) => a.updatedAt.localeCompare(b.updatedAt, "en"))
    .slice(0, 25)
    .map((entry) => ({
      id: entry.id,
      url: entry.url,
      action: entry.action,
      engines: entry.engines,
      updatedAt: entry.updatedAt,
    }));

  return { summary, pending };
}

function parseIndexingEngines(input: unknown): IndexEngine[] {
  const raw = Array.isArray(input)
    ? input.map((x) => String(x).toLowerCase())
    : [String(input ?? "all").toLowerCase()];

  const useAll = raw.includes("all");
  const out: IndexEngine[] = [];
  if (useAll || raw.includes("indexnow")) out.push("indexnow");
  if (useAll || raw.includes("google")) out.push("google");
  return out;
}

async function enqueueIndexQueue(
  env: Env,
  options: EnqueueQueueOptions,
): Promise<{ created: number; updated: number; deduped: number; state: IndexQueueState; summary: ReturnType<typeof summarizeQueueForResponse> }> {
  const state = await loadIndexQueue(env);

  const nowIso = new Date().toISOString();
  let created = 0;
  let updated = 0;
  let deduped = 0;

  for (const url of options.urls) {
    const id = await queueEntryId(url, options.action);
    let entry = state.entries[id];
    const wasExisting = Boolean(entry);
    let changed = false;

    if (!entry) {
      entry = {
        id,
        url,
        action: options.action,
        engines: {},
        createdAt: nowIso,
        updatedAt: nowIso,
        source: options.source,
      };
      state.entries[id] = entry;
      created += 1;
      changed = true;
    }

    for (const engine of options.engines) {
      const maxAttempts = queueMaxAttemptsForEngine(env, engine);
      const existing = entry.engines[engine];

      if (!existing) {
        entry.engines[engine] = {
          status: "queued",
          attempts: 0,
          maxAttempts,
          nextAttemptAt: nowIso,
        };
        changed = true;
        continue;
      }

      if (options.force) {
        entry.engines[engine] = {
          status: "queued",
          attempts: 0,
          maxAttempts,
          nextAttemptAt: nowIso,
        };
        changed = true;
        continue;
      }

      existing.maxAttempts = maxAttempts;

      if (existing.status === "done") {
        deduped += 1;
        continue;
      }

      if (existing.status === "failed" && existing.attempts >= existing.maxAttempts) {
        deduped += 1;
        continue;
      }

      if (existing.status === "failed" || existing.status === "retry") {
        existing.status = "queued";
        existing.nextAttemptAt = nowIso;
        existing.lastError = undefined;
        changed = true;
        continue;
      }

      deduped += 1;
    }

    if (changed) {
      entry.updatedAt = nowIso;
      entry.source = options.source ?? entry.source;
      if (!entry.createdAt) entry.createdAt = nowIso;
      if (wasExisting) updated += 1;
    }
  }

  await saveIndexQueue(env, state);
  return {
    created,
    updated,
    deduped,
    state,
    summary: summarizeQueueForResponse(state),
  };
}

async function forceRequeueFailedEntries(env: Env): Promise<{ requeued: number; state: IndexQueueState }> {
  const state = await loadIndexQueue(env);
  const nowIso = new Date().toISOString();
  let requeued = 0;

  for (const entry of Object.values(state.entries)) {
    let changed = false;
    for (const engine of INDEX_ENGINES) {
      const s = entry.engines[engine];
      if (!s || s.status !== "failed") continue;
      s.status = "queued";
      s.nextAttemptAt = nowIso;
      s.lastError = undefined;
      changed = true;
      requeued += 1;
    }
    if (changed) entry.updatedAt = nowIso;
  }

  if (requeued > 0) await saveIndexQueue(env, state);
  return { requeued, state };
}

function googleFailureStatus(result: GoogleIndexResult, url: string): { status: number; retryable: boolean; error?: string } {
  const detail = result.details.find((d) => d.url === url) ?? result.details[0];
  if (detail) {
    return {
      status: detail.status,
      retryable: isRetryableStatus(detail.status),
      error: detail.ok ? undefined : "GOOGLE_INDEXING_REQUEST_FAILED",
    };
  }

  return {
    status: result.status,
    retryable: isRetryableStatus(result.status),
    error: result.error,
  };
}

async function processIndexQueue(env: Env, options: ProcessQueueOptions): Promise<ProcessQueueResult> {
  const startedAt = new Date().toISOString();
  const runId = startedAt.replace(/[:.]/g, "-");

  if (!queueEnabled(env)) {
    const disabledRun: IndexQueueRunArtifact = {
      runId,
      source: options.source,
      startedAt,
      finishedAt: new Date().toISOString(),
      processedEntries: 0,
      processedEngines: 0,
      succeeded: 0,
      scheduledRetry: 0,
      failed: 0,
      clearedEntries: 0,
      simulate429: Boolean(options.simulate429),
      items: [],
      queueAfter: {
        totalEntries: 0,
        byEngine: {
          indexnow: { queued: 0, retry: 0, done: 0, failed: 0 },
          google: { queued: 0, retry: 0, done: 0, failed: 0 },
        },
      },
    };

    const disabledKey = `articles/_indexing_runs/queue-${runId}.json`;
    await env.ARTICLES.put(disabledKey, JSON.stringify(disabledRun, null, 2), {
      httpMetadata: { contentType: "application/json" },
    });

    return { run: disabledRun, artifactKey: disabledKey };
  }

  const state = await loadIndexQueue(env);
  const maxEntries = Math.max(1, options.maxEntries ?? queueMaxEntriesPerRun(env));
  const nowMs = Date.now();

  const candidates = Object.values(state.entries)
    .map((entry) => {
      const dueEngines = INDEX_ENGINES.filter((engine) => {
        const s = entry.engines[engine];
        if (!s || !isPendingState(s.status)) return false;
        return parseDueMs(s.nextAttemptAt) <= nowMs;
      });
      return { entry, dueEngines };
    })
    .filter((x) => x.dueEngines.length > 0)
    .sort((a, b) => a.entry.updatedAt.localeCompare(b.entry.updatedAt, "en"))
    .slice(0, maxEntries);

  const items: IndexQueueRunItem[] = [];
  let succeeded = 0;
  let scheduledRetry = 0;
  let failed = 0;
  let clearedEntries = 0;

  for (const candidate of candidates) {
    const entry = candidate.entry;
    const engineResults: IndexQueueRunEngineResult[] = [];

    for (const engine of candidate.dueEngines) {
      const stateForEngine = entry.engines[engine];
      if (!stateForEngine) continue;

      stateForEngine.attempts += 1;
      stateForEngine.lastProcessedAt = new Date().toISOString();

      let ok = false;
      let status = 503;
      let retryable = false;
      let error: string | undefined;

      if (options.simulate429) {
        status = 429;
        retryable = true;
        error = "SIMULATED_429";
      } else if (engine === "indexnow") {
        const result = await submitIndexNow([entry.url], env);
        ok = result.ok;
        status = result.status;
        retryable = isRetryableStatus(result.status);
        error = result.error;
      } else {
        const result = await submitGoogleIndexing([entry.url], entry.action, env);
        ok = result.ok;
        const failure = googleFailureStatus(result, entry.url);
        status = ok ? 200 : failure.status;
        retryable = !ok && failure.retryable;
        error = ok ? undefined : (failure.error ?? result.error);
      }

      if (ok) {
        stateForEngine.status = "done";
        stateForEngine.nextAttemptAt = undefined;
        stateForEngine.lastStatus = status;
        stateForEngine.lastError = undefined;
        succeeded += 1;
      } else if (retryable && stateForEngine.attempts < stateForEngine.maxAttempts) {
        stateForEngine.status = "retry";
        const waitMs = queueBackoffMs(env, `${entry.id}:${engine}`, stateForEngine.attempts);
        stateForEngine.nextAttemptAt = new Date(Date.now() + waitMs).toISOString();
        stateForEngine.lastStatus = status;
        stateForEngine.lastError = error ?? "INDEXING_RETRY_SCHEDULED";
        scheduledRetry += 1;
      } else {
        stateForEngine.status = "failed";
        stateForEngine.nextAttemptAt = undefined;
        stateForEngine.lastStatus = status;
        stateForEngine.lastError = error ?? "INDEXING_FAILED";
        failed += 1;
      }

      engineResults.push({
        engine,
        ok,
        status,
        retryable,
        attempts: stateForEngine.attempts,
        maxAttempts: stateForEngine.maxAttempts,
        nextAttemptAt: stateForEngine.nextAttemptAt,
        error: stateForEngine.lastError,
      });
    }

    entry.updatedAt = new Date().toISOString();
    items.push({
      id: entry.id,
      url: entry.url,
      action: entry.action,
      engineResults,
    });

    const allDone = INDEX_ENGINES.every((engine) => {
      const s = entry.engines[engine];
      return !s || s.status === "done";
    });

    if (allDone) {
      delete state.entries[entry.id];
      clearedEntries += 1;
    }
  }

  await saveIndexQueue(env, state);

  const run: IndexQueueRunArtifact = {
    runId,
    source: options.source,
    startedAt,
    finishedAt: new Date().toISOString(),
    processedEntries: items.length,
    processedEngines: items.reduce((sum, item) => sum + item.engineResults.length, 0),
    succeeded,
    scheduledRetry,
    failed,
    clearedEntries,
    simulate429: Boolean(options.simulate429),
    items,
    queueAfter: summarizeIndexQueue(state),
  };

  const artifactKey = `articles/_indexing_runs/queue-${runId}.json`;
  await env.ARTICLES.put(artifactKey, JSON.stringify(run, null, 2), {
    httpMetadata: { contentType: "application/json" },
  });
  await env.ARTICLES.put(INDEX_QUEUE_SUMMARY_KEY, JSON.stringify(run, null, 2), {
    httpMetadata: { contentType: "application/json" },
  });

  return { run, artifactKey };
}

async function loadLastQueueRun(env: Env): Promise<IndexQueueRunArtifact | null> {
  const obj = await env.ARTICLES.get(INDEX_QUEUE_SUMMARY_KEY);
  if (!obj) return null;
  try {
    return await obj.json<IndexQueueRunArtifact>();
  } catch {
    return null;
  }
}

async function loadArticle(env: Env, slug: string): Promise<Article | null> {
  const key = `articles/${slug}.json`;
  const obj = await env.ARTICLES.get(key);
  if (!obj) return null;
  const data = await obj.json<Article>();
  if ((data as any).error) return null;
  return data;
}

async function loadManifest(env: Env): Promise<Record<string, ManifestEntry>> {
  const obj = await env.ARTICLES.get("articles/_manifest.json");
  if (!obj) return {};
  try {
    const parsed = await obj.json<Record<string, ManifestEntry>>();
    return parsed && typeof parsed === "object" ? parsed : {};
  } catch {
    return {};
  }
}

function slugFromPath(pathname: string): string {
  return pathname.replace(/^\//, "").replace(/\/$/, "");
}

function normalizeSearchQuery(raw: string | null): string {
  return (raw ?? "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, " ")
    .slice(0, 120);
}

function categoryLabel(category: string): string {
  return category.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
}

const STATIC_SEARCH_DOCS: SearchDocument[] = [
  {
    path: "/",
    title: "Claw EA | Enterprise AI Agents, Deployed and Verified",
    description: "Deploy managed AI agents for your enterprise with cryptographic attestation and policy controls.",
    category: "landing",
    kind: "static",
  },
  {
    path: "/pricing",
    title: "Pricing | Claw EA Enterprise AI Agents",
    description: "Pricing plans for enterprise AI agent infrastructure.",
    category: "pricing",
    kind: "static",
  },
  {
    path: "/assessment",
    title: "AI Readiness Assessment | Claw EA",
    description: "Two-minute assessment for enterprise AI readiness, expected ROI, and rollout risk posture.",
    category: "assessment",
    kind: "static",
  },
  {
    path: "/sources",
    title: "Citation Source Hub | Claw EA",
    description: "Citation routing hub for source-backed enterprise AI implementation pages.",
    category: "sources",
    kind: "static",
  },
  {
    path: "/contact",
    title: "Contact Sales | Claw EA Enterprise AI Agents",
    description: "Talk to Claw EA enterprise sales.",
    category: "contact",
    kind: "static",
  },
  {
    path: "/book",
    title: "Book a Rollout Session | Claw EA",
    description: "Book a deployment planning session with lead-context prefill and conversion tracking.",
    category: "book",
    kind: "static",
  },
  {
    path: "/trust",
    title: "Trust Layer | Verified AI Agent Execution | Claw EA",
    description: "Cryptographic proof of AI agent actions.",
    category: "trust",
    kind: "static",
  },
  {
    path: "/trust/security-review",
    title: "Security Review Pack | Claw EA Enterprise AI Agents",
    description: "Architecture, threat model, proof artifacts, and deployment integrity for security review.",
    category: "trust",
    kind: "static",
  },
  {
    path: "/secure-workers",
    title: "Secure AI Workers | Sandboxed Enterprise Agents | Claw EA",
    description: "Hardware-isolated secure AI workers with strict policy enforcement.",
    category: "trust",
    kind: "static",
  },
  {
    path: "/consulting",
    title: "Enterprise AI Consulting | Agent Strategy & Deployment | Claw EA",
    description: "Consulting services for deployment and governance of AI agent programs.",
    category: "consulting",
    kind: "static",
  },
  {
    path: "/about",
    title: "About Claw Bureau | Enterprise AI Trust Infrastructure",
    description: "About Claw Bureau and the trust infrastructure approach for enterprise AI.",
    category: "about",
    kind: "static",
  },
  {
    path: "/glossary",
    title: "Glossary | Claw EA",
    description: "Glossary of enterprise AI policy, proof, and control terms.",
    category: "glossary",
    kind: "static",
  },
];

function buildSearchCorpus(manifest: Record<string, ManifestEntry>): SearchDocument[] {
  const manifestDocs: SearchDocument[] = Object.entries(manifest)
    .filter(([, entry]) => Boolean(entry?.title))
    .map(([slug, entry]) => ({
      path: `/${slug}`,
      title: entry.title,
      description: entry.description,
      category: entry.category,
      kind: "article" as const,
    }));

  const map = new Map<string, SearchDocument>();
  for (const doc of [...manifestDocs, ...STATIC_SEARCH_DOCS]) {
    map.set(doc.path, doc);
  }
  return [...map.values()];
}

function searchCorpus(corpus: SearchDocument[], query: string, limit = 30): SearchResult[] {
  if (!query) return [];
  const tokens = [...new Set(query.split(/[^a-z0-9]+/g).filter((t) => t.length >= 2))];
  const out: SearchResult[] = [];

  for (const doc of corpus) {
    const title = doc.title.toLowerCase();
    const desc = (doc.description ?? "").toLowerCase();
    const pathText = doc.path.toLowerCase().replace(/\//g, " ");
    const categoryText = doc.category.toLowerCase();

    let score = 0;
    if (title.includes(query)) score += 120;
    if (pathText.includes(query)) score += 95;
    if (desc.includes(query)) score += 45;
    if (categoryText.includes(query)) score += 30;

    for (const t of tokens) {
      if (title.startsWith(t)) score += 25;
      if (title.includes(t)) score += 18;
      if (pathText.includes(t)) score += 15;
      if (desc.includes(t)) score += 8;
      if (categoryText.includes(t)) score += 6;
    }

    if (doc.kind === "article") score += 6;
    if (score <= 0) continue;

    out.push({ ...doc, score });
  }

  return out
    .sort((a, b) => (b.score - a.score) || a.path.localeCompare(b.path, "en"))
    .slice(0, limit);
}

function previewText(input: string, max = 220): string {
  const cleaned = input.replace(/\s+/g, " ").trim();
  if (cleaned.length <= max) return cleaned;
  return `${cleaned.slice(0, max - 1)}…`;
}

function glossarySearchPage(query: string, results: SearchResult[]): string {
  const q = query.trim();
  const hasResults = results.length > 0;
  const body = hasResults
    ? `<div class="search-results">${results
        .map(
          (r) => `<a class="search-result-card" href="${r.path}">
            <div class="search-result-meta">
              <span class="badge badge-blue">${esc(categoryLabel(r.category))}</span>
              <span class="search-pill">${esc(r.path)}</span>
            </div>
            <div class="search-result-title">${esc(r.title.replace(/ \| Claw EA$/, ""))}</div>
            <p class="search-result-desc">${esc(previewText(r.description, 240))}</p>
          </a>`,
        )
        .join("")}</div>`
    : `<div class="search-empty">
        No exact matches for <strong>${esc(q)}</strong>. Try a tool name (e.g. <em>okta</em>), a control (e.g. <em>dlp</em>), or a workflow phrase (e.g. <em>approval gate</em>).
      </div>`;

  return layout({
    meta: {
      title: `Search: ${q} | Claw EA`,
      description: `Search Claw EA policy, workflow, tool, and glossary content for “${q}”.`,
      path: "/glossary",
      canonicalPath: "/glossary",
      noindex: true,
      ogImageAlt: `Search results for ${q}`,
    },
    breadcrumbs: [
      { name: "Home", path: "/" },
      { name: "Glossary", path: "/glossary" },
      { name: `Search: ${q}`, path: "/glossary" },
    ],
    body: `
    <section class="section content-page">
      <div class="wrap">
        <h1>Search results</h1>
        <p class="search-summary">
          <span class="search-pill">Query: ${esc(q)}</span>
          <span>${results.length} result${results.length === 1 ? "" : "s"}</span>
        </p>
        <form class="card" role="search" action="/glossary" method="get" style="max-width:780px;padding:1rem 1.2rem;display:flex;gap:.6rem;align-items:center;flex-wrap:wrap">
          <label for="glossary-search-input" class="sr-only">Refine search query</label>
          <input id="glossary-search-input" type="search" name="q" value="${esc(q)}" placeholder="Search controls, workflows, tools..." style="flex:1;min-width:200px;border:1px solid var(--border);background:var(--surface-2);color:var(--text);padding:.6rem .75rem;border-radius:.6rem">
          <button type="submit" class="cta-btn" data-cta="glossary-search-submit">Search</button>
        </form>
        ${body}
      </div>
    </section>`,
  });
}

type TrackingEventType =
  | "cta_click"
  | "contact_intent_view"
  | "contact_email_click"
  | "contact_intent_submit"
  | "lead_submit"
  | "variant_assignment"
  | "search_query"
  | "search_result_click"
  | "search_clear"
  | "book_prompt_shown"
  | "booking_submit"
  | "booking_complete";

type TrackingEvent = {
  eventType: TrackingEventType;
  page: string;
  pageFamily: string;
  href?: string;
  ctaId?: string;
  ctaVariant?: string;
  actionOutcome?: string;
  query?: string;
  resultCount?: number;
  targetPath?: string;
  variantId?: string;
  heroVariant?: string;
  visitorId?: string;
  ts: string;
  source: string;
  attribution: Record<string, string>;
  context: {
    referrer?: string;
    country?: string;
    userAgent?: string;
    ipClassC?: string;
  };
};

const TRACKING_EVENT_TYPES = new Set<TrackingEventType>([
  "cta_click",
  "contact_intent_view",
  "contact_email_click",
  "contact_intent_submit",
  "lead_submit",
  "variant_assignment",
  "search_query",
  "search_result_click",
  "search_clear",
  "book_prompt_shown",
  "booking_submit",
  "booking_complete",
]);

function clipString(input: unknown, maxLen: number): string | undefined {
  if (typeof input !== "string") return undefined;
  const v = input.trim();
  if (!v) return undefined;
  return v.slice(0, maxLen);
}

function pageFamilyFromPath(input: string | undefined): string {
  const path = (input ?? "/").trim();
  if (!path || path === "/") return "home";
  const parts = path.replace(/^\//, "").split("/").filter(Boolean);
  if (parts.length === 0) return "home";

  const known = new Set([
    "controls",
    "workflows",
    "tools",
    "channels",
    "policy",
    "proof",
    "verify",
    "audit",
    "mcp",
    "supply-chain",
    "events",
    "compliance",
    "guides",
    "glossary",
    "trust",
    "secure-workers",
    "consulting",
    "pricing",
    "contact",
    "assessment",
    "sources",
    "book",
    "about",
  ]);

  const first = parts[0];
  if (known.has(first)) return first;
  return "root";
}

function normalizeResultCount(input: unknown): number | undefined {
  const n = Number(input);
  if (!Number.isFinite(n) || n < 0) return undefined;
  return Math.min(100_000, Math.floor(n));
}

function normalizeAttribution(input: unknown): Record<string, string> {
  const src = typeof input === "object" && input !== null ? (input as Record<string, unknown>) : {};

  const allowedKeys = [
    "utm_source",
    "utm_medium",
    "utm_campaign",
    "utm_term",
    "utm_content",
    "gclid",
    "fbclid",
    "msclkid",
    "referrer_host",
    "landing_path",
    "source",
    "first_touch_ts",
    "first_touch_path",
    "first_touch_page_family",
  ];

  const out: Record<string, string> = {};
  for (const key of allowedKeys) {
    const v = clipString(src[key], 160);
    if (v) out[key] = v;
  }

  return out;
}

function deriveSource(attribution: Record<string, string>): string {
  if (attribution.source) return attribution.source;
  if (attribution.utm_source) return `utm:${attribution.utm_source}`;
  if (attribution.referrer_host) return `ref:${attribution.referrer_host}`;
  return "direct";
}

function anonymizeIpClassC(ip: string | null): string | undefined {
  if (!ip) return undefined;
  const m = ip.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/);
  if (!m) return undefined;
  return `${m[1]}.${m[2]}.${m[3]}.x`;
}

async function storeTrackingEvent(env: Env, event: TrackingEvent): Promise<string> {
  const day = event.ts.slice(0, 10);
  const random = typeof crypto.randomUUID === "function"
    ? crypto.randomUUID().slice(0, 8)
    : Math.random().toString(36).slice(2, 10);
  const key = `events/${day}/${event.ts.replace(/[:.]/g, "-")}-${random}.json`;

  await env.ARTICLES.put(key, JSON.stringify(event), {
    httpMetadata: { contentType: "application/json" },
  });

  await persistTrackingEventD1(env, event);
  return key;
}

async function ingestTrackingEvent(request: Request, env: Env): Promise<Response> {
  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  let body: any;
  try {
    body = await request.json<any>();
  } catch {
    return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
  }

  const eventTypeRaw = clipString(body?.eventType, 64);
  const eventType = eventTypeRaw && TRACKING_EVENT_TYPES.has(eventTypeRaw as TrackingEventType)
    ? (eventTypeRaw as TrackingEventType)
    : null;

  if (!eventType) {
    return apiError("EVENT_TYPE_INVALID", "eventType is missing or not allowed", 400);
  }

  const page = clipString(body?.page, 240) ?? "/";
  const pageFamily = clipString(body?.pageFamily, 80) ?? pageFamilyFromPath(page);
  const ts = clipString(body?.ts, 80) ?? new Date().toISOString();
  const parsedTs = Number.isNaN(Date.parse(ts)) ? new Date().toISOString() : ts;

  const attribution = normalizeAttribution(body?.attribution);

  const event: TrackingEvent = {
    eventType,
    page,
    pageFamily,
    href: clipString(body?.href, 500),
    ctaId: clipString(body?.ctaId, 160),
    ctaVariant: clipString(body?.ctaVariant, 120),
    actionOutcome: clipString(body?.actionOutcome, 120),
    query: clipString(body?.query, 120),
    resultCount: normalizeResultCount(body?.resultCount),
    targetPath: clipString(body?.targetPath, 240),
    variantId: clipString(body?.variantId, 120),
    heroVariant: clipString(body?.heroVariant, 120),
    visitorId: clipString(body?.visitorId, 140),
    ts: parsedTs,
    source: deriveSource(attribution),
    attribution,
    context: {
      referrer: clipString(request.headers.get("referer"), 500),
      country: clipString(request.headers.get("cf-ipcountry"), 8),
      userAgent: clipString(request.headers.get("user-agent"), 180),
      ipClassC: anonymizeIpClassC(request.headers.get("cf-connecting-ip")),
    },
  };

  const key = await storeTrackingEvent(env, event);
  return apiJson({ ok: true, eventId: key });
}

async function listTrackingEvents(env: Env, fromMs: number, toMs: number): Promise<TrackingEvent[]> {
  const out: TrackingEvent[] = [];
  let cursor: string | undefined;

  while (true) {
    const listed = await env.ARTICLES.list({
      prefix: "events/",
      cursor,
      limit: 1000,
    });

    for (const obj of listed.objects) {
      const file = await env.ARTICLES.get(obj.key);
      if (!file) continue;

      try {
        const evRaw = await file.json<TrackingEvent>();
        const ev: TrackingEvent = {
          ...evRaw,
          pageFamily: clipString((evRaw as any)?.pageFamily, 80) ?? pageFamilyFromPath((evRaw as any)?.page),
        };

        const tsMs = Date.parse(ev.ts);
        if (Number.isNaN(tsMs) || tsMs < fromMs || tsMs > toMs) continue;
        if (!TRACKING_EVENT_TYPES.has(ev.eventType)) continue;
        out.push(ev);
      } catch {
        // ignore malformed rows
      }
    }

    if (!listed.truncated || !listed.cursor) break;
    cursor = listed.cursor;
  }

  return out;
}

function topCounts(map: Map<string, number>, limit = 10): Array<{ key: string; count: number }> {
  return [...map.entries()]
    .sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0], "en"))
    .slice(0, limit)
    .map(([key, count]) => ({ key, count }));
}

async function summarizeTrackingEvents(request: Request, env: Env): Promise<Response> {
  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  let body: any = {};
  try {
    body = await request.json<any>();
  } catch {
    // allow empty JSON body
  }

  const daysRaw = Number(body?.days ?? 7);
  const days = Number.isFinite(daysRaw) ? Math.min(90, Math.max(1, Math.floor(daysRaw))) : 7;

  const nowMs = Date.now();
  const fromRaw = clipString(body?.from, 80);
  const toRaw = clipString(body?.to, 80);

  const fallbackFromMs = nowMs - (days * 24 * 60 * 60 * 1000);
  const fromMs = fromRaw ? Date.parse(fromRaw) : fallbackFromMs;
  const toMs = toRaw ? Date.parse(toRaw) : nowMs;

  if (Number.isNaN(fromMs) || Number.isNaN(toMs) || fromMs > toMs) {
    return apiError("DATE_RANGE_INVALID", "Invalid from/to date range", 400);
  }

  const events = await listTrackingEvents(env, fromMs, toMs);

  const byType = new Map<string, number>();
  const bySource = new Map<string, number>();
  const byPage = new Map<string, number>();
  const byPageFamily = new Map<string, number>();
  const byCta = new Map<string, number>();
  const byCtaVariant = new Map<string, number>();
  const byVariantId = new Map<string, number>();
  const byHeroVariant = new Map<string, number>();
  const byOutcome = new Map<string, number>();

  const variantOutcome = new Map<string, { impressions: number; clicks: number; submits: number }>();

  const searchQueryCount = new Map<string, number>();
  const searchQueryClicks = new Map<string, number>();
  const searchQueryResultsSum = new Map<string, number>();

  const ctaFamilyViews = new Map<string, number>();
  const ctaFamilyActions = new Map<string, number>();
  const ctaFamilyClicks = new Map<string, number>();

  let contactIntentViews = 0;
  let contactIntentActions = 0;
  let leadSubmits = 0;
  let bookingSubmits = 0;
  let bookingCompletions = 0;
  let searchQueries = 0;
  let searchResultClicks = 0;

  for (const ev of events) {
    byType.set(ev.eventType, (byType.get(ev.eventType) ?? 0) + 1);
    bySource.set(ev.source, (bySource.get(ev.source) ?? 0) + 1);
    byPage.set(ev.page, (byPage.get(ev.page) ?? 0) + 1);
    byPageFamily.set(ev.pageFamily, (byPageFamily.get(ev.pageFamily) ?? 0) + 1);

    const ctaKey = ev.ctaId ?? ev.href ?? "unknown";
    if (ev.eventType === "cta_click" || ev.eventType === "contact_email_click") {
      byCta.set(ctaKey, (byCta.get(ctaKey) ?? 0) + 1);
    }

    if (ev.ctaVariant) {
      byCtaVariant.set(ev.ctaVariant, (byCtaVariant.get(ev.ctaVariant) ?? 0) + 1);
    }

    if (ev.variantId) {
      byVariantId.set(ev.variantId, (byVariantId.get(ev.variantId) ?? 0) + 1);

      const current = variantOutcome.get(ev.variantId) ?? { impressions: 0, clicks: 0, submits: 0 };
      if (ev.eventType === "variant_assignment") current.impressions += 1;
      if (ev.eventType === "cta_click") current.clicks += 1;
      if (ev.eventType === "contact_intent_submit" || ev.eventType === "lead_submit" || ev.eventType === "booking_submit") current.submits += 1;
      variantOutcome.set(ev.variantId, current);
    }

    if (ev.heroVariant) {
      byHeroVariant.set(ev.heroVariant, (byHeroVariant.get(ev.heroVariant) ?? 0) + 1);
    }

    if (ev.actionOutcome) {
      byOutcome.set(ev.actionOutcome, (byOutcome.get(ev.actionOutcome) ?? 0) + 1);
    }

    if (ev.eventType === "contact_intent_view") {
      contactIntentViews += 1;
      ctaFamilyViews.set(ev.pageFamily, (ctaFamilyViews.get(ev.pageFamily) ?? 0) + 1);
    }

    if (ev.eventType === "cta_click") {
      ctaFamilyClicks.set(ev.pageFamily, (ctaFamilyClicks.get(ev.pageFamily) ?? 0) + 1);
    }

    if (ev.eventType === "contact_email_click" || ev.eventType === "contact_intent_submit" || ev.eventType === "lead_submit" || ev.eventType === "booking_submit") {
      contactIntentActions += 1;
      ctaFamilyActions.set(ev.pageFamily, (ctaFamilyActions.get(ev.pageFamily) ?? 0) + 1);
    }

    if (ev.eventType === "lead_submit") {
      leadSubmits += 1;
    }

    if (ev.eventType === "booking_submit") {
      bookingSubmits += 1;
    }

    if (ev.eventType === "booking_complete") {
      bookingCompletions += 1;
    }

    if (ev.eventType === "search_query" && ev.query) {
      searchQueries += 1;
      searchQueryCount.set(ev.query, (searchQueryCount.get(ev.query) ?? 0) + 1);
      const rc = typeof ev.resultCount === "number" ? ev.resultCount : 0;
      searchQueryResultsSum.set(ev.query, (searchQueryResultsSum.get(ev.query) ?? 0) + rc);
    }

    if (ev.eventType === "search_result_click") {
      searchResultClicks += 1;
      if (ev.query) {
        searchQueryClicks.set(ev.query, (searchQueryClicks.get(ev.query) ?? 0) + 1);
      }
    }
  }

  const intentToActionRate = contactIntentViews > 0
    ? Number((contactIntentActions / contactIntentViews).toFixed(4))
    : 0;
  const searchToClickRate = searchQueries > 0
    ? Number((searchResultClicks / searchQueries).toFixed(4))
    : 0;
  const leadToBookingRate = leadSubmits > 0
    ? Number((bookingSubmits / leadSubmits).toFixed(4))
    : 0;
  const bookingCompletionRate = bookingSubmits > 0
    ? Number((bookingCompletions / bookingSubmits).toFixed(4))
    : 0;

  const topSearchQueries = [...searchQueryCount.entries()]
    .map(([query, queries]) => {
      const clicks = searchQueryClicks.get(query) ?? 0;
      const resultsTotal = searchQueryResultsSum.get(query) ?? 0;
      return {
        query,
        queries,
        clicks,
        ctr: queries > 0 ? Number((clicks / queries).toFixed(4)) : 0,
        avgResults: queries > 0 ? Number((resultsTotal / queries).toFixed(2)) : 0,
      };
    })
    .sort((a, b) => (b.queries - a.queries) || a.query.localeCompare(b.query, "en"))
    .slice(0, 20);

  const ctaByPageFamily = [...new Set([
    ...ctaFamilyViews.keys(),
    ...ctaFamilyActions.keys(),
    ...ctaFamilyClicks.keys(),
  ])]
    .map((family) => {
      const views = ctaFamilyViews.get(family) ?? 0;
      const actions = ctaFamilyActions.get(family) ?? 0;
      const clicks = ctaFamilyClicks.get(family) ?? 0;
      return {
        pageFamily: family,
        views,
        clicks,
        actions,
        actionRate: views > 0 ? Number((actions / views).toFixed(4)) : 0,
      };
    })
    .sort((a, b) => (b.actions - a.actions) || a.pageFamily.localeCompare(b.pageFamily, "en"));

  const variantPerformance = [...variantOutcome.entries()]
    .map(([variantId, row]) => ({
      variantId,
      impressions: row.impressions,
      clicks: row.clicks,
      submits: row.submits,
      clickRate: row.impressions > 0 ? Number((row.clicks / row.impressions).toFixed(4)) : 0,
      submitRate: row.impressions > 0 ? Number((row.submits / row.impressions).toFixed(4)) : 0,
    }))
    .sort((a, b) => (b.submitRate - a.submitRate) || (b.impressions - a.impressions) || a.variantId.localeCompare(b.variantId, "en"))
    .slice(0, 40);

  const queue = await loadIndexQueue(env);
  const queueSummary = summarizeIndexQueue(queue);
  const lastQueueRun = await loadLastQueueRun(env);

  return apiJson({
    ok: true,
    range: {
      from: new Date(fromMs).toISOString(),
      to: new Date(toMs).toISOString(),
      days,
    },
    generatedAt: new Date().toISOString(),
    totals: {
      events: events.length,
      contactIntentViews,
      contactIntentActions,
      leadSubmits,
      bookingSubmits,
      bookingCompletions,
      intentToActionRate,
      leadToBookingRate,
      bookingCompletionRate,
      searchQueries,
      searchResultClicks,
      searchToClickRate,
    },
    breakdown: {
      byType: topCounts(byType, 30),
      bySource: topCounts(bySource, 30),
      topPages: topCounts(byPage, 30),
      byPageFamily: topCounts(byPageFamily, 30),
      topCtas: topCounts(byCta, 30),
      byCtaVariant: topCounts(byCtaVariant, 30),
      byVariantId: topCounts(byVariantId, 40),
      byHeroVariant: topCounts(byHeroVariant, 40),
      byOutcome: topCounts(byOutcome, 30),
    },
    funnel: {
      search: {
        queries: searchQueries,
        clicks: searchResultClicks,
        searchToClickRate,
        topQueries: topSearchQueries,
      },
      ctaByPageFamily,
      variants: variantPerformance,
      booking: {
        leadSubmits,
        bookingSubmits,
        bookingCompletions,
        leadToBookingRate,
        bookingCompletionRate,
      },
    },
    indexing: {
      queue: queueSummary,
      lastRun: lastQueueRun,
    },
  });
}

function envFlag(value: string | undefined, fallback = false): boolean {
  if (value === undefined) return fallback;
  const v = value.trim().toLowerCase();
  if (!v) return fallback;
  return v === "1" || v === "true" || v === "yes" || v === "on";
}

const TURNSTILE_DEFAULT_TEST_SITE_KEY = "1x00000000000000000000AA";
const TURNSTILE_TEST_SITE_KEYS = new Set([
  TURNSTILE_DEFAULT_TEST_SITE_KEY,
  "2x00000000000000000000AB",
]);

function isTurnstileTestSiteKey(siteKey: string | undefined): boolean {
  if (!siteKey) return false;
  return TURNSTILE_TEST_SITE_KEYS.has(siteKey);
}

function resolveTurnstilePosture(env: Env): TurnstilePosture {
  const required = envFlag(env.TURNSTILE_REQUIRED, true);
  const strictRealKey = envFlag(env.TURNSTILE_STRICT_REAL_KEY, (env.ENVIRONMENT ?? "").trim().toLowerCase() === "production");
  const siteKey = clipString(env.TURNSTILE_SITE_KEY, 120);
  const secretConfigured = Boolean(clipString(env.TURNSTILE_SECRET_KEY, 200));
  const usesTestSiteKey = isTurnstileTestSiteKey(siteKey);

  if (!required) {
    return {
      required,
      strictRealKey,
      siteKey,
      secretConfigured,
      usesTestSiteKey,
      formEnabled: true,
      code: "TURNSTILE_OPTIONAL",
      message: siteKey
        ? "Form protection is optional in this environment."
        : "Form protection is optional in this environment and Turnstile is disabled.",
    };
  }

  if (!secretConfigured) {
    return {
      required,
      strictRealKey,
      siteKey,
      secretConfigured,
      usesTestSiteKey,
      formEnabled: false,
      code: "TURNSTILE_NOT_CONFIGURED",
      message: "Lead intake is temporarily unavailable while bot protection is being configured.",
    };
  }

  if (!siteKey) {
    return {
      required,
      strictRealKey,
      siteKey,
      secretConfigured,
      usesTestSiteKey,
      formEnabled: false,
      code: "TURNSTILE_SITE_KEY_MISSING",
      message: "Lead intake is temporarily unavailable while bot protection keys are being rotated.",
    };
  }

  if (strictRealKey && usesTestSiteKey) {
    return {
      required,
      strictRealKey,
      siteKey,
      secretConfigured,
      usesTestSiteKey,
      formEnabled: false,
      code: "TURNSTILE_TEST_KEY_FORBIDDEN",
      message: "Lead intake is paused until production-grade Turnstile keys are active.",
    };
  }

  return {
    required,
    strictRealKey,
    siteKey,
    secretConfigured,
    usesTestSiteKey,
    formEnabled: true,
    code: "TURNSTILE_READY",
    message: "Bot protection active.",
  };
}

function shouldRenderTurnstileWidget(posture: TurnstilePosture): boolean {
  return Boolean(posture.siteKey) && posture.formEnabled;
}

function randomId(prefix = "id"): string {
  const raw = typeof crypto.randomUUID === "function"
    ? crypto.randomUUID().replace(/-/g, "")
    : Math.random().toString(36).slice(2) + Date.now().toString(36);
  return `${prefix}_${raw.slice(0, 24)}`;
}

function base64Url(bytes: Uint8Array): string {
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }

  const b64 = btoa(binary);
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

async function sha256Base64Url(input: string): Promise<string> {
  const data = new TextEncoder().encode(input);
  const digest = await crypto.subtle.digest("SHA-256", data);
  return base64Url(new Uint8Array(digest));
}

async function hmacSha256Base64Url(secret: string, payload: string): Promise<string> {
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw",
    enc.encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"],
  );

  const sig = await crypto.subtle.sign("HMAC", key, enc.encode(payload));
  return base64Url(new Uint8Array(sig));
}

function normalizeLeadStatus(raw: string | undefined): LeadLifecycleStatus {
  const v = (raw ?? "").trim().toLowerCase();
  if (v === "enriched") return "scored";
  if (v === "rejected") return "disqualified";
  if (v === "closed") return "booked";
  if (
    v === "new"
    || v === "validated"
    || v === "scored"
    || v === "routed"
    || v === "contacted"
    || v === "qualified"
    || v === "disqualified"
    || v === "booked"
  ) {
    return v;
  }
  return "new";
}

function scoreBandFromQualification(score: number): LeadScoreBand {
  if (score >= 80) return "high";
  if (score >= 55) return "medium";
  return "low";
}

function segmentFromPayload(payload: LeadSubmissionPayload, qualificationScore: number): LeadSegment {
  const source = (payload.attribution?.source ?? "").toLowerCase();
  const campaign = (payload.attribution?.utm_campaign ?? "").toLowerCase();
  const role = (payload.role ?? "").toLowerCase();
  const team = (payload.teamSize ?? "").toLowerCase();

  if (
    source.includes("partner")
    || campaign.includes("partner")
    || role.includes("partner")
    || role.includes("reseller")
  ) {
    return "partner";
  }

  if (
    qualificationScore >= 72
    || team.includes("500")
    || team.includes("1000")
    || team.includes("enterprise")
    || role.includes("cto")
    || role.includes("security")
  ) {
    return "enterprise";
  }

  return "smb";
}

function leadWindowMinutes(env: Env): number {
  return Math.max(1, Math.min(120, Number(env.LEAD_SUBMIT_WINDOW_MINUTES ?? "10")));
}

function leadIpWindowLimit(env: Env): number {
  return Math.max(5, Math.min(500, Number(env.LEAD_SUBMIT_IP_WINDOW_LIMIT ?? "24")));
}

function leadEmailWindowLimit(env: Env): number {
  return Math.max(2, Math.min(100, Number(env.LEAD_SUBMIT_EMAIL_WINDOW_LIMIT ?? "8")));
}

function routingMaxAttempts(env: Env): number {
  return Math.max(1, Math.min(12, Number(env.ROUTING_MAX_ATTEMPTS ?? "5")));
}

function leadResponseSlaMinutes(env: Env): number {
  return Math.max(5, Math.min(24 * 60, Number(env.LEAD_RESPONSE_SLA_MINUTES ?? "45")));
}

function routingQueueLagAlertMinutes(env: Env): number {
  return Math.max(5, Math.min(24 * 60, Number(env.ROUTING_QUEUE_LAG_ALERT_MINUTES ?? "20")));
}

function inferSourceIntent(payload: LeadSubmissionPayload): LeadSourceIntent {
  const source = String(payload.attribution?.source ?? payload.firstTouch?.source ?? "direct").toLowerCase();
  const campaign = String(payload.attribution?.utm_campaign ?? "").toLowerCase();
  const intentText = [payload.primaryUseCase, payload.intentNote, payload.role, payload.timeline]
    .filter(Boolean)
    .join(" ")
    .toLowerCase();

  if (source.includes("partner") || campaign.includes("partner") || intentText.includes("reseller")) {
    return "partner";
  }

  if (/(buyer|book|demo|assessment|enterprise|security|audit|compliance|sox|hipaa|incident|migration|approval|pilot|procurement)/.test(`${campaign} ${intentText}`)) {
    return "high-intent";
  }

  if (source.startsWith("utm:") || /(google|linkedin|bing|paid|ads)/.test(source) || /(ppc|paid|cpc)/.test(campaign)) {
    return "paid-intent";
  }

  if (source.startsWith("ref:") || /(organic|seo|blog|newsletter)/.test(source)) {
    return "organic";
  }

  return "direct";
}

function normalizeSourceIntent(input: string | undefined): LeadSourceIntent {
  const v = (input ?? "").trim().toLowerCase();
  if (v === "partner" || v === "paid-intent" || v === "high-intent" || v === "organic" || v === "direct") {
    return v;
  }
  return "direct";
}

async function leadSubmitLockAcquire(env: Env, idempotencyKey: string): Promise<{
  ok: boolean;
  replay: boolean;
  inFlight: boolean;
  leadId?: string;
}> {
  const id = env.LEAD_SUBMIT_LOCK.idFromName(idempotencyKey);
  const stub = env.LEAD_SUBMIT_LOCK.get(id);
  const res = await stub.fetch("https://lead-submit-lock/acquire", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ ttlMs: 45_000 }),
  });

  const payload = await res.json<any>().catch(() => ({}));
  if (res.status === 409) {
    return { ok: false, replay: false, inFlight: true };
  }

  if (!res.ok || payload?.ok !== true) {
    return { ok: false, replay: false, inFlight: false };
  }

  return {
    ok: true,
    replay: payload?.replay === true,
    inFlight: false,
    leadId: typeof payload?.leadId === "string" ? payload.leadId : undefined,
  };
}

async function leadSubmitLockComplete(env: Env, idempotencyKey: string, leadId: string): Promise<void> {
  const id = env.LEAD_SUBMIT_LOCK.idFromName(idempotencyKey);
  const stub = env.LEAD_SUBMIT_LOCK.get(id);
  await stub.fetch("https://lead-submit-lock/complete", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ leadId }),
  });
}

async function leadSubmitLockFail(env: Env, idempotencyKey: string): Promise<void> {
  const id = env.LEAD_SUBMIT_LOCK.idFromName(idempotencyKey);
  const stub = env.LEAD_SUBMIT_LOCK.get(id);
  await stub.fetch("https://lead-submit-lock/fail", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: "{}",
  });
}

function normalizeEmail(input: string | undefined): string {
  return (input ?? "").trim().toLowerCase();
}

function safeJsonParse<T>(raw: string | null, fallback: T): T {
  if (!raw) return fallback;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return fallback;
  }
}

function normalizeLeadPayload(body: any): LeadSubmissionPayload {
  const behaviorSrc = typeof body?.behavior === "object" && body.behavior !== null
    ? body.behavior as Record<string, unknown>
    : {};

  return {
    fullName: clipString(body?.fullName, 120),
    email: clipString(body?.email, 200),
    company: clipString(body?.company, 160),
    role: clipString(body?.role, 120),
    teamSize: clipString(body?.teamSize, 80),
    timeline: clipString(body?.timeline, 120),
    primaryUseCase: clipString(body?.primaryUseCase, 600),
    intentNote: clipString(body?.intentNote, 1200),
    assessment: {
      readinessScore: normalizeResultCount(body?.assessment?.readinessScore),
      roiScore: normalizeResultCount(body?.assessment?.roiScore),
      riskScore: normalizeResultCount(body?.assessment?.riskScore),
      confidenceLabel: clipString(body?.assessment?.confidenceLabel, 80),
    },
    behavior: {
      sessionEvents: normalizeResultCount(behaviorSrc.sessionEvents),
      ctaClicks: normalizeResultCount(behaviorSrc.ctaClicks),
      intentViews: normalizeResultCount(behaviorSrc.intentViews),
      assessmentCompleted: behaviorSrc.assessmentCompleted === true,
      secondsOnSite: normalizeResultCount(behaviorSrc.secondsOnSite),
    },
    attribution: normalizeAttribution(body?.attribution),
    firstTouch: {
      ts: clipString(body?.firstTouch?.ts, 80),
      path: clipString(body?.firstTouch?.path, 240),
      pageFamily: clipString(body?.firstTouch?.pageFamily, 80),
      source: clipString(body?.firstTouch?.source, 80),
    },
    page: clipString(body?.page, 240),
    pageFamily: clipString(body?.pageFamily, 80),
    variantId: clipString(body?.variantId, 120),
    heroVariant: clipString(body?.heroVariant, 120),
    ctaVariant: clipString(body?.ctaVariant, 120),
    visitorId: clipString(body?.visitorId, 140),
    turnstileToken: clipString(body?.turnstileToken, 3000),
    idempotencyKey: clipString(body?.idempotencyKey, 160),
  };
}

function scoreLeadIntent(payload: LeadSubmissionPayload): LeadScoreResult {
  const baseReadiness = Math.min(100, Math.max(0, Number(payload.assessment?.readinessScore ?? 0)));
  const baseRoi = Math.min(100, Math.max(0, Number(payload.assessment?.roiScore ?? 0)));
  const baseRisk = Math.min(100, Math.max(0, Number(payload.assessment?.riskScore ?? 40)));
  const sourceIntent = inferSourceIntent(payload);

  const scoreReasons: LeadScoreReason[] = [];

  const teamBoost = (() => {
    const t = (payload.teamSize ?? "").toLowerCase();
    if (/(500|1000|enterprise|global)/.test(t)) return 16;
    if (/(100|200|300|400)/.test(t)) return 10;
    if (/(50|75)/.test(t)) return 6;
    return 2;
  })();
  if (teamBoost > 0) {
    scoreReasons.push({ code: "team_size", points: teamBoost, detail: payload.teamSize ?? "unknown" });
  }

  const timelineBoost = (() => {
    const t = (payload.timeline ?? "").toLowerCase();
    if (/(now|immediate|this week|2 weeks)/.test(t)) return 14;
    if (/(30|month|q1|q2|q3|q4)/.test(t)) return 8;
    if (/(quarter|90)/.test(t)) return 4;
    return 1;
  })();
  if (timelineBoost > 0) {
    scoreReasons.push({ code: "timeline_urgency", points: timelineBoost, detail: payload.timeline ?? "unknown" });
  }

  const sourceBoost = sourceIntent === "partner"
    ? 10
    : sourceIntent === "high-intent"
      ? 8
      : sourceIntent === "paid-intent"
        ? 6
        : sourceIntent === "organic"
          ? 3
          : 1;
  scoreReasons.push({ code: "source_intent", points: sourceBoost, detail: sourceIntent });

  const campaign = String(payload.attribution?.utm_campaign ?? "").toLowerCase();
  const campaignBoost = /(enterprise|security|audit|compliance|pilot|buyer|intent|book|demo)/.test(campaign)
    ? 6
    : 0;
  if (campaignBoost > 0) {
    scoreReasons.push({ code: "campaign_match", points: campaignBoost, detail: campaign });
  }

  const behavior = payload.behavior ?? {};
  const behaviorBoost = Math.min(
    18,
    Math.round(
      (Number(behavior.ctaClicks ?? 0) * 2.2)
      + (Number(behavior.intentViews ?? 0) * 1.3)
      + (Number(behavior.sessionEvents ?? 0) * 0.5)
      + (behavior.assessmentCompleted ? 6 : 0)
      + Math.min(5, Number(behavior.secondsOnSite ?? 0) / 120),
    ),
  );
  if (behaviorBoost > 0) {
    scoreReasons.push({
      code: "behavior_signals",
      points: behaviorBoost,
      detail: `cta=${Number(behavior.ctaClicks ?? 0)},intentViews=${Number(behavior.intentViews ?? 0)}`,
    });
  }

  const intentSignals = [
    payload.primaryUseCase,
    payload.intentNote,
    payload.role,
  ].join(" ").toLowerCase();

  const urgencyBoost = /(approval|security|audit|compliance|risk|incident|production|rollout|migration|sox|hipaa|soc 2)/.test(intentSignals)
    ? 10
    : 0;
  if (urgencyBoost > 0) {
    scoreReasons.push({ code: "problem_urgency", points: urgencyBoost, detail: "regulatory-or-incident-signal" });
  }

  const intentScore = Math.min(100, baseReadiness + teamBoost + timelineBoost + urgencyBoost + sourceBoost + campaignBoost + behaviorBoost);
  const readinessScore = Math.min(100, Math.max(0, baseReadiness || Math.round(intentScore * 0.72)));
  const roiScore = Math.min(100, Math.max(0, baseRoi || Math.round(intentScore * 0.68)));
  const riskScore = Math.min(100, Math.max(0, baseRisk));

  const qualificationScore = Math.max(
    0,
    Math.min(
      100,
      Math.round((intentScore * 0.36) + (readinessScore * 0.27) + (roiScore * 0.23) + ((100 - riskScore) * 0.14)),
    ),
  );

  const confidenceLabel = qualificationScore >= 78
    ? "high-intent"
    : qualificationScore >= 55
      ? "medium-intent"
      : "early-intent";

  const scoreBand = scoreBandFromQualification(qualificationScore);
  const segment = segmentFromPayload(payload, qualificationScore);

  return {
    intentScore,
    readinessScore,
    roiScore,
    riskScore,
    qualificationScore,
    confidenceLabel,
    scoreBand,
    segment,
    sourceIntent,
    scoreReasons: scoreReasons.sort((a, b) => b.points - a.points),
  };
}

async function verifyTurnstile(token: string | undefined, request: Request, env: Env): Promise<{ ok: boolean; error?: string }> {
  const posture = resolveTurnstilePosture(env);

  if (!posture.required) {
    return { ok: true };
  }

  if (!posture.formEnabled) {
    return { ok: false, error: posture.code };
  }

  const secret = env.TURNSTILE_SECRET_KEY?.trim();
  if (!secret) {
    return { ok: false, error: "TURNSTILE_NOT_CONFIGURED" };
  }

  if (!token) {
    return { ok: false, error: "TURNSTILE_TOKEN_MISSING" };
  }

  try {
    const ip = clipString(request.headers.get("cf-connecting-ip"), 120);
    const form = new URLSearchParams();
    form.set("secret", secret);
    form.set("response", token);
    if (ip) form.set("remoteip", ip);

    const res = await fetch("https://challenges.cloudflare.com/turnstile/v0/siteverify", {
      method: "POST",
      headers: { "content-type": "application/x-www-form-urlencoded" },
      body: form.toString(),
    });

    const payload = safeJsonParse<any>(await res.text(), {});
    if (payload?.success === true) return { ok: true };

    const errorCodes = Array.isArray(payload?.["error-codes"])
      ? payload["error-codes"]
      : [];

    const errCode = errorCodes.length > 0
      ? String(errorCodes[0])
      : "TURNSTILE_VERIFY_FAILED";

    return { ok: false, error: errCode };
  } catch {
    return { ok: false, error: "TURNSTILE_UPSTREAM_UNAVAILABLE" };
  }
}

async function transitionLeadState(
  env: Env,
  leadId: string,
  nextState: LeadLifecycleStatus,
  reasonCode: string,
  metadata: Record<string, unknown> = {},
): Promise<void> {
  const currentRow = await env.DB.prepare(
    `SELECT status FROM leads WHERE lead_id = ?1 LIMIT 1`,
  ).bind(leadId).first<{ status: string }>();

  const current = normalizeLeadStatus(currentRow?.status);
  if (current === nextState) return;

  const allowedNext = LEAD_STATE_TRANSITIONS[current] ?? [];
  if (!allowedNext.includes(nextState)) {
    return;
  }

  const nowIso = new Date().toISOString();

  await env.DB.prepare(
    `UPDATE leads SET status = ?2, lifecycle_updated_at = ?3, updated_at = ?3 WHERE lead_id = ?1`,
  ).bind(leadId, nextState, nowIso).run();

  await env.DB.prepare(
    `INSERT INTO lead_state_transitions (
      transition_id,
      lead_id,
      from_state,
      to_state,
      reason_code,
      metadata_json,
      created_at
    ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)`,
  )
    .bind(
      randomId("lead_state"),
      leadId,
      current,
      nextState,
      reasonCode,
      JSON.stringify(metadata),
      nowIso,
    )
    .run();

  if (RESPONSE_SLA_CLOSED_STATES.has(nextState)) {
    await env.DB.prepare(
      `UPDATE lead_alerts
       SET status = 'resolved', resolved_at = ?2, updated_at = ?2
       WHERE alert_type = 'lead_response_sla_miss'
         AND lead_id = ?1
         AND status = 'open'`,
    ).bind(leadId, nowIso).run().catch(() => {});
  }
}

function addMinutesIso(iso: string, minutes: number): string {
  const ms = Date.parse(iso);
  if (Number.isNaN(ms)) return new Date().toISOString();
  return new Date(ms + minutes * 60_000).toISOString();
}

function diffMinutes(fromIso: string, toIso: string): number {
  const fromMs = Date.parse(fromIso);
  const toMs = Date.parse(toIso);
  if (Number.isNaN(fromMs) || Number.isNaN(toMs)) return 0;
  return Math.max(0, Math.floor((toMs - fromMs) / 60_000));
}

async function upsertLeadAlert(env: Env, params: {
  alertKey: string;
  alertType: string;
  severity: "info" | "warning" | "critical";
  leadId?: string;
  jobId?: string;
  summary: string;
  metadata?: Record<string, unknown>;
}): Promise<void> {
  const nowIso = new Date().toISOString();
  await env.DB.prepare(
    `INSERT INTO lead_alerts (
      alert_id,
      alert_key,
      alert_type,
      severity,
      lead_id,
      job_id,
      status,
      summary,
      metadata_json,
      first_seen_at,
      last_seen_at,
      created_at,
      updated_at
    ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, 'open', ?7, ?8, ?9, ?9, ?9, ?9)
    ON CONFLICT(alert_key)
    DO UPDATE SET
      status = 'open',
      severity = excluded.severity,
      summary = excluded.summary,
      metadata_json = excluded.metadata_json,
      last_seen_at = excluded.last_seen_at,
      updated_at = excluded.updated_at,
      resolved_at = NULL`,
  )
    .bind(
      randomId("alert"),
      params.alertKey,
      params.alertType,
      params.severity,
      params.leadId ?? null,
      params.jobId ?? null,
      params.summary.slice(0, 280),
      JSON.stringify(params.metadata ?? {}),
      nowIso,
    )
    .run();
}

async function resolveLeadAlertsByType(env: Env, alertType: string, keepKeys: string[] = []): Promise<void> {
  const nowIso = new Date().toISOString();
  if (keepKeys.length === 0) {
    await env.DB.prepare(
      `UPDATE lead_alerts
       SET status = 'resolved', resolved_at = ?2, updated_at = ?2
       WHERE alert_type = ?1 AND status = 'open'`,
    ).bind(alertType, nowIso).run();
    return;
  }

  const placeholders = keepKeys.map((_, i) => `?${i + 3}`).join(",");
  await env.DB.prepare(
    `UPDATE lead_alerts
     SET status = 'resolved', resolved_at = ?2, updated_at = ?2
     WHERE alert_type = ?1
       AND status = 'open'
       AND alert_key NOT IN (${placeholders})`,
  ).bind(alertType, nowIso, ...keepKeys).run();
}

async function hashIpForAbuse(request: Request, env: Env): Promise<string> {
  const rawIp = clipString(request.headers.get("cf-connecting-ip"), 120) ?? "0.0.0.0";
  const salt = env.LEAD_ID_HASH_SALT?.trim() ?? "clawea-www-lead";
  return sha256Base64Url(`${salt}|ip|${rawIp}`);
}

async function evaluateLeadAbuse(
  payload: LeadSubmissionPayload,
  request: Request,
  env: Env,
): Promise<{
  ok: boolean;
  denyCode?: string;
  ipHash: string;
  emailHash: string | null;
}> {
  const email = normalizeEmail(payload.email);
  const salt = env.LEAD_ID_HASH_SALT?.trim() ?? "clawea-www-lead";
  const ipHash = await hashIpForAbuse(request, env);
  const emailHash = email ? await sha256Base64Url(`${salt}|email|${email}`) : null;

  const domain = email.includes("@") ? email.split("@")[1] : "";
  if (domain && DISPOSABLE_EMAIL_DOMAINS.has(domain)) {
    return { ok: false, denyCode: "DISPOSABLE_EMAIL_DENY", ipHash, emailHash };
  }

  const minutes = leadWindowMinutes(env);
  const cutoff = new Date(Date.now() - minutes * 60_000).toISOString();

  const ipRow = await env.DB.prepare(
    `SELECT COUNT(*) AS count
     FROM lead_submit_attempts
     WHERE ip_hash = ?1 AND created_at >= ?2`,
  ).bind(ipHash, cutoff).first<{ count: number }>();

  if (Number(ipRow?.count ?? 0) >= leadIpWindowLimit(env)) {
    return { ok: false, denyCode: "RATE_LIMIT_IP_WINDOW", ipHash, emailHash };
  }

  if (emailHash) {
    const emailRow = await env.DB.prepare(
      `SELECT COUNT(*) AS count
       FROM lead_submit_attempts
       WHERE email_hash = ?1 AND created_at >= ?2`,
    ).bind(emailHash, cutoff).first<{ count: number }>();

    if (Number(emailRow?.count ?? 0) >= leadEmailWindowLimit(env)) {
      return { ok: false, denyCode: "RATE_LIMIT_EMAIL_WINDOW", ipHash, emailHash };
    }
  }

  return { ok: true, ipHash, emailHash };
}

async function recordLeadSubmitAttempt(env: Env, params: {
  leadId?: string;
  ipHash: string;
  emailHash: string | null;
  idempotencyKey?: string;
  visitorId?: string;
  source: string;
  campaignId: string;
  pageFamily: string;
  outcomeCode: string;
}): Promise<void> {
  await env.DB.prepare(
    `INSERT INTO lead_submit_attempts (
      attempt_id,
      lead_id,
      ip_hash,
      email_hash,
      idempotency_key,
      visitor_id,
      source,
      campaign_id,
      page_family,
      outcome_code,
      created_at
    ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)`,
  )
    .bind(
      randomId("lead_attempt"),
      params.leadId ?? null,
      params.ipHash,
      params.emailHash,
      params.idempotencyKey ?? null,
      params.visitorId ?? null,
      params.source,
      params.campaignId,
      params.pageFamily,
      params.outcomeCode,
      new Date().toISOString(),
    )
    .run();
}

async function loadCrmRoutingConfig(env: Env): Promise<CrmRoutingConfig> {
  const key = env.CRM_PROVIDER_CONFIG_KEY?.trim() || "crm-provider-config-v1";
  const kvRaw = await env.VARIANT_CONFIG.get(key, "text").catch(() => null);
  const envRaw = env.CRM_PROVIDER_CONFIG_JSON?.trim() || null;
  const raw = kvRaw || envRaw;

  if (!raw) return DEFAULT_CRM_ROUTING_CONFIG;

  const parsed = safeJsonParse<any>(raw, {});
  const parsedProviders = Array.isArray(parsed?.providers) ? parsed.providers as Array<Record<string, unknown>> : [];

  const providers: CrmProvider[] = parsedProviders.length > 0
    ? parsedProviders
      .filter((p) => typeof p?.id === "string")
      .map((p) => {
        const authTypeRaw = typeof p.authType === "string" ? p.authType : "none";
        const authType: CrmProvider["authType"] = authTypeRaw === "bearer" || authTypeRaw === "header" || authTypeRaw === "none"
          ? authTypeRaw
          : "none";

        return {
          id: String(p.id),
          endpoint: typeof p.endpoint === "string" ? p.endpoint : undefined,
          authType,
          authHeader: typeof p.authHeader === "string" ? p.authHeader : undefined,
        };
      })
    : DEFAULT_CRM_ROUTING_CONFIG.providers;

  const defaults = (parsed?.defaultProviderBySegment ?? {}) as Partial<Record<LeadSegment, string>>;
  const parsedRules = Array.isArray(parsed?.providerRules)
    ? parsed.providerRules as Array<Record<string, unknown>>
    : [];

  const providerRules: CrmRoutingRule[] = [];
  for (const rule of parsedRules) {
    const providerId = clipString(rule?.providerId, 80);
    if (!providerId) continue;

    const segmentRaw = clipString(rule?.segment, 24);
    const segment = segmentRaw === "enterprise" || segmentRaw === "smb" || segmentRaw === "partner"
      ? segmentRaw
      : undefined;

    const scoreBandRaw = clipString(rule?.scoreBand, 24);
    const scoreBand = scoreBandRaw === "high" || scoreBandRaw === "medium" || scoreBandRaw === "low"
      ? scoreBandRaw
      : undefined;

    const sourceIntentRaw = clipString(rule?.sourceIntent, 24);
    const sourceIntent = sourceIntentRaw
      ? normalizeSourceIntent(sourceIntentRaw)
      : undefined;

    providerRules.push({
      providerId,
      segment,
      scoreBand,
      sourceIntent,
    });
  }

  const config: CrmRoutingConfig = {
    defaultProviderBySegment: {
      enterprise: typeof defaults.enterprise === "string" ? defaults.enterprise : DEFAULT_CRM_ROUTING_CONFIG.defaultProviderBySegment.enterprise,
      smb: typeof defaults.smb === "string" ? defaults.smb : DEFAULT_CRM_ROUTING_CONFIG.defaultProviderBySegment.smb,
      partner: typeof defaults.partner === "string" ? defaults.partner : DEFAULT_CRM_ROUTING_CONFIG.defaultProviderBySegment.partner,
    },
    providers,
    providerRules: providerRules.length > 0 ? providerRules : DEFAULT_CRM_ROUTING_CONFIG.providerRules,
  };

  return config;
}

function crmAuthTokenMap(env: Env): Record<string, string> {
  return safeJsonParse<Record<string, string>>(env.CRM_PROVIDER_AUTH_JSON ?? null, {});
}

function selectProviderForLead(
  config: CrmRoutingConfig,
  segment: LeadSegment,
  scoreBand: LeadScoreBand,
  sourceIntent: LeadSourceIntent,
): string {
  const providers = new Set(config.providers.map((p) => p.id));

  const matchedRule = config.providerRules.find((rule) => {
    if (rule.segment && rule.segment !== segment) return false;
    if (rule.scoreBand && rule.scoreBand !== scoreBand) return false;
    if (rule.sourceIntent && rule.sourceIntent !== sourceIntent) return false;
    return true;
  });

  const ruleProvider = matchedRule?.providerId;
  if (ruleProvider && providers.has(ruleProvider)) {
    return ruleProvider;
  }

  const fallback = config.defaultProviderBySegment[segment] ?? "internal-r2";
  if (providers.has(fallback)) return fallback;

  return providers.values().next().value ?? "internal-r2";
}

function queueForSegment(env: Env, segment: LeadSegment): Queue {
  if (segment === "enterprise") return env.LEAD_ROUTE_ENTERPRISE;
  if (segment === "partner") return env.LEAD_ROUTE_PARTNER;
  return env.LEAD_ROUTE_SMB;
}

async function enqueueRoutingJob(env: Env, segment: LeadSegment, body: Record<string, unknown>): Promise<void> {
  const q = queueForSegment(env, segment);
  await q.send(body);
}

async function persistTrackingEventD1(env: Env, event: TrackingEvent): Promise<void> {
  try {
    await env.DB.prepare(
      `INSERT INTO funnel_events (
        event_id,
        event_type,
        page,
        page_family,
        source,
        cta_id,
        cta_variant,
        action_outcome,
        query,
        result_count,
        target_path,
        variant_id,
        hero_variant,
        visitor_id,
        attribution_json,
        event_ts,
        created_at
      ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15, ?16, ?17)
      `,
    )
      .bind(
        randomId("ev"),
        event.eventType,
        event.page,
        event.pageFamily,
        event.source,
        event.ctaId ?? null,
        event.ctaVariant ?? null,
        event.actionOutcome ?? null,
        event.query ?? null,
        event.resultCount ?? null,
        event.targetPath ?? null,
        event.variantId ?? null,
        event.heroVariant ?? null,
        event.visitorId ?? null,
        JSON.stringify(event.attribution ?? {}),
        event.ts,
        new Date().toISOString(),
      )
      .run();

    env.ANALYTICS?.writeDataPoint({
      indexes: [event.eventType, event.pageFamily, event.ctaVariant ?? "none", event.source],
      blobs: [event.page, event.variantId ?? "none", event.actionOutcome ?? "none"],
      doubles: [
        Number(event.resultCount ?? 0),
        Number(event.eventType === "cta_click" ? 1 : 0),
        Number(event.eventType === "lead_submit" ? 1 : 0),
      ],
    });
  } catch (err) {
    console.error("FUNNEL_EVENT_D1_INSERT_FAILED", err);
  }
}

async function upsertLeadFromPayload(payload: LeadSubmissionPayload, request: Request, env: Env): Promise<{
  leadId: string;
  deduped: boolean;
  idempotentReplay: boolean;
  scores: LeadScoreResult;
  idempotencyKey: string;
  segment: LeadSegment;
  routeJobId: string | null;
}> {
  const nowIso = new Date().toISOString();
  const email = normalizeEmail(payload.email);

  if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    throw new Error("EMAIL_INVALID");
  }

  const idempotencyKey = payload.idempotencyKey
    ?? `idem_${(await sha256Base64Url([
      email,
      payload.page ?? "/contact",
      payload.attribution?.utm_campaign ?? "",
      payload.visitorId ?? "",
    ].join("|"))).slice(0, 30)}`;

  const lock = await leadSubmitLockAcquire(env, idempotencyKey);
  if (!lock.ok) {
    if (lock.inFlight) {
      throw new Error("IDEMPOTENCY_IN_FLIGHT");
    }
    throw new Error("IDEMPOTENCY_LOCK_FAILED");
  }

  if (lock.replay && lock.leadId) {
    const replayScores = scoreLeadIntent(payload);
    return {
      leadId: lock.leadId,
      deduped: true,
      idempotentReplay: true,
      scores: replayScores,
      idempotencyKey,
      segment: replayScores.segment,
      routeJobId: null,
    };
  }

  try {
    const salt = env.LEAD_ID_HASH_SALT?.trim() ?? "clawea-www-lead";
    const identityHash = await sha256Base64Url(`${salt}|${email}`);
    const emailHash = await sha256Base64Url(email);

    const page = payload.page ?? "/contact";
    const pageFamily = payload.pageFamily ?? pageFamilyFromPath(page);
    const source = payload.attribution?.source ?? payload.firstTouch?.source ?? "direct";
    const campaignId = payload.attribution?.utm_campaign ?? "";

    const scores = scoreLeadIntent(payload);

    const emailParts = email.split("@");
    const emailHint = emailParts.length === 2
      ? `${emailParts[0].slice(0, 2)}***@${emailParts[1]}`
      : "***";

    const existing = await env.DB.prepare(
      `SELECT lead_id, dedupe_count, status FROM leads WHERE identity_hash = ?1 LIMIT 1`,
    ).bind(identityHash).first<{ lead_id: string; dedupe_count: number; status: string }>();

    const leadId = existing?.lead_id ?? randomId("lead");
    const deduped = Boolean(existing?.lead_id);

    if (!deduped) {
      await env.DB.prepare(
        `INSERT INTO leads (
          lead_id,
          identity_hash,
          email_hash,
          email_hint,
          full_name,
          company,
          role,
          team_size,
          timeline,
          primary_use_case,
          intent_note,
          source,
          source_intent,
          page,
          page_family,
          attribution_json,
          first_touch_json,
          assessment_json,
          behavior_json,
          readiness_score,
          roi_score,
          risk_score,
          intent_score,
          qualification_score,
          score_band,
          segment,
          campaign_id,
          variant_id,
          hero_variant,
          cta_variant,
          status,
          route_status,
          dedupe_count,
          created_at,
          updated_at,
          last_seen_at,
          lifecycle_updated_at
        ) VALUES (
          ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
          ?, ?, ?, ?, ?, ?, ?, ?,
          ?, ?, ?, ?, ?, ?, ?,
          ?, ?, ?, ?, 'new', 'pending', 0, ?, ?, ?, ?
        )`,
      )
        .bind(
          leadId,
          identityHash,
          emailHash,
          emailHint,
          payload.fullName ?? "",
          payload.company ?? "",
          payload.role ?? "",
          payload.teamSize ?? "",
          payload.timeline ?? "",
          payload.primaryUseCase ?? "",
          payload.intentNote ?? "",
          source,
          scores.sourceIntent,
          page,
          pageFamily,
          JSON.stringify(payload.attribution ?? {}),
          JSON.stringify(payload.firstTouch ?? {}),
          JSON.stringify(payload.assessment ?? {}),
          JSON.stringify(payload.behavior ?? {}),
          scores.readinessScore,
          scores.roiScore,
          scores.riskScore,
          scores.intentScore,
          scores.qualificationScore,
          scores.scoreBand,
          scores.segment,
          campaignId,
          payload.variantId ?? "",
          payload.heroVariant ?? "",
          payload.ctaVariant ?? "",
          nowIso,
          nowIso,
          nowIso,
          nowIso,
        )
        .run();
    } else {
      await env.DB.prepare(
        `UPDATE leads
          SET
            full_name = COALESCE(NULLIF(?,''), full_name),
            company = COALESCE(NULLIF(?,''), company),
            role = COALESCE(NULLIF(?,''), role),
            team_size = COALESCE(NULLIF(?,''), team_size),
            timeline = COALESCE(NULLIF(?,''), timeline),
            primary_use_case = COALESCE(NULLIF(?,''), primary_use_case),
            intent_note = COALESCE(NULLIF(?,''), intent_note),
            source = COALESCE(NULLIF(?,''), source),
            source_intent = COALESCE(NULLIF(?,''), source_intent),
            page = COALESCE(NULLIF(?,''), page),
            page_family = COALESCE(NULLIF(?,''), page_family),
            campaign_id = COALESCE(NULLIF(?,''), campaign_id),
            variant_id = COALESCE(NULLIF(?,''), variant_id),
            hero_variant = COALESCE(NULLIF(?,''), hero_variant),
            cta_variant = COALESCE(NULLIF(?,''), cta_variant),
            attribution_json = CASE WHEN ? <> '{}' THEN ? ELSE attribution_json END,
            first_touch_json = CASE WHEN ? <> '{}' THEN ? ELSE first_touch_json END,
            assessment_json = CASE WHEN ? <> '{}' THEN ? ELSE assessment_json END,
            behavior_json = CASE WHEN ? <> '{}' THEN ? ELSE behavior_json END,
            readiness_score = MAX(readiness_score, ?),
            roi_score = MAX(roi_score, ?),
            risk_score = MIN(risk_score, ?),
            intent_score = MAX(intent_score, ?),
            qualification_score = MAX(qualification_score, ?),
            score_band = CASE WHEN MAX(qualification_score, ?) >= 80 THEN 'high' WHEN MAX(qualification_score, ?) >= 55 THEN 'medium' ELSE 'low' END,
            segment = CASE WHEN ? = 'partner' THEN 'partner' WHEN ? = 'enterprise' THEN 'enterprise' ELSE segment END,
            dedupe_count = dedupe_count + 1,
            updated_at = ?,
            last_seen_at = ?
          WHERE lead_id = ?`,
      )
        .bind(
          payload.fullName ?? "",
          payload.company ?? "",
          payload.role ?? "",
          payload.teamSize ?? "",
          payload.timeline ?? "",
          payload.primaryUseCase ?? "",
          payload.intentNote ?? "",
          source,
          scores.sourceIntent,
          page,
          pageFamily,
          campaignId,
          payload.variantId ?? "",
          payload.heroVariant ?? "",
          payload.ctaVariant ?? "",
          JSON.stringify(payload.attribution ?? {}),
          JSON.stringify(payload.attribution ?? {}),
          JSON.stringify(payload.firstTouch ?? {}),
          JSON.stringify(payload.firstTouch ?? {}),
          JSON.stringify(payload.assessment ?? {}),
          JSON.stringify(payload.assessment ?? {}),
          JSON.stringify(payload.behavior ?? {}),
          JSON.stringify(payload.behavior ?? {}),
          scores.readinessScore,
          scores.roiScore,
          scores.riskScore,
          scores.intentScore,
          scores.qualificationScore,
          scores.qualificationScore,
          scores.qualificationScore,
          scores.segment,
          scores.segment,
          nowIso,
          nowIso,
          leadId,
        )
        .run();
    }

    await env.DB.prepare(
      `INSERT OR REPLACE INTO lead_idempotency (idempotency_key, lead_id, created_at)
       VALUES (?1, ?2, ?3)`,
    ).bind(idempotencyKey, leadId, nowIso).run();

    await env.DB.prepare(
      `INSERT INTO lead_events (
        event_id,
        lead_id,
        event_type,
        event_payload_json,
        source,
        page,
        page_family,
        created_at
      ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)`,
    )
      .bind(
        randomId("lead_evt"),
        leadId,
        deduped ? "lead_deduped" : "lead_submitted",
        JSON.stringify({
          deduped,
          scores,
          emailHint,
          attribution: payload.attribution ?? {},
          campaignId,
          variantId: payload.variantId ?? null,
          ctaVariant: payload.ctaVariant ?? null,
          heroVariant: payload.heroVariant ?? null,
        }),
        source,
        page,
        pageFamily,
        nowIso,
      )
      .run();

    await transitionLeadState(env, leadId, "validated", "turnstile_validated", {
      source,
      pageFamily,
    });
    await transitionLeadState(env, leadId, "scored", "score_v3", {
      qualificationScore: scores.qualificationScore,
      scoreBand: scores.scoreBand,
      segment: scores.segment,
      sourceIntent: scores.sourceIntent,
      scoreReasons: scores.scoreReasons,
    });

    const routingConfig = await loadCrmRoutingConfig(env);
    const providerId = selectProviderForLead(
      routingConfig,
      scores.segment,
      scores.scoreBand,
      scores.sourceIntent,
    );

    await transitionLeadState(env, leadId, "routed", "routing_enqueued", {
      segment: scores.segment,
      sourceIntent: scores.sourceIntent,
      scoreBand: scores.scoreBand,
      providerId,
    });

    let routeJobId: string | null = null;

    const existingJob = await env.DB.prepare(
      `SELECT job_id FROM lead_routing_jobs WHERE idempotency_key = ?1 LIMIT 1`,
    ).bind(idempotencyKey).first<{ job_id: string }>();

    if (existingJob?.job_id) {
      routeJobId = existingJob.job_id;
    } else {
      routeJobId = randomId("route_job");

      await env.DB.prepare(
        `INSERT INTO lead_routing_jobs (
          job_id,
          lead_id,
          segment,
          provider_id,
          state,
          attempts,
          max_attempts,
          payload_json,
          idempotency_key,
          created_at,
          updated_at
        ) VALUES (?1, ?2, ?3, ?4, 'queued', 0, ?5, ?6, ?7, ?8, ?8)`,
      )
        .bind(
          routeJobId,
          leadId,
          scores.segment,
          providerId,
          routingMaxAttempts(env),
          JSON.stringify({
            source,
            sourceIntent: scores.sourceIntent,
            campaignId,
            scoreBand: scores.scoreBand,
            scoreReasons: scores.scoreReasons,
            variantId: payload.variantId ?? null,
          }),
          idempotencyKey,
          nowIso,
        )
        .run();

      await env.DB.prepare(
        `UPDATE leads
         SET route_status = 'queued', routed_provider_id = ?2, updated_at = ?3
         WHERE lead_id = ?1`,
      ).bind(leadId, providerId, nowIso).run();

      await enqueueRoutingJob(env, scores.segment, {
        type: "lead_route_dispatch",
        routeJobId,
        leadId,
        segment: scores.segment,
      });
    }

    await leadSubmitLockComplete(env, idempotencyKey, leadId);

    return {
      leadId,
      deduped,
      idempotentReplay: false,
      scores,
      idempotencyKey,
      segment: scores.segment,
      routeJobId,
    };
  } catch (err) {
    await leadSubmitLockFail(env, idempotencyKey);
    throw err;
  }
}

async function submitLead(request: Request, env: Env): Promise<Response> {
  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  let body: any;
  try {
    body = await request.json<any>();
  } catch {
    return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
  }

  const payload = normalizeLeadPayload(body);
  const source = payload.attribution?.source ?? payload.firstTouch?.source ?? "direct";
  const campaignId = payload.attribution?.utm_campaign ?? "";
  const pageFamily = payload.pageFamily ?? pageFamilyFromPath(payload.page ?? "/contact");

  const abuse = await evaluateLeadAbuse(payload, request, env);
  if (!abuse.ok) {
    await recordLeadSubmitAttempt(env, {
      ipHash: abuse.ipHash,
      emailHash: abuse.emailHash,
      idempotencyKey: payload.idempotencyKey,
      visitorId: payload.visitorId,
      source,
      campaignId,
      pageFamily,
      outcomeCode: abuse.denyCode ?? "RATE_LIMIT_DENY",
    });

    return apiError(
      abuse.denyCode ?? "RATE_LIMIT_DENY",
      "Lead submission blocked by abuse protection policy",
      429,
    );
  }

  const turnstile = await verifyTurnstile(payload.turnstileToken, request, env);
  if (!turnstile.ok) {
    await recordLeadSubmitAttempt(env, {
      ipHash: abuse.ipHash,
      emailHash: abuse.emailHash,
      idempotencyKey: payload.idempotencyKey,
      visitorId: payload.visitorId,
      source,
      campaignId,
      pageFamily,
      outcomeCode: `TURNSTILE_${turnstile.error ?? "FAILED"}`,
    });

    return apiError("TURNSTILE_FAILED", turnstile.error ?? "Turnstile validation failed", 403);
  }

  try {
    const saved = await upsertLeadFromPayload(payload, request, env);

    await recordLeadSubmitAttempt(env, {
      leadId: saved.leadId,
      ipHash: abuse.ipHash,
      emailHash: abuse.emailHash,
      idempotencyKey: saved.idempotencyKey,
      visitorId: payload.visitorId,
      source,
      campaignId,
      pageFamily,
      outcomeCode: saved.idempotentReplay ? "IDEMPOTENT_REPLAY" : (saved.deduped ? "DEDUPED" : "ACCEPTED"),
    });

    try {
      await storeTrackingEvent(env, {
        eventType: "lead_submit",
        page: payload.page ?? "/contact",
        pageFamily,
        source,
        ctaId: payload.pageFamily === "assessment" ? "assessment-result-submit" : "contact-fast-submit",
        ctaVariant: payload.ctaVariant ?? "submit",
        actionOutcome: saved.deduped ? "deduped" : "submitted",
        variantId: payload.variantId ?? `${pageFamily}:proof:submit`,
        heroVariant: payload.heroVariant ?? "proof",
        visitorId: payload.visitorId,
        ts: new Date().toISOString(),
        attribution: payload.attribution ?? {},
        context: {},
        targetPath: saved.routeJobId ? "/api/routing/status" : undefined,
      });
    } catch (telemetryErr) {
      console.error("LEAD_SUBMIT_TELEMETRY_FAILED", telemetryErr);
    }

    return apiJson({
      ok: true,
      leadId: saved.leadId,
      routeJobId: saved.routeJobId,
      segment: saved.segment,
      scoreBand: saved.scores.scoreBand,
      deduped: saved.deduped,
      idempotentReplay: saved.idempotentReplay,
      confidenceLabel: saved.scores.confidenceLabel,
      qualificationScore: saved.scores.qualificationScore,
      sourceIntent: saved.scores.sourceIntent,
      scoreReasons: saved.scores.scoreReasons.slice(0, 8),
      next: saved.scores.qualificationScore >= 78 ? "priority_follow_up" : "standard_follow_up",
      bookPath: `/book?lead=${encodeURIComponent(saved.leadId)}`,
    });
  } catch (err: any) {
    const code = String(err?.message ?? "LEAD_SUBMIT_FAILED");

    if (code === "IDEMPOTENCY_IN_FLIGHT") {
      await recordLeadSubmitAttempt(env, {
        ipHash: abuse.ipHash,
        emailHash: abuse.emailHash,
        idempotencyKey: payload.idempotencyKey,
        visitorId: payload.visitorId,
        source,
        campaignId,
        pageFamily,
        outcomeCode: "IDEMPOTENCY_IN_FLIGHT",
      });
      return apiError("IDEMPOTENCY_IN_FLIGHT", "A lead submission with this key is already processing", 409);
    }

    if (code === "EMAIL_INVALID") {
      await recordLeadSubmitAttempt(env, {
        ipHash: abuse.ipHash,
        emailHash: abuse.emailHash,
        idempotencyKey: payload.idempotencyKey,
        visitorId: payload.visitorId,
        source,
        campaignId,
        pageFamily,
        outcomeCode: "EMAIL_INVALID",
      });
      return apiError("EMAIL_INVALID", "A valid work email is required", 400);
    }

    console.error("LEAD_SUBMIT_FAILED", err);
    await recordLeadSubmitAttempt(env, {
      ipHash: abuse.ipHash,
      emailHash: abuse.emailHash,
      idempotencyKey: payload.idempotencyKey,
      visitorId: payload.visitorId,
      source,
      campaignId,
      pageFamily,
      outcomeCode: "LEAD_SUBMIT_FAILED",
    });

    return apiError("LEAD_SUBMIT_FAILED", "Lead intake failed", 500);
  }
}

function csvEscape(value: unknown): string {
  const s = String(value ?? "");
  if (/[",\n]/.test(s)) {
    return `"${s.replace(/"/g, '""')}"`;
  }
  return s;
}

async function leadsStatus(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const totalRow = await env.DB.prepare(`SELECT COUNT(*) AS count FROM leads`).first<{ count: number }>();

  const statusRows = await env.DB.prepare(
    `SELECT status AS key, COUNT(*) AS count FROM leads GROUP BY status ORDER BY count DESC`,
  ).all<{ key: string; count: number }>();

  const sourceRows = await env.DB.prepare(
    `SELECT source AS key, COUNT(*) AS count FROM leads GROUP BY source ORDER BY count DESC LIMIT 20`,
  ).all<{ key: string; count: number }>();

  const familyRows = await env.DB.prepare(
    `SELECT page_family AS key, COUNT(*) AS count FROM leads GROUP BY page_family ORDER BY count DESC LIMIT 20`,
  ).all<{ key: string; count: number }>();

  const transitionRows = await env.DB.prepare(
    `SELECT to_state AS key, COUNT(*) AS count FROM lead_state_transitions GROUP BY to_state ORDER BY count DESC LIMIT 20`,
  ).all<{ key: string; count: number }>();

  const recentRows = await env.DB.prepare(
    `SELECT
      lead_id,
      created_at,
      updated_at,
      last_seen_at,
      status,
      qualification_score,
      intent_score,
      risk_score,
      readiness_score,
      roi_score,
      dedupe_count,
      source,
      source_intent,
      page,
      page_family,
      full_name,
      company,
      role,
      team_size,
      timeline,
      primary_use_case,
      email_hint,
      score_band,
      segment,
      campaign_id,
      variant_id,
      hero_variant,
      cta_variant,
      route_status,
      routed_provider_id,
      booked_at,
      completed_at
    FROM leads
    ORDER BY last_seen_at DESC
    LIMIT 50`,
  ).all<LeadRow>();

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    totals: {
      leads: Number(totalRow?.count ?? 0),
      recentWindow: Number(recentRows.results?.length ?? 0),
    },
    breakdown: {
      byStatus: statusRows.results ?? [],
      bySource: sourceRows.results ?? [],
      byPageFamily: familyRows.results ?? [],
      byTransition: transitionRows.results ?? [],
    },
    recent: (recentRows.results ?? []).map((row) => ({
      leadId: row.lead_id,
      status: row.status,
      qualificationScore: row.qualification_score,
      intentScore: row.intent_score,
      readinessScore: row.readiness_score,
      roiScore: row.roi_score,
      riskScore: row.risk_score,
      dedupeCount: row.dedupe_count,
      source: row.source,
      sourceIntent: normalizeSourceIntent(row.source_intent),
      page: row.page,
      pageFamily: row.page_family,
      company: row.company,
      role: row.role,
      teamSize: row.team_size,
      timeline: row.timeline,
      scoreBand: row.score_band,
      segment: row.segment,
      campaignId: row.campaign_id,
      variantId: row.variant_id,
      heroVariant: row.hero_variant,
      ctaVariant: row.cta_variant,
      routeStatus: row.route_status,
      routedProviderId: row.routed_provider_id,
      bookedAt: row.booked_at,
      completedAt: row.completed_at,
      emailHint: row.email_hint,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      lastSeenAt: row.last_seen_at,
    })),
  });
}

async function leadsExport(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const url = new URL(request.url);
  const format = (clipString(url.searchParams.get("format"), 12) ?? "json").toLowerCase();
  const statusFilter = clipString(url.searchParams.get("status"), 32);
  const segmentFilter = clipString(url.searchParams.get("segment"), 24);
  const scoreBandFilter = clipString(url.searchParams.get("scoreBand"), 24);
  const limit = Math.min(2000, Math.max(1, Number(url.searchParams.get("limit") ?? "500")));

  let sql = `SELECT
    lead_id,
    status,
    qualification_score,
    intent_score,
    readiness_score,
    roi_score,
    risk_score,
    dedupe_count,
    source,
    source_intent,
    page,
    page_family,
    company,
    role,
    team_size,
    timeline,
    primary_use_case,
    email_hint,
    score_band,
    segment,
    campaign_id,
    variant_id,
    hero_variant,
    cta_variant,
    route_status,
    routed_provider_id,
    booked_at,
    completed_at,
    created_at,
    updated_at,
    last_seen_at
  FROM leads`;

  const binds: Array<string | number> = [];
  const where: string[] = [];

  if (statusFilter) {
    where.push(`status = ?${binds.length + 1}`);
    binds.push(statusFilter);
  }

  if (segmentFilter) {
    where.push(`segment = ?${binds.length + 1}`);
    binds.push(segmentFilter);
  }

  if (scoreBandFilter) {
    where.push(`score_band = ?${binds.length + 1}`);
    binds.push(scoreBandFilter);
  }

  if (where.length > 0) {
    sql += ` WHERE ${where.join(" AND ")}`;
  }

  sql += ` ORDER BY last_seen_at DESC LIMIT ${limit}`;

  const rows = binds.length > 0
    ? await env.DB.prepare(sql).bind(...binds).all<Record<string, unknown>>()
    : await env.DB.prepare(sql).all<Record<string, unknown>>();
  const results = rows.results ?? [];

  if (format === "csv") {
    const headers = [
      "lead_id",
      "status",
      "qualification_score",
      "intent_score",
      "readiness_score",
      "roi_score",
      "risk_score",
      "score_band",
      "segment",
      "campaign_id",
      "variant_id",
      "hero_variant",
      "cta_variant",
      "route_status",
      "routed_provider_id",
      "dedupe_count",
      "source",
      "source_intent",
      "page",
      "page_family",
      "company",
      "role",
      "team_size",
      "timeline",
      "primary_use_case",
      "email_hint",
      "booked_at",
      "completed_at",
      "created_at",
      "updated_at",
      "last_seen_at",
    ];

    const lines = [headers.join(",")];
    for (const row of results) {
      lines.push(headers.map((h) => csvEscape(row[h])).join(","));
    }

    return new Response(lines.join("\n"), {
      status: 200,
      headers: apiHeaders({
        "content-type": "text/csv;charset=utf-8",
        "content-disposition": `attachment; filename="clawea-leads-${new Date().toISOString().slice(0, 10)}.csv"`,
      }),
    });
  }

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    count: results.length,
    leads: results,
  });
}

async function computeLeadResponseSla(env: Env): Promise<{
  nowIso: string;
  slaMinutes: number;
  totalLeads: number;
  openLeads: number;
  dueSoon: number;
  breached: number;
  breachRate: number;
  openByStatus: Array<{ key: string; count: number }>;
  breachedBySegment: Array<{ key: string; count: number }>;
  topBreaches: Array<Record<string, unknown>>;
}> {
  const nowIso = new Date().toISOString();
  const nowMs = Date.parse(nowIso);
  const slaMinutes = leadResponseSlaMinutes(env);
  const recentCutoff = new Date(nowMs - (30 * 24 * 60 * 60 * 1000)).toISOString();

  const rows = await env.DB.prepare(
    `SELECT
      lead_id,
      status,
      created_at,
      source,
      source_intent,
      page_family,
      campaign_id,
      segment,
      score_band,
      qualification_score
     FROM leads
     WHERE created_at >= ?1
     ORDER BY created_at DESC
     LIMIT 4000`,
  ).bind(recentCutoff).all<Record<string, unknown>>();

  const openByStatus = new Map<string, number>();
  const breachedBySegment = new Map<string, number>();
  const topBreaches: Array<Record<string, unknown>> = [];
  const activeAlertKeys: string[] = [];

  let totalLeads = 0;
  let openLeads = 0;
  let dueSoon = 0;
  let breached = 0;

  for (const row of rows.results ?? []) {
    totalLeads += 1;
    const leadId = String(row.lead_id ?? "");
    const status = normalizeLeadStatus(clipString(row.status, 24));
    if (!RESPONSE_SLA_OPEN_STATES.has(status)) {
      continue;
    }

    openLeads += 1;
    openByStatus.set(status, (openByStatus.get(status) ?? 0) + 1);

    const createdAt = String(row.created_at ?? nowIso);
    const dueAt = addMinutesIso(createdAt, slaMinutes);
    const dueMs = Date.parse(dueAt);
    if (Number.isNaN(dueMs)) continue;

    const minutesToDue = Math.floor((dueMs - nowMs) / 60_000);
    const overdueMinutes = Math.max(0, Math.floor((nowMs - dueMs) / 60_000));

    if (minutesToDue <= 15 && minutesToDue >= 0) {
      dueSoon += 1;
    }

    if (nowMs <= dueMs) continue;

    breached += 1;
    const segment = clipString(row.segment, 24) ?? "smb";
    breachedBySegment.set(segment, (breachedBySegment.get(segment) ?? 0) + 1);

    const alertKey = `lead_response_sla_miss:${leadId}`;
    activeAlertKeys.push(alertKey);

    await upsertLeadAlert(env, {
      alertKey,
      alertType: "lead_response_sla_miss",
      severity: overdueMinutes >= 120 ? "critical" : "warning",
      leadId,
      summary: `Lead ${leadId} missed first-response SLA by ${overdueMinutes}m`,
      metadata: {
        status,
        createdAt,
        dueAt,
        overdueMinutes,
        source: String(row.source ?? "direct"),
        sourceIntent: String(row.source_intent ?? "direct"),
        pageFamily: String(row.page_family ?? "contact"),
        campaignId: String(row.campaign_id ?? ""),
        scoreBand: String(row.score_band ?? "low"),
        qualificationScore: Number(row.qualification_score ?? 0),
      },
    });

    topBreaches.push({
      leadId,
      status,
      createdAt,
      dueAt,
      overdueMinutes,
      source: String(row.source ?? "direct"),
      sourceIntent: String(row.source_intent ?? "direct"),
      pageFamily: String(row.page_family ?? "contact"),
      campaignId: String(row.campaign_id ?? ""),
      segment,
      scoreBand: String(row.score_band ?? "low"),
      qualificationScore: Number(row.qualification_score ?? 0),
    });
  }

  await resolveLeadAlertsByType(env, "lead_response_sla_miss", activeAlertKeys);

  topBreaches.sort((a, b) => Number(b.overdueMinutes ?? 0) - Number(a.overdueMinutes ?? 0));

  const openByStatusRows = [...openByStatus.entries()]
    .map(([key, count]) => ({ key, count }))
    .sort((a, b) => b.count - a.count);

  const breachedBySegmentRows = [...breachedBySegment.entries()]
    .map(([key, count]) => ({ key, count }))
    .sort((a, b) => b.count - a.count);

  return {
    nowIso,
    slaMinutes,
    totalLeads,
    openLeads,
    dueSoon,
    breached,
    breachRate: openLeads > 0 ? Number((breached / openLeads).toFixed(4)) : 0,
    openByStatus: openByStatusRows,
    breachedBySegment: breachedBySegmentRows,
    topBreaches: topBreaches.slice(0, 40),
  };
}

async function collectFailingStepBuckets(env: Env, fromIso: string, toIso: string): Promise<{
  leadSubmit: Array<{ key: string; count: number }>;
  routing: Array<{ key: string; count: number }>;
  top: Array<{ key: string; count: number }>;
}> {
  const submitRows = await env.DB.prepare(
    `SELECT outcome_code AS key, COUNT(*) AS count
     FROM lead_submit_attempts
     WHERE created_at >= ?1 AND created_at <= ?2
       AND outcome_code NOT IN ('ACCEPTED', 'DEDUPED', 'IDEMPOTENT_REPLAY')
     GROUP BY outcome_code
     ORDER BY count DESC
     LIMIT 50`,
  ).bind(fromIso, toIso).all<{ key: string; count: number }>();

  const routingRows = await env.DB.prepare(
    `SELECT COALESCE(NULLIF(last_error_code,''), state) AS key, COUNT(*) AS count
     FROM lead_routing_jobs
     WHERE updated_at >= ?1 AND updated_at <= ?2
       AND (state IN ('failed', 'dead_letter') OR last_error_code <> '')
     GROUP BY COALESCE(NULLIF(last_error_code,''), state)
     ORDER BY count DESC
     LIMIT 50`,
  ).bind(fromIso, toIso).all<{ key: string; count: number }>();

  const aggregate = new Map<string, number>();
  for (const row of submitRows.results ?? []) {
    aggregate.set(`submit:${row.key}`, (aggregate.get(`submit:${row.key}`) ?? 0) + Number(row.count ?? 0));
  }
  for (const row of routingRows.results ?? []) {
    aggregate.set(`routing:${row.key}`, (aggregate.get(`routing:${row.key}`) ?? 0) + Number(row.count ?? 0));
  }

  const top = [...aggregate.entries()]
    .map(([key, count]) => ({ key, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 30);

  return {
    leadSubmit: submitRows.results ?? [],
    routing: routingRows.results ?? [],
    top,
  };
}

async function computeRoutingHealth(env: Env): Promise<{
  queueLagThresholdMinutes: number;
  maxLagMinutes: number;
  laggingJobs: Array<Record<string, unknown>>;
  stateCounts: Array<{ key: string; count: number }>;
  segmentCounts: Array<{ key: string; count: number }>;
  deadLetter: { total: number; pending: number };
}> {
  const nowIso = new Date().toISOString();
  const nowMs = Date.parse(nowIso);
  const lagThreshold = routingQueueLagAlertMinutes(env);

  const stateCountsRows = await env.DB.prepare(
    `SELECT state AS key, COUNT(*) AS count
     FROM lead_routing_jobs
     GROUP BY state
     ORDER BY count DESC`,
  ).all<{ key: string; count: number }>();

  const segmentCountsRows = await env.DB.prepare(
    `SELECT segment AS key, COUNT(*) AS count
     FROM lead_routing_jobs
     GROUP BY segment
     ORDER BY count DESC`,
  ).all<{ key: string; count: number }>();

  const jobsRows = await env.DB.prepare(
    `SELECT
      job_id,
      lead_id,
      segment,
      state,
      attempts,
      max_attempts,
      created_at,
      updated_at,
      next_attempt_at,
      last_error_code
     FROM lead_routing_jobs
     WHERE state IN ('queued', 'processing', 'failed')
     ORDER BY updated_at ASC
     LIMIT 500`,
  ).all<Record<string, unknown>>();

  const deadLetterRow = await env.DB.prepare(
    `SELECT
      COUNT(*) AS total,
      SUM(CASE WHEN replayed_at IS NULL THEN 1 ELSE 0 END) AS pending
     FROM lead_handoff_dead_letter`,
  ).first<{ total: number; pending: number }>();

  const laggingJobs: Array<Record<string, unknown>> = [];
  const activeLagAlerts: string[] = [];
  let maxLagMinutes = 0;

  for (const row of jobsRows.results ?? []) {
    const referenceIso = String(row.updated_at ?? row.created_at ?? nowIso);
    const lagMinutes = diffMinutes(referenceIso, nowIso);
    if (lagMinutes > maxLagMinutes) maxLagMinutes = lagMinutes;

    if (lagMinutes < lagThreshold) continue;

    const jobId = String(row.job_id ?? "");
    const leadId = String(row.lead_id ?? "");
    const alertKey = `routing_queue_lag:${jobId}`;
    activeLagAlerts.push(alertKey);

    await upsertLeadAlert(env, {
      alertKey,
      alertType: "routing_queue_lag",
      severity: lagMinutes >= lagThreshold * 3 ? "critical" : "warning",
      leadId,
      jobId,
      summary: `Routing job ${jobId} lagging ${lagMinutes}m in ${String(row.state ?? 'queued')}`,
      metadata: {
        lagMinutes,
        thresholdMinutes: lagThreshold,
        segment: String(row.segment ?? "smb"),
        state: String(row.state ?? "queued"),
        attempts: Number(row.attempts ?? 0),
        maxAttempts: Number(row.max_attempts ?? 0),
        lastErrorCode: String(row.last_error_code ?? ""),
      },
    });

    laggingJobs.push({
      jobId,
      leadId,
      segment: String(row.segment ?? "smb"),
      state: String(row.state ?? "queued"),
      attempts: Number(row.attempts ?? 0),
      maxAttempts: Number(row.max_attempts ?? 0),
      lagMinutes,
      lastErrorCode: String(row.last_error_code ?? ""),
      updatedAt: String(row.updated_at ?? ""),
      nextAttemptAt: String(row.next_attempt_at ?? ""),
    });
  }

  await resolveLeadAlertsByType(env, "routing_queue_lag", activeLagAlerts);

  const deadPending = Number(deadLetterRow?.pending ?? 0);
  if (deadPending > 0) {
    await upsertLeadAlert(env, {
      alertKey: "routing_dead_letter_pending",
      alertType: "routing_dead_letter_pending",
      severity: deadPending >= 10 ? "critical" : "warning",
      summary: `${deadPending} dead-letter routing jobs pending replay`,
      metadata: {
        pending: deadPending,
        total: Number(deadLetterRow?.total ?? 0),
      },
    });
  } else {
    await resolveLeadAlertsByType(env, "routing_dead_letter_pending", []);
  }

  laggingJobs.sort((a, b) => Number(b.lagMinutes ?? 0) - Number(a.lagMinutes ?? 0));

  return {
    queueLagThresholdMinutes: lagThreshold,
    maxLagMinutes,
    laggingJobs: laggingJobs.slice(0, 50),
    stateCounts: stateCountsRows.results ?? [],
    segmentCounts: segmentCountsRows.results ?? [],
    deadLetter: {
      total: Number(deadLetterRow?.total ?? 0),
      pending: deadPending,
    },
  };
}

async function conversionHeatmap(env: Env, days: number): Promise<{
  fromIso: string;
  toIso: string;
  rows: Array<Record<string, unknown>>;
  totals: { leads: number; booked: number; completed: number };
}> {
  const toIso = new Date().toISOString();
  const fromIso = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();

  const rows = await env.DB.prepare(
    `SELECT
      source,
      source_intent,
      campaign_id,
      page_family,
      cta_variant,
      COUNT(*) AS leads,
      SUM(CASE WHEN booked_at IS NOT NULL THEN 1 ELSE 0 END) AS booked,
      SUM(CASE WHEN completed_at IS NOT NULL THEN 1 ELSE 0 END) AS completed
     FROM leads
     WHERE created_at >= ?1 AND created_at <= ?2
     GROUP BY source, source_intent, campaign_id, page_family, cta_variant
     ORDER BY leads DESC
     LIMIT 1000`,
  ).bind(fromIso, toIso).all<Record<string, unknown>>();

  const normalized = (rows.results ?? []).map((row) => {
    const leads = Number(row.leads ?? 0);
    const booked = Number(row.booked ?? 0);
    const completed = Number(row.completed ?? 0);
    return {
      source: String(row.source ?? "direct"),
      sourceIntent: normalizeSourceIntent(clipString(row.source_intent, 24)),
      campaignId: String(row.campaign_id ?? ""),
      pageFamily: String(row.page_family ?? "root"),
      variant: String(row.cta_variant ?? ""),
      leads,
      booked,
      completed,
      leadToBookedRate: leads > 0 ? Number((booked / leads).toFixed(4)) : 0,
      bookedToCompletedRate: booked > 0 ? Number((completed / booked).toFixed(4)) : 0,
      leadToCompletedRate: leads > 0 ? Number((completed / leads).toFixed(4)) : 0,
    };
  });

  const totals = normalized.reduce(
    (acc, row) => {
      acc.leads += Number(row.leads ?? 0);
      acc.booked += Number(row.booked ?? 0);
      acc.completed += Number(row.completed ?? 0);
      return acc;
    },
    { leads: 0, booked: 0, completed: 0 },
  );

  return { fromIso, toIso, rows: normalized, totals };
}

function redactKeyPreview(value: string | undefined): string | null {
  if (!value) return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  if (trimmed.length <= 8) return "••••";
  return `${trimmed.slice(0, 4)}••••${trimmed.slice(-4)}`;
}

async function opsLeadIntakeSecurityPosture(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const posture = resolveTurnstilePosture(env);

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    environment: clipString(env.ENVIRONMENT, 40) ?? "unknown",
    leadIntake: {
      turnstile: {
        required: posture.required,
        strictRealKey: posture.strictRealKey,
        formEnabled: posture.formEnabled,
        code: posture.code,
        message: posture.message,
        usesTestSiteKey: posture.usesTestSiteKey,
        siteKeyPreview: redactKeyPreview(posture.siteKey),
        secretConfigured: posture.secretConfigured,
      },
    },
  });
}

async function opsLeadFunnelHealth(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const sla = await computeLeadResponseSla(env);
  const url = new URL(request.url);
  const days = Math.max(1, Math.min(30, Number(url.searchParams.get("days") ?? "7")));
  const toIso = new Date().toISOString();
  const fromIso = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();
  const failing = await collectFailingStepBuckets(env, fromIso, toIso);

  const statusRows = await env.DB.prepare(
    `SELECT status AS key, COUNT(*) AS count FROM leads GROUP BY status ORDER BY count DESC`,
  ).all<{ key: string; count: number }>();

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    sla,
    totals: {
      byStatus: statusRows.results ?? [],
    },
    failingSteps: failing,
  });
}

async function opsRoutingHealth(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const health = await computeRoutingHealth(env);

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    ...health,
  });
}

async function opsConversionHeatmap(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const url = new URL(request.url);
  const days = Math.max(1, Math.min(90, Number(url.searchParams.get("days") ?? "14")));
  const heatmap = await conversionHeatmap(env, days);

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    range: {
      from: heatmap.fromIso,
      to: heatmap.toIso,
      days,
    },
    totals: {
      ...heatmap.totals,
      leadToBookedRate: heatmap.totals.leads > 0 ? Number((heatmap.totals.booked / heatmap.totals.leads).toFixed(4)) : 0,
      leadToCompletedRate: heatmap.totals.leads > 0 ? Number((heatmap.totals.completed / heatmap.totals.leads).toFixed(4)) : 0,
    },
    rows: heatmap.rows,
  });
}

async function opsFailingSteps(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const url = new URL(request.url);
  const days = Math.max(1, Math.min(30, Number(url.searchParams.get("days") ?? "7")));
  const toIso = new Date().toISOString();
  const fromIso = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();

  const buckets = await collectFailingStepBuckets(env, fromIso, toIso);
  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    range: { from: fromIso, to: toIso, days },
    buckets,
  });
}

async function attributionRevenueSummary(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const url = new URL(request.url);
  const days = Math.max(1, Math.min(90, Number(url.searchParams.get("days") ?? "14")));
  const toIso = new Date().toISOString();
  const fromIso = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();

  const rows = await env.DB.prepare(
    `SELECT
      lead_id,
      source,
      source_intent,
      campaign_id,
      page_family,
      cta_variant,
      first_touch_json,
      booked_at,
      completed_at
     FROM leads
     WHERE created_at >= ?1 AND created_at <= ?2
     ORDER BY created_at DESC
     LIMIT 8000`,
  ).bind(fromIso, toIso).all<Record<string, unknown>>();

  type Rollup = { leads: number; booked: number; completed: number; assists: number };
  const firstTouch = new Map<string, Rollup>();
  const lastTouch = new Map<string, Rollup>();
  const assists = new Map<string, Rollup>();

  const bump = (map: Map<string, Rollup>, key: string, booked: number, completed: number, assist = 0) => {
    const current = map.get(key) ?? { leads: 0, booked: 0, completed: 0, assists: 0 };
    current.leads += 1;
    current.booked += booked;
    current.completed += completed;
    current.assists += assist;
    map.set(key, current);
  };

  for (const row of rows.results ?? []) {
    const booked = row.booked_at ? 1 : 0;
    const completed = row.completed_at ? 1 : 0;

    const firstTouchJson = safeJsonParse<Record<string, string>>(String(row.first_touch_json ?? "{}"), {});
    const first = clipString(firstTouchJson.source, 120)
      ?? clipString(firstTouchJson.utm_source, 120)
      ?? String(row.source ?? "direct");
    const last = String(row.source ?? "direct");

    bump(firstTouch, first, booked, completed);
    bump(lastTouch, last, booked, completed);

    if (first !== last) {
      bump(assists, first, booked, completed, 1);
      bump(assists, last, booked, completed, 1);
    }
  }

  const toRows = (map: Map<string, Rollup>) => [...map.entries()]
    .map(([source, m]) => ({
      source,
      leads: m.leads,
      booked: m.booked,
      completed: m.completed,
      assists: m.assists,
      leadToBookedRate: m.leads > 0 ? Number((m.booked / m.leads).toFixed(4)) : 0,
      leadToCompletedRate: m.leads > 0 ? Number((m.completed / m.leads).toFixed(4)) : 0,
    }))
    .sort((a, b) => (b.completed - a.completed) || (b.booked - a.booked) || (b.leads - a.leads));

  const heatmap = await conversionHeatmap(env, days);

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    range: { from: fromIso, to: toIso, days },
    totals: {
      leads: heatmap.totals.leads,
      booked: heatmap.totals.booked,
      completed: heatmap.totals.completed,
      leadToBookedRate: heatmap.totals.leads > 0 ? Number((heatmap.totals.booked / heatmap.totals.leads).toFixed(4)) : 0,
      leadToCompletedRate: heatmap.totals.leads > 0 ? Number((heatmap.totals.completed / heatmap.totals.leads).toFixed(4)) : 0,
    },
    attribution: {
      firstTouch: toRows(firstTouch).slice(0, 50),
      lastTouch: toRows(lastTouch).slice(0, 50),
      assists: toRows(assists).slice(0, 50),
    },
    conversionByDimension: heatmap.rows,
  });
}

async function routingStatus(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const health = await computeRoutingHealth(env);

  const recentJobs = await env.DB.prepare(
    `SELECT
      job_id,
      lead_id,
      segment,
      provider_id,
      state,
      attempts,
      max_attempts,
      next_attempt_at,
      last_error_code,
      updated_at,
      sent_at,
      dead_lettered_at
    FROM lead_routing_jobs
    ORDER BY updated_at DESC
    LIMIT 40`,
  ).all<Record<string, unknown>>();

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    summary: {
      byState: health.stateCounts,
      bySegment: health.segmentCounts,
      deadLetter: health.deadLetter,
      queueLagThresholdMinutes: health.queueLagThresholdMinutes,
      maxLagMinutes: health.maxLagMinutes,
      laggingJobs: health.laggingJobs.slice(0, 20),
    },
    recentJobs: recentJobs.results ?? [],
  });
}

async function routingReplay(request: Request, env: Env): Promise<Response> {
  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const body = await request.json<any>().catch(() => ({}));
  const limit = Math.max(1, Math.min(100, Number(body?.limit ?? 10)));
  const rawIds: unknown[] = Array.isArray(body?.jobIds) ? body.jobIds : [];
  const ids = rawIds
    .map((x) => clipString(x, 80))
    .filter((x): x is string => Boolean(x));

  const dryRun = body?.dryRun !== false;
  const force = body?.force === true;
  const includeReplayed = body?.includeReplayed === true;
  const confirm = clipString(body?.confirm, 32);
  const maxAgeHours = Math.max(1, Math.min(24 * 30, Number(body?.maxAgeHours ?? 24 * 14)));
  const cutoffIso = new Date(Date.now() - maxAgeHours * 60 * 60 * 1000).toISOString();

  if (!dryRun && confirm !== "replay") {
    return apiError("REPLAY_CONFIRM_REQUIRED", "Set confirm=replay to execute replay", 400);
  }

  let rows: Array<{ job_id: string; segment: string; reason_code: string; created_at: string; replay_count: number }> = [];

  if (ids.length > 0) {
    const placeholders = ids.map((_: string, i: number) => `?${i + 1}`).join(",");
    const out = await env.DB.prepare(
      `SELECT DISTINCT job_id, segment, reason_code, created_at, replay_count
       FROM lead_handoff_dead_letter
       WHERE job_id IN (${placeholders})
         AND created_at >= ?${ids.length + 1}
       ORDER BY created_at DESC
       LIMIT ${limit}`,
    ).bind(...ids, cutoffIso).all<{ job_id: string; segment: string; reason_code: string; created_at: string; replay_count: number }>();
    rows = out.results ?? [];
  } else {
    const whereReplayed = includeReplayed ? "" : "AND replayed_at IS NULL";
    const out = await env.DB.prepare(
      `SELECT DISTINCT job_id, segment, reason_code, created_at, replay_count
       FROM lead_handoff_dead_letter
       WHERE created_at >= ?1
       ${whereReplayed}
       ORDER BY created_at DESC
       LIMIT ${limit}`,
    ).bind(cutoffIso).all<{ job_id: string; segment: string; reason_code: string; created_at: string; replay_count: number }>();
    rows = out.results ?? [];
  }

  if (!dryRun && !force && rows.length > 20) {
    return apiError("REPLAY_FORCE_REQUIRED", `Refusing to replay ${rows.length} jobs without force=true`, 400);
  }

  const preview = rows.map((row) => ({
    jobId: row.job_id,
    segment: row.segment,
    reasonCode: row.reason_code,
    createdAt: row.created_at,
    replayCount: Number(row.replay_count ?? 0),
  }));

  if (dryRun) {
    return apiJson({
      ok: true,
      dryRun: true,
      requested: preview.length,
      selected: preview,
    });
  }

  let requeued = 0;
  const failures: Array<{ jobId: string; error: string }> = [];

  for (const row of rows) {
    const segment = (clipString(row.segment, 24) ?? "smb") as LeadSegment;
    const nowIso = new Date().toISOString();

    try {
      await env.DB.prepare(
        `UPDATE lead_routing_jobs
         SET state = 'queued', attempts = 0, last_error_code = '', last_error_message = '', updated_at = ?2, dead_lettered_at = NULL
         WHERE job_id = ?1`,
      ).bind(row.job_id, nowIso).run();

      await env.DB.prepare(
        `UPDATE leads
         SET route_status = 'queued', updated_at = ?2
         WHERE lead_id = (SELECT lead_id FROM lead_routing_jobs WHERE job_id = ?1 LIMIT 1)`,
      ).bind(row.job_id, nowIso).run();

      await env.DB.prepare(
        `UPDATE lead_handoff_dead_letter
         SET replay_count = replay_count + 1, replayed_at = ?2
         WHERE job_id = ?1`,
      ).bind(row.job_id, nowIso).run();

      await enqueueRoutingJob(env, segment, {
        type: "lead_route_dispatch",
        routeJobId: row.job_id,
        replay: true,
      });

      requeued += 1;
    } catch (err: any) {
      failures.push({ jobId: row.job_id, error: String(err?.message ?? err) });
    }
  }

  return apiJson({
    ok: failures.length === 0,
    dryRun: false,
    requested: rows.length,
    requeued,
    failures,
  });
}

async function attributionSummary(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const url = new URL(request.url);
  const days = Math.max(1, Math.min(90, Number(url.searchParams.get("days") ?? "7")));
  const to = new Date();
  const from = new Date(to.getTime() - (days * 24 * 60 * 60 * 1000));
  const fromIso = from.toISOString();
  const toIso = to.toISOString();

  const rows = await env.DB.prepare(
    `SELECT
      source,
      source_intent,
      campaign_id,
      page_family,
      cta_variant,
      score_band,
      COUNT(*) AS leads,
      SUM(CASE WHEN booked_at IS NOT NULL THEN 1 ELSE 0 END) AS booked,
      SUM(CASE WHEN completed_at IS NOT NULL THEN 1 ELSE 0 END) AS completed
    FROM leads
    WHERE created_at >= ?1 AND created_at <= ?2
    GROUP BY source, source_intent, campaign_id, page_family, cta_variant, score_band
    ORDER BY leads DESC
    LIMIT 500`,
  ).bind(fromIso, toIso).all<any>();

  const normalized = (rows.results ?? []).map((row) => {
    const leads = Number(row.leads ?? 0);
    const booked = Number(row.booked ?? 0);
    const completed = Number(row.completed ?? 0);
    return {
      source: String(row.source ?? "direct"),
      sourceIntent: normalizeSourceIntent(clipString(row.source_intent, 24)),
      campaignId: String(row.campaign_id ?? ""),
      pageFamily: String(row.page_family ?? "root"),
      variant: String(row.cta_variant ?? ""),
      scoreBand: String(row.score_band ?? "low"),
      leads,
      booked,
      completed,
      bookedRate: leads > 0 ? Number((booked / leads).toFixed(4)) : 0,
      completedRate: leads > 0 ? Number((completed / leads).toFixed(4)) : 0,
    };
  });

  const totals = normalized.reduce(
    (acc, row) => {
      acc.leads += row.leads;
      acc.booked += row.booked;
      acc.completed += row.completed;
      return acc;
    },
    { leads: 0, booked: 0, completed: 0 },
  );

  return apiJson({
    ok: true,
    generatedAt: new Date().toISOString(),
    range: { from: fromIso, to: toIso, days },
    totals: {
      leads: totals.leads,
      booked: totals.booked,
      completed: totals.completed,
      bookedRate: totals.leads > 0 ? Number((totals.booked / totals.leads).toFixed(4)) : 0,
      completedRate: totals.leads > 0 ? Number((totals.completed / totals.leads).toFixed(4)) : 0,
    },
    rows: normalized,
  });
}

function wilsonLowerBound(successes: number, trials: number, z = 1.96): number {
  if (trials <= 0) return 0;
  const p = successes / trials;
  const z2 = z * z;
  const denom = 1 + z2 / trials;
  const center = p + z2 / (2 * trials);
  const margin = z * Math.sqrt((p * (1 - p) + z2 / (4 * trials)) / trials);
  return Math.max(0, (center - margin) / denom);
}

function wilsonUpperBound(successes: number, trials: number, z = 1.96): number {
  if (trials <= 0) return 0;
  const p = successes / trials;
  const z2 = z * z;
  const denom = 1 + z2 / trials;
  const center = p + z2 / (2 * trials);
  const margin = z * Math.sqrt((p * (1 - p) + z2 / (4 * trials)) / trials);
  return Math.min(1, (center + margin) / denom);
}

async function recommendExperimentWinners(request: Request, env: Env): Promise<Response> {
  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const body = await request.json<any>().catch(() => ({}));
  const days = Math.max(1, Math.min(90, Number(body?.days ?? 7)));
  const to = new Date();
  const from = new Date(to.getTime() - (days * 24 * 60 * 60 * 1000));
  const fromIso = from.toISOString();
  const toIso = to.toISOString();

  const impressionRows = await env.DB.prepare(
    `SELECT page_family, cta_variant, COUNT(*) AS impressions
     FROM funnel_events
     WHERE event_type = 'variant_assignment'
       AND event_ts >= ?1 AND event_ts <= ?2
       AND cta_variant IS NOT NULL
     GROUP BY page_family, cta_variant`,
  ).bind(fromIso, toIso).all<any>();

  const submitRows = await env.DB.prepare(
    `SELECT page_family, cta_variant, COUNT(*) AS submits
     FROM funnel_events
     WHERE event_type IN ('lead_submit', 'contact_intent_submit', 'booking_submit')
       AND event_ts >= ?1 AND event_ts <= ?2
       AND cta_variant IS NOT NULL
     GROUP BY page_family, cta_variant`,
  ).bind(fromIso, toIso).all<any>();

  const bookedRows = await env.DB.prepare(
    `SELECT page_family, cta_variant, COUNT(*) AS booked
     FROM leads
     WHERE created_at >= ?1 AND created_at <= ?2
       AND cta_variant <> ''
       AND status = 'booked'
     GROUP BY page_family, cta_variant`,
  ).bind(fromIso, toIso).all<any>();

  const map = new Map<string, { pageFamily: string; variant: string; impressions: number; submits: number; booked: number }>();
  const keyFor = (family: string, variant: string) => `${family}::${variant}`;

  for (const row of impressionRows.results ?? []) {
    const family = String(row.page_family ?? "root");
    const variant = String(row.cta_variant ?? "unknown");
    map.set(keyFor(family, variant), {
      pageFamily: family,
      variant,
      impressions: Number(row.impressions ?? 0),
      submits: 0,
      booked: 0,
    });
  }

  for (const row of submitRows.results ?? []) {
    const family = String(row.page_family ?? "root");
    const variant = String(row.cta_variant ?? "unknown");
    const key = keyFor(family, variant);
    const current = map.get(key) ?? { pageFamily: family, variant, impressions: 0, submits: 0, booked: 0 };
    current.submits = Number(row.submits ?? 0);
    map.set(key, current);
  }

  for (const row of bookedRows.results ?? []) {
    const family = String(row.page_family ?? "root");
    const variant = String(row.cta_variant ?? "unknown");
    const key = keyFor(family, variant);
    const current = map.get(key) ?? { pageFamily: family, variant, impressions: 0, submits: 0, booked: 0 };
    current.booked = Number(row.booked ?? 0);
    map.set(key, current);
  }

  const grouped = new Map<string, Array<{ pageFamily: string; variant: string; impressions: number; submits: number; booked: number }>>();
  for (const row of map.values()) {
    const existing = grouped.get(row.pageFamily) ?? [];
    existing.push(row);
    grouped.set(row.pageFamily, existing);
  }

  const minImpressions = Math.max(1, Number(env.EXPERIMENT_WINNER_MIN_IMPRESSIONS ?? "40"));
  const minBooked = Math.max(0, Number(env.EXPERIMENT_WINNER_MIN_BOOKED ?? "2"));
  const minConfidence = Math.max(0, Math.min(1, Number(env.EXPERIMENT_WINNER_MIN_CONFIDENCE ?? "0.12")));
  const holdoutPercent = Math.max(0, Math.min(30, Number(env.EXPERIMENT_HOLDOUT_PERCENT ?? String(DEFAULT_EXPERIMENT_CONFIG.holdoutPercent ?? 0))));
  const nowIso = new Date().toISOString();

  const recommendations = [...grouped.entries()].map(([pageFamily, variants]) => {
    const sorted = [...variants]
      .map((v) => {
        const submitRate = v.impressions > 0 ? Number((v.submits / v.impressions).toFixed(4)) : 0;
        const bookedRate = v.impressions > 0 ? Number((v.booked / v.impressions).toFixed(4)) : 0;
        const confidenceFloor = Number(wilsonLowerBound(v.booked, Math.max(1, v.impressions)).toFixed(4));
        const confidenceUpper = Number(wilsonUpperBound(v.booked, Math.max(1, v.impressions)).toFixed(4));
        return {
          ...v,
          submitRate,
          bookedRate,
          confidenceFloor,
          confidenceUpper,
        };
      })
      .sort((a, b) => (b.bookedRate - a.bookedRate) || (b.submitRate - a.submitRate) || (b.impressions - a.impressions));

    const winner = sorted[0] ?? null;
    const runnerUp = sorted[1] ?? null;

    const guardrailNotes: string[] = [];
    let recommendedVariant: string | null = winner?.variant ?? null;

    if (!winner) {
      guardrailNotes.push("no_variants");
      recommendedVariant = null;
    } else {
      if (winner.variant === "holdout") guardrailNotes.push("holdout_variant_not_promotable");
      if (winner.impressions < minImpressions) guardrailNotes.push("insufficient_impressions");
      if (winner.booked < minBooked) guardrailNotes.push("insufficient_bookings");
      if (winner.confidenceFloor < minConfidence) guardrailNotes.push("insufficient_confidence");
      if (runnerUp && winner.bookedRate - runnerUp.bookedRate < 0.01) guardrailNotes.push("margin_too_small");
      if (runnerUp && winner.confidenceFloor <= runnerUp.confidenceUpper) guardrailNotes.push("confidence_overlap_runner_up");
    }

    if (guardrailNotes.length > 0) {
      recommendedVariant = null;
    }

    return {
      pageFamily,
      recommendedVariant,
      winner,
      runnerUp,
      candidates: sorted,
      holdoutPercent,
      guardrailNotes,
    };
  });

  for (const rec of recommendations) {
    await env.DB.prepare(
      `INSERT INTO experiment_winner_recommendations (
        recommendation_id,
        period_from,
        period_to,
        page_family,
        recommended_variant,
        support_impressions,
        support_submits,
        support_booked,
        confidence,
        guardrail_notes,
        metadata_json,
        created_at
      ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12)`,
    )
      .bind(
        randomId("winner_rec"),
        fromIso,
        toIso,
        rec.pageFamily,
        rec.recommendedVariant,
        Number(rec.winner?.impressions ?? 0),
        Number(rec.winner?.submits ?? 0),
        Number(rec.winner?.booked ?? 0),
        Number(rec.winner?.confidenceFloor ?? 0),
        rec.guardrailNotes.join(","),
        JSON.stringify({
          winner: rec.winner,
          runnerUp: rec.runnerUp,
          candidates: rec.candidates,
          autoApply: false,
        }),
        nowIso,
      )
      .run();
  }

  const artifact = {
    generatedAt: nowIso,
    range: { from: fromIso, to: toIso, days },
    guardrails: {
      minImpressions,
      minBooked,
      minConfidence,
      holdoutPercent,
      autoApply: false,
    },
    recommendations,
  };

  const key = `reports/growth/experiment-winner-recommendation-${nowIso.slice(0, 10)}.json`;
  await env.ARTICLES.put(key, JSON.stringify(artifact, null, 2), {
    httpMetadata: { contentType: "application/json" },
  });

  return apiJson({
    ok: true,
    key,
    guardrails: {
      minImpressions,
      minBooked,
      minConfidence,
      holdoutPercent,
      autoApply: false,
    },
    recommendations,
  });
}

async function findLeadForBooking(env: Env, leadId: string | undefined, email: string | undefined): Promise<{ leadId: string; created: boolean }> {
  const nowIso = new Date().toISOString();
  const emailNorm = normalizeEmail(email);
  const salt = env.LEAD_ID_HASH_SALT?.trim() ?? "clawea-www-lead";

  if (leadId) {
    const existing = await env.DB.prepare(
      `SELECT lead_id FROM leads WHERE lead_id = ?1 LIMIT 1`,
    ).bind(leadId).first<{ lead_id: string }>();

    if (existing?.lead_id) {
      return { leadId: existing.lead_id, created: false };
    }
  }

  if (emailNorm) {
    const identityHash = await sha256Base64Url(`${salt}|${emailNorm}`);
    const existingByEmail = await env.DB.prepare(
      `SELECT lead_id FROM leads WHERE identity_hash = ?1 LIMIT 1`,
    ).bind(identityHash).first<{ lead_id: string }>();

    if (existingByEmail?.lead_id) {
      return { leadId: existingByEmail.lead_id, created: false };
    }

    const leadIdNew = randomId("lead");
    const emailHash = await sha256Base64Url(emailNorm);
    const emailParts = emailNorm.split("@");
    const emailHint = emailParts.length === 2 ? `${emailParts[0].slice(0, 2)}***@${emailParts[1]}` : "***";

    await env.DB.prepare(
      `INSERT INTO leads (
        lead_id,
        identity_hash,
        email_hash,
        email_hint,
        source,
        source_intent,
        page,
        page_family,
        readiness_score,
        roi_score,
        risk_score,
        intent_score,
        qualification_score,
        score_band,
        segment,
        status,
        route_status,
        created_at,
        updated_at,
        last_seen_at,
        lifecycle_updated_at
      ) VALUES (?1, ?2, ?3, ?4, 'book-form', 'high-intent', '/book', 'book', 50, 50, 30, 55, 60, 'medium', 'enterprise', 'new', 'booking_direct', ?5, ?5, ?5, ?5)`,
    )
      .bind(leadIdNew, identityHash, emailHash, emailHint, nowIso)
      .run();

    return { leadId: leadIdNew, created: true };
  }

  throw new Error("LEAD_NOT_FOUND");
}

async function bookSubmit(request: Request, env: Env): Promise<Response> {
  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  const body = await request.json<any>().catch(() => null);
  if (!body || typeof body !== "object") {
    return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
  }

  const leadIdIn = clipString(body?.leadId, 80);
  const email = clipString(body?.email, 200);
  const company = clipString(body?.company, 160) ?? "";
  const slotIso = clipString(body?.slotIso, 80);
  const notes = clipString(body?.notes, 1200) ?? "";

  if (!email && !leadIdIn) {
    return apiError("EMAIL_OR_LEAD_REQUIRED", "Provide leadId or work email", 400);
  }

  if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    return apiError("EMAIL_INVALID", "A valid work email is required", 400);
  }

  const turnstileToken = clipString(body?.turnstileToken, 3000);
  const turnstile = await verifyTurnstile(turnstileToken, request, env);
  if (!turnstile.ok) {
    return apiError("TURNSTILE_FAILED", turnstile.error ?? "Turnstile validation failed", 403);
  }

  const nowIso = new Date().toISOString();

  try {
    const found = await findLeadForBooking(env, leadIdIn ?? undefined, email ?? undefined);

    if (company) {
      await env.DB.prepare(
        `UPDATE leads SET company = COALESCE(NULLIF(?2,''), company), updated_at = ?3, last_seen_at = ?3 WHERE lead_id = ?1`,
      ).bind(found.leadId, company, nowIso).run();
    }

    await transitionLeadState(env, found.leadId, "validated", "book_submit");
    await transitionLeadState(env, found.leadId, "scored", "book_submit");
    await transitionLeadState(env, found.leadId, "routed", "book_submit");
    await transitionLeadState(env, found.leadId, "contacted", "book_submit");
    await transitionLeadState(env, found.leadId, "qualified", "book_submit");
    await transitionLeadState(env, found.leadId, "booked", "book_submit");

    await env.DB.prepare(
      `UPDATE leads SET booked_at = ?2, updated_at = ?2, last_seen_at = ?2 WHERE lead_id = ?1`,
    ).bind(found.leadId, nowIso).run();

    const bookingId = randomId("booking");

    await env.DB.prepare(
      `INSERT INTO booking_events (
        booking_id,
        lead_id,
        status,
        slot_iso,
        notes,
        source,
        metadata_json,
        created_at,
        updated_at
      ) VALUES (?1, ?2, 'booked', ?3, ?4, 'book-form', ?5, ?6, ?6)`,
    )
      .bind(
        bookingId,
        found.leadId,
        slotIso ?? null,
        notes,
        JSON.stringify({
          createdLead: found.created,
          company,
        }),
        nowIso,
      )
      .run();

    await env.DB.prepare(
      `INSERT INTO lead_events (
        event_id,
        lead_id,
        event_type,
        event_payload_json,
        source,
        page,
        page_family,
        created_at
      ) VALUES (?1, ?2, 'booking_booked', ?3, 'book-form', '/book', 'book', ?4)`,
    )
      .bind(
        randomId("lead_evt"),
        found.leadId,
        JSON.stringify({
          bookingId,
          slotIso,
          notes,
        }),
        nowIso,
      )
      .run();

    try {
      await storeTrackingEvent(env, {
        eventType: "booking_submit",
        page: "/book",
        pageFamily: "book",
        source: "book-form",
        ctaId: "book-submit-primary",
        ctaVariant: "submit",
        actionOutcome: "submitted",
        variantId: "book:proof:submit",
        heroVariant: "proof",
        visitorId: undefined,
        ts: nowIso,
        attribution: {},
        context: {},
      });
    } catch (telemetryErr) {
      console.error("BOOKING_SUBMIT_TELEMETRY_FAILED", telemetryErr);
    }

    return apiJson({
      ok: true,
      bookingId,
      leadId: found.leadId,
      createdLead: found.created,
      status: "booked",
    });
  } catch (err: any) {
    const code = String(err?.message ?? "BOOK_SUBMIT_FAILED");
    if (code === "LEAD_NOT_FOUND") {
      return apiError("LEAD_NOT_FOUND", "Could not resolve lead for booking", 404);
    }
    console.error("BOOK_SUBMIT_FAILED", err);
    return apiError("BOOK_SUBMIT_FAILED", "Booking submission failed", 500);
  }
}

async function bookComplete(request: Request, env: Env): Promise<Response> {
  if (request.method !== "POST") {
    return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const body = await request.json<any>().catch(() => null);
  const bookingId = clipString(body?.bookingId, 80);

  if (!bookingId) {
    return apiError("BOOKING_ID_REQUIRED", "bookingId is required", 400);
  }

  const row = await env.DB.prepare(
    `SELECT booking_id, lead_id FROM booking_events WHERE booking_id = ?1 LIMIT 1`,
  ).bind(bookingId).first<{ booking_id: string; lead_id: string }>();

  if (!row?.booking_id) {
    return apiError("BOOKING_NOT_FOUND", "Booking not found", 404);
  }

  const nowIso = new Date().toISOString();

  await env.DB.prepare(
    `UPDATE booking_events SET status = 'completed', completed_at = ?2, updated_at = ?2 WHERE booking_id = ?1`,
  ).bind(bookingId, nowIso).run();

  await env.DB.prepare(
    `UPDATE leads SET completed_at = ?2, updated_at = ?2, last_seen_at = ?2 WHERE lead_id = ?1`,
  ).bind(row.lead_id, nowIso).run();

  await env.DB.prepare(
    `INSERT INTO lead_events (
      event_id,
      lead_id,
      event_type,
      event_payload_json,
      source,
      page,
      page_family,
      created_at
    ) VALUES (?1, ?2, 'booking_completed', ?3, 'book-api', '/book', 'book', ?4)`,
  )
    .bind(
      randomId("lead_evt"),
      row.lead_id,
      JSON.stringify({ bookingId }),
      nowIso,
    )
    .run();

  try {
    await storeTrackingEvent(env, {
      eventType: "booking_complete",
      page: "/book",
      pageFamily: "book",
      source: "book-api",
      ctaId: "booking-complete",
      ctaVariant: "submit",
      actionOutcome: "completed",
      variantId: "book:proof:submit",
      heroVariant: "proof",
      visitorId: undefined,
      ts: nowIso,
      attribution: {},
      context: {},
    });
  } catch (telemetryErr) {
    console.error("BOOKING_COMPLETE_TELEMETRY_FAILED", telemetryErr);
  }

  return apiJson({
    ok: true,
    bookingId,
    leadId: row.lead_id,
    status: "completed",
  });
}

async function experimentsWinners(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const authError = checkOpsAuth(request, env);
  if (authError) return authError;

  const url = new URL(request.url);
  const date = clipString(url.searchParams.get("date"), 10);

  let key = date ? `reports/growth/variant-performance-${date}.json` : null;

  if (!key) {
    const listed = await env.ARTICLES.list({
      prefix: "reports/growth/variant-performance-",
      limit: 100,
    });

    const latest = listed.objects
      .map((o) => o.key)
      .filter((k) => k.startsWith("reports/growth/variant-performance-") && k.endsWith(".json"))
      .sort((a, b) => b.localeCompare(a, "en"))[0];

    key = latest ?? null;
  }

  if (!key) {
    return apiError("REPORT_NOT_FOUND", "No variant report found", 404);
  }

  const obj = await env.ARTICLES.get(key);
  if (!obj) {
    return apiError("REPORT_NOT_FOUND", `Variant report not found for key ${key}`, 404);
  }

  const parsed = safeJsonParse(await obj.text(), null);
  return apiJson({
    ok: true,
    key,
    report: parsed,
  });
}

function stableHash(input: string): number {
  let hash = 2166136261;
  for (let i = 0; i < input.length; i++) {
    hash ^= input.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return hash >>> 0;
}

async function loadExperimentConfig(env: Env): Promise<ExperimentVariantConfig> {
  const key = env.EXPERIMENT_CONFIG_KEY?.trim() || "experiment-config-v1";

  const fallback = {
    ...DEFAULT_EXPERIMENT_CONFIG,
    seed: env.EXPERIMENT_SEED?.trim() || DEFAULT_EXPERIMENT_CONFIG.seed,
    holdoutPercent: Math.max(0, Math.min(30, Number(env.EXPERIMENT_HOLDOUT_PERCENT ?? String(DEFAULT_EXPERIMENT_CONFIG.holdoutPercent ?? 0)))),
  } satisfies ExperimentVariantConfig;

  try {
    const raw = await env.VARIANT_CONFIG.get(key, "text");
    if (!raw) {
      return fallback;
    }

    const parsed = safeJsonParse<ExperimentVariantConfig>(raw, fallback);
    const seed = clipString(parsed?.seed, 120) ?? fallback.seed;
    const holdoutPercent = Math.max(
      0,
      Math.min(
        30,
        Number(parsed?.holdoutPercent ?? env.EXPERIMENT_HOLDOUT_PERCENT ?? fallback.holdoutPercent ?? 0),
      ),
    );

    const rawFamilies = parsed?.families && typeof parsed.families === "object"
      ? parsed.families
      : fallback.families;

    const families: Record<string, ExperimentFamilyConfig> = {};
    for (const [family, cfg] of Object.entries(rawFamilies)) {
      const hero = Array.isArray(cfg?.hero) ? cfg.hero.filter((x): x is string => typeof x === "string" && x.length > 0) : [];
      const cta = Array.isArray(cfg?.cta) ? cfg.cta.filter((x): x is string => typeof x === "string" && x.length > 0) : [];
      const holdout = Number((cfg as ExperimentFamilyConfig)?.holdoutPercent ?? holdoutPercent);
      families[family] = {
        hero: hero.length > 0 ? hero : ["proof"],
        cta: cta.length > 0 ? cta : ["sales"],
        holdoutPercent: Math.max(0, Math.min(30, holdout)),
      };
    }

    return { seed, holdoutPercent, families };
  } catch {
    return fallback;
  }
}

function assignVariant(config: ExperimentVariantConfig, visitorId: string, pageFamily: string): {
  pageFamily: string;
  heroVariant: string;
  ctaVariant: string;
} {
  const family = pageFamily || "root";
  const familyConfig = config.families[family] ?? config.families.root ?? { hero: ["proof"], cta: ["sales"], holdoutPercent: 0 };

  const heroOptions = familyConfig.hero.length > 0 ? familyConfig.hero : ["proof"];
  const ctaOptions = familyConfig.cta.length > 0 ? familyConfig.cta : ["sales"];

  const holdoutPercent = Math.max(
    0,
    Math.min(
      30,
      Number(familyConfig.holdoutPercent ?? config.holdoutPercent ?? 0),
    ),
  );

  const holdoutHash = stableHash(`${config.seed}|holdout|${family}|${visitorId}`) % 100;
  if (holdoutPercent > 0 && holdoutHash < holdoutPercent) {
    return {
      pageFamily: family,
      heroVariant: "holdout",
      ctaVariant: "holdout",
    };
  }

  const heroHash = stableHash(`${config.seed}|hero|${family}|${visitorId}`);
  const ctaHash = stableHash(`${config.seed}|cta|${family}|${visitorId}`);

  const heroVariant = heroOptions[heroHash % heroOptions.length];
  const ctaVariant = ctaOptions[ctaHash % ctaOptions.length];

  return {
    pageFamily: family,
    heroVariant,
    ctaVariant,
  };
}

function readCookie(request: Request, name: string): string | null {
  const cookies = request.headers.get("cookie") ?? "";
  const entries = cookies.split(";").map((x) => x.trim());
  for (const entry of entries) {
    const [k, ...rest] = entry.split("=");
    if (!k || rest.length === 0) continue;
    if (k === name) return decodeURIComponent(rest.join("="));
  }
  return null;
}

function getOrCreateVisitorId(request: Request): { visitorId: string; cookieNeeded: boolean } {
  const existing = clipString(readCookie(request, "clawea_vid"), 120);
  if (existing) {
    return { visitorId: existing, cookieNeeded: false };
  }

  return {
    visitorId: randomId("vid"),
    cookieNeeded: true,
  };
}

function applyExperimentCookies(response: Response, visitorId: string, assignment: {
  pageFamily: string;
  heroVariant: string;
  ctaVariant: string;
}, setVisitorCookie: boolean, setExperimentCookie: boolean): Response {
  const headers = new Headers(response.headers);
  if (setVisitorCookie) {
    headers.append(
      "set-cookie",
      `clawea_vid=${encodeURIComponent(visitorId)}; Path=/; Max-Age=31536000; SameSite=Lax; Secure`,
    );
  }

  if (setExperimentCookie) {
    headers.append(
      "set-cookie",
      `clawea_exp=${encodeURIComponent(`${assignment.pageFamily}:${assignment.heroVariant}:${assignment.ctaVariant}`)}; Path=/; Max-Age=2592000; SameSite=Lax; Secure`,
    );
  }

  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers,
  });
}

async function experimentAssignmentEndpoint(request: Request, env: Env): Promise<Response> {
  if (request.method !== "GET") {
    return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
  }

  const url = new URL(request.url);
  const visitorId = clipString(url.searchParams.get("visitorId"), 120)
    ?? getOrCreateVisitorId(request).visitorId;
  const pageFamily = clipString(url.searchParams.get("pageFamily"), 80) ?? "root";

  const config = await loadExperimentConfig(env);
  const assignment = assignVariant(config, visitorId, pageFamily);

  return apiJson({
    ok: true,
    visitorId,
    seed: config.seed,
    holdoutPercent: config.holdoutPercent ?? 0,
    assignment,
  });
}

async function leadJobsQueue(batch: MessageBatch<any>, env: Env): Promise<void> {
  for (const message of batch.messages) {
    const payload = message.body as Record<string, unknown>;
    const type = String(payload?.type ?? "");

    try {
      if (type === "lead_enrich") {
        const leadId = clipString(payload?.leadId, 80);
        if (!leadId) {
          message.ack();
          continue;
        }

        const lead = await env.DB.prepare(
          `SELECT lead_id, qualification_score FROM leads WHERE lead_id = ?1 LIMIT 1`,
        ).bind(leadId).first<{ lead_id: string; qualification_score: number }>();

        if (!lead?.lead_id) {
          message.ack();
          continue;
        }

        if (Number(lead.qualification_score ?? 0) >= 78) {
          await transitionLeadState(env, leadId, "qualified", "lead_enrich");
        }

        message.ack();
        continue;
      }

      if (type === "lead_route_dispatch") {
        const routeJobId = clipString(payload?.routeJobId, 80);
        if (!routeJobId) {
          message.ack();
          continue;
        }

        const job = await env.DB.prepare(
          `SELECT
            job_id,
            lead_id,
            segment,
            provider_id,
            state,
            attempts,
            max_attempts,
            idempotency_key,
            payload_json
          FROM lead_routing_jobs
          WHERE job_id = ?1
          LIMIT 1`,
        ).bind(routeJobId).first<any>();

        if (!job?.job_id) {
          message.ack();
          continue;
        }

        const currentState = String(job.state ?? "queued");
        if (currentState === "sent" || currentState === "dead_letter") {
          message.ack();
          continue;
        }

        if (Number(job.attempts ?? 0) >= Number(job.max_attempts ?? routingMaxAttempts(env))) {
          message.ack();
          continue;
        }

        const lead = await env.DB.prepare(
          `SELECT
            lead_id,
            company,
            role,
            team_size,
            timeline,
            primary_use_case,
            email_hint,
            source,
            source_intent,
            campaign_id,
            page_family,
            variant_id,
            hero_variant,
            cta_variant,
            qualification_score,
            intent_score,
            readiness_score,
            roi_score,
            risk_score,
            score_band,
            segment,
            status
          FROM leads
          WHERE lead_id = ?1
          LIMIT 1`,
        ).bind(String(job.lead_id)).first<any>();

        if (!lead?.lead_id) {
          message.ack();
          continue;
        }

        const attempts = Number(job.attempts ?? 0) + 1;
        const nowIso = new Date().toISOString();

        await env.DB.prepare(
          `UPDATE lead_routing_jobs
           SET state = 'processing', attempts = ?2, updated_at = ?3
           WHERE job_id = ?1`,
        ).bind(routeJobId, attempts, nowIso).run();

        const routingConfig = await loadCrmRoutingConfig(env);
        const provider = routingConfig.providers.find((p) => p.id === String(job.provider_id));

        if (!provider) {
          throw new Error("ROUTING_PROVIDER_NOT_CONFIGURED");
        }

        const jobPayload = safeJsonParse<Record<string, unknown>>(String(job.payload_json ?? "{}"), {});
        const sourceIntent = normalizeSourceIntent(clipString(lead.source_intent, 24) ?? clipString(jobPayload.sourceIntent, 24));
        const scoreReasons = Array.isArray(jobPayload.scoreReasons)
          ? (jobPayload.scoreReasons as Array<Record<string, unknown>>)
            .map((r) => ({
              code: clipString(r.code, 80) ?? "unknown",
              points: Number(r.points ?? 0),
              detail: clipString(r.detail, 240),
            }))
          : [];

        const envelope: LeadHandoffEnvelope = {
          version: "1.0",
          handoffId: String(job.job_id),
          leadId: String(lead.lead_id),
          idempotencyKey: String(job.idempotency_key),
          occurredAt: nowIso,
          segment: (clipString(lead.segment, 24) ?? "smb") as LeadSegment,
          score: {
            qualification: Number(lead.qualification_score ?? 0),
            band: (clipString(lead.score_band, 24) ?? "low") as LeadScoreBand,
            intent: Number(lead.intent_score ?? 0),
            readiness: Number(lead.readiness_score ?? 0),
            roi: Number(lead.roi_score ?? 0),
            risk: Number(lead.risk_score ?? 0),
            sourceIntent,
            reasons: scoreReasons,
          },
          attribution: {
            source: String(lead.source ?? "direct"),
            campaignId: String(lead.campaign_id ?? ""),
            pageFamily: String(lead.page_family ?? "root"),
            variantId: String(lead.variant_id ?? ""),
            heroVariant: String(lead.hero_variant ?? ""),
            ctaVariant: String(lead.cta_variant ?? ""),
          },
          lead: {
            company: String(lead.company ?? ""),
            role: String(lead.role ?? ""),
            teamSize: String(lead.team_size ?? ""),
            timeline: String(lead.timeline ?? ""),
            primaryUseCase: String(lead.primary_use_case ?? ""),
            emailHint: String(lead.email_hint ?? ""),
          },
        };

        const signingSecret = env.CRM_HANDOFF_SIGNING_SECRET?.trim()
          || env.LEAD_ID_HASH_SALT?.trim()
          || "clawea-handoff";
        const envelopeJson = JSON.stringify(envelope);
        const signature = await hmacSha256Base64Url(signingSecret, envelopeJson);

        let endpoint = provider.endpoint ?? "r2://internal-handoff";
        let status = "success";
        let httpStatus: number | null = 200;
        let responseSnippet = "ok";

        if (provider.id === "internal-r2") {
          const key = `handoffs/${nowIso.slice(0, 10)}/${routeJobId}.json`;
          await env.ARTICLES.put(key, JSON.stringify({ envelope, signature }, null, 2), {
            httpMetadata: { contentType: "application/json" },
          });
          responseSnippet = `stored:${key}`;
        } else {
          if (!provider.endpoint) {
            throw new Error("ROUTING_PROVIDER_ENDPOINT_MISSING");
          }

          endpoint = provider.endpoint;
          const authMap = crmAuthTokenMap(env);
          const headers: Record<string, string> = {
            "content-type": "application/json",
            "x-clawea-signature": `sha256=${signature}`,
            "x-clawea-idempotency-key": String(job.idempotency_key),
          };

          if (provider.authType === "bearer") {
            const token = authMap[provider.id];
            if (!token) throw new Error("CRM_PROVIDER_AUTH_MISSING");
            headers.authorization = `Bearer ${token}`;
          }

          if (provider.authType === "header") {
            const token = authMap[provider.id];
            if (!token) throw new Error("CRM_PROVIDER_AUTH_MISSING");
            headers[provider.authHeader || "x-api-key"] = token;
          }

          const res = await fetch(provider.endpoint, {
            method: "POST",
            headers,
            body: envelopeJson,
          });

          httpStatus = res.status;
          responseSnippet = (await res.text()).slice(0, 500);

          if (!res.ok) {
            throw new Error(`ROUTING_UPSTREAM_${res.status}`);
          }
        }

        await env.DB.prepare(
          `UPDATE lead_routing_jobs
           SET state = 'sent', sent_at = ?2, updated_at = ?2, last_error_code = '', last_error_message = ''
           WHERE job_id = ?1`,
        ).bind(routeJobId, nowIso).run();

        await env.DB.prepare(
          `UPDATE leads
           SET route_status = 'sent', routed_provider_id = ?2, updated_at = ?3
           WHERE lead_id = ?1`,
        ).bind(String(lead.lead_id), String(job.provider_id), nowIso).run();

        await env.DB.prepare(
          `INSERT INTO lead_handoff_deliveries (
            delivery_id,
            job_id,
            lead_id,
            provider_id,
            endpoint,
            status,
            http_status,
            response_snippet,
            signature,
            attempt,
            created_at
          ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)`,
        )
          .bind(
            randomId("handoff_delivery"),
            routeJobId,
            String(lead.lead_id),
            String(job.provider_id),
            endpoint,
            status,
            httpStatus,
            responseSnippet,
            signature,
            attempts,
            nowIso,
          )
          .run();

        await transitionLeadState(env, String(lead.lead_id), "contacted", "routing_delivery", {
          providerId: job.provider_id,
          routeJobId,
        });

        const qualificationScore = Number(lead.qualification_score ?? 0);
        await transitionLeadState(
          env,
          String(lead.lead_id),
          qualificationScore >= 72 ? "qualified" : "disqualified",
          "routing_scored_disposition",
          { qualificationScore },
        );

        await env.DB.prepare(
          `INSERT INTO lead_events (
            event_id,
            lead_id,
            event_type,
            event_payload_json,
            source,
            page,
            page_family,
            created_at
          ) VALUES (?1, ?2, 'lead_routed', ?3, ?4, ?5, ?6, ?7)`,
        )
          .bind(
            randomId("lead_evt"),
            String(lead.lead_id),
            JSON.stringify({
              routeJobId,
              providerId: job.provider_id,
              attempt: attempts,
              responseSnippet,
              sourceIntent,
              scoreBand: clipString(lead.score_band, 24) ?? "low",
            }),
            String(lead.source ?? "direct"),
            String(lead.page ?? "/contact"),
            String(lead.page_family ?? "contact"),
            nowIso,
          )
          .run();

        message.ack();
        continue;
      }

      if (type === "variant_weekly_report") {
        const nowIso = new Date().toISOString();
        const fromIso = new Date(Date.now() - (7 * 24 * 60 * 60 * 1000)).toISOString();

        const rows = await env.DB.prepare(
          `SELECT
            page_family,
            cta_variant,
            COUNT(*) AS events,
            SUM(CASE WHEN event_type = 'cta_click' THEN 1 ELSE 0 END) AS cta_clicks,
            SUM(CASE WHEN event_type IN ('contact_intent_submit', 'lead_submit', 'booking_submit') THEN 1 ELSE 0 END) AS contact_submits
          FROM funnel_events
          WHERE event_ts >= ?1 AND event_ts <= ?2
            AND cta_variant IS NOT NULL
          GROUP BY page_family, cta_variant
          ORDER BY page_family ASC, events DESC`,
        ).bind(fromIso, nowIso).all<any>();

        const bookedRows = await env.DB.prepare(
          `SELECT page_family, cta_variant, COUNT(*) AS booked
           FROM leads
           WHERE created_at >= ?1 AND created_at <= ?2
             AND cta_variant <> ''
             AND status = 'booked'
           GROUP BY page_family, cta_variant`,
        ).bind(fromIso, nowIso).all<any>();

        const byFamily = new Map<string, Array<any>>();
        for (const row of rows.results ?? []) {
          const family = String(row.page_family ?? "root");
          const variants = byFamily.get(family) ?? [];
          variants.push({
            variant: String(row.cta_variant ?? "unknown"),
            events: Number(row.events ?? 0),
            ctaClicks: Number(row.cta_clicks ?? 0),
            contactSubmits: Number(row.contact_submits ?? 0),
            booked: 0,
          });
          byFamily.set(family, variants);
        }

        const bookedMap = new Map<string, number>();
        for (const row of bookedRows.results ?? []) {
          const key = `${String(row.page_family ?? "root")}::${String(row.cta_variant ?? "unknown")}`;
          bookedMap.set(key, Number(row.booked ?? 0));
        }

        const winners = [...byFamily.entries()].map(([family, variants]) => {
          const hydrated = variants.map((v) => {
            const booked = bookedMap.get(`${family}::${v.variant}`) ?? 0;
            return {
              ...v,
              booked,
              submitRate: v.events > 0 ? Number((v.contactSubmits / v.events).toFixed(4)) : 0,
              bookedRate: v.events > 0 ? Number((booked / v.events).toFixed(4)) : 0,
            };
          });

          const sorted = [...hydrated].sort((a, b) => {
            if (b.bookedRate !== a.bookedRate) return b.bookedRate - a.bookedRate;
            if (b.submitRate !== a.submitRate) return b.submitRate - a.submitRate;
            return b.events - a.events;
          });

          const winner = sorted[0] ?? null;
          return {
            pageFamily: family,
            winner,
            candidates: sorted,
          };
        });

        const artifact = {
          generatedAt: nowIso,
          range: { from: fromIso, to: nowIso, days: 7 },
          winners,
          guardrail: {
            autoPublish: false,
            note: "winner suggestions are advisory and require explicit operator approval",
          },
        };

        const key = `reports/growth/variant-performance-${nowIso.slice(0, 10)}.json`;
        await env.ARTICLES.put(key, JSON.stringify(artifact, null, 2), {
          httpMetadata: { contentType: "application/json" },
        });

        message.ack();
        continue;
      }

      message.ack();
    } catch (err: any) {
      const routeJobId = clipString(payload?.routeJobId, 80);
      const typeLocal = String(payload?.type ?? "");
      console.error("LEAD_QUEUE_MESSAGE_FAILED", { type: typeLocal, routeJobId, err });

      if (typeLocal === "lead_route_dispatch" && routeJobId) {
        const job = await env.DB.prepare(
          `SELECT job_id, lead_id, segment, provider_id, attempts, max_attempts FROM lead_routing_jobs WHERE job_id = ?1 LIMIT 1`,
        ).bind(routeJobId).first<any>();

        if (job?.job_id) {
          const attempts = Number(job.attempts ?? 1);
          const maxAttempts = Number(job.max_attempts ?? routingMaxAttempts(env));
          const nowIso = new Date().toISOString();
          const errorCode = String(err?.message ?? "ROUTING_UNKNOWN_ERROR").slice(0, 80);
          const errorMessage = String(err?.stack ?? err?.message ?? err).slice(0, 800);

          if (attempts >= maxAttempts) {
            await env.DB.prepare(
              `UPDATE lead_routing_jobs
               SET state = 'dead_letter', last_error_code = ?2, last_error_message = ?3, updated_at = ?4, dead_lettered_at = ?4
               WHERE job_id = ?1`,
            ).bind(routeJobId, errorCode, errorMessage, nowIso).run();

            await env.DB.prepare(
              `UPDATE leads SET route_status = 'dead_letter', updated_at = ?2, last_deny_code = ?3 WHERE lead_id = ?1`,
            ).bind(String(job.lead_id), nowIso, errorCode).run();

            await env.DB.prepare(
              `INSERT INTO lead_handoff_dead_letter (
                dead_letter_id,
                job_id,
                lead_id,
                segment,
                provider_id,
                reason_code,
                reason_message,
                payload_json,
                created_at
              ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)`,
            )
              .bind(
                randomId("dead_letter"),
                routeJobId,
                String(job.lead_id),
                String(job.segment ?? "smb"),
                String(job.provider_id ?? "unknown"),
                errorCode,
                errorMessage,
                JSON.stringify(payload ?? {}),
                nowIso,
              )
              .run();

            await env.DB.prepare(
              `INSERT INTO lead_events (
                event_id,
                lead_id,
                event_type,
                event_payload_json,
                source,
                page,
                page_family,
                created_at
              ) VALUES (?1, ?2, 'lead_routing_dead_letter', ?3, 'queue', '/api/routing', 'ops', ?4)`,
            )
              .bind(
                randomId("lead_evt"),
                String(job.lead_id),
                JSON.stringify({ routeJobId, errorCode, errorMessage }),
                nowIso,
              )
              .run();

            message.ack();
            continue;
          }

          await env.DB.prepare(
            `UPDATE lead_routing_jobs
             SET state = 'failed', last_error_code = ?2, last_error_message = ?3, updated_at = ?4
             WHERE job_id = ?1`,
          ).bind(routeJobId, errorCode, errorMessage, nowIso).run();

          await env.DB.prepare(
            `UPDATE leads
             SET route_status = 'retrying', updated_at = ?2, last_deny_code = ?3
             WHERE lead_id = ?1`,
          ).bind(String(job.lead_id), nowIso, errorCode).run();

          await env.DB.prepare(
            `INSERT INTO lead_events (
              event_id,
              lead_id,
              event_type,
              event_payload_json,
              source,
              page,
              page_family,
              created_at
            ) VALUES (?1, ?2, 'lead_routing_retry', ?3, 'queue', '/api/routing', 'ops', ?4)`,
          )
            .bind(
              randomId("lead_evt"),
              String(job.lead_id),
              JSON.stringify({ routeJobId, errorCode, attempts, maxAttempts }),
              nowIso,
            )
            .run();
        }
      }

      message.retry();
    }
  }
}

async function enqueueWeeklyVariantReportIfDue(env: Env): Promise<void> {
  const now = new Date();
  const isMondayMorningUtc = now.getUTCDay() === 1 && now.getUTCHours() >= 6 && now.getUTCHours() < 8;
  if (!isMondayMorningUtc) return;

  const weekKey = `${now.getUTCFullYear()}-W${String(Math.ceil(((Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()) - Date.UTC(now.getUTCFullYear(), 0, 1)) / 86400000 + 1) / 7)).padStart(2, "0")}`;
  const lockKey = `variant-report-lock:${weekKey}`;

  const exists = await env.VARIANT_CONFIG.get(lockKey, "text");
  if (exists) return;

  await env.VARIANT_CONFIG.put(lockKey, now.toISOString(), { expirationTtl: 14 * 24 * 60 * 60 });
  await env.LEAD_JOBS.send({
    type: "variant_weekly_report",
    weekKey,
    requestedAt: now.toISOString(),
  });
}

function breadcrumbsFromSlug(slug: string): { name: string; path: string }[] {
  const parts = slug.split("/");
  const crumbs = [{ name: "Home", path: "/" }];

  const labels: Record<string, string> = {
    // v2 taxonomy
    controls: "Controls",
    policy: "Policy",
    proof: "Proof",
    verify: "Verify",
    audit: "Audit",
    channels: "Channels",
    tools: "Tools",
    workflows: "Workflows",
    events: "Events",
    mcp: "MCP",
    "supply-chain": "Supply Chain",
    compliance: "Compliance",
    guides: "Guides",
    glossary: "Glossary",
    compare: "Compare",
    vs: "Vs",
    for: "For",

    // legacy (if old slugs exist in R2)
    deploy: "Deploy",
    integrations: "Integrations",
    "use-cases": "Use Cases",
    models: "Models",
    solutions: "Solutions",
    connect: "Connect",
    enterprise: "Enterprise",
  };

  let accum = "";
  for (const part of parts) {
    accum += "/" + part;
    crumbs.push({
      name: labels[part] ?? part.split("-").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(" "),
      path: accum,
    });
  }

  return crumbs;
}

// ── Static Pages ──────────────────────────────────────────────────

function homePage(): string {
  return layout({
    meta: {
      title: "Claw EA | Enterprise AI Agents, Deployed and Verified",
      description: "Deploy managed AI agents for your enterprise. Every action cryptographically attested. Every model call receipted. Every output verifiable. Reliable, performant, scalable, flexible, secure.",
      path: "/",
    },
    body: `
    <section class="hero">
      <div class="wrap">
        <span class="badge badge-blue">Proof-First Agent Pilots</span>
        <h1>Ship Irreversible Agent Workflows With Proof</h1>
        <p class="sub">Policy-as-code controls. Cryptographic receipts. Offline verification. Start with one production deploy approval workflow and expand from evidence, not assumptions. Two-week pilot.</p>
        <div class="actions">
          <a href="/assessment" class="cta-btn cta-btn-lg" data-cta="home-assessment">Take the assessment</a>
          <a href="/trust/security-review" class="cta-btn cta-btn-outline cta-btn-lg" data-cta="home-security-review">See the Security Review Pack</a>
        </div>
        <ul class="trust-proof-list" aria-label="What your security team gets">
          <li>Every model call receipted (Ed25519)</li>
          <li>Tamper-evident audit logs (Merkle)</li>
          <li>Offline-verifiable proof bundles</li>
        </ul>
      </div>
    </section>

    <section class="section-sm" style="border-bottom:1px solid var(--border)">
      <div class="wrap stats">
        <div class="stat"><div class="num">20+</div><div class="label">Channel Integrations</div></div>
        <div class="stat"><div class="num">12+</div><div class="label">AI Models Supported</div></div>
        <div class="stat"><div class="num">100%</div><div class="label">Action Attestation</div></div>
        <div class="stat"><div class="num">&lt;200ms</div><div class="label">Receipt Overhead</div></div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Why Claw EA</span>
          <h2>Six Pillars of Enterprise AI Done Right</h2>
          <p>Built on OpenClaw, hardened for enterprise. Every design decision optimizes for these six properties.</p>
        </div>
        <div class="grid-3">
          <div class="card">
            <div class="icon">🛡️</div>
            <h3>Secure by Architecture</h3>
            <p>Hardware-isolated Cloudflare Sandboxes. Per-agent DID identities. Work Policy Contracts enforce egress, DLP, and approval gates before any agent runs.</p>
          </div>
          <div class="card">
            <div class="icon">⚡</div>
            <h3>Performant at the Edge</h3>
            <p>Cloudflare's global edge network. Smart model routing. Sleep/wake cycles that cut costs without sacrificing response time. Sub-200ms receipt overhead.</p>
          </div>
          <div class="card">
            <div class="icon">📈</div>
            <h3>Scales to Thousands</h3>
            <p>Up to 9,999 agents per tenant. Multi-tenant isolation at the infrastructure level. Budget controls per agent, team, or org. Fleet management dashboard.</p>
          </div>
          <div class="card">
            <div class="icon">🔄</div>
            <h3>No Model Lock-in</h3>
            <p>Claude, GPT, Gemini, Llama, Mistral, DeepSeek, Qwen. Any model, any provider. BYOK (Bring Your Own Key) or managed. Switch models without code changes.</p>
          </div>
          <div class="card">
            <div class="icon">✅</div>
            <h3>Reliable Operations</h3>
            <p>Auto-restart on failure. Health checks every 5 minutes. Persistent R2 state survives sleep/wake. Cron-based monitoring with configurable retry limits.</p>
          </div>
          <div class="card">
            <div class="icon">📋</div>
            <h3>Audit-Ready by Default</h3>
            <p>Cryptographic proof bundles for every run. Tamper-evident audit logs. SOC 2, HIPAA, GDPR, FedRAMP compatible. Export to any SIEM.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="section" style="background:var(--bg-alt)">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Permissioned Execution</span>
          <h2>Controls That Make Agents Safe to Run</h2>
          <p>Agents get cheap. Risk gets expensive. Claw EA is built around enforceable policy-as-code controls that prevent exfiltration and force approvals for irreversible actions.</p>
        </div>
        <div class="grid-4">
          ${[
            ["Egress Allowlist", "/controls/egress-allowlist", "Only approved domains and IPs."],
            ["DLP Redaction", "/controls/dlp-redaction", "Redact before data leaves the boundary."],
            ["Approval Gates", "/controls/approval-gates", "Step-up approvals for high-risk steps."],
            ["Two-person Rule", "/controls/two-person-rule", "Require two humans for irreversible actions."],
            ["Budgets", "/controls/budgets", "Token and cost budgets per workflow."],
            ["File Path Scopes", "/controls/file-path-scopes", "Restrict what can be read or written."],
            ["Kill Switch", "/controls/kill-switch", "Stop execution when policy is violated."],
            ["MCP Security", "/mcp/security-best-practices", "Use MCP without turning tools into exfiltration."],
          ]
            .map(([name, href, desc]) => `<a href="${href}" class="card card-link"><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Channels + Tools</span>
          <h2>Chat Control Plane Plus Enterprise Systems</h2>
          <p>Run agents where your team already works, and connect them to enterprise tools under strict policy and proof.</p>
        </div>
        <div class="grid-4">
          ${[
            ["Microsoft Teams", "/channels/microsoft-teams", "Approvals and control sessions."],
            ["Slack", "/channels/slack", "Fast control plane for teams."],
            ["Email", "/channels/email", "High-risk outbound, policy-first."],
            ["Google Chat", "/channels/google-chat", "Workspace-native control plane."],
            ["Entra ID", "/tools/entra-id", "Identity and step-up approvals."],
            ["SharePoint", "/tools/sharepoint", "Scoped document access."],
            ["GitHub", "/tools/github", "Code changes with policy and proof."],
            ["Jira", "/tools/jira", "Change control and ticket workflows."],
          ]
            .map(([name, href, desc]) => `<a href="${href}" class="card card-link"><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
        <div class="actions" style="justify-content:center;margin-top:2rem">
          <a href="/channels" class="cta-btn cta-btn-outline" data-cta="home-browse-channels">Browse all channels</a>
          <a href="/tools" class="cta-btn cta-btn-outline" data-cta="home-browse-tools">Browse all tools</a>
        </div>
      </div>
    </section>

    <section class="section" style="background:var(--bg-alt)">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Pillars</span>
          <h2>Policy, Proof, and Supply Chain</h2>
          <p>Claw EA is built for permissioned execution you can audit, not generic "AI agents".</p>
        </div>
        <div class="grid-2">
          ${[
            ["Policy-as-Code", "/policy-as-code-for-agents", "Define what agents may do before they run."],
            ["Secure Execution", "/secure-agent-execution", "Sandboxing, tool policy, and secrets boundaries."],
            ["Proof and Attestation", "/agent-proof-and-attestation", "Receipts and proof bundles you can verify."],
            ["Audit and Replay", "/agent-audit-and-replay", "Evidence retention and replay posture."],
            ["Supply Chain Security", "/agent-supply-chain-security", "Signed skills and governance for extensions."],
            ["Event-native Agents", "/event-native-agents", "Webhooks and changefeeds, paired with policy."],
          ]
            .map(([name, href, desc]) => `<a href="${href}" class="card card-link"><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="cta-banner">
          <h2>Start With a Two-Week Proof-First Pilot</h2>
          <p>Pick one irreversible workflow. We deploy controls, receipts, and proof bundles. Your security team verifies independently. You decide whether to expand.</p>
          <a href="/assessment" class="cta-btn cta-btn-lg" data-cta="home-bottom-assessment">Take the assessment</a>
          <a href="/trust/security-review" class="cta-btn cta-btn-outline cta-btn-lg" style="margin-left:.75rem" data-cta="home-bottom-security-review">Security Review Pack</a>
        </div>
      </div>
    </section>`,
    schemas: [
      serviceSchema(
        "Claw EA - Enterprise AI Agent Platform",
        "Deploy managed, verified AI agents for enterprise. Cryptographic attestation, multi-model support, 20+ channel integrations.",
        "https://www.clawea.com",
      ),
    ],
  });
}

function pricingPage(): string {
  return layout({
    meta: {
      title: "Pricing | Claw EA Enterprise AI Agents",
      description: "Transparent pricing for enterprise AI agent infrastructure. Start free, scale to thousands. Starter, Team, Business, and Enterprise tiers.",
      path: "/pricing",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Pricing", path: "/pricing" }],
    body: `
    <section class="section content-page">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Pricing</span>
          <h2>Start Small, Scale Without Limits</h2>
          <p>Every tier includes full execution attestation, proof bundles, and audit logs.</p>
        </div>
        <ul class="trust-proof-list" style="margin:-.5rem 0 1.5rem" aria-label="Compliance highlights">
          <li>SOC 2 aligned controls</li>
          <li>HIPAA and GDPR mapping</li>
          <li>SIEM export ready</li>
        </ul>
        <div class="grid-4 pricing-grid">
          <div class="price-card">
            <div class="tier">Starter</div>
            <div class="amount">$49</div>
            <div class="period">per month</div>
            <ul>
              <li>1 AI agent</li>
              <li>5 skills per agent</li>
              <li>All channels supported</li>
              <li>All models (BYOK)</li>
              <li>Execution attestation</li>
              <li>90-day audit log retention</li>
            </ul>
            <a href="/contact" class="cta-btn cta-btn-outline">Get Started</a>
          </div>
          <div class="price-card">
            <div class="tier">Team</div>
            <div class="amount">$249</div>
            <div class="period">per month</div>
            <ul>
              <li>5 AI agents</li>
              <li>15 skills per agent</li>
              <li>All channels supported</li>
              <li>Model routing + failover</li>
              <li>Work Policy Contracts</li>
              <li>1-year audit log retention</li>
              <li>Budget controls</li>
            </ul>
            <a href="/contact" class="cta-btn cta-btn-outline">Get Started</a>
          </div>
          <div class="price-card featured">
            <div class="tier" style="color:var(--accent)">Business</div>
            <div class="amount">$999</div>
            <div class="period">per month</div>
            <ul>
              <li>25 AI agents</li>
              <li>50 skills per agent</li>
              <li>Fleet management dashboard</li>
              <li>Multi-agent orchestration</li>
              <li>Custom agent templates</li>
              <li>3-year audit log retention</li>
              <li>SIEM integration</li>
              <li>Priority support</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card">
            <div class="tier">Enterprise</div>
            <div class="amount">Custom</div>
            <div class="period">Contact sales</div>
            <ul>
              <li><strong>Everything in Business, plus:</strong></li>
              <li>Unlimited agents</li>
              <li>Unlimited skills</li>
              <li>Custom container limits</li>
              <li>Custom compliance mapping</li>
              <li>Dedicated support engineer</li>
              <li>7-year audit log retention</li>
              <li>BAA / DPA available</li>
              <li>On-prem option</li>
            </ul>
            <a href="/contact" class="cta-btn cta-btn-outline">Talk to Sales</a>
          </div>
        </div>
      </div>
    </section>`,
    schemas: [
      productSchema("Claw EA", "Enterprise AI Agent Platform", "https://www.clawea.com/pricing", [
        { price: "49", priceCurrency: "USD" },
        { price: "249", priceCurrency: "USD" },
        { price: "999", priceCurrency: "USD" },
      ]),
    ],
  });
}

type AssessmentResult = {
  readinessScore: number;
  roiScore: number;
  riskScore: number;
  confidenceLabel: string;
  recommendedTrack: "guided-pilot" | "self-serve-pilot" | "architecture-review";
  timeline?: string;
  previewMode: boolean;
};

function parseAssessmentResult(url: URL): AssessmentResult {
  const hasExplicitScores = ["readiness", "roi", "risk"].some((k) => url.searchParams.has(k));

  let readinessScore = Math.min(100, Math.max(0, Number(url.searchParams.get("readiness") ?? "0") || 0));
  let roiScore = Math.min(100, Math.max(0, Number(url.searchParams.get("roi") ?? "0") || 0));
  let riskScore = Math.min(100, Math.max(0, Number(url.searchParams.get("risk") ?? "0") || 0));

  const previewMode = !hasExplicitScores || (readinessScore === 0 && roiScore === 0 && riskScore === 0);
  if (previewMode) {
    readinessScore = 67;
    roiScore = 63;
    riskScore = 38;
  }

  const blended = Math.round((readinessScore * 0.4) + (roiScore * 0.35) + ((100 - riskScore) * 0.25));
  const confidenceLabel = blended >= 78 ? "high-intent" : blended >= 55 ? "medium-intent" : "early-intent";

  const recommendedTrack: AssessmentResult["recommendedTrack"] = blended >= 78
    ? "guided-pilot"
    : blended >= 55
      ? "architecture-review"
      : "self-serve-pilot";

  return {
    readinessScore,
    roiScore,
    riskScore,
    confidenceLabel,
    recommendedTrack,
    timeline: clipString(url.searchParams.get("timeline"), 80) ?? "",
    previewMode,
  };
}

function formGuardAttrs(posture: TurnstilePosture): string {
  if (posture.formEnabled) return "";
  return ` data-form-blocked="1" data-form-block-message="${esc(posture.message)}" data-form-block-code="${esc(posture.code)}"`;
}

function submitGuardAttrs(posture: TurnstilePosture): string {
  if (posture.formEnabled) return "";
  return " disabled aria-disabled=\"true\"";
}

function renderTurnstileBlock(posture: TurnstilePosture, opts?: { widgetEnabled?: boolean }): string {
  const widgetEnabled = opts?.widgetEnabled ?? true;
  const widget = widgetEnabled && shouldRenderTurnstileWidget(posture) && posture.siteKey
    ? `<div class="cf-turnstile" data-sitekey="${esc(posture.siteKey)}"></div>`
    : "";

  const statusClass = posture.formEnabled
    ? "form-security-note"
    : "form-security-note form-security-note-critical";

  const statusText = posture.formEnabled
    ? posture.required
      ? "Bot protection enabled via Cloudflare Turnstile."
      : "Bot protection optional in this environment."
    : posture.message;

  return `${widget}<p class="${statusClass}" data-form-security-note>${esc(statusText)}</p>`;
}

function renderLeadIntakeTrustRail(posture: TurnstilePosture): string {
  const postureLine = posture.formEnabled
    ? "Turnstile challenge required before lead or booking submission."
    : posture.message;

  return `<aside class="trust-rail" aria-label="Lead intake safeguards">
    <span class="badge ${posture.formEnabled ? "badge-green" : "badge-purple"}">${posture.formEnabled ? "Protection active" : "Protection paused"}</span>
    <h3>Submission safeguards</h3>
    <ul>
      <li>${esc(postureLine)}</li>
      <li>Duplicate suppression enforced by Durable Object lead locks.</li>
      <li>Lead and booking transitions are captured in immutable audit rows.</li>
    </ul>
  </aside>`;
}

function assessmentPage(turnstile: TurnstilePosture): string {
  return layout({
    meta: {
      title: "AI Readiness Assessment | Claw EA",
      description: "Score your enterprise readiness, expected ROI, and operational risk in 2 minutes.",
      path: "/assessment",
      canonicalPath: "/assessment",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Assessment", path: "/assessment" }],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:760px">
        <span class="badge badge-purple">Demand capture</span>
        <h1 data-hero-copy>Enterprise Agent Readiness Assessment</h1>
        <p class="lead">Answer five short questions. We return a readiness score, ROI estimate, and risk posture with a clear next step.</p>

        <form class="card lead-form" data-assessment-form style="margin-top:1.5rem">
          <div class="form-grid-2">
            <label class="form-field">
              <span>Team size *</span>
              <select name="teamSize" required>
                <option value="">Select…</option>
                <option value="1-20">1-20</option>
                <option value="21-100">21-100</option>
                <option value="101-500">101-500</option>
                <option value="500+">500+</option>
              </select>
            </label>

            <label class="form-field">
              <span>Current stage *</span>
              <select name="maturity" required>
                <option value="">Select…</option>
                <option value="exploration">Exploration</option>
                <option value="pilot">Pilot running</option>
                <option value="production">Production with guardrails</option>
              </select>
            </label>

            <label class="form-field">
              <span>Primary objective *</span>
              <select name="objective" required>
                <option value="">Select…</option>
                <option value="cost">Reduce manual process cost</option>
                <option value="speed">Faster approvals and delivery</option>
                <option value="compliance">Audit and compliance confidence</option>
              </select>
            </label>

            <label class="form-field">
              <span>Risk tolerance *</span>
              <select name="riskTolerance" required>
                <option value="">Select…</option>
                <option value="low">Low (strict approvals)</option>
                <option value="moderate">Moderate</option>
                <option value="high">High (speed first)</option>
              </select>
            </label>

            <label class="form-field form-field-wide">
              <span>Timeline to launch *</span>
              <select name="timeline" required>
                <option value="">Select…</option>
                <option value="2-weeks">Within 2 weeks</option>
                <option value="30-days">Within 30 days</option>
                <option value="quarter">This quarter</option>
                <option value="later">Later planning</option>
              </select>
            </label>
          </div>

          <div class="form-actions" style="margin-top:1.25rem">
            <button type="submit" class="cta-btn cta-btn-lg" data-cta="assessment-calculate" data-cta-copy>Calculate my score</button>
            <a href="/contact" style="font-size:.9rem;color:var(--text);text-decoration:underline" data-cta="assessment-contact">Need a custom plan? Talk to sales.</a>
          </div>

          <p class="form-note">No signup required for scoring. You can submit your details on the result page if you want a tailored plan.</p>
        </form>

        <div style="margin-top:1.25rem">${renderLeadIntakeTrustRail(turnstile)}</div>
      </div>
    </section>
    <script>
    (function(){
      var form=document.querySelector('[data-assessment-form]');
      if(!form)return;

      function pick(value,map,fallback){return (map&&map[value])||fallback;}

      form.addEventListener('submit',function(e){
        e.preventDefault();

        var fd=new FormData(form);
        var team=String(fd.get('teamSize')||'');
        var maturity=String(fd.get('maturity')||'');
        var objective=String(fd.get('objective')||'');
        var riskTolerance=String(fd.get('riskTolerance')||'');
        var timeline=String(fd.get('timeline')||'');

        var readiness=Math.round(
          pick(team,{'1-20':40,'21-100':55,'101-500':70,'500+':78},42)
          + pick(maturity,{'exploration':8,'pilot':18,'production':25},10)
          + pick(timeline,{'2-weeks':15,'30-days':10,'quarter':6,'later':3},5)
        );

        var roi=Math.round(
          pick(objective,{'cost':72,'speed':68,'compliance':64},60)
          + pick(team,{'1-20':5,'21-100':8,'101-500':12,'500+':15},6)
        );

        var risk=Math.round(
          pick(riskTolerance,{'low':30,'moderate':48,'high':66},48)
          - pick(maturity,{'exploration':0,'pilot':5,'production':10},0)
        );

        readiness=Math.max(0,Math.min(100,readiness));
        roi=Math.max(0,Math.min(100,roi));
        risk=Math.max(0,Math.min(100,risk));

        var out='/assessment/result?readiness='+encodeURIComponent(String(readiness))
          +'&roi='+encodeURIComponent(String(roi))
          +'&risk='+encodeURIComponent(String(risk))
          +'&team='+encodeURIComponent(team)
          +'&objective='+encodeURIComponent(objective)
          +'&timeline='+encodeURIComponent(timeline);

        if(window.__claweaTrack){
          window.__claweaTrack('cta_click',{
            ctaId:'assessment-calculate',
            ctaVariant:'calculator',
            actionOutcome:'calculated',
            targetPath:'/assessment/result'
          });
        }

        window.location.href=out;
      });
    })();
    </script>`,
    schemas: [
      faqSchema([
        { q: "How long does this take?", a: "Around two minutes. You only answer five questions." },
        { q: "Do I need to sign up?", a: "No. You can calculate your score without entering contact details." },
        { q: "Can I share this with my team?", a: "Yes. Copy the result URL and share it internally." },
      ]),
    ],
  });
}

function assessmentResultPage(result: AssessmentResult, turnstile: TurnstilePosture, opts?: { widgetEnabled?: boolean }): string {
  const trackLabel = result.recommendedTrack === "guided-pilot"
    ? "Guided pilot"
    : result.recommendedTrack === "architecture-review"
      ? "Architecture review"
      : "Self-serve pilot";

  const readinessClass = result.readinessScore >= 70 ? "score-good" : result.readinessScore >= 50 ? "score-warn" : "score-bad";
  const roiClass = result.roiScore >= 70 ? "score-good" : result.roiScore >= 50 ? "score-warn" : "score-bad";
  const riskClass = result.riskScore <= 40 ? "score-good" : result.riskScore <= 65 ? "score-warn" : "score-bad";

  return layout({
    meta: {
      title: `Assessment Result (${result.confidenceLabel}) | Claw EA`,
      description: "Review your readiness, ROI, and risk score. Get the fastest next step for enterprise agent rollout.",
      path: "/assessment/result",
      canonicalPath: "/assessment/result",
      noindex: true,
    },
    breadcrumbs: [
      { name: "Home", path: "/" },
      { name: "Assessment", path: "/assessment" },
      { name: "Result", path: "/assessment/result" },
    ],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:820px">
        <span class="badge badge-green">Assessment result</span>
        <h1>Your recommended track: ${esc(trackLabel)}</h1>
        <p class="lead">We scored your current operating posture across readiness, ROI potential, and risk control fit.</p>

        <div class="score-grid">
          <article class="score-card">
            <h3>Readiness</h3>
            <div class="score-value ${readinessClass}">${result.readinessScore}</div>
            <p>How prepared your team is to launch a controlled pilot quickly.</p>
          </article>
          <article class="score-card">
            <h3>ROI signal</h3>
            <div class="score-value ${roiClass}">${result.roiScore}</div>
            <p>Estimated value potential from throughput and approval cycle improvements.</p>
          </article>
          <article class="score-card">
            <h3>Risk posture</h3>
            <div class="score-value ${riskClass}">${result.riskScore}</div>
            <p>Lower is safer. Higher scores indicate higher risk exposure without strict execution controls.</p>
          </article>
        </div>

        <div class="proof-summary-block" style="margin-top:1.5rem">
          <h3>Proof-first rollout checklist</h3>
          <ul>
            <li>Start with one irreversible workflow and enforce approval gates.</li>
            <li>Require receipts and proof bundles for every model call and side effect.</li>
            <li>Track lead-to-launch metrics weekly and keep an explicit rollback path.</li>
          </ul>
        </div>

        <div class="card" style="margin-top:1.5rem;border-left:3px solid var(--accent)">
          <h3 style="margin-bottom:.5rem">Recommended controls for your profile</h3>
          <p style="font-size:.9rem;color:var(--text-secondary);margin-bottom:.75rem">Based on your assessment scores, these are the controls that matter most for your rollout.</p>
          <div class="grid-2">
            ${result.riskScore >= 50 ? `
            <a href="/controls/approval-gates" class="card card-link" data-cta="result-control-approval-gates"><h4>Approval Gates</h4><p>Step-up human approvals for irreversible actions.</p></a>
            <a href="/controls/two-person-rule" class="card card-link" data-cta="result-control-two-person"><h4>Two-Person Rule</h4><p>Require two humans for high-risk steps.</p></a>
            ` : ""}
            <a href="/controls/egress-allowlist" class="card card-link" data-cta="result-control-egress"><h4>Egress Allowlist</h4><p>Lock down what agents can reach.</p></a>
            <a href="/controls/dlp-redaction" class="card card-link" data-cta="result-control-dlp"><h4>DLP Redaction</h4><p>Strip sensitive data before it leaves the boundary.</p></a>
            ${result.readinessScore < 60 ? `
            <a href="/controls/budgets" class="card card-link" data-cta="result-control-budgets"><h4>Budget Controls</h4><p>Set token and cost limits per workflow.</p></a>
            ` : ""}
            <a href="/controls/kill-switch" class="card card-link" data-cta="result-control-kill-switch"><h4>Kill Switch</h4><p>Stop execution instantly when policy is violated.</p></a>
          </div>
          <p style="margin-top:.75rem;font-size:.9rem"><a href="/trust/security-review" data-cta="result-security-review-pack">See the full Security Review Pack &rarr;</a></p>
        </div>

        <form class="card lead-form" data-lead-form data-cta="assessment-result-form" style="margin-top:2rem"${formGuardAttrs(turnstile)}>
          <h3 style="margin-bottom:.5rem">Get your tailored rollout plan</h3>
          <p class="form-note" style="margin-bottom:1rem">This takes less than 45 seconds.</p>

          <div class="form-grid-2">
            <label class="form-field">
              <span>Work email *</span>
              <input type="email" name="email" required placeholder="you@company.com" autocomplete="email">
            </label>
            <label class="form-field">
              <span>Company *</span>
              <input type="text" name="company" required placeholder="Company name" autocomplete="organization">
            </label>
            <label class="form-field">
              <span>Your role</span>
              <input type="text" name="role" placeholder="Security lead, platform lead, CTO..." autocomplete="organization-title">
            </label>
          </div>

          <input type="hidden" name="primaryUseCase" value="assessment-result-followup">
          <input type="hidden" name="assessment.readinessScore" value="${result.readinessScore}">
          <input type="hidden" name="assessment.roiScore" value="${result.roiScore}">
          <input type="hidden" name="assessment.riskScore" value="${result.riskScore}">
          <input type="hidden" name="assessment.confidenceLabel" value="${esc(result.confidenceLabel)}">
          <input type="hidden" name="timeline" value="${esc(result.timeline ?? "")}">

          ${renderTurnstileBlock(turnstile, { widgetEnabled: opts?.widgetEnabled })}

          <div class="form-actions">
            <button type="submit" class="cta-btn" data-cta="assessment-result-submit"${submitGuardAttrs(turnstile)}>Email me the tailored plan</button>
            <span class="form-status" data-lead-form-status aria-live="polite"></span>
          </div>
        </form>

        <div class="cta-banner" style="margin-top:1.5rem">
          <h2>Want to skip forms and talk now?</h2>
          <p>Book a rollout session directly or review trust controls before you proceed.</p>
          <a href="/book?from=assessment-result&confidence=${encodeURIComponent(result.confidenceLabel)}" class="cta-btn cta-btn-lg" data-cta="assessment-result-book">Book rollout session</a>
          <a href="/contact?from=assessment-result&confidence=${encodeURIComponent(result.confidenceLabel)}" class="cta-btn cta-btn-outline cta-btn-lg" style="margin-left:.75rem" data-cta="assessment-result-contact" data-cta-copy>Talk to Sales</a>
          <p style="margin-top:.9rem;font-size:.9rem"><a href="/trust/security-review" style="color:var(--text);text-decoration:underline" data-cta="assessment-result-security-review">Review the Security Review Pack first</a></p>
        </div>

        <div style="margin-top:1.25rem">${renderLeadIntakeTrustRail(turnstile)}</div>
      </div>
    </section>`,
    schemas: [
      serviceSchema(
        "Claw EA Readiness Assessment",
        "Assessment route for enterprise AI agent rollout readiness and risk-to-proof conversion planning.",
        "https://www.clawea.com/assessment",
      ),
    ],
  });
}

function contactPage(turnstile: TurnstilePosture, opts?: { widgetEnabled?: boolean }): string {
  return layout({
    meta: {
      title: "Contact Sales | Claw EA Enterprise AI Agents",
      description: "Talk to our enterprise sales team about deploying verified AI agents for your organization.",
      path: "/contact",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Contact", path: "/contact" }],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:760px">
        <h1>Talk to Sales</h1>
        <p class="lead">Short path: share your contact details and use case. We reply with a scoped recommendation and next steps.</p>

        <form class="card lead-form" data-lead-form data-cta="contact-lead-form"${formGuardAttrs(turnstile)}>
          <div class="form-grid-2">
            <label class="form-field">
              <span>Work email *</span>
              <input type="email" name="email" required placeholder="you@company.com" autocomplete="email">
            </label>
            <label class="form-field">
              <span>Company *</span>
              <input type="text" name="company" required placeholder="Company name" autocomplete="organization">
            </label>
            <label class="form-field">
              <span>Full name *</span>
              <input type="text" name="fullName" required placeholder="Your name" autocomplete="name">
            </label>
            <label class="form-field">
              <span>Role (optional)</span>
              <input type="text" name="role" placeholder="Security lead, platform lead, CTO..." autocomplete="organization-title">
            </label>
            <label class="form-field form-field-wide">
              <span>Primary use case (optional)</span>
              <textarea name="primaryUseCase" rows="3" placeholder="Example: production deploy approvals, SIEM evidence collection, identity lifecycle approvals"></textarea>
            </label>
          </div>

          ${renderTurnstileBlock(turnstile, { widgetEnabled: opts?.widgetEnabled })}

          <p class="form-note" style="margin:.75rem 0 0">By submitting, you agree to follow-up from Claw EA and our <a href="/policy" aria-label="Read privacy policy">privacy policy</a>.</p>

          <div class="form-actions">
            <button type="submit" class="cta-btn cta-btn-lg" data-cta="contact-fast-submit" data-cta-copy${submitGuardAttrs(turnstile)}>Request tailored plan</button>
            <a href="/assessment" class="cta-btn cta-btn-outline cta-btn-lg" data-cta="contact-assessment">Run readiness assessment</a>
            <span class="form-status" data-lead-form-status aria-live="polite"></span>
          </div>

          <p class="form-note">Prefer email? Write to <a href="mailto:enterprise@clawbureau.com">enterprise@clawbureau.com</a>. Include company, role, and target use case.</p>
        </form>

        <div style="margin-top:1.25rem">${renderLeadIntakeTrustRail(turnstile)}</div>
      </div>
    </section>`,
    schemas: [
      faqSchema([
        { q: "How fast do you reply?", a: "Typically within four business hours." },
        { q: "Do you support pilots before contract?", a: "Yes. We can run a guided pilot with strict scope and measurable success criteria." },
        { q: "Can we bring our own model keys?", a: "Yes. BYOK is supported, and we keep proof and policy controls in place." },
      ]),
    ],
  });
}

function bookPage(requestUrl: URL, turnstile: TurnstilePosture, opts?: { widgetEnabled?: boolean }): string {
  const leadId = clipString(requestUrl.searchParams.get("lead"), 80) ?? "";
  const email = clipString(requestUrl.searchParams.get("email"), 220) ?? "";
  const company = clipString(requestUrl.searchParams.get("company"), 160) ?? "";

  return layout({
    meta: {
      title: "Book a Rollout Session | Claw EA",
      description: "Book a deployment planning session for your enterprise AI agent rollout.",
      path: "/book",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Book", path: "/book" }],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:760px">
        <span class="badge badge-blue">Deployment planning</span>
        <h1>Book your deployment planning session</h1>
        <p class="lead">Share minimal details and reserve a rollout session. We prefill context from your assessment/contact path when available.</p>

        <form class="card lead-form" data-book-form data-cta="book-submit-form"${formGuardAttrs(turnstile)}>
          <input type="hidden" name="leadId" value="${esc(leadId)}">

          <div class="form-grid-2">
            <label class="form-field">
              <span>Work email</span>
              <input type="email" name="email" value="${esc(email)}" placeholder="you@company.com" autocomplete="email">
            </label>
            <label class="form-field">
              <span>Company</span>
              <input type="text" name="company" value="${esc(company)}" placeholder="Company name" autocomplete="organization">
            </label>
            <label class="form-field">
              <span>Preferred date</span>
              <input type="date" name="slotDate">
            </label>
            <label class="form-field">
              <span>Preferred time</span>
              <input type="time" name="slotTime" step="900">
            </label>
            <label class="form-field form-field-wide">
              <span>Timezone</span>
              <select name="timezone">
                <option value="">Auto-detect / Not sure</option>
                <option value="UTC">UTC</option>
                <option value="Europe/Berlin">Europe/Berlin</option>
                <option value="Europe/London">Europe/London</option>
                <option value="America/New_York">America/New_York</option>
                <option value="America/Chicago">America/Chicago</option>
                <option value="America/Los_Angeles">America/Los_Angeles</option>
                <option value="Asia/Singapore">Asia/Singapore</option>
                <option value="Asia/Tokyo">Asia/Tokyo</option>
              </select>
            </label>
            <label class="form-field form-field-wide">
              <span>Context for the session</span>
              <textarea name="notes" rows="4" placeholder="Scope, teams involved, compliance constraints, deadlines"></textarea>
            </label>
          </div>

          ${renderTurnstileBlock(turnstile, { widgetEnabled: opts?.widgetEnabled })}

          <div class="form-actions">
            <button type="submit" class="cta-btn cta-btn-lg" data-cta="book-submit-primary"${submitGuardAttrs(turnstile)}>Confirm booking request</button>
            <a href="/assessment" class="cta-btn cta-btn-outline cta-btn-lg" data-cta="book-assessment">Run assessment first</a>
            <span class="form-status" data-book-form-status aria-live="polite"></span>
          </div>

          <p class="form-note">Ops will confirm by email with exact session time and preparation checklist.</p>
        </form>

        <div style="margin-top:1.25rem">${renderLeadIntakeTrustRail(turnstile)}</div>
      </div>
    </section>`,
    schemas: [
      serviceSchema(
        "Claw EA Rollout Planning Session",
        "Book an enterprise rollout planning and qualification session for verified AI agents.",
        "https://www.clawea.com/book",
      ),
    ],
  });
}

function sourcesHubPage(manifest: Record<string, ManifestEntry>): string {
  const rows = Object.entries(manifest)
    .map(([slug, meta]) => ({ slug, meta }))
    .filter((row) => row.meta.indexable !== false)
    .slice(0, 80);

  const familyCounts = new Map<string, number>();
  for (const row of rows) {
    const family = row.slug.split("/")[0] || "root";
    familyCounts.set(family, (familyCounts.get(family) ?? 0) + 1);
  }

  const familySummary = [...familyCounts.entries()]
    .sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0], "en"))
    .map(([family, count]) => `<li><a href="/${family}" class="pill-link">${esc(family)} · ${count} pages</a></li>`)
    .join("");

  const defaultFamilySummary = [
    ["tools", "Connector security and operations guides"],
    ["workflows", "Approval and evidence playbooks"],
    ["controls", "Policy controls and guardrails"],
    ["channels", "Team-facing control plane entries"],
  ]
    .map(([slug, label]) => `<li><a href="/${slug}" class="pill-link">${esc(slug)} · ${esc(label)}</a></li>`)
    .join("");

  const topIndexable = rows
    .slice(0, 24)
    .map((row) => `<li><a href="/${row.slug}">${esc(row.meta.title.replace(/ \| Claw EA$/, ""))}</a></li>`)
    .join("");

  const defaultTopIndexable = [
    ["/trust", "Trust Layer"],
    ["/agent-proof-and-attestation", "Proof and Attestation"],
    ["/secure-agent-execution", "Secure Agent Execution"],
    ["/policy-as-code-for-agents", "Policy as Code for Agents"],
    ["/controls", "Controls Hub"],
    ["/workflows", "Workflow Playbooks"],
    ["/tools", "Tools Hub"],
    ["/channels", "Channels Hub"],
  ]
    .map(([path, label]) => `<li><a href="${path}">${label}</a></li>`)
    .join("");

  return layout({
    meta: {
      title: "Citation Source Hub | Claw EA",
      description: "Source-first routing hub for citation-ready Claw EA pages and proof-linked implementation guides.",
      path: "/sources",
      canonicalPath: "/sources",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Sources", path: "/sources" }],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:900px">
        <span class="badge badge-blue">Citation hub</span>
        <h1>Source hub for AI discovery and enterprise buyers</h1>
        <p class="lead">Use this page to route to citation-ready articles, workflow runbooks, and proof-first pages with explicit references.</p>

        <div class="proof-summary-block">
          <h3>How to cite Claw EA pages</h3>
          <ul>
            <li>Prefer direct article URLs under <code>/tools</code>, <code>/workflows</code>, and <code>/controls</code>.</li>
            <li>Use pages that include explicit Sources sections and proof summaries.</li>
            <li>For platform trust claims, cite <a href="/trust">/trust</a> and <a href="/agent-proof-and-attestation">/agent-proof-and-attestation</a>.</li>
          </ul>
        </div>

        <div class="grid-2" style="margin-top:1.5rem">
          <article class="card sources-family-card">
            <h3>Core resource categories</h3>
            <ul>${familySummary || defaultFamilySummary}</ul>
          </article>
          <article class="card sources-next-card">
            <h3>Next steps</h3>
            <div class="actions" style="justify-content:flex-start;gap:.5rem;margin-top:.25rem">
              <a href="/assessment" class="cta-btn cta-btn-outline">Run assessment</a>
              <a href="/contact" class="cta-btn cta-btn-outline">Submit project brief</a>
              <a href="/book" class="cta-btn cta-btn-outline">Book rollout session</a>
            </div>
            <ul style="margin-top:.85rem">
              <li><a href="/trust">Review trust controls</a></li>
              <li><a href="/pricing">Review pricing and rollout tiers</a></li>
            </ul>
          </article>
        </div>

        <article class="card" style="margin-top:1.5rem">
          <h3>Frequently cited pages</h3>
          <ul class="sources-hub-list">${topIndexable || defaultTopIndexable}</ul>
        </article>
      </div>
    </section>`,
  });
}

function notFoundPage(): string {
  return layout({
    meta: { title: "Page Not Found | Claw EA", description: "The page you're looking for doesn't exist.", path: "/404", noindex: true },
    body: `
    <section class="section content-page" style="text-align:center">
      <div class="wrap">
        <h1>404 - Page Not Found</h1>
        <p class="lead">The page you're looking for doesn't exist or has been moved.</p>
        <div class="actions" style="margin-top:2rem;justify-content:center">
          <a href="/" class="cta-btn cta-btn-lg">Back to Home</a>
          <a href="/assessment" class="cta-btn cta-btn-outline cta-btn-lg">Run assessment</a>
          <a href="/book" class="cta-btn cta-btn-outline cta-btn-lg">Book session</a>
          <a href="/contact" class="cta-btn cta-btn-outline cta-btn-lg">Talk to sales</a>
        </div>
      </div>
    </section>`,
  });
}

// ── Article Page Renderer ─────────────────────────────────────────

function formatDateYmd(iso: string): string {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return iso;
  return d.toISOString().slice(0, 10);
}

function estimateReadMinutes(rawHtml: string, wordsPerMinute = 220): number {
  const words = rawHtml
    .replace(/<[^>]+>/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .split(" ")
    .filter(Boolean).length;

  if (words <= 0) return 1;
  return Math.max(1, Math.round(words / wordsPerMinute));
}

function toTitle(s: string): string {
  return s
    .split("-")
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(" ");
}

function uniqueLinks(items: Array<{ name: string; path: string }>): Array<{ name: string; path: string }> {
  const out: Array<{ name: string; path: string }> = [];
  const seen = new Set<string>();
  for (const i of items) {
    if (!i?.path || seen.has(i.path)) continue;
    seen.add(i.path);
    out.push(i);
  }
  return out;
}

function relatedLinksForArticle(article: Article): Array<{ name: string; path: string }> {
  const slugParts = article.slug.split("/").filter(Boolean);
  const family = slugParts[0] ?? "";

  const links: Array<{ name: string; path: string }> = [
    { name: "Run assessment", path: "/assessment" },
    { name: "Talk to sales", path: "/contact" },
    { name: "Policy-as-Code", path: "/policy-as-code-for-agents" },
    { name: "Secure Execution", path: "/secure-agent-execution" },
    { name: "Proof and Attestation", path: "/agent-proof-and-attestation" },
  ];

  if (family) {
    links.push({ name: `${toTitle(family)} hub`, path: `/${family}` });
  }

  // Family-specific helpers
  if (family === "workflows") {
    const toolSlug = slugParts[2];
    const channelSlug = slugParts[3];
    if (toolSlug) links.push({ name: `${toTitle(toolSlug)} tool page`, path: `/tools/${toolSlug}` });
    if (channelSlug) links.push({ name: `${toTitle(channelSlug)} channel page`, path: `/channels/${channelSlug}` });

    links.push({ name: "Approval gates", path: "/controls/approval-gates" });
    links.push({ name: "Two-person rule", path: "/controls/two-person-rule" });
    links.push({ name: "Budgets", path: "/controls/budgets" });
  }

  if (family === "tools") {
    const toolSlug = slugParts[1];
    if (toolSlug) links.push({ name: `${toTitle(toolSlug)} overview`, path: `/tools/${toolSlug}` });

    links.push({ name: "Egress allowlist", path: "/controls/egress-allowlist" });
    links.push({ name: "DLP and redaction", path: "/controls/dlp-redaction" });
    links.push({ name: "Secrets boundary", path: "/controls/secret-boundary" });
  }

  if (family === "channels") {
    const channelSlug = slugParts[1];
    if (channelSlug) links.push({ name: `${toTitle(channelSlug)} overview`, path: `/channels/${channelSlug}` });

    links.push({ name: "Tool allow/deny", path: "/controls/tool-allow-deny" });
    links.push({ name: "Approval gates", path: "/controls/approval-gates" });
    links.push({ name: "Kill switch", path: "/controls/kill-switch" });
  }

  if (family === "controls") {
    links.push({ name: "Controls hub", path: "/controls" });
    links.push({ name: "Policy artifacts", path: "/policy" });
  }

  // Remove self-link and dedupe
  const self = `/${article.slug}`;
  return uniqueLinks(links.filter((l) => l.path !== self)).slice(0, 8);
}

// ── Article Processing Helpers ────────────────────────────────────

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/<[^>]+>/g, "")
    .replace(/&[^;]+;/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "");
}

interface TocEntry {
  id: string;
  text: string;
  depth: number;
}

/** Inject `id` attributes + anchor links into h2/h3 elements, extract TOC. */
function extractAndInjectHeadings(rawHtml: string): { html: string; toc: TocEntry[] } {
  const toc: TocEntry[] = [];
  const seen = new Set<string>();
  const processed = rawHtml.replace(
    /<(h[23])([^>]*)>([\s\S]*?)<\/\1>/gi,
    (_match, tag: string, attrs: string, content: string) => {
      if (attrs.includes(" id=")) return _match; // already has id
      const text = content.replace(/<[^>]+>/g, "").trim();
      let id = slugify(text);
      if (!id) return _match;
      if (seen.has(id)) id += "-" + seen.size;
      seen.add(id);
      const depth = tag.toLowerCase() === "h2" ? 2 : 3;
      toc.push({ id, text, depth });
      return `<${tag}${attrs} id="${id}">${content}<a href="#${id}" class="heading-anchor" aria-hidden="true">#</a></${tag}>`;
    },
  );
  return { html: processed, toc };
}

/** Render a sticky sidebar Table of Contents from extracted headings. */
function renderToc(toc: TocEntry[]): string {
  if (toc.length < 3) return "";
  const items = toc
    .map((e) => `<li class="depth-${e.depth}"><a href="#${e.id}">${esc(e.text)}</a></li>`)
    .join("");
  return `
  <aside class="toc" aria-label="Table of contents">
    <details open>
      <summary>On this page</summary>
      <nav><ol>${items}</ol></nav>
    </details>
  </aside>`;
}

/** Wrap bare <table> elements in a responsive scroll container. */
function wrapTables(rawHtml: string): string {
  return rawHtml
    .replace(/<table\b/g, '<div class="table-wrap" role="region" tabindex="0"><table')
    .replace(/<\/table>/g, "</table></div>");
}

function isBofuArticle(article: Article): boolean {
  return (
    article.slug.startsWith("tools/")
    || article.slug.startsWith("workflows/")
    || article.slug.startsWith("channels/")
    || article.slug.startsWith("compliance/")
    || article.slug.startsWith("compare/")
    || article.slug.startsWith("for/")
  );
}

function renderProofSummaryBlock(article: Article): string {
  if (!isBofuArticle(article)) return "";

  const sourceList = (article.sources ?? [])
    .slice(0, 3)
    .map((s) => `<li><a href="${esc(s.uri)}" rel="noopener" target="_blank">${esc(s.title || s.uri)}</a></li>`)
    .join("");

  return `
  <section class="proof-summary-block" aria-label="Proof-first summary">
    <h3>Proof-first summary</h3>
    <ul>
      <li>Execution policy is explicit before an agent can run irreversible actions.</li>
      <li>Every model call and tool action can be tied to receipts and audit evidence.</li>
      <li>Rollback posture is documented with deterministic failure handling paths.</li>
    </ul>
    <p class="proof-summary-links">
      <a href="/assessment" data-cta="proof-summary-assessment">Run assessment</a>
      <span>·</span>
      <a href="/contact" data-cta="proof-summary-contact">Request tailored rollout plan</a>
    </p>
    ${sourceList ? `<div class="proof-summary-sources"><strong>Top references</strong><ul>${sourceList}</ul></div>` : ""}
  </section>`;
}

function articlePage(article: Article): string {
  const breadcrumbs = breadcrumbsFromSlug(article.slug);
  const schemas: string[] = [];

  const url = canonical(`/${article.slug}`);
  const headline = article.title.replace(/ \| Claw EA$/, "");

  if (article.faqs.length > 0) {
    schemas.push(faqSchema(article.faqs));
  }

  if (article.howToSteps && article.howToSteps.length > 0) {
    schemas.push(
      howToSchema(
        { title: article.howToTitle ?? headline, steps: article.howToSteps },
        url,
      ),
    );
  }

  if (article.category === "glossary") {
    schemas.push(definedTermSchema(headline, article.description, url));
  } else {
    schemas.push(
      techArticleSchema({
        headline,
        description: article.description,
        url,
        datePublished: article.generatedAt,
        dateModified: article.generatedAt,
        section: article.category,
      }),
    );
  }

  const updated = formatDateYmd(article.generatedAt);
  const readMinutes = estimateReadMinutes(article.html);
  const slugParts = article.slug.split("/").filter(Boolean);

  // Process article body: inject heading IDs, extract TOC, wrap tables
  const { html: processedHtml, toc } = extractAndInjectHeadings(article.html);
  const bodyHtml = wrapTables(processedHtml);
  const tocHtml = renderToc(toc);

  // Key takeaways module (uses article description as summary)
  const takeawaysHtml = article.description
    ? `<div class="takeaways"><div class="takeaways-title">&#9672; Key takeaway</div><p>${esc(article.description)}</p></div>`
    : "";

  const proofSummaryHtml = renderProofSummaryBlock(article);

  // Related content with card styling
  const related = relatedLinksForArticle(article);
  const relatedHtml = related.length
    ? `<div class="related"><h3>Related</h3><div class="related-grid">${related
        .map((l) => `<a href="${l.path}" class="related-card"><span class="related-label">${esc(l.name)}</span></a>`)
        .join("")}</div></div>`
    : "";

  const categoryLabel = article.category
    .replace(/-/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase());

  const familySlug = slugParts.length > 1 ? slugParts[0] : null;
  const familyLinkHtml = familySlug
    ? `<a href="/${familySlug}" class="meta-chip meta-chip-link" role="listitem">${esc(toTitle(familySlug))} hub</a>`
    : "";

  return layout({
    meta: {
      title: article.title,
      description: article.description,
      path: `/${article.slug}`,
      ogType: "article",
      ogImageAlt: `${headline} | Claw EA`,
      articleSection: categoryLabel,
      publishedTime: article.generatedAt,
      modifiedTime: article.generatedAt,
      // Plan A: fail-closed. Only explicitly indexable pages should be indexed.
      noindex: article.indexable !== true,
    },
    breadcrumbs,
    schemas,
    body: `
    <section class="section content-page">
      <div class="wrap">
        <span class="badge badge-blue">${categoryLabel}</span>
        <h1>${esc(headline)}</h1>
        <p class="article-meta">Evidence is linked in Sources when available.</p>
        <div class="article-meta-strip" role="list" aria-label="Article metadata">
          <span class="meta-chip" role="listitem">Updated <time datetime="${esc(article.generatedAt)}">${updated}</time></span>
          <span class="meta-chip" role="listitem">${readMinutes} min read</span>
          <span class="meta-chip" role="listitem">${esc(categoryLabel)}</span>
          ${familyLinkHtml}
        </div>
        ${takeawaysHtml}
        ${proofSummaryHtml}
        <div class="article-layout">
          ${tocHtml}
          <div class="article-main">
            <div class="article-body">${bodyHtml}</div>
            ${clusterCtaForArticle(article.slug)}
            ${relatedHtml}
          </div>
        </div>
      </div>
    </section>`,
  });
}

function esc(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

/* ── Money Cluster CTAs ────────────────────────────────────────── */

interface ClusterDef {
  label: string;
  hub: string;
  hubTitle: string;
  children: string[];
  angle: string;
}

const MONEY_CLUSTERS: ClusterDef[] = [
  {
    label: "Production Deploy Approvals",
    hub: "workflows/production-deploy-approval",
    hubTitle: "Production Deploy Approval Workflow",
    children: [
      "tools/github", "tools/argocd", "tools/terraform-cloud",
      "controls/two-person-rule", "controls/approval-gates",
      "workflows/cicd-policy-enforcement",
    ],
    angle: "We run this on our own repo. Every agent PR carries a verifiable evidence pack.",
  },
  {
    label: "Identity / Access Request Automation",
    hub: "workflows/access-request-automation",
    hubTitle: "Access Request Automation Workflow",
    children: [
      "tools/okta", "tools/entra-id", "tools/google-admin",
      "controls/scoped-tokens", "controls/approval-gates",
    ],
    angle: "Scoped tokens bind agent identity to permissions to audit trail.",
  },
  {
    label: "Compliance Evidence Collection",
    hub: "workflows/siem-evidence-collection",
    hubTitle: "SIEM Evidence Collection Workflow",
    children: [
      "compliance/sox-controls", "audit/tamper-evident-logs",
      "proof/proof-bundles", "compliance",
    ],
    angle: "Proof bundles are offline-verifiable evidence artifacts. No vendor lock-in.",
  },
];

function clusterCtaForArticle(slug: string): string {
  for (const cluster of MONEY_CLUSTERS) {
    const isHub = slug === cluster.hub;
    const isChild = cluster.children.includes(slug);
    if (!isHub && !isChild) continue;

    const hubLink = isHub
      ? ""
      : `<p style="margin-bottom:.5rem"><a href="/${cluster.hub}">&larr; ${esc(cluster.hubTitle)}</a></p>`;

    return `
    <div class="cta-banner" style="margin-top:2rem">
      ${hubLink}
      <h2>See how this works for your stack</h2>
      <p>${esc(cluster.angle)}</p>
      <a href="/assessment" class="cta-btn cta-btn-lg" data-cta="cluster-assessment-${esc(cluster.hub.split("/").pop() ?? "")}">Take the assessment</a>
      <a href="/trust/security-review" class="cta-btn cta-btn-outline cta-btn-lg" style="margin-left:.75rem" data-cta="cluster-security-review">Security Review Pack</a>
    </div>`;
  }

  // Default CTA for non-cluster pages
  return `
    <div class="cta-banner" style="margin-top:2rem">
      <h2>See how this applies to your environment</h2>
      <p>Take the two-minute assessment. We map controls to your stack and risk profile.</p>
      <a href="/assessment" class="cta-btn cta-btn-lg" data-cta="article-assessment">Take the assessment</a>
    </div>`;
}

// ── Router ────────────────────────────────────────────────────────

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname.replace(/\/+$/, "") || "/";

    const visitor = getOrCreateVisitorId(request);
    const existingExpCookie = clipString(readCookie(request, "clawea_exp"), 240);
    const experimentConfigPromise = loadExperimentConfig(env);

    const htmlWithExperiment = async (response: Response, routePath = path): Promise<Response> => {
      const config = await experimentConfigPromise;
      const assignment = assignVariant(config, visitor.visitorId, pageFamilyFromPath(routePath));
      const expectedExp = `${assignment.pageFamily}:${assignment.heroVariant}:${assignment.ctaVariant}`;
      const shouldSetExpCookie = existingExpCookie !== expectedExp;
      return applyExperimentCookies(response, visitor.visitorId, assignment, visitor.cookieNeeded, shouldSetExpCookie);
    };

    // ── IndexNow key file ──
    if ((request.method === "GET" || request.method === "HEAD") && env.INDEXNOW_KEY && path === `/${env.INDEXNOW_KEY}.txt`) {
      return new Response(request.method === "HEAD" ? null : `${env.INDEXNOW_KEY}\n`, {
        headers: {
          "content-type": "text/plain;charset=utf-8",
          "cache-control": "public, max-age=86400",
        },
      });
    }

    // ── API routes (search + indexing + conversion telemetry) ──
    if (path.startsWith("/api/")) {
      if (request.method === "OPTIONS") {
        return new Response(null, { status: 204, headers: apiHeaders() });
      }

      // Public conversion instrumentation endpoint (no bearer token)
      if (path === "/api/events") {
        return await ingestTrackingEvent(request, env);
      }

      // Public search endpoint
      if (path === "/api/search") {
        if (request.method !== "GET") {
          return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
        }

        const query = normalizeSearchQuery(url.searchParams.get("q"));
        const limit = Math.min(50, Math.max(1, Number(url.searchParams.get("limit") ?? "10")));

        if (query.length < 2) {
          return apiError("QUERY_TOO_SHORT", "q must be at least 2 characters", 400);
        }

        const manifest = await loadManifest(env);
        const corpus = buildSearchCorpus(manifest);
        const results = searchCorpus(corpus, query, limit);

        return apiJson({
          ok: true,
          query,
          count: results.length,
          results: results.map((r) => ({
            path: r.path,
            title: r.title,
            description: previewText(r.description, 240),
            category: r.category,
            kind: r.kind,
            score: r.score,
          })),
        });
      }

      if (path === "/api/experiments/config") {
        if (request.method !== "GET") {
          return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
        }

        const config = await loadExperimentConfig(env);
        return apiJson({ ok: true, config });
      }

      if (path === "/api/experiments/assignment") {
        return await experimentAssignmentEndpoint(request, env);
      }

      if (path === "/api/experiments/winners") {
        return await experimentsWinners(request, env);
      }

      if (path === "/api/leads/submit") {
        return await submitLead(request, env);
      }

      if (path === "/api/leads/status") {
        return await leadsStatus(request, env);
      }

      if (path === "/api/leads/export") {
        return await leadsExport(request, env);
      }

      if (path === "/api/routing/status") {
        return await routingStatus(request, env);
      }

      if (path === "/api/routing/replay") {
        return await routingReplay(request, env);
      }

      if (path === "/api/attribution/summary") {
        return await attributionSummary(request, env);
      }

      if (path === "/api/attribution/revenue") {
        return await attributionRevenueSummary(request, env);
      }

      if (path === "/api/ops/lead-funnel-health") {
        return await opsLeadFunnelHealth(request, env);
      }

      if (path === "/api/ops/routing-health") {
        return await opsRoutingHealth(request, env);
      }

      if (path === "/api/ops/conversion-heatmap") {
        return await opsConversionHeatmap(request, env);
      }

      if (path === "/api/ops/failing-steps") {
        return await opsFailingSteps(request, env);
      }

      if (path === "/api/ops/lead-intake-security") {
        return await opsLeadIntakeSecurityPosture(request, env);
      }

      if (path === "/api/experiments/recommend") {
        return await recommendExperimentWinners(request, env);
      }

      if (path === "/api/book/submit") {
        return await bookSubmit(request, env);
      }

      if (path === "/api/book/complete") {
        return await bookComplete(request, env);
      }

      // Protected telemetry summary endpoint
      if (path === "/api/events/summary") {
        return await summarizeTrackingEvents(request, env);
      }

      const authError = checkAutomationAuth(request, env);
      if (authError) return authError;

      if (path === "/api/index-queue/status") {
        if (request.method !== "GET") {
          return apiError("METHOD_NOT_ALLOWED", "Use GET for this endpoint", 405);
        }

        const queue = await loadIndexQueue(env);
        const lastRun = await loadLastQueueRun(env);
        return apiJson({
          ok: true,
          enabled: queueEnabled(env),
          ...summarizeQueueForResponse(queue),
          lastRun,
        });
      }

      if (request.method !== "POST") {
        return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
      }

      let body: any;
      try {
        body = await request.json<any>();
      } catch {
        return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
      }

      if (path === "/api/index-queue/replay") {
        const forceFailed = body?.forceFailed === true;
        const simulate429 = body?.simulate429 === true;
        const maxEntries = Math.min(500, Math.max(1, Number(body?.maxEntries ?? queueMaxEntriesPerRun(env))));

        let forced = 0;
        if (forceFailed) {
          const out = await forceRequeueFailedEntries(env);
          forced = out.requeued;
        }

        const processed = await processIndexQueue(env, {
          source: "api:index-queue-replay",
          maxEntries,
          simulate429,
        });

        return apiJson({
          ok: true,
          forced,
          artifactKey: processed.artifactKey,
          run: processed.run,
        }, 200);
      }

      if (path === "/api/index-queue/enqueue") {
        const { accepted, rejected } = normalizeUrlList(body?.urls, 500);
        if (accepted.length === 0) {
          return apiError("URLS_INVALID", "No valid clawea.com URLs were provided", 400);
        }

        const action: IndexAction = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const engines = parseIndexingEngines(body?.engines);
        if (engines.length === 0) {
          return apiError("ENGINES_INVALID", "engines must include indexnow, google, or all", 400);
        }

        const enqueued = await enqueueIndexQueue(env, {
          urls: accepted,
          action,
          engines,
          force: body?.force === true,
          source: "api:index-queue-enqueue",
        });

        return apiJson({
          ok: true,
          action,
          engines,
          requested: accepted.length,
          rejected,
          created: enqueued.created,
          updated: enqueued.updated,
          deduped: enqueued.deduped,
          queue: enqueued.summary,
        });
      }

      const { accepted, rejected } = normalizeUrlList(body?.urls, 500);
      if (accepted.length === 0) {
        return apiError("URLS_INVALID", "No valid clawea.com URLs were provided", 400);
      }

      if (path === "/api/indexnow") {
        const result = await submitIndexNow(accepted, env);
        return apiJson({
          ok: result.ok,
          engine: "indexnow",
          submitted: result.submitted,
          requested: accepted.length,
          rejected,
          status: result.status,
          attempts: result.attempts,
          retried: result.retried,
          retryableFailures: result.retryableFailures,
          attemptLog: result.attemptLog,
          body: result.body,
          error: result.error,
        }, result.ok ? 200 : 502);
      }

      if (path === "/api/google-index") {
        const action = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const result = await submitGoogleIndexing(accepted, action, env);
        return apiJson({
          ok: result.ok,
          engine: "google",
          action,
          submitted: result.submitted,
          failed: result.failed,
          requested: accepted.length,
          rejected,
          status: result.status,
          details: result.details,
          error: result.error,
        }, result.ok ? 200 : result.status);
      }

      if (path === "/api/index-urls") {
        const action: IndexAction = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const engines = parseIndexingEngines(body?.engines);
        if (engines.length === 0) {
          return apiError("ENGINES_INVALID", "engines must include indexnow, google, or all", 400);
        }

        const queueOnly = body?.queueOnly === true;
        const queueOnFailure = body?.queueOnFailure !== false;

        if (queueOnly) {
          const queued = await enqueueIndexQueue(env, {
            urls: accepted,
            action,
            engines,
            force: body?.force === true,
            source: "api:index-urls(queue-only)",
          });

          return apiJson({
            ok: true,
            mode: "queue_only",
            action,
            engines,
            requested: accepted.length,
            rejected,
            created: queued.created,
            updated: queued.updated,
            deduped: queued.deduped,
            queue: queued.summary,
          });
        }

        const out: Record<string, unknown> = {
          ok: true,
          requested: accepted.length,
          rejected,
          action,
          engines,
          queueOnFailure,
        };

        const failedForQueue: Record<IndexEngine, string[]> = {
          indexnow: [],
          google: [],
        };

        if (engines.includes("indexnow")) {
          const r = await submitIndexNow(accepted, env);
          out.indexnow = {
            ok: r.ok,
            submitted: r.submitted,
            status: r.status,
            attempts: r.attempts,
            retried: r.retried,
            retryableFailures: r.retryableFailures,
            attemptLog: r.attemptLog,
            body: r.body,
            error: r.error,
          };

          if (!r.ok) {
            out.ok = false;
            failedForQueue.indexnow.push(...accepted);
          }
        }

        if (engines.includes("google")) {
          const r = await submitGoogleIndexing(accepted, action, env);
          out.google = {
            ok: r.ok,
            submitted: r.submitted,
            failed: r.failed,
            status: r.status,
            details: r.details,
            error: r.error,
          };

          if (!r.ok) {
            out.ok = false;
          }

          for (const detail of r.details) {
            if (!detail.ok) failedForQueue.google.push(detail.url);
          }
        }

        const queuedFailures: Record<string, unknown> = {};
        if (queueOnFailure) {
          if (failedForQueue.indexnow.length > 0) {
            const q = await enqueueIndexQueue(env, {
              urls: [...new Set(failedForQueue.indexnow)],
              action,
              engines: ["indexnow"],
              source: "api:index-urls(indexnow-failure)",
            });
            queuedFailures.indexnow = {
              queued: failedForQueue.indexnow.length,
              created: q.created,
              updated: q.updated,
              deduped: q.deduped,
            };
          }

          if (failedForQueue.google.length > 0) {
            const q = await enqueueIndexQueue(env, {
              urls: [...new Set(failedForQueue.google)],
              action,
              engines: ["google"],
              source: "api:index-urls(google-failure)",
            });
            queuedFailures.google = {
              queued: failedForQueue.google.length,
              created: q.created,
              updated: q.updated,
              deduped: q.deduped,
            };
          }
        }

        const queue = await loadIndexQueue(env);
        out.queue = summarizeQueueForResponse(queue);
        out.queuedFailures = queuedFailures;

        return apiJson(out, out.ok ? 200 : 207);
      }

      return apiError("NOT_FOUND", "Unknown API route", 404);
    }

    // ── Static routes ──
    if (path === "/health") return json({ ok: true, service: "clawea-www", ts: new Date().toISOString() });

    const turnstile = resolveTurnstilePosture(env);
    const host = url.hostname.toLowerCase();
    const widgetEnabled = host !== "localhost" && host !== "127.0.0.1" && host !== "::1";

    if (path === "/") return await htmlWithExperiment(html(homePage(), 200, 7200), path);
    if (path === "/pricing") return await htmlWithExperiment(html(pricingPage()), path);
    if (path === "/assessment") return await htmlWithExperiment(html(assessmentPage(turnstile), 200, 1800), path);
    if (path === "/assessment/result") {
      return await htmlWithExperiment(
        html(assessmentResultPage(parseAssessmentResult(url), turnstile, { widgetEnabled }), 200, 900),
        "/assessment/result",
      );
    }
    if (path === "/contact") return await htmlWithExperiment(html(contactPage(turnstile, { widgetEnabled })), path);
    if (path === "/book") return await htmlWithExperiment(html(bookPage(url, turnstile, { widgetEnabled }), 200, 900), path);
    if (path === "/trust") return await htmlWithExperiment(html(trustPage()), path);
    if (path === "/trust/security-review") return await htmlWithExperiment(html(securityReviewPackPage()), path);
    if (path === "/secure-workers") return await htmlWithExperiment(html(secureWorkersPage()), path);
    if (path === "/consulting") return await htmlWithExperiment(html(consultingPage()), path);
    if (path === "/about") return await htmlWithExperiment(html(aboutPage()), path);
    if (path === "/sources") {
      const manifest = await loadManifest(env);
      return await htmlWithExperiment(html(sourcesHubPage(manifest), 200, 1800), path);
    }

    if (path === "/glossary") {
      const q = normalizeSearchQuery(url.searchParams.get("q"));
      if (q) {
        const manifest = await loadManifest(env);
        const corpus = buildSearchCorpus(manifest);
        const results = searchCorpus(corpus, q, 32);
        return await htmlWithExperiment(html(glossarySearchPage(q, results), 200, 300), "/glossary");
      }
    }

    if (path === "/llms.txt") {
      return new Response(
        [
          "# Claw EA",
          "",
          "Claw EA publishes policy-first enterprise agent implementation references.",
          "Use citation-ready pages with explicit sources and proof summaries.",
          "",
          "## High-intent routes",
          "- https://www.clawea.com/assessment",
          "- https://www.clawea.com/contact",
          "- https://www.clawea.com/book",
          "- https://www.clawea.com/trust",
          "- https://www.clawea.com/trust/security-review",
          "- https://www.clawea.com/sources",
          "",
          "## Core references",
          "- https://www.clawea.com/policy-as-code-for-agents",
          "- https://www.clawea.com/secure-agent-execution",
          "- https://www.clawea.com/agent-proof-and-attestation",
          "- https://www.clawea.com/agent-audit-and-replay",
          "",
          "## Sitemap",
          "- https://www.clawea.com/sitemap.xml",
        ].join("\n"),
        { headers: { "content-type": "text/plain;charset=utf-8", "cache-control": "public, max-age=86400" } },
      );
    }

    // ── Robots.txt ──
    if (path === "/robots.txt") {
      return new Response(
        `User-agent: *\nAllow: /\nDisallow: /api/\nDisallow: /v1/\n\nSitemap: https://www.clawea.com/sitemap.xml\n`,
        { headers: { "content-type": "text/plain", "cache-control": "public, max-age=86400" } },
      );
    }

    // ── Sitemap ──
    if (path === "/sitemap.xml") {
      return await serveSitemap(env);
    }

    // ── Dynamic article routes ──
    const slug = slugFromPath(path);
    const article = await loadArticle(env, slug);
    if (article) {
      return await htmlWithExperiment(html(articlePage(article), 200, 3600), `/${article.slug}`);
    }

    // ── 404 ──
    return await htmlWithExperiment(html(notFoundPage(), 404), path);
  },

  async scheduled(_controller: ScheduledController, env: Env, ctx: ExecutionContext): Promise<void> {
    if (queueEnabled(env)) {
      const maxEntries = queueMaxEntriesPerRun(env);
      ctx.waitUntil((async () => {
        try {
          await processIndexQueue(env, {
            source: "scheduled",
            maxEntries,
          });
        } catch (err) {
          console.error("INDEX_QUEUE_SCHEDULED_FAILED", err);
        }
      })());
    }

    ctx.waitUntil((async () => {
      try {
        await enqueueWeeklyVariantReportIfDue(env);
      } catch (err) {
        console.error("VARIANT_REPORT_ENQUEUE_FAILED", err);
      }
    })());

    ctx.waitUntil((async () => {
      try {
        await computeLeadResponseSla(env);
        await computeRoutingHealth(env);
      } catch (err) {
        console.error("OPS_HEALTH_SWEEP_FAILED", err);
      }
    })());
  },

  async queue(batch: MessageBatch<any>, env: Env): Promise<void> {
    await leadJobsQueue(batch, env);
  },
} satisfies ExportedHandler<Env>;

// ── Sitemap Generator ─────────────────────────────────────────────

async function serveSitemap(env: Env): Promise<Response> {
  // Load sitemap index from R2
  // Core sitemap only (Plan A)
  const obj = await env.ARTICLES.get("articles/_sitemap_core.json");
  const staticPages = [
    { slug: "", priority: "1.0" },
    { slug: "assessment", priority: "0.9" },
    { slug: "trust", priority: "0.8" },
    { slug: "trust/security-review", priority: "0.9" },
    { slug: "secure-workers", priority: "0.8" },
    { slug: "consulting", priority: "0.8" },
    { slug: "pricing", priority: "0.8" },
    { slug: "contact", priority: "0.8" },
    { slug: "book", priority: "0.85" },
    { slug: "sources", priority: "0.7" },
    { slug: "about", priority: "0.6" },
  ];

  let entries = staticPages.map((p) => `  <url><loc>https://www.clawea.com/${p.slug}</loc><priority>${p.priority}</priority><changefreq>weekly</changefreq></url>`);

  if (obj) {
    const articles = await obj.json<{ slug: string; category: string }[]>();
    for (const a of articles) {
      const pri =
        a.category === "pillars" || a.category === "hubs" ? "0.8"
          : a.category === "guides" ? "0.7"
            : ["controls", "policy", "proof", "verify", "audit"].includes(a.category) ? "0.7"
              : [
                  "workflows",
                  "tools",
                  "channels",
                  "mcp",
                  "supply-chain",
                  "compliance",
                  "compare",
                  "roles",
                ].includes(a.category) ? "0.6"
                : a.category === "glossary" ? "0.5"
                  : "0.5";
      entries.push(`  <url><loc>https://www.clawea.com/${a.slug}</loc><priority>${pri}</priority><changefreq>monthly</changefreq></url>`);
    }
  }

  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${entries.join("\n")}
</urlset>`;

  return new Response(xml, {
    headers: { "content-type": "application/xml", "cache-control": "public, max-age=3600" },
  });
}
