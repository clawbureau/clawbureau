/**
 * clawea-www ‚Äî Programmatic SEO site for clawea.com
 *
 * Serves 10k+ pages from R2-stored articles generated by Gemini.
 * Full SEO: JSON-LD, FAQ schema, OG tags, sitemap, robots.txt,
 * internal linking mesh, breadcrumbs, canonical URLs.
 *
 * Routes:
 *   GET /                        ‚Üí homepage
 *
 *   Core permissioned-execution taxonomy:
 *   GET /policy-as-code-for-agents
 *   GET /secure-agent-execution
 *   GET /agent-proof-and-attestation
 *   GET /agent-audit-and-replay
 *   GET /agent-supply-chain-security
 *   GET /event-native-agents
 *   GET /mcp-security
 *
 *   Families:
 *   GET /controls/*              ‚Üí control pages
 *   GET /tools/*                 ‚Üí enterprise tool pages
 *   GET /channels/*              ‚Üí channel control plane pages
 *   GET /workflows/*             ‚Üí workflow recipes (workflow ‚Üí tool ‚Üí channel)
 *   GET /policy/*                ‚Üí policy artifacts and validation
 *   GET /proof/*                 ‚Üí proof pages
 *   GET /verify/*                ‚Üí verification pages
 *   GET /audit/*                 ‚Üí audit/replay pages
 *   GET /mcp/*                   ‚Üí MCP security and server governance
 *   GET /supply-chain/*          ‚Üí extension supply chain security
 *   GET /events/*                ‚Üí event-native trigger patterns
 *   GET /compliance/*            ‚Üí compliance mappings and evidence
 *   GET /guides/*                ‚Üí implementation guides
 *   GET /glossary/*              ‚Üí glossary entries
 *   GET /vs/*, /compare/*, /for/* ‚Üí comparisons and role-based pages
 *
 *   Static pages:
 *   GET /pricing, /contact, /about, /trust, /secure-workers, /consulting
 *
 *   System endpoints:
 *   GET /sitemap.xml, /robots.txt, /health
 *   GET /<INDEXNOW_KEY>.txt
 *   POST /api/indexnow, /api/google-index, /api/index-urls
 *
 * Dynamic article routing:
 * - Any non-static route attempts to load articles/<slug>.json from R2.
 */

import { layout } from "./layout";
import {
  faqSchema,
  howToSchema,
  serviceSchema,
  canonical,
  definedTermSchema,
  techArticleSchema,
  productSchema,
  type PageMeta,
} from "./seo";
import { trustPage, secureWorkersPage, consultingPage, aboutPage } from "./pages/static";

interface Env {
  ARTICLES: R2Bucket;
  SITE_URL: string;
  ENVIRONMENT: string;

  // Indexing automation
  INDEXNOW_KEY?: string;
  INDEX_AUTOMATION_TOKEN?: string;
  GOOGLE_INDEXING_SERVICE_ACCOUNT_JSON?: string;
}

interface Article {
  slug: string;
  title: string;
  category: string;
  html: string;
  description: string;
  faqs: { q: string; a: string }[];
  /** v2 structured how-to support (optional, used when present) */
  howToTitle?: string;
  howToSteps?: Array<{ name: string; text: string }>;
  sources: { title: string; uri: string }[];
  model: string;
  generatedAt: string;
  /** Plan A: only index selected pages initially. */
  indexable?: boolean;
}

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function json(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: { "content-type": "application/json", "access-control-allow-origin": "*" },
  });
}

function html(body: string, status = 200, cacheSeconds = 3600): Response {
  return new Response(body, {
    status,
    headers: {
      "content-type": "text/html;charset=utf-8",
      "cache-control": `public, max-age=${cacheSeconds}, s-maxage=${cacheSeconds * 24}`,
    },
  });
}

function apiHeaders(extra: HeadersInit = {}): Headers {
  const h = new Headers(extra);
  h.set("access-control-allow-origin", "*");
  h.set("access-control-allow-methods", "POST,OPTIONS");
  h.set("access-control-allow-headers", "content-type,authorization");
  h.set("cache-control", "no-store");
  return h;
}

function apiJson(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: apiHeaders({ "content-type": "application/json" }),
  });
}

function apiError(code: string, message: string, status = 400): Response {
  return apiJson({ ok: false, error: { code, message } }, status);
}

function getBearerToken(request: Request): string | null {
  const auth = request.headers.get("authorization") ?? "";
  const m = auth.match(/^Bearer\s+(.+)$/i);
  return m?.[1]?.trim() ?? null;
}

function checkAutomationAuth(request: Request, env: Env): Response | null {
  const secret = env.INDEX_AUTOMATION_TOKEN?.trim();
  if (!secret) {
    return apiError("INDEX_AUTOMATION_NOT_CONFIGURED", "Indexing automation token is not configured", 503);
  }

  const token = getBearerToken(request);
  if (!token || token !== secret) {
    return apiError("UNAUTHORIZED", "Missing or invalid bearer token", 401);
  }

  return null;
}

const INDEXABLE_HOSTS = new Set(["clawea.com", "www.clawea.com"]);

function normalizeIndexingUrl(input: string): string | null {
  try {
    const u = new URL(input);
    if (u.protocol !== "https:") return null;
    const host = u.hostname.toLowerCase();
    if (!INDEXABLE_HOSTS.has(host)) return null;

    u.hash = "";
    return u.toString();
  } catch {
    return null;
  }
}

function normalizeUrlList(input: unknown, maxUrls = 500): { accepted: string[]; rejected: string[] } {
  const accepted: string[] = [];
  const rejected: string[] = [];

  if (!Array.isArray(input)) {
    return { accepted, rejected: ["urls_must_be_array"] };
  }

  for (const raw of input) {
    if (accepted.length >= maxUrls) break;
    if (typeof raw !== "string") {
      rejected.push(String(raw));
      continue;
    }

    const normalized = normalizeIndexingUrl(raw.trim());
    if (!normalized) {
      rejected.push(raw);
      continue;
    }

    if (!accepted.includes(normalized)) accepted.push(normalized);
  }

  return { accepted, rejected };
}

type IndexNowResult = {
  ok: boolean;
  submitted: number;
  status: number;
  body?: unknown;
  error?: string;
};

async function submitIndexNow(urls: string[], env: Env): Promise<IndexNowResult> {
  const key = env.INDEXNOW_KEY?.trim();
  if (!key) {
    return {
      ok: false,
      submitted: 0,
      status: 503,
      error: "INDEXNOW_KEY_NOT_CONFIGURED",
    };
  }

  const payload = {
    host: "clawea.com",
    key,
    keyLocation: `https://clawea.com/${key}.txt`,
    urlList: urls,
  };

  const res = await fetch("https://api.indexnow.org/IndexNow", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify(payload),
  });

  const raw = await res.text();
  let parsed: unknown = raw;
  try {
    parsed = raw ? JSON.parse(raw) : null;
  } catch {
    // keep raw text body
  }

  return {
    ok: res.ok,
    submitted: res.ok ? urls.length : 0,
    status: res.status,
    body: parsed,
    error: res.ok ? undefined : "INDEXNOW_REQUEST_FAILED",
  };
}

type GoogleServiceAccount = {
  client_email: string;
  private_key: string;
  token_uri?: string;
};

type GoogleIndexResult = {
  ok: boolean;
  submitted: number;
  failed: number;
  status: number;
  details: Array<{ url: string; ok: boolean; status: number; body?: unknown }>;
  error?: string;
};

function b64Url(input: string | Uint8Array): string {
  const str =
    typeof input === "string"
      ? input
      : String.fromCharCode(...input);
  return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function pemToPkcs8Bytes(pem: string): Uint8Array {
  const b64 = pem
    .replace(/-----BEGIN PRIVATE KEY-----/g, "")
    .replace(/-----END PRIVATE KEY-----/g, "")
    .replace(/\s+/g, "");

  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
  return out;
}

async function buildGoogleAccessToken(env: Env): Promise<string> {
  const raw = env.GOOGLE_INDEXING_SERVICE_ACCOUNT_JSON?.trim();
  if (!raw) {
    throw new Error("GOOGLE_INDEXING_NOT_CONFIGURED");
  }

  let sa: GoogleServiceAccount;
  try {
    sa = JSON.parse(raw) as GoogleServiceAccount;
  } catch {
    throw new Error("GOOGLE_INDEXING_SERVICE_ACCOUNT_INVALID_JSON");
  }

  if (!sa.client_email || !sa.private_key) {
    throw new Error("GOOGLE_INDEXING_SERVICE_ACCOUNT_FIELDS_MISSING");
  }

  const tokenUri = sa.token_uri ?? "https://oauth2.googleapis.com/token";
  const iat = Math.floor(Date.now() / 1000);
  const exp = iat + 3600;

  const header = { alg: "RS256", typ: "JWT" };
  const claim = {
    iss: sa.client_email,
    scope: "https://www.googleapis.com/auth/indexing",
    aud: tokenUri,
    iat,
    exp,
  };

  const encodedHeader = b64Url(JSON.stringify(header));
  const encodedClaim = b64Url(JSON.stringify(claim));
  const signingInput = `${encodedHeader}.${encodedClaim}`;

  const key = await crypto.subtle.importKey(
    "pkcs8",
    pemToPkcs8Bytes(sa.private_key),
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"],
  );

  const sig = await crypto.subtle.sign(
    { name: "RSASSA-PKCS1-v1_5" },
    key,
    new TextEncoder().encode(signingInput),
  );

  const jwt = `${signingInput}.${b64Url(new Uint8Array(sig))}`;

  const tokenRes = await fetch(tokenUri, {
    method: "POST",
    headers: { "content-type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: jwt,
    }).toString(),
  });

  if (!tokenRes.ok) {
    const errBody = await tokenRes.text();
    throw new Error(`GOOGLE_OAUTH_FAILED:${tokenRes.status}:${errBody.slice(0, 400)}`);
  }

  const tokenJson = await tokenRes.json<any>();
  const accessToken = tokenJson?.access_token;
  if (!accessToken || typeof accessToken !== "string") {
    throw new Error("GOOGLE_OAUTH_NO_ACCESS_TOKEN");
  }

  return accessToken;
}

async function submitGoogleIndexing(
  urls: string[],
  action: "URL_UPDATED" | "URL_DELETED",
  env: Env,
): Promise<GoogleIndexResult> {
  try {
    const accessToken = await buildGoogleAccessToken(env);

    const details: GoogleIndexResult["details"] = [];
    let submitted = 0;
    let failed = 0;

    for (const url of urls) {
      const res = await fetch("https://indexing.googleapis.com/v3/urlNotifications:publish", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          authorization: `Bearer ${accessToken}`,
        },
        body: JSON.stringify({
          url,
          type: action,
        }),
      });

      const raw = await res.text();
      let parsed: unknown = raw;
      try {
        parsed = raw ? JSON.parse(raw) : null;
      } catch {
        // leave as text
      }

      const ok = res.ok;
      if (ok) submitted += 1;
      else failed += 1;

      details.push({ url, ok, status: res.status, body: parsed });
    }

    return {
      ok: failed === 0,
      submitted,
      failed,
      status: failed === 0 ? 200 : 207,
      details,
    };
  } catch (err: any) {
    return {
      ok: false,
      submitted: 0,
      failed: urls.length,
      status: 503,
      details: [],
      error: String(err?.message ?? err),
    };
  }
}

async function loadArticle(env: Env, slug: string): Promise<Article | null> {
  const key = `articles/${slug}.json`;
  const obj = await env.ARTICLES.get(key);
  if (!obj) return null;
  const data = await obj.json<Article>();
  if ((data as any).error) return null;
  return data;
}

function slugFromPath(pathname: string): string {
  return pathname.replace(/^\//, "").replace(/\/$/, "");
}

function breadcrumbsFromSlug(slug: string): { name: string; path: string }[] {
  const parts = slug.split("/");
  const crumbs = [{ name: "Home", path: "/" }];

  const labels: Record<string, string> = {
    // v2 taxonomy
    controls: "Controls",
    policy: "Policy",
    proof: "Proof",
    verify: "Verify",
    audit: "Audit",
    channels: "Channels",
    tools: "Tools",
    workflows: "Workflows",
    events: "Events",
    mcp: "MCP",
    "supply-chain": "Supply Chain",
    compliance: "Compliance",
    guides: "Guides",
    glossary: "Glossary",
    compare: "Compare",
    vs: "Vs",
    for: "For",

    // legacy (if old slugs exist in R2)
    deploy: "Deploy",
    integrations: "Integrations",
    "use-cases": "Use Cases",
    models: "Models",
    solutions: "Solutions",
    connect: "Connect",
    enterprise: "Enterprise",
  };

  let accum = "";
  for (const part of parts) {
    accum += "/" + part;
    crumbs.push({
      name: labels[part] ?? part.split("-").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(" "),
      path: accum,
    });
  }

  return crumbs;
}

// ‚îÄ‚îÄ Static Pages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function homePage(): string {
  return layout({
    meta: {
      title: "Claw EA | Enterprise AI Agents, Deployed and Verified",
      description: "Deploy managed AI agents for your enterprise. Every action cryptographically attested. Every model call receipted. Every output verifiable. Reliable, performant, scalable, flexible, secure.",
      path: "/",
    },
    body: `
    <section class="hero">
      <div class="wrap">
        <span class="badge badge-blue">Enterprise AI Infrastructure</span>
        <h1>AI Agents That Your Enterprise Can Actually Trust</h1>
        <p class="sub">Deploy verified AI agents across Slack, Teams, Discord, and 20+ channels. Every action attested. Every model call receipted. No vendor lock-in. Works with Claude, GPT, Gemini, Llama, and any model you choose.</p>
        <div class="actions">
          <a href="/contact" class="cta-btn cta-btn-lg">Talk to Sales</a>
          <a href="/pricing" class="cta-btn cta-btn-outline cta-btn-lg">View Plans</a>
        </div>
      </div>
    </section>

    <section class="section-sm" style="border-bottom:1px solid var(--border)">
      <div class="wrap stats">
        <div class="stat"><div class="num">20+</div><div class="label">Channel Integrations</div></div>
        <div class="stat"><div class="num">12+</div><div class="label">AI Models Supported</div></div>
        <div class="stat"><div class="num">100%</div><div class="label">Action Attestation</div></div>
        <div class="stat"><div class="num">&lt;200ms</div><div class="label">Receipt Overhead</div></div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Why Claw EA</span>
          <h2>Six Pillars of Enterprise AI Done Right</h2>
          <p>Built on OpenClaw, hardened for enterprise. Every design decision optimizes for these six properties.</p>
        </div>
        <div class="grid-3">
          <div class="card">
            <div class="icon">üõ°Ô∏è</div>
            <h3>Secure by Architecture</h3>
            <p>Hardware-isolated Cloudflare Sandboxes. Per-agent DID identities. Work Policy Contracts enforce egress, DLP, and approval gates before any agent runs.</p>
          </div>
          <div class="card">
            <div class="icon">‚ö°</div>
            <h3>Performant at the Edge</h3>
            <p>Cloudflare's global edge network. Smart model routing. Sleep/wake cycles that cut costs without sacrificing response time. Sub-200ms receipt overhead.</p>
          </div>
          <div class="card">
            <div class="icon">üìà</div>
            <h3>Scales to Thousands</h3>
            <p>Up to 9,999 agents per tenant. Multi-tenant isolation at the infrastructure level. Budget controls per agent, team, or org. Fleet management dashboard.</p>
          </div>
          <div class="card">
            <div class="icon">üîÑ</div>
            <h3>No Model Lock-in</h3>
            <p>Claude, GPT, Gemini, Llama, Mistral, DeepSeek, Qwen. Any model, any provider. BYOK (Bring Your Own Key) or managed. Switch models without code changes.</p>
          </div>
          <div class="card">
            <div class="icon">‚úÖ</div>
            <h3>Reliable Operations</h3>
            <p>Auto-restart on failure. Health checks every 5 minutes. Persistent R2 state survives sleep/wake. Cron-based monitoring with configurable retry limits.</p>
          </div>
          <div class="card">
            <div class="icon">üìã</div>
            <h3>Audit-Ready by Default</h3>
            <p>Cryptographic proof bundles for every run. Tamper-evident audit logs. SOC 2, HIPAA, GDPR, FedRAMP compatible. Export to any SIEM.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="section" style="background:var(--bg-alt)">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Permissioned Execution</span>
          <h2>Controls That Make Agents Safe to Run</h2>
          <p>Agents get cheap. Risk gets expensive. Claw EA is built around enforceable policy-as-code controls that prevent exfiltration and force approvals for irreversible actions.</p>
        </div>
        <div class="grid-4">
          ${[
            ["Egress Allowlist", "/controls/egress-allowlist", "Only approved domains and IPs."],
            ["DLP Redaction", "/controls/dlp-redaction", "Redact before data leaves the boundary."],
            ["Approval Gates", "/controls/approval-gates", "Step-up approvals for high-risk steps."],
            ["Two-person Rule", "/controls/two-person-rule", "Require two humans for irreversible actions."],
            ["Budgets", "/controls/budgets", "Token and cost budgets per workflow."],
            ["File Path Scopes", "/controls/file-path-scopes", "Restrict what can be read or written."],
            ["Kill Switch", "/controls/kill-switch", "Stop execution when policy is violated."],
            ["MCP Security", "/mcp/security-best-practices", "Use MCP without turning tools into exfiltration."],
          ]
            .map(([name, href, desc]) => `<a href="${href}" class="card card-link"><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Channels + Tools</span>
          <h2>Chat Control Plane Plus Enterprise Systems</h2>
          <p>Run agents where your team already works, and connect them to enterprise tools under strict policy and proof.</p>
        </div>
        <div class="grid-4">
          ${[
            ["Microsoft Teams", "/channels/microsoft-teams", "üü¶", "Approvals and control sessions."],
            ["Slack", "/channels/slack", "üí¨", "Fast control plane for teams."],
            ["Email", "/channels/email", "üìß", "High-risk outbound, policy-first."],
            ["Google Chat", "/channels/google-chat", "üü©", "Workspace-native control plane."],
            ["Entra ID", "/tools/entra-id", "üîê", "Identity and step-up approvals."],
            ["SharePoint", "/tools/sharepoint", "üìÑ", "Scoped document access."],
            ["GitHub", "/tools/github", "üêô", "Code changes with policy and proof."],
            ["Jira", "/tools/jira", "üìã", "Change control and ticket workflows."],
          ]
            .map(([name, href, icon, desc]) => `<a href="${href}" class="card card-link"><div class="icon">${icon}</div><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
        <p style="text-align:center;margin-top:2rem">
          <a href="/channels" style="color:var(--text-muted)">Browse channels</a>
          <span style="color:var(--text-muted)"> ¬∑ </span>
          <a href="/tools" style="color:var(--text-muted)">Browse tools</a>
        </p>
      </div>
    </section>

    <section class="section" style="background:var(--bg-alt)">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Pillars</span>
          <h2>Policy, Proof, and Supply Chain</h2>
          <p>Claw EA is built for permissioned execution you can audit, not generic "AI agents".</p>
        </div>
        <div class="grid-2">
          ${[
            ["Policy-as-Code", "/policy-as-code-for-agents", "Define what agents may do before they run."],
            ["Secure Execution", "/secure-agent-execution", "Sandboxing, tool policy, and secrets boundaries."],
            ["Proof and Attestation", "/agent-proof-and-attestation", "Receipts and proof bundles you can verify."],
            ["Audit and Replay", "/agent-audit-and-replay", "Evidence retention and replay posture."],
            ["Supply Chain Security", "/agent-supply-chain-security", "Signed skills and governance for extensions."],
            ["Event-native Agents", "/event-native-agents", "Webhooks and changefeeds, paired with policy."],
          ]
            .map(([name, href, desc]) => `<a href="${href}" class="card card-link"><h3>${name}</h3><p>${desc}</p></a>`)
            .join("")}
        </div>
      </div>
    </section>

    <section class="section">
      <div class="wrap">
        <div class="cta-banner">
          <h2>Deploy Your First Enterprise AI Agent Today</h2>
          <p>Get a verified, attested AI agent running for your team in minutes. Start with Starter tier, scale to Enterprise.</p>
          <a href="/contact" class="cta-btn cta-btn-lg">Talk to Sales</a>
          <a href="/guides/first-30-days" class="cta-btn cta-btn-outline cta-btn-lg" style="margin-left:.75rem">Read the Guide</a>
        </div>
      </div>
    </section>`,
    schemas: [
      serviceSchema(
        "Claw EA - Enterprise AI Agent Platform",
        "Deploy managed, verified AI agents for enterprise. Cryptographic attestation, multi-model support, 20+ channel integrations.",
        "https://www.clawea.com",
      ),
    ],
  });
}

function pricingPage(): string {
  return layout({
    meta: {
      title: "Pricing | Claw EA Enterprise AI Agents",
      description: "Transparent pricing for enterprise AI agent infrastructure. Start free, scale to thousands. Starter, Team, Business, and Enterprise tiers.",
      path: "/pricing",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Pricing", path: "/pricing" }],
    body: `
    <section class="section content-page">
      <div class="wrap">
        <div class="sh">
          <span class="kicker">Pricing</span>
          <h2>Start Small, Scale Without Limits</h2>
          <p>Every tier includes full execution attestation, proof bundles, and audit logs.</p>
        </div>
        <div class="grid-4">
          <div class="price-card">
            <div class="tier">Starter</div>
            <div class="amount">$49</div>
            <div class="period">per month</div>
            <ul>
              <li>1 AI agent</li>
              <li>5 skills per agent</li>
              <li>All channels supported</li>
              <li>All models (BYOK)</li>
              <li>Execution attestation</li>
              <li>90-day audit log retention</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card">
            <div class="tier">Team</div>
            <div class="amount">$249</div>
            <div class="period">per month</div>
            <ul>
              <li>5 AI agents</li>
              <li>15 skills per agent</li>
              <li>All channels supported</li>
              <li>Model routing + failover</li>
              <li>Work Policy Contracts</li>
              <li>1-year audit log retention</li>
              <li>Budget controls</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card featured">
            <div class="tier" style="color:var(--accent)">Business</div>
            <div class="amount">$999</div>
            <div class="period">per month</div>
            <ul>
              <li>25 AI agents</li>
              <li>50 skills per agent</li>
              <li>Fleet management dashboard</li>
              <li>Multi-agent orchestration</li>
              <li>Custom agent templates</li>
              <li>3-year audit log retention</li>
              <li>SIEM integration</li>
              <li>Priority support</li>
            </ul>
            <a href="/contact" class="cta-btn">Get Started</a>
          </div>
          <div class="price-card">
            <div class="tier">Enterprise</div>
            <div class="amount">Custom</div>
            <div class="period">contact sales</div>
            <ul>
              <li>Unlimited agents</li>
              <li>Unlimited skills</li>
              <li>Custom container limits</li>
              <li>Custom compliance mapping</li>
              <li>Dedicated support engineer</li>
              <li>7-year audit log retention</li>
              <li>BAA / DPA available</li>
              <li>On-prem option</li>
            </ul>
            <a href="/contact" class="cta-btn">Talk to Sales</a>
          </div>
        </div>
      </div>
    </section>`,
    schemas: [
      productSchema("Claw EA", "Enterprise AI Agent Platform", "https://www.clawea.com/pricing", [
        { price: "49", priceCurrency: "USD" },
        { price: "249", priceCurrency: "USD" },
        { price: "999", priceCurrency: "USD" },
      ]),
    ],
  });
}

function contactPage(): string {
  return layout({
    meta: {
      title: "Contact Sales | Claw EA Enterprise AI Agents",
      description: "Talk to our enterprise sales team about deploying verified AI agents for your organization.",
      path: "/contact",
    },
    breadcrumbs: [{ name: "Home", path: "/" }, { name: "Contact", path: "/contact" }],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:600px">
        <h1>Talk to Sales</h1>
        <p class="lead">Tell us about your AI agent needs. We typically respond within 4 hours during business days.</p>
        <div class="card" style="margin-top:2rem">
          <p style="text-align:center;padding:2rem">
            <strong>Email:</strong> <a href="mailto:enterprise@clawbureau.com">enterprise@clawbureau.com</a><br><br>
            <strong>Subject line:</strong> Claw EA inquiry from [Your Company]<br><br>
            Include: industry, team size, primary use case, and timeline.
          </p>
        </div>
      </div>
    </section>`,
  });
}

function notFoundPage(): string {
  return layout({
    meta: { title: "Page Not Found | Claw EA", description: "The page you're looking for doesn't exist.", path: "/404", noindex: true },
    body: `
    <section class="section content-page" style="text-align:center">
      <div class="wrap">
        <h1>404 - Page Not Found</h1>
        <p class="lead">The page you're looking for doesn't exist or has been moved.</p>
        <a href="/" class="cta-btn cta-btn-lg" style="margin-top:2rem">Back to Home</a>
      </div>
    </section>`,
  });
}

// ‚îÄ‚îÄ Article Page Renderer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function formatDateYmd(iso: string): string {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return iso;
  return d.toISOString().slice(0, 10);
}

function toTitle(s: string): string {
  return s
    .split("-")
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(" ");
}

function uniqueLinks(items: Array<{ name: string; path: string }>): Array<{ name: string; path: string }> {
  const out: Array<{ name: string; path: string }> = [];
  const seen = new Set<string>();
  for (const i of items) {
    if (!i?.path || seen.has(i.path)) continue;
    seen.add(i.path);
    out.push(i);
  }
  return out;
}

function relatedLinksForArticle(article: Article): Array<{ name: string; path: string }> {
  const slugParts = article.slug.split("/").filter(Boolean);
  const family = slugParts[0] ?? "";

  const links: Array<{ name: string; path: string }> = [
    { name: "Policy-as-Code", path: "/policy-as-code-for-agents" },
    { name: "Secure Execution", path: "/secure-agent-execution" },
    { name: "Proof and Attestation", path: "/agent-proof-and-attestation" },
  ];

  if (family) {
    links.push({ name: `${toTitle(family)} hub`, path: `/${family}` });
  }

  // Family-specific helpers
  if (family === "workflows") {
    const toolSlug = slugParts[2];
    const channelSlug = slugParts[3];
    if (toolSlug) links.push({ name: `${toTitle(toolSlug)} tool page`, path: `/tools/${toolSlug}` });
    if (channelSlug) links.push({ name: `${toTitle(channelSlug)} channel page`, path: `/channels/${channelSlug}` });

    links.push({ name: "Approval gates", path: "/controls/approval-gates" });
    links.push({ name: "Two-person rule", path: "/controls/two-person-rule" });
    links.push({ name: "Budgets", path: "/controls/budgets" });
  }

  if (family === "tools") {
    const toolSlug = slugParts[1];
    if (toolSlug) links.push({ name: `${toTitle(toolSlug)} overview`, path: `/tools/${toolSlug}` });

    links.push({ name: "Egress allowlist", path: "/controls/egress-allowlist" });
    links.push({ name: "DLP and redaction", path: "/controls/dlp-redaction" });
    links.push({ name: "Secrets boundary", path: "/controls/secret-boundary" });
  }

  if (family === "channels") {
    const channelSlug = slugParts[1];
    if (channelSlug) links.push({ name: `${toTitle(channelSlug)} overview`, path: `/channels/${channelSlug}` });

    links.push({ name: "Tool allow/deny", path: "/controls/tool-allow-deny" });
    links.push({ name: "Approval gates", path: "/controls/approval-gates" });
    links.push({ name: "Kill switch", path: "/controls/kill-switch" });
  }

  if (family === "controls") {
    links.push({ name: "Controls hub", path: "/controls" });
    links.push({ name: "Policy artifacts", path: "/policy" });
  }

  // Remove self-link and dedupe
  const self = `/${article.slug}`;
  return uniqueLinks(links.filter((l) => l.path !== self)).slice(0, 8);
}

function articlePage(article: Article): string {
  const breadcrumbs = breadcrumbsFromSlug(article.slug);
  const schemas: string[] = [];

  const url = canonical(`/${article.slug}`);
  const headline = article.title.replace(/ \| Claw EA$/, "");

  if (article.faqs.length > 0) {
    schemas.push(faqSchema(article.faqs));
  }

  if (article.howToSteps && article.howToSteps.length > 0) {
    schemas.push(
      howToSchema(
        { title: article.howToTitle ?? headline, steps: article.howToSteps },
        url,
      ),
    );
  }

  if (article.category === "glossary") {
    schemas.push(definedTermSchema(headline, article.description, url));
  } else {
    schemas.push(
      techArticleSchema({
        headline,
        description: article.description,
        url,
        datePublished: article.generatedAt,
        dateModified: article.generatedAt,
        section: article.category,
      }),
    );
  }

  const updated = formatDateYmd(article.generatedAt);
  const related = relatedLinksForArticle(article);
  const relatedHtml = related.length
    ? `<div class="related"><h3>Related playbooks</h3><div class="related-grid">${related
        .map((l) => `<a href="${l.path}">${esc(l.name)}</a>`)
        .join("")}</div></div>`
    : "";

  return layout({
    meta: {
      title: article.title,
      description: article.description,
      path: `/${article.slug}`,
      modifiedTime: article.generatedAt,
      // Plan A: fail-closed. Only explicitly indexable pages should be indexed.
      noindex: article.indexable !== true,
    },
    breadcrumbs,
    schemas,
    body: `
    <section class="section content-page">
      <div class="wrap">
        <span class="badge badge-blue">${article.category.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase())}</span>
        <h1>${esc(headline)}</h1>
        <p class="article-meta">Updated <time datetime="${esc(article.generatedAt)}">${updated}</time>. Evidence is linked in Sources when available.</p>
        <div class="article-body">${article.html}</div>
        ${relatedHtml}
      </div>
    </section>`,
  });
}

function esc(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ‚îÄ‚îÄ Router ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname.replace(/\/+$/, "") || "/";

    // ‚îÄ‚îÄ IndexNow key file ‚îÄ‚îÄ
    if ((request.method === "GET" || request.method === "HEAD") && env.INDEXNOW_KEY && path === `/${env.INDEXNOW_KEY}.txt`) {
      return new Response(request.method === "HEAD" ? null : `${env.INDEXNOW_KEY}\n`, {
        headers: {
          "content-type": "text/plain;charset=utf-8",
          "cache-control": "public, max-age=86400",
        },
      });
    }

    // ‚îÄ‚îÄ API routes (indexing automation) ‚îÄ‚îÄ
    if (path.startsWith("/api/")) {
      if (request.method === "OPTIONS") {
        return new Response(null, { status: 204, headers: apiHeaders() });
      }

      const authError = checkAutomationAuth(request, env);
      if (authError) return authError;

      if (request.method !== "POST") {
        return apiError("METHOD_NOT_ALLOWED", "Use POST for this endpoint", 405);
      }

      let body: any;
      try {
        body = await request.json<any>();
      } catch {
        return apiError("INVALID_JSON", "Request body must be valid JSON", 400);
      }

      const { accepted, rejected } = normalizeUrlList(body?.urls, 500);
      if (accepted.length === 0) {
        return apiError("URLS_INVALID", "No valid clawea.com URLs were provided", 400);
      }

      if (path === "/api/indexnow") {
        const result = await submitIndexNow(accepted, env);
        return apiJson({
          ok: result.ok,
          engine: "indexnow",
          submitted: result.submitted,
          requested: accepted.length,
          rejected,
          status: result.status,
          body: result.body,
          error: result.error,
        }, result.ok ? 200 : 502);
      }

      if (path === "/api/google-index") {
        const action = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const result = await submitGoogleIndexing(accepted, action, env);
        return apiJson({
          ok: result.ok,
          engine: "google",
          action,
          submitted: result.submitted,
          failed: result.failed,
          requested: accepted.length,
          rejected,
          status: result.status,
          details: result.details,
          error: result.error,
        }, result.ok ? 200 : result.status);
      }

      if (path === "/api/index-urls") {
        const action = body?.action === "URL_DELETED" ? "URL_DELETED" : "URL_UPDATED";
        const enginesRaw = body?.engines;
        const enginesInput = Array.isArray(enginesRaw)
          ? enginesRaw.map((x) => String(x).toLowerCase())
          : [String(enginesRaw ?? "all").toLowerCase()];

        const useAll = enginesInput.includes("all");
        const useIndexNow = useAll || enginesInput.includes("indexnow");
        const useGoogle = useAll || enginesInput.includes("google");

        const out: Record<string, unknown> = {
          ok: true,
          requested: accepted.length,
          rejected,
          action,
          engines: enginesInput,
        };

        if (useIndexNow) {
          const r = await submitIndexNow(accepted, env);
          out.indexnow = {
            ok: r.ok,
            submitted: r.submitted,
            status: r.status,
            body: r.body,
            error: r.error,
          };
          if (!r.ok) out.ok = false;
        }

        if (useGoogle) {
          const r = await submitGoogleIndexing(accepted, action, env);
          out.google = {
            ok: r.ok,
            submitted: r.submitted,
            failed: r.failed,
            status: r.status,
            details: r.details,
            error: r.error,
          };
          if (!r.ok) out.ok = false;
        }

        if (!useIndexNow && !useGoogle) {
          return apiError("ENGINES_INVALID", "engines must include indexnow, google, or all", 400);
        }

        return apiJson(out, out.ok ? 200 : 207);
      }

      return apiError("NOT_FOUND", "Unknown API route", 404);
    }

    // ‚îÄ‚îÄ Static routes ‚îÄ‚îÄ
    if (path === "/health") return json({ ok: true, service: "clawea-www", ts: new Date().toISOString() });
    if (path === "/") return html(homePage(), 200, 7200);
    if (path === "/pricing") return html(pricingPage());
    if (path === "/contact") return html(contactPage());
    if (path === "/trust") return html(trustPage());
    if (path === "/secure-workers") return html(secureWorkersPage());
    if (path === "/consulting") return html(consultingPage());
    if (path === "/about") return html(aboutPage());

    // ‚îÄ‚îÄ Robots.txt ‚îÄ‚îÄ
    if (path === "/robots.txt") {
      return new Response(
        `User-agent: *\nAllow: /\nDisallow: /api/\nDisallow: /v1/\n\nSitemap: https://www.clawea.com/sitemap.xml\n`,
        { headers: { "content-type": "text/plain", "cache-control": "public, max-age=86400" } },
      );
    }

    // ‚îÄ‚îÄ Sitemap ‚îÄ‚îÄ
    if (path === "/sitemap.xml") {
      return await serveSitemap(env);
    }

    // ‚îÄ‚îÄ Dynamic article routes ‚îÄ‚îÄ
    const slug = slugFromPath(path);
    const article = await loadArticle(env, slug);
    if (article) {
      return html(articlePage(article), 200, 3600);
    }

    // ‚îÄ‚îÄ 404 ‚îÄ‚îÄ
    return html(notFoundPage(), 404);
  },
} satisfies ExportedHandler<Env>;

// ‚îÄ‚îÄ Sitemap Generator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function serveSitemap(env: Env): Promise<Response> {
  // Load sitemap index from R2
  // Core sitemap only (Plan A)
  const obj = await env.ARTICLES.get("articles/_sitemap_core.json");
  const staticPages = [
    { slug: "", priority: "1.0" },
    { slug: "trust", priority: "0.8" },
    { slug: "secure-workers", priority: "0.8" },
    { slug: "consulting", priority: "0.8" },
    { slug: "pricing", priority: "0.8" },
    { slug: "contact", priority: "0.7" },
    { slug: "about", priority: "0.6" },
  ];

  let entries = staticPages.map((p) => `  <url><loc>https://www.clawea.com/${p.slug}</loc><priority>${p.priority}</priority><changefreq>weekly</changefreq></url>`);

  if (obj) {
    const articles = await obj.json<{ slug: string; category: string }[]>();
    for (const a of articles) {
      const pri =
        a.category === "pillars" || a.category === "hubs" ? "0.8"
          : a.category === "guides" ? "0.7"
            : ["controls", "policy", "proof", "verify", "audit"].includes(a.category) ? "0.7"
              : [
                  "workflows",
                  "tools",
                  "channels",
                  "mcp",
                  "supply-chain",
                  "compliance",
                  "compare",
                  "roles",
                ].includes(a.category) ? "0.6"
                : a.category === "glossary" ? "0.5"
                  : "0.5";
      entries.push(`  <url><loc>https://www.clawea.com/${a.slug}</loc><priority>${pri}</priority><changefreq>monthly</changefreq></url>`);
    }
  }

  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${entries.join("\n")}
</urlset>`;

  return new Response(xml, {
    headers: { "content-type": "application/xml", "cache-control": "public, max-age=3600" },
  });
}
