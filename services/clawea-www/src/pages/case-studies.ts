/**
 * Case studies: /case-studies, /case-studies/dogfood-claw-bureau
 */

import { layout } from "../layout";
import { serviceSchema } from "../seo";

/* ── /case-studies ───────────────────────────────────────────── */

export function caseStudiesIndexPage(): string {
  return layout({
    meta: {
      title: "Case Studies | Claw EA",
      description: "How organizations use Claw EA for verifiable AI agent governance. Pilot engagements, dogfooding evidence, and deployment patterns.",
      path: "/case-studies",
    },
    breadcrumbs: [
      { name: "Home", path: "/" },
      { name: "Case Studies", path: "/case-studies" },
    ],
    schemas: [
      serviceSchema("Claw EA Case Studies", "Real-world deployments and pilot engagements for enterprise AI agent governance.", "https://www.clawea.com/case-studies"),
    ],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:900px">
        <h1>Case Studies</h1>
        <p class="lead">We are running pilot engagements with enterprise teams in financial services, healthcare, and technology. Named case studies will be published as pilots complete and customers approve.</p>

        <h2>Available Now</h2>
        <div class="grid-2">
          <a href="/case-studies/dogfood-claw-bureau" class="card" style="text-decoration:none;color:inherit">
            <h3>Claw Bureau: Dogfooding the Protocol</h3>
            <p>How we run 3 autonomous agents on our own codebase with full proof chains on every PR. 190+ PRs merged, 7 economy services, all passing verification.</p>
            <span style="color:var(--accent);font-weight:500">Read the case study &rarr;</span>
          </a>
          <div class="card" style="opacity:.7">
            <h3>Enterprise Pilot (Financial Services)</h3>
            <p>Production deploy approval workflow with proof bundles and SOX evidence export. Pilot in progress.</p>
            <span style="color:var(--text-muted);font-weight:500">Coming Q1 2026</span>
          </div>
        </div>

        <h2>Run Your Own Pilot</h2>
        <p>We deploy one workflow on proof bundles in two weeks. You get a proof bundle your auditor can verify offline, and you keep the infrastructure whether you continue or not.</p>
        <a href="/book" class="cta-btn cta-btn-lg" data-cta="case-studies-book">Book a pilot session</a>
      </div>
    </section>`,
  });
}

/* ── /case-studies/dogfood-claw-bureau ───────────────────────── */

export function caseStudyDogfoodPage(): string {
  return layout({
    meta: {
      title: "Case Study: Dogfooding the Clawsig Protocol | Claw EA",
      description: "How Claw Bureau runs 3 autonomous agents on its own monorepo with DID-signed commit proofs, Claw Verified PR pipeline, and 190+ PRs merged with full proof chains.",
      path: "/case-studies/dogfood-claw-bureau",
    },
    breadcrumbs: [
      { name: "Home", path: "/" },
      { name: "Case Studies", path: "/case-studies" },
      { name: "Dogfooding", path: "/case-studies/dogfood-claw-bureau" },
    ],
    schemas: [
      serviceSchema("Claw Bureau Dogfooding Case Study", "How Claw Bureau deploys its own protocol on its own codebase with autonomous agents and full proof chains.", "https://www.clawea.com/case-studies/dogfood-claw-bureau"),
    ],
    body: `
    <section class="section content-page">
      <div class="wrap" style="max-width:900px">
        <span class="badge badge-green">Case Study</span>
        <h1>Dogfooding: Running the Protocol on Our Own Codebase</h1>
        <p class="lead">The most credible proof of a protocol is using it yourself. Every PR to the Claw Bureau monorepo carries a verifiable proof chain, generated by the same protocol we sell to enterprise customers.</p>

        <h2>The Setup</h2>
        <div class="grid-2" style="margin-bottom:2rem">
          <div class="card" style="text-align:center">
            <div style="font-size:2.5rem;font-weight:700;color:var(--accent)">3</div>
            <div>Autonomous agents</div>
          </div>
          <div class="card" style="text-align:center">
            <div style="font-size:2.5rem;font-weight:700;color:var(--accent)">190+</div>
            <div>PRs merged with proof</div>
          </div>
          <div class="card" style="text-align:center">
            <div style="font-size:2.5rem;font-weight:700;color:var(--accent)">12</div>
            <div>Services in production</div>
          </div>
          <div class="card" style="text-align:center">
            <div style="font-size:2.5rem;font-weight:700;color:var(--accent)">22</div>
            <div>Conformance vectors passing</div>
          </div>
        </div>

        <h2>How It Works</h2>
        <h3>1. Agent generates code</h3>
        <p>Each agent operates in a dedicated worktree of the monorepo. It reads task specifications (PRDs, roadmap stories), generates implementation code, runs typechecks and tests, and commits the result.</p>

        <h3>2. Commit is signed with DID</h3>
        <p>After commit, the agent runs <code>sign-message.mjs "commit:&lt;sha&gt;"</code> to produce a <code>commit.sig.json</code> — an Ed25519 signature over the commit SHA, bound to the agent's DID. This file is committed alongside the code.</p>
        <pre><code>{
  "version": "m1",
  "type": "message_signature",
  "algo": "ed25519",
  "did": "did:key:z6Mkt...m8XW",
  "message": "commit:d4df105...",
  "createdAt": "2026-02-12T12:21:40.739Z",
  "signature": "base64-encoded-ed25519-signature"
}</code></pre>

        <h3>3. PR is created and pushed</h3>
        <p>The agent pushes its branch and creates a PR with a structured body listing all changes, their rationale, and deployment evidence.</p>

        <h3>4. Claw Verified PR check runs</h3>
        <p>A GitHub Actions workflow triggers on every PR. It:</p>
        <ul>
          <li>Finds all <code>proofs/**/commit.sig.json</code> files in the PR diff</li>
          <li>Verifies each signature against the declared DID public key</li>
          <li>Validates proof bundle artifacts if present</li>
          <li>Reports PASS/FAIL with machine-readable reason codes</li>
        </ul>

        <h3>5. Merge produces evidence</h3>
        <p>The merged PR becomes a permanent, auditable record: code + proof artifact + verification result. Anyone can clone the repo, find the proof, and re-verify independently.</p>

        <h2>What This Proves</h2>
        <ul>
          <li><strong>The protocol works at scale:</strong> 190+ PRs across protocol, economy, and marketing services — all with proof chains</li>
          <li><strong>Agents can self-prove:</strong> No human intervention required for proof generation. The agent signs its own work.</li>
          <li><strong>Verification is real:</strong> The GitHub Actions check is not a mock. It runs the actual verification algorithm on every PR.</li>
          <li><strong>The workflow is sustainable:</strong> This has been running continuously since the repository's inception. It is not a demo.</li>
        </ul>

        <h2>Verify It Yourself</h2>
        <p>The Claw Bureau monorepo is available on GitHub. You can:</p>
        <ol>
          <li>Browse the <code>proofs/</code> directory to see commit proof files</li>
          <li>Check the GitHub Actions tab to see Claw Verified PR checks passing</li>
          <li>Clone the repo and re-run verification locally with the reference verifier</li>
        </ol>
        <p>No trust required. The evidence is public and the verifier is deterministic.</p>

        <h2>Lessons Learned</h2>
        <ul>
          <li><strong>Proof generation adds negligible overhead:</strong> Signing a commit takes milliseconds. The bottleneck is always the code generation, never the proof.</li>
          <li><strong>DID key management matters:</strong> Each agent needs its own key pair. We store agent keys in isolated secret stores, not in shared config.</li>
          <li><strong>Proof artifacts should live in the repo:</strong> Storing proofs alongside code means they are version-controlled, diffable, and reviewable in the PR.</li>
          <li><strong>Fail-closed verification catches real issues:</strong> Unknown schema versions, missing fields, and expired signatures all fail closed. This has caught real bugs in proof generation.</li>
        </ul>
      </div>
    </section>
    <section class="section">
      <div class="wrap">
        <div class="cta-banner">
          <h2>Run the same workflow on your codebase</h2>
          <p>Start with one repository, one agent, one proof pipeline. See it work before committing to a broader rollout.</p>
          <a href="/book" class="cta-btn cta-btn-lg" data-cta="dogfood-book">Book a pilot session</a>
          <a href="/guides/github-actions-proof-pipeline" class="cta-btn cta-btn-outline cta-btn-lg" style="margin-left:.75rem" data-cta="dogfood-guide">Setup guide</a>
        </div>
      </div>
    </section>`,
  });
}
