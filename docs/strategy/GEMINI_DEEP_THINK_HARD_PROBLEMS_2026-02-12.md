# Gemini Deep Think: Hard Problems Resolution (2026-02-12)

> Canonical architectural decisions for the Notary Architecture.
> Generated by Gemini Deep Think in response to 5 hard open problems post-pivot.
> These decisions are binding unless explicitly superseded.

---

## Problem 1: Cryptographic Payment-Proof Binding (The Atomic Receipt)

**Decision: Bidirectional Hash Cross-Commitment**

We cannot make the blockchain and the gateway settle simultaneously without locking the gateway into a synchronous holding pattern. Instead, we bind the **authorization** of the payment to the **execution** of the receipt, making the proxy the cryptographic witness to the transaction.

### 1. The Request Phase (x402 `exact` or `upto`)

When the agent constructs the x402 `PaymentPayload` (to get the `PAYMENT-SIGNATURE`), it must inject a specific cryptographic commitment into the x402 metadata: the `X-Idempotency-Key` or `X-Run-Id` it intends to use for the `clawproxy` request.

*Result:* The payment authorization is now cryptographically locked to one specific execution attempt. It cannot be replayed for a different prompt.

### 2. The Execution Phase (`clawproxy`)

The agent sends the LLM request to `clawproxy` with the `PAYMENT-SIGNATURE` header.

- `clawproxy` verifies the x402 payment signature (fast, stateless Ed25519/SECP256k1 verify).
- It verifies that the x402 metadata commitment matches the `X-Idempotency-Key`.
- It proxies the call to the LLM.

### 3. The Settlement and Receipt Phase

For an `upto` (streaming LLM tokens) scheme, `clawproxy` waits until the stream finishes, calculates the exact token cost, and calls the x402 facilitator to settle the final amount.

- `clawproxy` then generates the `GatewayReceipt`.
- It embeds the payment proof into the receipt's `metadata`, specifically hashing the exact `PaymentPayload` it received.

### Schema Update (`packages/schema/poh/gateway_receipt.v1.json`)

```json
"metadata": {
  "x402_payment_auth_hash_b64u": {
    "type": "string",
    "description": "sha256_b64u(x402_PaymentPayload) - proves authorization was present at execution"
  }
}
```

### Adversary Defeat Matrix

| Attack | Defense |
|--------|---------|
| Pay without executing | Impossible. The x402 payment signature is useless to the employer unless the gateway countersigns it inside the GatewayReceipt. |
| Execute without paying | Impossible. `clawproxy` rejects the request at the edge (402 Payment Required). |
| Replay old receipt with new payment | The Clawsig receipt cryptographically signs `x402_payment_auth_hash_b64u`. If the agent submits a different x402 transaction to the employer, the hash won't match the receipt. |
| Asynchronous settlement (`upto` scheme) | The `upto` scheme authorizes a maximum spend. The receipt captures the authorized signature and the proxy's asserted actual tokens. The blockchain settlement can happen hours later. Offline verifiers check the authorization math; online verifiers can optionally query the facilitator network to ensure settlement actually cleared. |
| Amount blinding | The receipt only contains a hash. The verifier knows a payment was made, but cannot see the USD/ETH amount unless the agent explicitly provides the PaymentPayload sidecar file to the verifier. |

---

## Problem 2: The Claw Verified GitHub App — Trust Model Design

**Decision: Repo-Anchored TOFU (Trust On First Use) + Gateway Allowlist**

You cannot rely on a global PKI for agents. The trust anchor must be the GitHub repository itself, combined with the gateway's cryptographic attestation.

### 1. Policy Issuer Identity (Repo-Anchored Web2 Trust)

- Who signs the `.clawsig/policy.json` (WPC)? For v1, **no one**.
- The policy file in the repository's default branch (`main`) is the source of truth.
- *Trust Chain:* We rely on GitHub's native branch protection rules (Web2 trust). If an attacker can merge a weakened policy to `main` bypassing human code review, the repo is already compromised.

### 2. Gateway Identity (The Allowlist)

- The GitHub App (`@clawbureau/clawverify-cli`) maintains a hardcoded, open-source allowlist of trusted Gateway DIDs (`GATEWAY_RECEIPT_SIGNER_DIDS`).
- *Why:* You cannot trust an agent to run its own gateway. The gateway signature is the only proof that an LLM actually generated the response and consumed tokens.

### 3. Agent Identity (Informational)

- The agent generates an ephemeral `did:key` in memory when it starts.
- The identity is self-asserted. We do not care if it is "Claude Code" or "Devin". We care what the agent actually did.
- The agent DID simply mathematically links the steps of the `event_chain` together.

### 4. Preventing Bundle Fabrication (Zero-Knowledge Provenance)

- An agent can fabricate a `tool_receipt`. An agent can fabricate an `event_chain`. But an agent **cannot fabricate a `gateway_receipt`** without the gateway's private key.
- The agent claims it wrote a file: `tool_receipt` says `write_file("main.ts", content_hash="abc")`.
- The GitHub App looks at the actual PR diff on GitHub and hashes the changed files.
- If the PR diff hash matches the `tool_receipt` hash, and the `tool_receipt` is cryptographically linked in the `event_chain` to a `gateway_receipt` signed by a Trusted Gateway, **provenance is established.** The App knows the LLM explicitly requested this exact code change.

### Minimum Viable Trust Model (v1) UX

When the PR is opened, the GitHub App posts a check run:

```
Claw Verified: PASS
- Identity: Unverified Agent (did:key:z6Mk...)
- Intelligence: Verified via clawproxy.com (Tier: gateway)
- Policy: Compliant with main:.clawsig/policy.json
- Side-Effects: 0 network calls, 4 files modified.
```

---

## Problem 3: EIP-8004 Validation Oracle — Contract Architecture

**Decision: Agent-Funded EIP-712 Off-Chain Signatures (Claw Bureau Never Pays Gas)**

### On-Chain Payload (Minimum)

```solidity
struct ValidationResult {
    uint256 agentId;          // EIP-8004 NFT ID
    bytes32 bundleHash;       // SHA256 of the Clawsig Proof Bundle
    bytes32 policyHash;       // The WPC enforced
    bool isValid;             // PASS/FAIL
    bytes4 reasonCode;        // 4 bytes mapping to REASON_CODE_REGISTRY (e.g., "OK\0\0")
    uint8 proofTier;          // 0=Unknown, 1=Self, 2=Gateway, 3=Sandbox
}
```

### The Flow (Who Pays Gas?)

1. Agent completes work and gets the `proof_bundle.json`.
2. Agent submits the bundle to the free `api.clawverify.com`.
3. `clawverify` evaluates the bundle. Instead of just returning a JSON response, it returns an **EIP-712 signed message** of the `ValidationResult`, signed by the `ClawOracle` private key.
4. The **Agent** (or the employer) takes this signature and calls `submitValidation` on the EIP-8004 contract, paying the gas themselves.

### Dispute Resolution (Policy vs. Outcome)

Claw Bureau strictly attests to **Execution Provenance and Policy Compliance** (`isValid = true`). We are proving the agent didn't hallucinate tools or steal secrets. We are not proving the code is bug-free. Quality assessment is left to the employer's on-chain reputation feedback mechanism in EIP-8004. We are the syntax checker; the employer is the semantic judge.

### Multi-Chain Architecture

Deploy identical, lightweight Validation Oracle contracts on Base, Arbitrum, and Optimism. Do not use bridges. The `clawverify` backend simply signs the EIP-712 message for whatever `chainId` the agent requests.

---

## Problem 4: Protocol Adoption Flywheel — Getting to 1000 Repos

**Decision: Supply-Side Infiltration via the "Trojan Horse" Security Wedge**

Do not sell "Verification". Sell **"Protection against AI Supply Chain Attacks."** Target the Agent Frameworks, not the repo owners.

### Distribution Channels (Ranked by ROI)

1. **Direct Integration with Open Source Agents (Highest ROI):** Submit PRs to LangChain, CrewAI, Aider, and OpenHands to natively emit `.clawsig` bundles using `@clawbureau/clawsig-sdk`. If the tools emit the format by default, repos will install the app to read them.
2. **GitHub Marketplace Listing (High ROI):** Captures the exact moment of intent. "AI PR Reviewer" is crowded; "Cryptographic AI Verifier" is an empty space we will own.
3. **Twitter/X (AI/DevSecOps niche):** Share the 60-second "Aha Moment" prompt injection video.
4. **Discord Developer Communities:** Direct outreach to builders who want to prove to their bosses that their local agents are safe.

### The "Aha Moment" Demo (60 Seconds)

*Split Screen:*
- *Left Side (The Attack):* A popular open-source agent is instructed to "fix the database connection." It is prompt-injected via a malicious GitHub Issue. It secretly `curl`s the repo's `.env` file to a Russian IP, then pushes a seemingly benign CSS fix PR.
- *Right Side (The Defense):* The PR opens. Instantly, the "Claw Verified" GitHub App flashes FAILED.
- *The Log:* `POLICY_VIOLATION: Unauthorized Network Egress to attacker.com`.
- *The Kicker:* The human never had to read the code. The cryptography proved the agent violated the repo's `.clawsig/policy.json`.

### Target Segment

**Enterprise repos using Cursor/Claude Code that need audit trails.** CISOs at Fortune 500s are currently banning AI coding tools because they can't track what they do. Pitch: "You don't need to ban Claude Code. You just need to require the Claw Verified GitHub App. It guarantees the agent didn't touch unauthorized files."

### The Moat

The moat is not the CLI code (it's open source). The moat is the **schema standard** and the **Gateway Allowlist**. If 1,000 repos configure their CI to require `clawproxy.com` signatures, a competitor cannot just fork the app — they would have to convince 1,000 repo admins to change their `.clawsig` trust anchors to point to a new gateway. In infrastructure, inertia is the ultimate moat.

---

## Problem 5: The MTS Gap — Side-Effect Receipts in Production

**Decision: Tiered Observation Environments + GitHub Approval Minting Authority**

We abandon the idea that we can observe everything perfectly on a standard MacBook. We rely on the `proof_tier` system to represent the strength of the observation.

### Observation Tiers

**Tier 1: Best-Effort (SDK Interception)**
- Used for local CLI agents.
- The `@clawbureau/clawsig-sdk` monkey-patches `fetch`, `fs.writeFile`, and `child_process.exec`.
- When the agent requests a network call, the harness executes it, records the `side_effect_receipt`, and passes the result to the LLM.
- *Verifier Semantics:* The verifier labels these `proof_tier=self`. It proves the agent reported doing this. It does not prove the agent didn't do other things. (But if they touch repo files, the PR diff hash catches them.)

**Tier 2: Hardened (clawea Sandbox)**
- Used for Enterprise workloads.
- The Cloudflare Sandbox intercepts all syscalls at the V8 Isolate level.
- The Sandbox emits the side-effect receipts, not the agent SDK.
- *Verifier Semantics:* The verifier labels these `proof_tier=sandbox`. It is cryptographically guaranteed that no other side-effects occurred.

### Side-Effect Taxonomy and Hashing

| Category | `target` | `request_hash` | Notes |
|----------|----------|-----------------|-------|
| Network Egress | URL | SHA256(Headers + Body) | `vendor_id` = Domain |
| File System | Absolute Path | SHA256(File Contents Written) | |
| Process Execution | Command | SHA256(Args) | `response_hash` = SHA256(Stdout + Stderr) |

### Human Approval Receipts in CI/CD (The GitHub AMA)

When a WPC requires human approval for a specific side effect (e.g., `external_api_write` to production AWS):

1. The agent hits a policy block in the SDK. It emits a `CapabilityRequest` containing a `plan_hash_b64u` (hash of the proposed AWS payload).
2. The agent posts a PR comment: "Awaiting capability: deploy:production. Approvers, reply `/claw approve`."
3. A repo admin replies `/claw approve`. The GitHub App receives the webhook. Because GitHub authenticates the user, the App verifies the user is an admin.
4. The GitHub App (using its private `did:key`) mints a `human_approval_receipt.v1.json`, setting `approver_subject` to `github:username`.
5. The App mints a short-lived Capability Token (CST) and passes it back to the agent as a GitHub Actions environment variable (or via a secure comment).
6. The Agent executes the side effect using the CST. The final `proof_bundle` contains the `HumanApprovalReceipt`. `clawverify` checks that the Side-Effect hash matches the approved Plan Hash.

This bridges the gap between synchronous human identity (GitHub OAuth) and asynchronous cryptographic proof (Clawsig Bundle), keeping the final bundle 100% offline verifiable.

---

## Cross-Cutting Decisions Summary

| Decision | Binding? | Affects |
|----------|----------|---------|
| Bidirectional hash cross-commitment for x402+receipt | Yes | Phase 4 (x402), gateway_receipt schema |
| Repo-anchored TOFU for WPC trust | Yes (v1) | Phase 5 (GitHub App) |
| Gateway DID allowlist (hardcoded) | Yes (v1) | Phase 5 (GitHub App), clawverify-core |
| Agent identity is informational only | Yes | All phases |
| PR diff hash matching for fabrication prevention | Yes | Phase 5 (GitHub App) |
| EIP-712 off-chain signatures (agent pays gas) | Yes | Phase 3 (EIP-8004 oracle) |
| ValidationResult struct as on-chain minimum | Yes | Phase 3 (Solidity contract) |
| Multi-chain deploy (no bridges) | Yes | Phase 3 |
| Supply-side infiltration (target agent frameworks) | Yes | Go-to-market |
| "AI Supply Chain Attack" security framing | Yes | All messaging |
| Tiered observation (self vs. sandbox) | Yes | Protocol v0.2 |
| GitHub AMA for human approval | Yes | Phase 5 (GitHub App) |
