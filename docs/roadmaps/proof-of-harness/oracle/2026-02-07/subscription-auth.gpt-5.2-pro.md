- Subscription products (ChatGPT / gemini.google.com / Claude web / Claude Code subscription token) generally authenticate via **web sessions/cookies or proprietary tokens**, not stable API keys, so you cannot directly reuse the current **`clawproxy → signed gateway_receipt`** mechanism (per *File 1: `docs/roadmaps/proof-of-harness/ADAPTER_SPEC_v1.md` §5 and *File 7: `packages/schema/poh/proof_bundle.v1.json` receipts schema).
- If an attacker can run arbitrary local wrappers (your constraint), then **any purely-local “web run proof” is forgeable** unless you (a) shift execution to an **attested environment**, or (b) add **independent witnesses** that sign what they observed.
- The cleanest “high-trust” path remains: **route inference through `clawproxy`** (BYOK API keys *or* platform-paid keys) and keep “subscription web” as **low trust** until you can attest execution.
- Therefore: treat “subscription auth support” as primarily an **auth UX feature**, not a trust upgrade, unless you also change the **execution location** (remote sandbox/TEE) or add **witness attestations**.
- Realistic evidence classes you can produce for web/subscription runs:
  1) **Self-asserted artifacts** (screenshots/HAR/transcripts) — useful for audits, not for tier upgrades.
  2) **Witness-signed web receipts** generated by a controlled runner (remote browser automation that can see decrypted network via DevTools).
  3) **Sandbox/TEE execution attestations** that bind the run (URM + event chain) to an attested runtime plus captured web evidence.
- Don’t assume providers expose stable “web receipts” or verifiable usage tokens; instead, plan to **confirm by measurement** (capture real traffic from each harness).
- You already have a browser automation precedent in Oracle CLI (“engine: browser” for ChatGPT + Gemini cookies) (*File 9: `oracle-help.txt`), which suggests a practical v2 path: “remote oracle serve” as a **witness/attester**.
- Claude Code has `setup-token (requires Claude subscription)` (*File 8: `claude-help.txt`), but it’s unknown whether that token can be used against official Anthropic APIs or only Claude Code endpoints—this must be tested before designing around it.
- The PoH tier system in the spec is `self | gateway | sandbox` (*File 1* §2). “Web subscription proofs” should **not** count as `gateway` unless they result in **verifiable third-party receipts** (either `clawproxy` receipts or an allowlisted attestation authority).
- You likely need a **new envelope type** for “web/subscription runs,” because the current `receipts[]` schema is hard-typed to `envelope_type: gateway_receipt` (*File 7*).
- `clawverify` currently verifies gateway receipts and binding to event chains (*File 6: `services/clawverify/src/verify-proof-bundle.ts` `verifyReceiptEnvelope()`), but it does **not** yet recompute event hashes (noted in *File 1* §10). Any new receipt type should reuse the same binding rules (run_id + event_hash).
- Recommendation summary:
  - **v1:** keep high-trust as `clawproxy` receipts (BYOK or platform-paid); accept subscription web runs only as **self/low trust** evidence bundles.
  - **v2:** add an allowlisted **witness-runner** (remote browser) that issues **witness-signed web receipts** bound to the event chain; optionally elevate to `sandbox` tier once you add genuine remote attestation (or treat as a weaker “sandbox-lite” policy externally).
- Operationally, the most important near-term fix remains the receipt format alignment between `clawproxy` and `clawverify` (*File 1* §5.3), otherwise even API-key runs can’t reliably claim `gateway`.

---

## Options table (subscription-based auth + verifiable evidence)

| Option | What you do | Evidence you can produce | Security (gameability) | Privacy | ToS / practical constraints | Ops complexity | Fit into PoH tiers |
|---|---|---|---|---|---|---|---|
| A. Do nothing special: require API keys (status quo) | User supplies API key; route via `clawproxy` | **`gateway_receipt`** SignedEnvelope + event binding | Strong vs replay if binding enforced (already in `clawverify`) (*File 6*) | Good: hash-only / encrypted receipts exist in `clawproxy` (*File 4*, *File 5*) | Generally compliant (official APIs) | Low/medium | **gateway** (and later sandbox) |
| B. Platform-paid inference (no user key) | User authenticates to your platform; `clawproxy` uses platform keys | Same as A (`gateway_receipt`), plus CST binding (`token_scope_hash_b64u`) (*File 3*, *File 5*) | Strong (third-party signed receipts; attributable DID) | Good; policy-based redaction/confidential mode supported (*File 4*) | Needs billing/rate limits; still official APIs | Medium | **gateway** |
| C. Local “web session adapter” (cookies on user machine) | User runs wrapper/extension that calls ChatGPT/Gemini/Claude web; you log DOM/network locally | Screenshots/video, HAR, DOM snapshots, transcript hashes, local signature | **Weak** under your threat model: attacker can forge logs, patch wrapper, fake DOM/network traces | Risky: captures user content + cookies unless very careful | Likely ToS concerns: automation, scraping, cookie handling; also brittle UI changes | Medium | **self** only (audit artifact, not tier upgrade) |
| D. Local browser + remote timestamping/notary | User runs locally; submits hashes of artifacts to a notary service (timestamp / transparency log) | “Notarized at time T” hashes of transcript/HAR/video | Still forgeable content; only proves *existence at time* | Better (you only see hashes) | Still ToS risk; still brittle | Medium | Still **self** (slightly better audit) |
| E. Remote browser witness runner (non-TEE) | Run the web session in your controlled infra (CDP/Playwright). User interacts via remote session; runner captures network/DOM and signs receipts | **Witness-signed `web_receipt`** bound to run/event + optional artifacts (HAR/video) | Better: attacker can’t forge witness signature if witness keys protected; still must trust your runner isn’t compromised | High risk: runner can see prompts/responses; must offer hash-only logging modes | ToS risk remains (automation); storing accounts/cookies is sensitive; need safe “bring your own login” flow | High | Could be treated as **sandbox** only if allowlisted as an attestation authority; otherwise “self+3rd-party witness” policy |
| F. Remote browser in attested sandbox/TEE | Like E, but runner produces remote attestation (TEE quote) | Witness-signed `web_receipt` + **execution attestation** (allowlisted) | Strongest practical (prevents tampering with runner) | Still sees plaintext unless you build confidential pipelines; but can constrain retention | ToS issues unchanged; still brittle | Very high | **sandbox** |
| G. Provider partnership / official web receipts | Providers expose verifiable receipts or signed usage statements for subscription sessions | Provider-signed receipt chain | Strong | Potentially best | Unknown availability; must not assume | Very high (biz + eng) | **gateway** (or stronger) |
| H. Claude Code “setup-token” reused as API credential (speculative) | Investigate whether Claude Code subscription token can call official API endpoints; if yes, route via `clawproxy` | If it works, standard `gateway_receipt` | Strong (like A/B) | Good | Unknown; must confirm by traffic inspection; could violate ToS if token intended only for Claude Code | Medium | **gateway** if confirmed |
| I. Hybrid: subscription web run + API “shadow receipt” | During web run, also call official API with same prompt to get `clawproxy` receipt | `gateway_receipt` for shadow call + web transcript hashes | Doesn’t prove the web UI used that model/session; only proves *some* API call happened | Good | Costly; mismatched results; weak semantic link | Medium | `gateway` only for the shadow call; web part remains **self** |

---

## Recommended plan (v1 / v2)

### v1 (smartest now)
**Goal:** support subscription-based auth *as a UX feature* without claiming high trust.

1) **Keep “high trust” exclusively through `clawproxy`**:
   - BYOK API keys (existing).
   - Platform-paid (recommended default for users without keys) using CST + DID binding already present in `clawproxy` (*File 3* shows CST logic and binding extension with `tokenScopeHashB64u`).

2) **Add “subscription web runs” only as `self` tier evidence**:
   - Accept PoH bundles that include:
     - event_chain
     - URM
     - **web evidence artifacts** (hashes + references)
   - Do **not** upgrade tier unless there is an allowlisted third-party signature (receipt or attestation).

3) **Explicitly label these as “self/low trust” in marketplace policy**:
   - Because local wrappers are forgeable under your threat model.

4) **Close the current gateway gap first**:
   - Resolve `clawproxy` receipt format vs `clawverify` expectations (*File 1* §5.3). You already generate `_receipt_envelope` as `SignedEnvelope<GatewayReceiptPayload>` in `clawproxy` (*File 5*), so the simplest path is usually “make everyone use `_receipt_envelope` and ensure `clawverify` allowlists the `signer_did` (did:key)”.

### v2 (raise trust for subscription/web)
**Goal:** enable a path where subscription-based access can still generate third-party-verifiable evidence.

1) **Introduce a Witness Runner / Web Attester service** (can be built on your existing Oracle browser engine concept, cf. *File 9* “`oracle serve`” / remote delegation):
   - It runs the browser session in controlled infra, captures:
     - prompt/response hashes
     - network request/response hashes (via CDP network events)
     - DOM snapshot hashes / screenshot/video hashes
   - It issues a **witness-signed receipt envelope** bound to `run_id` and `event_hash_b64u`.

2) **Optionally elevate to `sandbox` tier only when**:
   - The witness runner is itself **attested** (TEE quote / signed measurement) or is otherwise an allowlisted “execution attestation authority” (aligns with *File 1* §8 “execution attestation (future)”).

3) **Do not call it `gateway`** unless you can cryptographically bind to a trusted API gateway receipt:
   - `gateway` in PoH is currently anchored on `clawproxy` signed receipts bound to the event chain (*File 1* §2, §5; *File 6* binding enforcement).

---

## Concrete evidence formats (new envelopes) + clawverify validation

### 1) New envelope: `web_receipt` (witness-signed)
Define `SignedEnvelope<WebReceiptPayload>`:

```jsonc
{
  "envelope_version": "1",
  "envelope_type": "web_receipt",
  "payload": {
    "receipt_version": "1",
    "receipt_id": "wrcpt_...",
    "witness_id": "did:web:oracle-witness.example#key1",          // or did:key
    "platform": "chatgpt_web|gemini_web|claude_web|claude_code",
    "model_label": "best_effort_string",                          // do not overclaim
    "timestamp": "2026-02-07T12:34:56.789Z",

    "request_hash_b64u": "...",                                   // hash of the user message / uploaded bundle bytes
    "response_hash_b64u": "...",                                  // hash of assistant final text bytes

    "artifacts": {
      "har_hash_b64u": "...",
      "video_hash_b64u": "...",
      "dom_snapshot_hash_b64u": "..."
    },

    "binding": {
      "run_id": "run_...",
      "event_hash_b64u": "...",
      "nonce": "..."
    },

    "metadata": {
      "target_url": "https://chatgpt.com/... (optional)",
      "session_fingerprint_hash_b64u": "...",                      // hash-only
      "account_hint_hash_b64u": "..."                              // hash-only
    }
  },
  "payload_hash_b64u": "...",
  "hash_algorithm": "SHA-256",
  "signature_b64u": "...",
  "algorithm": "Ed25519",
  "signer_did": "did:key:...",                                     // witness signer
  "issued_at": "..."
}
```

**Validation in `clawverify`:**
- Add `web_receipt` to allowed envelope types (schema registry + verifier).
- Verify envelope signature exactly like gateway receipts.
- Enforce **binding rules identical to `verifyReceiptEnvelope()`** (*File 6*):
  - proof bundle must include a valid `event_chain`
  - `payload.binding.run_id` must equal event_chain run_id
  - `payload.binding.event_hash_b64u` must be a member of event_chain hashes
- Tier logic:
  - `web_receipt` **does not** imply `gateway`.
  - It can count toward a new internal component flag like `web_receipts_valid`, and marketplace policy may treat it as “witnessed” (still below `gateway` unless you decide to map “allowlisted witness” to `sandbox`).

### 2) Execution attestation envelope: `execution_attestation` (for sandbox tier)
This matches your planned direction (*File 1* §8). Payload should minimally bind:
- `run_id`
- URM hash
- event chain root hash
- list of included receipt hashes (gateway + web)
- runtime claims (runner image hash / measurement)
- attester DID + expiry

**Validation in `clawverify`:**
- Verify attestation signature against an allowlist.
- Verify the bound hashes match the proof bundle’s URM reference + event chain + receipts.

### 3) Where to store artifacts (HAR/video/DOM)
Keep artifacts **out of the signed payload** (except their hashes + content-addressed references). Put the actual bytes in:
- URM referenced artifact list (your URM schema is “to be added” per *File 1* §6.2), or
- a marketplace upload store keyed by `sha256_b64u`.

---

## Next implementation steps (short checklist)

1) **Confirm provider realities (no guessing):**
   - Capture real traffic for:
     - ChatGPT web session message send
     - Gemini web message send
     - Claude web message send
     - Claude Code `setup-token` usage (*File 8*) to see whether it hits official Anthropic APIs or proprietary endpoints.
   - Outcome: which flows can be proxied via `clawproxy` vs require web evidence.

2) **Fix/standardize gateway receipts end-to-end:**
   - Ensure adapters always collect `_receipt_envelope` from `clawproxy` (*File 5*), and `clawverify` accepts/allowlists its `signer_did`.
   - This addresses the spec gap (*File 1* §5.3).

3) **Add schemas:**
   - `packages/schema/poh/web_receipt.v1.json`
   - `packages/schema/poh/execution_attestation.v1.json` (placeholder if needed)

4) **Extend proof bundle schema + types:**
   - Add `web_receipts?: SignedEnvelope<WebReceiptPayload>[]` (new field) rather than overloading `receipts[]` (since *File 7* hard-consts `gateway_receipt`).

5) **Update `clawverify` to verify `web_receipt` envelopes:**
   - Signature verification + binding-to-event-chain logic (clone of *File 6* `verifyReceiptEnvelope()` semantics).

6) **Tier policy update:**
   - v1: `web_receipts` never raise above `self`.
   - v2: `web_receipts` + allowlisted `execution_attestation` can qualify for `sandbox`.

7) **Build the witness runner (v2):**
   - Start with non-TEE remote browser runner issuing `web_receipt` signatures.
   - Later, add genuine sandbox/TEE attestation and flip marketplace policy to treat it as `sandbox`.

8) **Privacy controls:**
   - Implement “hash-only web receipts” by default (store only hashes + minimal metadata).
   - Make any plaintext capture explicitly opt-in with retention limits.

Files referenced: *File 1* `docs/roadmaps/proof-of-harness/ADAPTER_SPEC_v1.md`, *File 3* `services/clawproxy/src/index.ts`, *File 4* `services/clawproxy/src/policy.ts`, *File 5* `services/clawproxy/src/receipt.ts`, *File 6* `services/clawverify/src/verify-proof-bundle.ts`, *File 7* `packages/schema/poh/proof_bundle.v1.json`, *File 8* `.../claude-help.txt`, *File 9* `.../oracle-help.txt`.
