## 0) Goal: “crypto correctness + interoperability” = **bit-for-bit parity with Rust**
Treat `moltbook/crates/openclaw-crypto` as the reference, and make TypeScript implementations **prove** parity via the golden vectors in `moltbook/fixtures/golden_vectors.json` (CI must fail on divergence per the file header).

Files referenced (source of truth):
- `moltbook/fixtures/golden_vectors.json`
- `moltbook/crates/openclaw-crypto/src/{did.rs,hash.rs,jcs.rs,sign.rs,verify.rs,types.rs}`
- `moltbook/fixtures/policy.schema.json`
- `moltbook/crates/openclaw-server/src/security/prompt_filter.rs`
- Existing TS: `02-Projects/clawbureau/openclaw-did-work/src/crypto.ts`, `02-Projects/clawbureau/skill-did-work/src/crypto.ts`, `02-Projects/clawbureau/skill-did-work/src/signing.ts`

---

## 1) Mapping table: moltbook artifacts → Claw Bureau targets

| Priority | Moltbook artifact (file/module) | What to port (concrete) | Target in Claw Bureau | Notes / acceptance test |
|---:|---|---|---|---|
| P0 | `moltbook/fixtures/golden_vectors.json` | Golden vectors for DID, sha256, JCS canonical string, base64 signature for artifact + message | `monorepo/packages/contracts/fixtures/protocol-m/golden_vectors.m1.json` | Add tests that assert **exact** match for `did`, `sha256_hex`, `canonical_jcs`, `signature_base64` |
| P0 | `openclaw-crypto/src/jcs.rs` (RFC8785 via `serde_jcs`) | JCS canonicalization semantics | **Unify** in TS: `openclaw-did-work/src/crypto.ts` and `skill-did-work/src/crypto.ts` to use the *same* RFC8785 implementation | `openclaw-did-work` already uses `json-canonicalize`; `skill-did-work` currently does not (gap) |
| P0 | `openclaw-crypto/src/did.rs` | did:key encoding/decoding rules incl. multicodec prefix 0xed01 and strict key sizing | `openclaw-did-work/src/crypto.ts`, `skill-did-work/src/crypto.ts`, plus shared helper in `monorepo/packages/contracts/src/did.ts` (optional but recommended) | Must enforce decoded length and pubkey length = 32 (see gaps below) |
| P0 | `openclaw-crypto/src/hash.rs` | SHA-256 hex lowercase | `monorepo/packages/contracts/src/hash.ts` (or keep in each crypto.ts but tested centrally) | Must match `golden_vectors.json.sha256_hex` for `hello world\n` |
| P0 | `openclaw-crypto/src/sign.rs` + `types.rs` envelope behavior | “signature is empty string during canonicalization”; metadata default `{}`; createdAt field naming; version/type/algo fail-closed | `clawverify` + `openclaw-did-work` + `skill-did-work` | Ensure `canonical_jcs` matches the fixture **exactly** |
| P0 | `openclaw-crypto/src/verify.rs` | Verification semantics: check version/type/algo, hash algo, recompute hash, size checks, signature length checks, fail-closed messaging | `clawverify` (primary), and align `did_work.verify` tools | TS `verify-tool.ts` currently doesn’t check size/hash.algo; add parity |
| P1 | `moltbook/fixtures/policy.schema.json` | Policy schema (draft 2020-12), patterns for DIDs, approval tiers | `monorepo/packages/schema/policy/claw.policy.v1.json` | Keep compatible fields; add canonical hash computation for policy enforcement |
| P1 | `openclaw-server/src/security/prompt_filter.rs` | Prompt/command injection pattern library + result format + thresholds | `clawproxy/src/safety/promptFilter.ts` (and optionally `clawverify/src/safety/promptFilter.ts`) | Port patterns and threshold behavior; add unit tests matching Rust tests |
| P2 | `docs/MOLTBOOK_SAFETY.md` | Human-readable safety policy to guide operator + reviewers | `clawproxy/docs/SAFETY.md` (or monorepo `docs/`) | Document must match enforcement behavior; link to TS filter module |
| P2 | Other `openclaw-crypto` modules exported in `lib.rs` (`merkle`, `rotation`, `manifest`, `event_log`, `registry_entry`, `review_vote`, CSC) | Only port what Claw Bureau needs next (likely rotation + event log + registry entry) | `packages/contracts` for types + `clawverify` for verification | Defer until you actually consume these envelopes |

---

## 2) Gaps / risks vs Rust reference (Rust code + vectors vs current TS)

### A) **JCS canonicalization mismatch (critical)**
- Rust: RFC 8785 via `serde_jcs` (`moltbook/crates/openclaw-crypto/src/jcs.rs`).
- TS:
  - `openclaw-did-work/src/crypto.ts` uses `json-canonicalize` (`canonicalize()`): good direction.
  - `skill-did-work/src/crypto.ts` implements a **non-RFC8785** canonicalizer using `JSON.stringify` + object key sorting only.

Risk details:
- RFC8785 also normalizes numbers, escaping, Unicode handling, and requires deterministic object serialization rules. The `skill-did-work` implementation can diverge on:
  - floats / exponent forms (relevant for CSC `percentage`, `confidence`)
  - nested structures where replacer behavior differs from strict JCS
  - edge cases like `-0`, `1e-7`, etc.
- Consequence: signatures generated by skill package may not verify in Rust or in the other TS package.

**Fix**: make both TS implementations use the same RFC8785 canonicalizer (`json-canonicalize`) and add golden-vector tests.

---

### B) **`metadata` presence/default differs (critical)**
- Rust envelopes always include `metadata`, default `{}`:
  - `SignatureEnvelopeV1.metadata: serde_json::Value` and `new()` sets `{}` (`types.rs`)
- Golden canonical string includes `"metadata":{}` explicitly (`moltbook/fixtures/golden_vectors.json`).

TS today:
- `openclaw-did-work/src/sign-tool.ts` sets `metadata` to possibly `undefined`, and `SignatureEnvelopeV1` marks it optional.
- If `metadata` is omitted/undefined, canonical JSON differs → signature differs → breaks golden vector + Rust interop.

**Fix**:
- Normalize envelopes before signing/verifying:
  - always set `metadata: {}` (empty object) if absent
  - for artifact signing, always include `artifact` and its `size` as integer.

---

### C) **DID decoding length not strict (critical/interoperability + safety)**
Rust `did_to_verifying_key()`:
- Requires decoded length ≥ 34, checks prefix bytes 0xed 0x01, then **uses bytes [2..34]** (ignores any trailing bytes).

TS today:
- `openclaw-did-work/src/crypto.ts` returns `decoded.slice(2)` (returns *all remaining bytes*), which can be **not 32 bytes** if the DID has trailing data.
- `skill-did-work/src/crypto.ts` checks extracted key length is 32 (good), but still doesn’t reject decoded lengths that aren’t exactly 34.

Risks:
- A malformed DID could cause verification to behave inconsistently across TS packages.
- In the worst case, you can get non-obvious verification failures or ambiguous encodings.

**Fix**:
- Enforce **decoded length exactly 34** and extracted pubkey length exactly 32 in both TS implementations.

---

### D) **Verification semantics not fully parity (correctness)**
Rust `verify_artifact()` checks (`moltbook/crates/openclaw-crypto/src/verify.rs`):
- version/type/algo exact
- hash algo exact = sha256
- recompute sha256 and compare
- verify `artifact.size` matches file length
- base64 decode errors are surfaced; signature length must be 64

TS `did_work.verify` (`openclaw-did-work/src/verify-tool.ts`) checks:
- version/type/algo
- recompute hash and compare
- does **not** validate:
  - `hash.algo === 'sha256'`
  - `artifact.size` vs actual bytes
  - base64 signature length = 64 bytes (relies on noble verify returning false)

**Fix**:
- Move Rust-parity verification into `clawverify` and have tools call into it.
- Make verification fail-closed and explicit (like Rust).

---

### E) **Signature/base64 format expectations**
Rust uses standard Base64 with padding (`base64::STANDARD`) and signs canonical bytes.
TS uses Buffer/base64 and should match.

Remaining risk:
- If any code switches to base64url or strips padding, golden vector signature comparison will fail.

**Fix**:
- Lock signature encoding to standard base64 with padding for envelopes (and test it against `golden_vectors.json.signature_base64`).

---

## 3) Step-by-step PR plan (small slices; PRs only; signed commits)

### PR#1 — Add golden vectors fixture + CI test harness
- Add `monorepo/packages/contracts/fixtures/protocol-m/golden_vectors.m1.json` copied from `moltbook/fixtures/golden_vectors.json`.
- Add test: `monorepo/packages/contracts/tests/protocolm.golden.test.ts` that:
  - reads the fixture
  - asserts:
    - DID derivation matches `did` for the known seed/public key
    - sha256(hex) of `file_bytes_utf8` matches `sha256_hex`
    - JCS canonical of the envelope (with signature cleared) equals `canonical_jcs` exactly
- This PR should not change runtime code; it just installs “truth”.

Acceptance:
- Test fails if any byte differs from fixture.

---

### PR#2 — Fix/standardize JCS in `skill-did-work` to RFC8785
- Replace `skill-did-work/src/crypto.ts` `jcsCanonical()` implementation with `json-canonicalize` (same as `openclaw-did-work/src/crypto.ts`).
- Add a unit test in `skill-did-work` that canonicalizes the fixture envelope and matches `golden_vectors.json.canonical_jcs`.

Acceptance:
- `skill-did-work` can reproduce canonical string exactly.

---

### PR#3 — Enforce envelope normalization (metadata `{}` + required fields) before signing
Implement a shared normalization function (either duplicated initially, then dedup later):
- `normalizeEnvelopeV1ForSigning(envelope)`:
  - ensure `metadata` exists (default `{}`)
  - ensure `signature` is set to `""` for canonicalization
  - ensure `artifact.size` is an integer for artifact envelopes
- Apply in:
  - `openclaw-did-work/src/crypto.ts` `signEnvelope()`
  - `skill-did-work/src/crypto.ts` `signEnvelope()`
  - `skill-did-work/src/signing.ts` `signMessage()` (it hand-rolls canonicalization today)

Acceptance:
- Both packages reproduce fixture signature exactly (next PR adds signature assertion).

---

### PR#4 — DID decode strictness (exact 34 bytes, pubkey 32 bytes)
- Update:
  - `openclaw-did-work/src/crypto.ts didToPublicKey()`
  - `skill-did-work/src/crypto.ts didToPublicKey()`
- Add tests:
  - valid golden DID round-trip equals itself
  - malformed DID with extra trailing bytes is rejected (decoded length != 34)

Acceptance:
- Identical DID parsing rules across TS components.

---

### PR#5 — Signature equality test vs golden vector (artifact + message)
- Extend contracts tests to:
  - derive signing key from `seed_hex` and sign:
    - artifact envelope with `createdAt` from fixture, `artifact.name/size`, `hash.value`, metadata `{}`, signature empty during canonicalization
    - message envelope from `message_signature.envelope`
  - assert resulting base64 signature equals:
    - `signature_base64` for artifact
    - (you may need to add the message signature expected value later; fixture currently provides canonical but not explicit signature—consider extending fixture upstream or compute/record once in Rust and copy it)

Acceptance:
- TS signing is interoperable with Rust reference (bit-for-bit).

---

### PR#6 — Centralize verification in `clawverify` with Rust-parity checks
- Add `clawverify` module: `verifyArtifactEnvelopeV1(fileBytes, envelope)` implementing checks from `moltbook/crates/openclaw-crypto/src/verify.rs`.
- Update `openclaw-did-work/src/verify-tool.ts` and/or `skill-did-work` verification to call `clawverify` instead of local loose verification.

Acceptance:
- Verification rejects size mismatch, wrong hash algo, wrong signature length, wrong version/type/algo.

---

### PR#7 — Import policy schema into `packages/schema` + add policy hash computation
- Add `monorepo/packages/schema/policy/claw.policy.v1.json` based on `moltbook/fixtures/policy.schema.json` (details below).
- Add a tiny TS helper in (suggested) `packages/contracts/src/policy.ts`:
  - `validatePolicy(policyJson)`
  - `canonicalPolicy(policyJson)` using JCS
  - `policyHashB64u = base64url(sha256(canonicalBytes))`

Acceptance:
- Policy can be validated and hashed deterministically.

---

### PR#8 — Port prompt filter into TS + wire into clawproxy/clawverify
- Port patterns + threshold behavior from `moltbook/crates/openclaw-server/src/security/prompt_filter.rs`.
- Add unit tests mirroring Rust tests (rm -rf, curl|bash, env var access, etc.).
- Integrate in `clawproxy` request pipeline (no deploy; just code + tests).

Acceptance:
- Same pattern names and severity logic; fail-closed threshold matches Rust.

---

## 4) Turning `policy.schema.json` into a Claw Bureau schema (ID/versioning/consumption)

### A) Schema file + `$id` convention
You already use `https://schemas.clawbureau.org/...` with namespaced IDs (see `monorepo/packages/schema/*/*.v1.json`, e.g. `commit_proof.v1.json`).

Create:
- `monorepo/packages/schema/policy/claw.policy.v1.json`
  - `$id`: `https://schemas.clawbureau.org/claw.policy.v1.json`
  - `$schema`: draft 2020-12
  - Keep the existing field names for interoperability:
    - keep `"version": { "const": "1.0" }` (from `moltbook/fixtures/policy.schema.json`)
  - Keep the DID regex pattern exactly as in the source schema (`^did:key:z[1-9A-HJ-NP-Za-km-z]+$`)

Why keep `"version": "1.0"`?
- It’s already the compatibility gate in the legacy schema; changing it forces migration. You can introduce a future `claw.policy.v2.json` later that uses `policy_version: "2"` if you want.

### B) How it’s consumed (clawproxy enforcement + clawverify)
Recommended flow:

1) **Load + validate**
- `clawproxy` loads a policy JSON document (from config, token claim, or attachment).
- Validate against the schema with Ajv 2020.

2) **Canonicalize + hash**
- Canonical bytes = RFC8785 JCS of the policy JSON.
- Hash = sha256(canonical bytes)
- Encode = base64url (no padding) to match your other “*_b64u” conventions (see `scoped_token_claims.v1.json` fields like `policy_hash_b64u`).

3) **Bind to tokens**
- Your existing `monorepo/packages/schema/auth/scoped_token_claims.v1.json` includes `policy_hash_b64u`.
- `clawproxy` should:
  - compute hash of the policy it is enforcing
  - require claim `policy_hash_b64u` to match (if present)
  - reject if mismatch (fail-closed)

4) **clawverify**
- `clawverify` validates the policy structure AND recomputes `policy_hash_b64u` when verifying proof bundles.

---

## 5) Safety patterns to port (prompt_filter / rate limiting / redaction) + TS equivalents

### A) Prompt filter (direct port)
Source of truth:
- `moltbook/crates/openclaw-server/src/security/prompt_filter.rs`

Port as:
- `clawproxy/src/safety/promptFilter.ts`
- (optional shared) `monorepo/packages/contracts/src/safety/promptFilter.ts`

Match Rust structures conceptually:
- `PatternSeverity = 'low'|'medium'|'high'`
- `FilteredPattern { pattern_name, description, matched_content, severity, position }`
- `ContentFilterResult { is_safe, flagged_patterns, content_hash, filtered_at }`

Match Rust logic:
- scan both simple string patterns and regex patterns
- sort by severity (high first)
- unsafe if:
  - any `High`, OR
  - `Medium >= 3`

Add tests paralleling Rust tests:
- “rm -rf” → unsafe
- “curl … | bash” → unsafe
- `$API_KEY` → unsafe
- “Ignore previous instructions” → unsafe
- safe content → safe

### B) Rate limiting (Claw Bureau-friendly; no deploy yet)
In Workers you’ll eventually use Durable Objects / KV. For now (PR-only), implement an interface and unit tests:

- `clawproxy/src/safety/rateLimit.ts`
  - `RateLimiter` interface: `check(key, limit, windowMs): { allowed, remaining, resetAt }`
  - In-memory implementation for tests/dev
  - Later swap in DO-backed implementation without changing call sites

Enforcement points:
- per agent DID (from token `sub`)
- per IP (edge-level)
- per endpoint (e.g., signing/verification/proxy routes)

### C) Redaction (prevent credential leakage in logs and prompts)
Port the “Protected files / credentials” intent from `docs/MOLTBOOK_SAFETY.md`:
- Create `clawproxy/src/safety/redact.ts`:
  - redact common secret patterns:
    - `BEGIN PRIVATE KEY`, `AWS_SECRET_ACCESS_KEY`, `xoxb-` Slack tokens, `ghp_` GitHub tokens, `.env` lines `KEY=...`
  - redact filesystem paths matching:
    - `~/.openclaw/**`, `**/*.key`, `**/*.pem`, `**/*.env`
- Apply before:
  - logging request bodies
  - passing untrusted text into LLM/system prompts
  - storing audit traces

### D) Where to wire this
- `clawproxy`:
  - run `promptFilter` on any untrusted content entering the agent runtime (webhooks, “skills” inputs, social feeds)
  - run `redact` on logs/errors
  - apply `RateLimiter` at request entry
- `clawverify`:
  - use `promptFilter` on untrusted human-provided “instructions” fields in bundles (if any)
  - always `redact` verification error logs to avoid leaking secrets embedded in artifacts

---

## “Steal this” summary: what to port first
1) **Golden vectors** + tests (CI enforcement) from `moltbook/fixtures/golden_vectors.json` (P0).
2) **RFC8785 JCS** everywhere (P0): fix `skill-did-work` canonicalization to match Rust.
3) **Envelope normalization** (P0): metadata `{}` always present; signature empty for canonicalization; strict required fields.
4) **Strict DID decoding** (P0): enforce exact sizes to avoid ambiguous encodings.
5) **Rust-parity verification** centralized in `clawverify` (P0).
6) **Policy schema + deterministic policy hashing** (P1): binds to `policy_hash_b64u` claim in `scoped_token_claims.v1.json`.
7) **Prompt filter + redaction + rate-limit scaffolding** (P1/P2): port Rust patterns and thresholds; wire into `clawproxy`.

If you want, I can draft the exact TypeScript test assertions for the golden vector (including reconstructing the envelope to reproduce `canonical_jcs` and `signature_base64`) based on your existing `openclaw-did-work/src/crypto.ts` and the fixture contents.
